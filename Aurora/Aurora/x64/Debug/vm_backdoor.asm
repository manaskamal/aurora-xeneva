; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
vmware_aware DB	01H DUP (?)
_BSS	ENDS
PUBLIC	?vm_backdoor_mouse_init@@YAX_N@Z		; vm_backdoor_mouse_init
PUBLIC	?vmbackdoor_mouse_get_packet@@YA_NPEAU_mouse_packet_@@@Z ; vmbackdoor_mouse_get_packet
PUBLIC	?vmbackdoor_mouse_aware@@YA_NXZ			; vmbackdoor_mouse_aware
EXTRN	vm_backdoor_in:PROC
EXTRN	vm_backdoor_get_ecx:PROC
EXTRN	vm_backdoor_get_edx:PROC
EXTRN	vm_backdoor_get_ebx:PROC
pdata	SEGMENT
$pdata$?vm_backdoor_mouse_init@@YAX_N@Z DD imagerel $LN7
	DD	imagerel $LN7+162
	DD	imagerel $unwind$?vm_backdoor_mouse_init@@YAX_N@Z
$pdata$?vmbackdoor_mouse_get_packet@@YA_NPEAU_mouse_packet_@@@Z DD imagerel $LN6
	DD	imagerel $LN6+189
	DD	imagerel $unwind$?vmbackdoor_mouse_get_packet@@YA_NPEAU_mouse_packet_@@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?vm_backdoor_mouse_init@@YAX_N@Z DD 010801H
	DD	06208H
$unwind$?vmbackdoor_mouse_get_packet@@YA_NPEAU_mouse_packet_@@@Z DD 010901H
	DD	06209H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vm_backdoor.cpp
_TEXT	SEGMENT
?vmbackdoor_mouse_aware@@YA_NXZ PROC			; vmbackdoor_mouse_aware

; 73   : 	return vmware_aware;

	movzx	eax, BYTE PTR vmware_aware

; 74   : }

	ret	0
?vmbackdoor_mouse_aware@@YA_NXZ ENDP			; vmbackdoor_mouse_aware
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vm_backdoor.cpp
_TEXT	SEGMENT
eax$ = 32
ecx$ = 36
words_to_read$1 = 40
packet$ = 64
?vmbackdoor_mouse_get_packet@@YA_NPEAU_mouse_packet_@@@Z PROC ; vmbackdoor_mouse_get_packet

; 42   : bool vmbackdoor_mouse_get_packet (vm_mouse_packet  *packet) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 43   : 	uint32_t eax;
; 44   : 	eax = vm_backdoor_in (0,BDOOR_CMD_GETVERSION);

	mov	edx, 10
	xor	ecx, ecx
	call	vm_backdoor_in
	mov	DWORD PTR eax$[rsp], eax

; 45   : 	uint32_t ecx = vm_backdoor_get_ecx();

	call	vm_backdoor_get_ecx
	mov	DWORD PTR ecx$[rsp], eax

; 46   : 	if (ecx <= 0x4) {

	cmp	DWORD PTR ecx$[rsp], 4
	ja	$LN3@vmbackdoor

; 47   : 
; 48   : 	const uint32_t words_to_read = 4;

	mov	DWORD PTR words_to_read$1[rsp], 4

; 49   :    
; 50   : 	eax = vm_backdoor_in (0,BDOOR_CMD_ABSPOINTER_STATUS);

	mov	edx, 40					; 00000028H
	xor	ecx, ecx
	call	vm_backdoor_in
	mov	DWORD PTR eax$[rsp], eax

; 51   : 
; 52   : 	if ((eax & 0x0000ffff) < words_to_read) {

	mov	eax, DWORD PTR eax$[rsp]
	and	eax, 65535				; 0000ffffH
	cmp	eax, 4
	jae	SHORT $LN2@vmbackdoor

; 53   : 		//printf ("No Mouse packet available\n");
; 54   : 		return false;

	xor	al, al
	jmp	SHORT $LN4@vmbackdoor
$LN2@vmbackdoor:

; 55   : 	}
; 56   : 
; 57   : 	eax = vm_backdoor_in (words_to_read, BDOOR_CMD_ABSPOINTER_DATA);

	mov	edx, 39					; 00000027H
	mov	ecx, 4
	call	vm_backdoor_in
	mov	DWORD PTR eax$[rsp], eax

; 58   : 
; 59   : 	packet->x = vm_backdoor_get_ebx();

	call	vm_backdoor_get_ebx
	mov	rcx, QWORD PTR packet$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 60   : 	packet->y = vm_backdoor_get_ecx();

	call	vm_backdoor_get_ecx
	mov	rcx, QWORD PTR packet$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 61   : 	packet->z = vm_backdoor_get_edx();

	call	vm_backdoor_get_edx
	mov	rcx, QWORD PTR packet$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 62   : 	packet->flags = eax >> 16;

	mov	eax, DWORD PTR eax$[rsp]
	shr	eax, 16
	mov	rcx, QWORD PTR packet$[rsp]
	mov	DWORD PTR [rcx], eax

; 63   : 	packet->buttons = eax & 0xFFFF;

	mov	eax, DWORD PTR eax$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR packet$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 64   : 
; 65   : 	return true;

	mov	al, 1
	jmp	SHORT $LN4@vmbackdoor

; 66   : 	}
; 67   : 	else

	jmp	SHORT $LN1@vmbackdoor
$LN3@vmbackdoor:

; 68   : 		return false;

	xor	al, al
$LN1@vmbackdoor:
$LN4@vmbackdoor:

; 69   : }

	add	rsp, 56					; 00000038H
	ret	0
?vmbackdoor_mouse_get_packet@@YA_NPEAU_mouse_packet_@@@Z ENDP ; vmbackdoor_mouse_get_packet
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vm_backdoor.cpp
_TEXT	SEGMENT
eax$ = 32
tv84 = 36
ecx$ = 40
absolute$ = 64
?vm_backdoor_mouse_init@@YAX_N@Z PROC			; vm_backdoor_mouse_init

; 24   : void vm_backdoor_mouse_init (bool absolute) {

$LN7:
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 56					; 00000038H

; 25   : 	uint32_t eax;
; 26   : 	eax = vm_backdoor_in (0,BDOOR_CMD_GETVERSION);

	mov	edx, 10
	xor	ecx, ecx
	call	vm_backdoor_in
	mov	DWORD PTR eax$[rsp], eax

; 27   : 	uint32_t ecx = vm_backdoor_get_ecx();

	call	vm_backdoor_get_ecx
	mov	DWORD PTR ecx$[rsp], eax

; 28   : 	if (ecx <= 0x4) {

	cmp	DWORD PTR ecx$[rsp], 4
	ja	SHORT $LN2@vm_backdoo

; 29   : 		vmware_aware = true;

	mov	BYTE PTR vmware_aware, 1
$LN2@vm_backdoo:

; 30   : 	} 
; 31   : 
; 32   : 	if (vmware_aware){

	movzx	eax, BYTE PTR vmware_aware
	test	eax, eax
	je	SHORT $LN1@vm_backdoo

; 33   : 	eax = vm_backdoor_in (VMMOUSE_CMD_READ_ID,BDOOR_CMD_ABSPOINTER_COMMAND);

	mov	edx, 41					; 00000029H
	mov	ecx, 1161905490				; 45414552H
	call	vm_backdoor_in
	mov	DWORD PTR eax$[rsp], eax

; 34   : 	eax = vm_backdoor_in (0, BDOOR_CMD_ABSPOINTER_STATUS);

	mov	edx, 40					; 00000028H
	xor	ecx, ecx
	call	vm_backdoor_in
	mov	DWORD PTR eax$[rsp], eax

; 35   : 	eax = vm_backdoor_in(1, BDOOR_CMD_ABSPOINTER_DATA);

	mov	edx, 39					; 00000027H
	mov	ecx, 1
	call	vm_backdoor_in
	mov	DWORD PTR eax$[rsp], eax

; 36   : 	eax = vm_backdoor_in (absolute ? VMMOUSE_CMD_REQUEST_ABSOLUTE : VMMOUSE_CMD_REQUEST_RELATIVE,
; 37   : 		BDOOR_CMD_ABSPOINTER_COMMAND);

	movzx	eax, BYTE PTR absolute$[rsp]
	test	eax, eax
	je	SHORT $LN5@vm_backdoo
	mov	DWORD PTR tv84[rsp], 1396851026		; 53424152H
	jmp	SHORT $LN6@vm_backdoo
$LN5@vm_backdoo:
	mov	DWORD PTR tv84[rsp], 1279611474		; 4c455252H
$LN6@vm_backdoo:
	mov	edx, 41					; 00000029H
	mov	ecx, DWORD PTR tv84[rsp]
	call	vm_backdoor_in
	mov	DWORD PTR eax$[rsp], eax
$LN1@vm_backdoo:

; 38   : 	}
; 39   : }

	add	rsp, 56					; 00000038H
	ret	0
?vm_backdoor_mouse_init@@YAX_N@Z ENDP			; vm_backdoor_mouse_init
_TEXT	ENDS
END
