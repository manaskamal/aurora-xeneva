; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?svga_dev@@3U_svga_drive_@@A			; svga_dev
_BSS	SEGMENT
?svga_dev@@3U_svga_drive_@@A DB 0100058H DUP (?)	; svga_dev
_BSS	ENDS
CONST	SEGMENT
$SG5404	DB	'No VMware SVGA device found', 0aH, 00H
	ORG $+3
$SG5413	DB	'[VMware SVGA]: negotiating SVGA device version!', 0aH, 00H
	ORG $+15
$SG5415	DB	'[VMware SVGA]: FrameBuffer size is very small, probably '
	DB	'incorrect', 0aH, 00H
	ORG $+5
$SG5417	DB	'[VMware SVGA]: FIFO size is very small, probably incorre'
	DB	'ct', 0aH, 00H
	ORG $+4
$SG5423	DB	'Irq of svga -> %d', 0aH, 00H
	ORG $+5
$SG5434	DB	'SVGA IRQ appears to be present but broken %d', 0aH, 00H
	ORG $+2
$SG5454	DB	'[VMware SVGA]: FIFO command too large %d bytes', 0aH, 00H
$SG5457	DB	'[VMware SVGA]: FIFO command length not 32-bit aligned', 0aH
	DB	00H
	ORG $+1
$SG5459	DB	'[VMware SVGA]: FIFO reserve before FIFO commit', 0aH, 00H
$SG5492	DB	'[VMware SVGA]: FIFO commit before FIFO reserve', 0aH, 00H
$SG5590	DB	'Cursor Bypass 3 supported', 0aH, 00H
CONST	ENDS
PUBLIC	?svga_read_reg@@YAII@Z				; svga_read_reg
PUBLIC	?svga_write_reg@@YAXII@Z			; svga_write_reg
PUBLIC	?svga_is_fifo_reg_valid@@YA_NH@Z		; svga_is_fifo_reg_valid
PUBLIC	?svga_has_fifo_cap@@YA_NH@Z			; svga_has_fifo_cap
PUBLIC	?svga_init@@YAXXZ				; svga_init
PUBLIC	?svga_enable@@YAXXZ				; svga_enable
PUBLIC	?svga_set_mode@@YAXIII@Z			; svga_set_mode
PUBLIC	?svga_fifo_full@@YAXXZ				; svga_fifo_full
PUBLIC	?svga_fifo_reserve@@YAPEAXI@Z			; svga_fifo_reserve
PUBLIC	?svga_fifo_commit@@YAXI@Z			; svga_fifo_commit
PUBLIC	?svga_fifo_commit_all@@YAXXZ			; svga_fifo_commit_all
PUBLIC	?svga_fifo_reserved_cmd@@YAPEAXII@Z		; svga_fifo_reserved_cmd
PUBLIC	?svga_fifo_reserve_escape@@YAPEAXII@Z		; svga_fifo_reserve_escape
PUBLIC	?svga_ring_doorbell@@YAXXZ			; svga_ring_doorbell
PUBLIC	?svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z	; svga_alloc_gmr
PUBLIC	?svga_update@@YAXIIII@Z				; svga_update
PUBLIC	?svga_begin_define_cursor@@YAXPEBUSVGAFifoCmdDefineCursor@@PEAPEAX1@Z ; svga_begin_define_cursor
PUBLIC	?svga_begin_define_alpha_cursor@@YAXPEBUSVGAFifoCmdDefineAlphaCursor@@PEAPEAX@Z ; svga_begin_define_alpha_cursor
PUBLIC	?svga_move_cursor@@YAXIIII@Z			; svga_move_cursor
PUBLIC	?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z ; svga_begin_video_set_regs
PUBLIC	?svga_video_set_all_regs@@YAXIPEAUSVGAOverlayUnit@@I@Z ; svga_video_set_all_regs
PUBLIC	?svga_video_set_reg@@YAXIII@Z			; svga_video_set_reg
PUBLIC	?svga_video_flush@@YAXI@Z			; svga_video_flush
PUBLIC	?svga_interrupt_handler@@YAX_KPEAX@Z		; svga_interrupt_handler
PUBLIC	?svga_panic@@YAXPEBD@Z				; svga_panic
PUBLIC	?svga_sync_to_fence@@YAXI@Z			; svga_sync_to_fence
PUBLIC	?svga_insert_fence@@YAIXZ			; svga_insert_fence
PUBLIC	?svga_wait_for_irq@@YAIXZ			; svga_wait_for_irq
PUBLIC	?svga_get_fb_mem@@YAPEAIXZ			; svga_get_fb_mem
PUBLIC	?svga_disable@@YAXXZ				; svga_disable
PUBLIC	?svga_has_fence_passed@@YA_NI@Z			; svga_has_fence_passed
EXTRN	x64_cli:PROC
EXTRN	x64_sti:PROC
EXTRN	?inportd@@YAIG@Z:PROC				; inportd
EXTRN	?outportd@@YAXGI@Z:PROC				; outportd
EXTRN	?interrupt_end@@YAXXZ:PROC			; interrupt_end
EXTRN	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z:PROC	; interrupt_set
EXTRN	?pci_config_read8@@YAEPEBU_pci_address_@@G@Z:PROC ; pci_config_read8
EXTRN	?pci_find_device@@YA_NGGPEAU_pci_address_@@@Z:PROC ; pci_find_device
EXTRN	?pci_get_bar_addr@@YAIPEBU_pci_address_@@H@Z:PROC ; pci_get_bar_addr
EXTRN	?pci_set_mem_enable@@YAXPEBU_pci_address_@@_N@Z:PROC ; pci_set_mem_enable
EXTRN	?memset@@YAXPEAXEI@Z:PROC			; memset
EXTRN	memcpy:PROC
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
EXTRN	?gmr_init@@YAXXZ:PROC				; gmr_init
EXTRN	?vm_backdoor_mouse_init@@YAX_N@Z:PROC		; vm_backdoor_mouse_init
EXTRN	?screen_set_configuration@@YAXII@Z:PROC		; screen_set_configuration
pdata	SEGMENT
$pdata$?svga_read_reg@@YAII@Z DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?svga_read_reg@@YAII@Z
$pdata$?svga_write_reg@@YAXII@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?svga_write_reg@@YAXII@Z
$pdata$?svga_is_fifo_reg_valid@@YA_NH@Z DD imagerel $LN5
	DD	imagerel $LN5+61
	DD	imagerel $unwind$?svga_is_fifo_reg_valid@@YA_NH@Z
$pdata$?svga_has_fifo_cap@@YA_NH@Z DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$?svga_has_fifo_cap@@YA_NH@Z
$pdata$?svga_init@@YAXXZ DD imagerel $LN15
	DD	imagerel $LN15+586
	DD	imagerel $unwind$?svga_init@@YAXXZ
$pdata$?svga_enable@@YAXXZ DD imagerel $LN8
	DD	imagerel $LN8+334
	DD	imagerel $unwind$?svga_enable@@YAXXZ
$pdata$?svga_set_mode@@YAXIII@Z DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$?svga_set_mode@@YAXIII@Z
$pdata$?svga_fifo_full@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+115
	DD	imagerel $unwind$?svga_fifo_full@@YAXXZ
$pdata$?svga_fifo_reserve@@YAPEAXI@Z DD imagerel $LN23
	DD	imagerel $LN23+495
	DD	imagerel $unwind$?svga_fifo_reserve@@YAPEAXI@Z
$pdata$?svga_fifo_commit@@YAXI@Z DD imagerel $LN16
	DD	imagerel $LN16+593
	DD	imagerel $unwind$?svga_fifo_commit@@YAXI@Z
$pdata$?svga_fifo_commit_all@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+20
	DD	imagerel $unwind$?svga_fifo_commit_all@@YAXXZ
$pdata$?svga_fifo_reserved_cmd@@YAPEAXII@Z DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$?svga_fifo_reserved_cmd@@YAPEAXII@Z
$pdata$?svga_fifo_reserve_escape@@YAPEAXII@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?svga_fifo_reserve_escape@@YAPEAXII@Z
$pdata$?svga_ring_doorbell@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+92
	DD	imagerel $unwind$?svga_ring_doorbell@@YAXXZ
$pdata$?svga_update@@YAXIIII@Z DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$?svga_update@@YAXIIII@Z
$pdata$?svga_begin_define_cursor@@YAXPEBUSVGAFifoCmdDefineCursor@@PEAPEAX1@Z DD imagerel $LN3
	DD	imagerel $LN3+210
	DD	imagerel $unwind$?svga_begin_define_cursor@@YAXPEBUSVGAFifoCmdDefineCursor@@PEAPEAX1@Z
$pdata$?svga_begin_define_alpha_cursor@@YAXPEBUSVGAFifoCmdDefineAlphaCursor@@PEAPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$?svga_begin_define_alpha_cursor@@YAXPEBUSVGAFifoCmdDefineAlphaCursor@@PEAPEAX@Z
$pdata$?svga_move_cursor@@YAXIIII@Z DD imagerel $LN5
	DD	imagerel $LN5+205
	DD	imagerel $unwind$?svga_move_cursor@@YAXIIII@Z
$pdata$?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z
$pdata$?svga_video_set_all_regs@@YAXIPEAUSVGAOverlayUnit@@I@Z DD imagerel $LN6
	DD	imagerel $LN6+141
	DD	imagerel $unwind$?svga_video_set_all_regs@@YAXIPEAUSVGAOverlayUnit@@I@Z
$pdata$?svga_video_set_reg@@YAXIII@Z DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?svga_video_set_reg@@YAXIII@Z
$pdata$?svga_video_flush@@YAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$?svga_video_flush@@YAXI@Z
$pdata$?svga_interrupt_handler@@YAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+85
	DD	imagerel $unwind$?svga_interrupt_handler@@YAX_KPEAX@Z
$pdata$?svga_panic@@YAXPEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?svga_panic@@YAXPEBD@Z
$pdata$?svga_sync_to_fence@@YAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+319
	DD	imagerel $unwind$?svga_sync_to_fence@@YAXI@Z
$pdata$?svga_insert_fence@@YAIXZ DD imagerel $LN5
	DD	imagerel $LN5+112
	DD	imagerel $unwind$?svga_insert_fence@@YAIXZ
$pdata$?svga_wait_for_irq@@YAIXZ DD imagerel $LN6
	DD	imagerel $LN6+49
	DD	imagerel $unwind$?svga_wait_for_irq@@YAIXZ
$pdata$?svga_disable@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?svga_disable@@YAXXZ
$pdata$?svga_has_fence_passed@@YA_NI@Z DD imagerel $LN7
	DD	imagerel $LN7+97
	DD	imagerel $unwind$?svga_has_fence_passed@@YA_NI@Z
pdata	ENDS
;	COMDAT ?next_ptr@?1??svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z@4U2@A
_DATA	SEGMENT
?next_ptr@?1??svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z@4U2@A DD 0fffffffeH ; `svga_alloc_gmr'::`2'::next_ptr
	DD	00H
_DATA	ENDS
xdata	SEGMENT
$unwind$?svga_read_reg@@YAII@Z DD 010801H
	DD	04208H
$unwind$?svga_write_reg@@YAXII@Z DD 010c01H
	DD	0420cH
$unwind$?svga_is_fifo_reg_valid@@YA_NH@Z DD 010801H
	DD	02208H
$unwind$?svga_has_fifo_cap@@YA_NH@Z DD 010801H
	DD	02208H
$unwind$?svga_init@@YAXXZ DD 010401H
	DD	06204H
$unwind$?svga_enable@@YAXXZ DD 010401H
	DD	04204H
$unwind$?svga_set_mode@@YAXIII@Z DD 011101H
	DD	04211H
$unwind$?svga_fifo_full@@YAXXZ DD 010401H
	DD	04204H
$unwind$?svga_fifo_reserve@@YAPEAXI@Z DD 010801H
	DD	08208H
$unwind$?svga_fifo_commit@@YAXI@Z DD 010801H
	DD	0c208H
$unwind$?svga_fifo_commit_all@@YAXXZ DD 010401H
	DD	04204H
$unwind$?svga_fifo_reserved_cmd@@YAPEAXII@Z DD 010c01H
	DD	0620cH
$unwind$?svga_fifo_reserve_escape@@YAPEAXII@Z DD 010c01H
	DD	0620cH
$unwind$?svga_ring_doorbell@@YAXXZ DD 010401H
	DD	04204H
$unwind$?svga_update@@YAXIIII@Z DD 011601H
	DD	06216H
$unwind$?svga_begin_define_cursor@@YAXPEBUSVGAFifoCmdDefineCursor@@PEAPEAX1@Z DD 031501H
	DD	070118215H
	DD	06010H
$unwind$?svga_begin_define_alpha_cursor@@YAXPEBUSVGAFifoCmdDefineAlphaCursor@@PEAPEAX@Z DD 031001H
	DD	0700c6210H
	DD	0600bH
$unwind$?svga_move_cursor@@YAXIIII@Z DD 011601H
	DD	04216H
$unwind$?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z DD 011101H
	DD	06211H
$unwind$?svga_video_set_all_regs@@YAXIPEAUSVGAOverlayUnit@@I@Z DD 011201H
	DD	08212H
$unwind$?svga_video_set_reg@@YAXIII@Z DD 011101H
	DD	06211H
$unwind$?svga_video_flush@@YAXI@Z DD 010801H
	DD	06208H
$unwind$?svga_interrupt_handler@@YAX_KPEAX@Z DD 010e01H
	DD	0620eH
$unwind$?svga_panic@@YAXPEBD@Z DD 010901H
	DD	04209H
$unwind$?svga_sync_to_fence@@YAXI@Z DD 010801H
	DD	06208H
$unwind$?svga_insert_fence@@YAIXZ DD 010401H
	DD	06204H
$unwind$?svga_wait_for_irq@@YAIXZ DD 010401H
	DD	02204H
$unwind$?svga_disable@@YAXXZ DD 010401H
	DD	04204H
$unwind$?svga_has_fence_passed@@YA_NI@Z DD 010801H
	DD	06208H
xdata	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
tv73 = 32
fence$ = 64
?svga_has_fence_passed@@YA_NI@Z PROC			; svga_has_fence_passed

; 469  : bool svga_has_fence_passed (uint32_t fence) {

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 470  : 
; 471  : 	if (!fence) {

	cmp	DWORD PTR fence$[rsp], 0
	jne	SHORT $LN2@svga_has_f

; 472  : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@svga_has_f
$LN2@svga_has_f:

; 473  : 	}
; 474  : 
; 475  : 	if (!svga_has_fifo_cap (SVGA_FIFO_CAP_FENCE)) {

	mov	ecx, 1
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@svga_has_f

; 476  : 		return false;

	xor	al, al
	jmp	SHORT $LN3@svga_has_f
$LN1@svga_has_f:

; 477  : 	}
; 478  : 
; 479  : 	return ((int32_t)(svga_dev.fifo_mem[SVGA_FIFO_FENCE] - fence)) >= 0;

	mov	eax, 4
	imul	rax, 6
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	edx, DWORD PTR fence$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	sub	eax, edx
	test	eax, eax
	jl	SHORT $LN5@svga_has_f
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN6@svga_has_f
$LN5@svga_has_f:
	mov	DWORD PTR tv73[rsp], 0
$LN6@svga_has_f:
	movzx	eax, BYTE PTR tv73[rsp]
$LN3@svga_has_f:

; 480  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_has_fence_passed@@YA_NI@Z ENDP			; svga_has_fence_passed
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
?svga_disable@@YAXXZ PROC				; svga_disable

; 145  : void svga_disable () {

$LN3:
	sub	rsp, 40					; 00000028H

; 146  : 	svga_write_reg (SVGA_REG_ENABLE, false);

	xor	edx, edx
	mov	ecx, 1
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 147  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_disable@@YAXXZ ENDP				; svga_disable
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
?svga_get_fb_mem@@YAPEAIXZ PROC				; svga_get_fb_mem

; 579  : 	return (uint32_t*)svga_dev.fb_mem;

	mov	rax, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16

; 580  : }

	ret	0
?svga_get_fb_mem@@YAPEAIXZ ENDP				; svga_get_fb_mem
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
i$1 = 0
flags$ = 4
?svga_wait_for_irq@@YAIXZ PROC				; svga_wait_for_irq

; 461  : uint32_t svga_wait_for_irq () {

$LN6:
	sub	rsp, 24

; 462  : 	
; 463  : 	uint32_t flags = 0;

	mov	DWORD PTR flags$[rsp], 0

; 464  : 	for (int i = 0; i < 10000; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@svga_wait_
$LN2@svga_wait_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@svga_wait_:
	cmp	DWORD PTR i$1[rsp], 10000		; 00002710H
	jge	SHORT $LN1@svga_wait_

; 465  : 		;

	jmp	SHORT $LN2@svga_wait_
$LN1@svga_wait_:

; 466  : 	return flags;

	mov	eax, DWORD PTR flags$[rsp]

; 467  : }

	add	rsp, 24
	ret	0
?svga_wait_for_irq@@YAIXZ ENDP				; svga_wait_for_irq
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
fence$ = 32
cmd$ = 40
?svga_insert_fence@@YAIXZ PROC				; svga_insert_fence

; 527  : uint32_t svga_insert_fence () {

$LN5:
	sub	rsp, 56					; 00000038H

; 528  : 	uint32_t fence;
; 529  : 
; 530  : #pragma pack (push)
; 531  : 	struct cmmnd{
; 532  : 		uint32_t id;
; 533  : 		uint32_t fence;
; 534  : 	};
; 535  : #pragma pack (pop)
; 536  : 
; 537  : 	cmmnd *cmd;
; 538  : 
; 539  : 	//printf ("Insert fence cmd size -> %d\n", sizeof *cmd);
; 540  : 	if (!svga_has_fifo_cap (SVGA_FIFO_CAP_FENCE)) {

	mov	ecx, 1
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	movzx	eax, al

; 541  : 		//printf ("Insert fence no cap\n");
; 542  : 		//return 1;
; 543  : 	}
; 544  : 
; 545  : 	if (svga_dev.fifo.next_fence == 0) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048644, 0
	jne	SHORT $LN1@svga_inser

; 546  : 		svga_dev.fifo.next_fence = 1;

	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048644, 1
$LN1@svga_inser:

; 547  : 	}
; 548  : 
; 549  : 	fence = svga_dev.fifo.next_fence++;

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048644
	mov	DWORD PTR fence$[rsp], eax
	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048644
	inc	eax
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048644, eax

; 550  : 	//printf ("Fence -> %x\n", fence);
; 551  : 	cmd = (cmmnd*)svga_fifo_reserve (sizeof *cmd);

	mov	ecx, 8
	call	?svga_fifo_reserve@@YAPEAXI@Z		; svga_fifo_reserve
	mov	QWORD PTR cmd$[rsp], rax

; 552  : 	cmd->id = SVGA_CMD_FENCE;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	DWORD PTR [rax], 30

; 553  : 	cmd->fence = fence;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR fence$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 554  : 
; 555  : 	svga_fifo_commit_all();

	call	?svga_fifo_commit_all@@YAXXZ		; svga_fifo_commit_all

; 556  : 
; 557  : 	return fence;

	mov	eax, DWORD PTR fence$[rsp]

; 558  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_insert_fence@@YAIXZ ENDP				; svga_insert_fence
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
busy$1 = 32
tv141 = 36
fence$ = 64
?svga_sync_to_fence@@YAXI@Z PROC			; svga_sync_to_fence

; 482  : void svga_sync_to_fence (uint32_t fence) {

$LN17:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 483  : 
; 484  : 	if (!fence) 

	cmp	DWORD PTR fence$[rsp], 0
	jne	SHORT $LN12@svga_sync_

; 485  : 		return;

	jmp	$LN13@svga_sync_
$LN12@svga_sync_:

; 486  : 
; 487  : 	if (!svga_has_fifo_cap (SVGA_FIFO_CAP_FENCE)) {

	mov	ecx, 1
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@svga_sync_

; 488  : 		//printf ("Fence Polling\n");
; 489  : 		svga_write_reg (SVGA_REG_SYNC, 1);

	mov	edx, 1
	mov	ecx, 21
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg
$LN10@svga_sync_:

; 490  : 		while (svga_read_reg (SVGA_REG_BUSY) != false) {}

	mov	ecx, 22
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	test	eax, eax
	je	SHORT $LN9@svga_sync_
	jmp	SHORT $LN10@svga_sync_
$LN9@svga_sync_:
$LN11@svga_sync_:

; 491  : 		//return;
; 492  : 	}
; 493  : 
; 494  : 	if (svga_has_fence_passed (fence)) {

	mov	ecx, DWORD PTR fence$[rsp]
	call	?svga_has_fence_passed@@YA_NI@Z		; svga_has_fence_passed
	movzx	eax, al

; 495  : 		//return;
; 496  : 	}
; 497  : 
; 498  : 	if (svga_is_fifo_reg_valid (SVGA_FIFO_FENCE_GOAL) &&
; 499  : 		(svga_dev.capabilities & SVGA_CAP_IRQMASK)) {

	mov	ecx, 289				; 00000121H
	call	?svga_is_fifo_reg_valid@@YA_NH@Z	; svga_is_fifo_reg_valid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@svga_sync_
	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+40
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN7@svga_sync_

; 500  : 			svga_dev.fifo_mem[SVGA_FIFO_FENCE_GOAL] = fence;

	mov	eax, 4
	imul	rax, 289				; 00000121H
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	edx, DWORD PTR fence$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 501  : 			svga_write_reg (SVGA_REG_IRQMASK, SVGA_IRQFLAG_FENCE_GOAL);

	mov	edx, 4
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 502  : 			x64_cli ();

	call	x64_cli

; 503  : 
; 504  : 			if (!svga_has_fence_passed(fence)) {

	mov	ecx, DWORD PTR fence$[rsp]
	call	?svga_has_fence_passed@@YA_NI@Z		; svga_has_fence_passed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@svga_sync_

; 505  : 				svga_ring_doorbell ();

	call	?svga_ring_doorbell@@YAXXZ		; svga_ring_doorbell

; 506  : 				if (!svga_has_fence_passed(fence)) {

	mov	ecx, DWORD PTR fence$[rsp]
	call	?svga_has_fence_passed@@YA_NI@Z		; svga_has_fence_passed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@svga_sync_

; 507  : 					svga_wait_for_irq();

	call	?svga_wait_for_irq@@YAIXZ		; svga_wait_for_irq
$LN5@svga_sync_:
$LN6@svga_sync_:

; 508  : 				}
; 509  : 			}
; 510  : 
; 511  : 			svga_write_reg (SVGA_REG_IRQMASK, 0);

	xor	edx, edx
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 512  : 	} else {

	jmp	SHORT $LN4@svga_sync_
$LN7@svga_sync_:

; 513  : 		bool busy = true;

	mov	BYTE PTR busy$1[rsp], 1

; 514  : 		svga_write_reg (SVGA_REG_SYNC, 1);

	mov	edx, 1
	mov	ecx, 21
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg
$LN3@svga_sync_:

; 515  : 
; 516  : 		while (!svga_has_fence_passed (fence) && busy) {

	mov	ecx, DWORD PTR fence$[rsp]
	call	?svga_has_fence_passed@@YA_NI@Z		; svga_has_fence_passed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@svga_sync_
	movzx	eax, BYTE PTR busy$1[rsp]
	test	eax, eax
	je	SHORT $LN2@svga_sync_

; 517  : 			busy = (svga_read_reg (SVGA_REG_BUSY) != 0);

	mov	ecx, 22
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	test	eax, eax
	je	SHORT $LN15@svga_sync_
	mov	DWORD PTR tv141[rsp], 1
	jmp	SHORT $LN16@svga_sync_
$LN15@svga_sync_:
	mov	DWORD PTR tv141[rsp], 0
$LN16@svga_sync_:
	movzx	eax, BYTE PTR tv141[rsp]
	mov	BYTE PTR busy$1[rsp], al

; 518  : 		}

	jmp	SHORT $LN3@svga_sync_
$LN2@svga_sync_:
$LN4@svga_sync_:

; 519  : 	}
; 520  : 
; 521  : 	if (!svga_has_fence_passed (fence)) {

	mov	ecx, DWORD PTR fence$[rsp]
	call	?svga_has_fence_passed@@YA_NI@Z		; svga_has_fence_passed
	movzx	eax, al
$LN13@svga_sync_:

; 522  : 		//printf ("[VMware SVGA]: SyncToFence failed\n");
; 523  : 	}
; 524  : 
; 525  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_sync_to_fence@@YAXI@Z ENDP			; svga_sync_to_fence
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
text$ = 48
?svga_panic@@YAXPEBD@Z PROC				; svga_panic

; 150  : void svga_panic (const char* text) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 151  : 	svga_disable ();

	call	?svga_disable@@YAXXZ			; svga_disable

; 152  : 	printf (text);

	mov	rcx, QWORD PTR text$[rsp]
	call	?printf@@YAXPEBDZZ			; printf

; 153  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_panic@@YAXPEBD@Z ENDP				; svga_panic
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
port$ = 32
irq_flags$ = 36
s$ = 64
p$ = 72
?svga_interrupt_handler@@YAX_KPEAX@Z PROC		; svga_interrupt_handler

; 563  : void svga_interrupt_handler (size_t s, void* p) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 564  : 	x64_cli ();

	call	x64_cli

; 565  : 	uint16_t port = svga_dev.io_base + SVGA_IRQSTATUS_PORT;

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+4
	add	eax, 8
	mov	WORD PTR port$[rsp], ax

; 566  : 	uint32_t irq_flags = inportd (port);

	movzx	ecx, WORD PTR port$[rsp]
	call	?inportd@@YAIG@Z			; inportd
	mov	DWORD PTR irq_flags$[rsp], eax

; 567  : 	outportd (port, irq_flags);

	mov	edx, DWORD PTR irq_flags$[rsp]
	movzx	ecx, WORD PTR port$[rsp]
	call	?outportd@@YAXGI@Z			; outportd

; 568  : 	//printf ("Irq flags -> %d\n", irq_flags);
; 569  : 	svga_dev.irq.count++;

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048656
	inc	eax
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048656, eax

; 570  : 	//printf ("SVGA interrupted\n");
; 571  : 	/*if (!irq_flags)
; 572  : 		printf ("[VMware SVGA]: spurious SVGA IRQ\n");*/
; 573  : 	interrupt_end();

	call	?interrupt_end@@YAXXZ			; interrupt_end

; 574  : 	
; 575  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_interrupt_handler@@YAX_KPEAX@Z ENDP		; svga_interrupt_handler
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
cmd$ = 32
stream_id$ = 64
?svga_video_flush@@YAXI@Z PROC				; svga_video_flush

; 450  : void svga_video_flush (uint32_t stream_id) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 451  : 	SVGAEscapeVideoFlush *cmd;
; 452  : 
; 453  : 	cmd = (SVGAEscapeVideoFlush*)svga_fifo_reserve_escape (SVGA_ESCAPE_NSID_VMWARE, sizeof *cmd);

	mov	edx, 8
	xor	ecx, ecx
	call	?svga_fifo_reserve_escape@@YAPEAXII@Z	; svga_fifo_reserve_escape
	mov	QWORD PTR cmd$[rsp], rax

; 454  : 	cmd->cmdType = SVGA_ESCAPE_VMWARE_VIDEO_FLUSH;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	DWORD PTR [rax], 131074			; 00020002H

; 455  : 	cmd->streamId = stream_id;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR stream_id$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 456  : 	svga_fifo_commit_all();

	call	?svga_fifo_commit_all@@YAXXZ		; svga_fifo_commit_all

; 457  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_video_flush@@YAXI@Z ENDP				; svga_video_flush
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
set_regs$ = 32
stream_id$ = 64
register_id$ = 72
value$ = 80
?svga_video_set_reg@@YAXIII@Z PROC			; svga_video_set_reg

; 439  : void svga_video_set_reg (uint32_t stream_id, uint32_t register_id, uint32_t value) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 440  : 
; 441  : 	SVGAEscapeVideoSetRegs *set_regs;
; 442  : 
; 443  : 	svga_begin_video_set_regs (stream_id, 1, &set_regs);

	lea	r8, QWORD PTR set_regs$[rsp]
	mov	edx, 1
	mov	ecx, DWORD PTR stream_id$[rsp]
	call	?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z ; svga_begin_video_set_regs

; 444  : 	set_regs->items[0].registerId = register_id;

	mov	eax, 8
	imul	rax, 0
	mov	rcx, QWORD PTR set_regs$[rsp]
	mov	edx, DWORD PTR register_id$[rsp]
	mov	DWORD PTR [rcx+rax+8], edx

; 445  : 	set_regs->items[0].value = value;

	mov	eax, 8
	imul	rax, 0
	mov	rcx, QWORD PTR set_regs$[rsp]
	mov	edx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rcx+rax+12], edx

; 446  : 	svga_fifo_commit_all();

	call	?svga_fifo_commit_all@@YAXXZ		; svga_fifo_commit_all

; 447  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_video_set_reg@@YAXIII@Z ENDP			; svga_video_set_reg
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
i$ = 32
num_regs$ = 36
set_regs$ = 40
reg_array$ = 48
stream_id$ = 80
regs$ = 88
max_reg$ = 96
?svga_video_set_all_regs@@YAXIPEAUSVGAOverlayUnit@@I@Z PROC ; svga_video_set_all_regs

; 420  : void svga_video_set_all_regs (uint32_t stream_id, SVGAOverlayUnit *regs, uint32_t max_reg) {

$LN6:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 421  : 
; 422  : 	uint32_t *reg_array = (uint32_t*) regs;

	mov	rax, QWORD PTR regs$[rsp]
	mov	QWORD PTR reg_array$[rsp], rax

; 423  : 	const uint32_t num_regs = max_reg + 1;

	mov	eax, DWORD PTR max_reg$[rsp]
	inc	eax
	mov	DWORD PTR num_regs$[rsp], eax

; 424  : 	SVGAEscapeVideoSetRegs *set_regs;
; 425  : 	uint32_t i;
; 426  : 
; 427  : 	svga_begin_video_set_regs (stream_id, num_regs, &set_regs);

	lea	r8, QWORD PTR set_regs$[rsp]
	mov	edx, DWORD PTR num_regs$[rsp]
	mov	ecx, DWORD PTR stream_id$[rsp]
	call	?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z ; svga_begin_video_set_regs

; 428  : 
; 429  : 	for (i = 0; i < num_regs; i++) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN3@svga_video
$LN2@svga_video:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN3@svga_video:
	mov	eax, DWORD PTR num_regs$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN1@svga_video

; 430  : 		set_regs->items[i].registerId = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR set_regs$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rcx+rax*8+8], edx

; 431  : 		set_regs->items[i].value = reg_array[i];

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR set_regs$[rsp]
	mov	r8, QWORD PTR reg_array$[rsp]
	mov	eax, DWORD PTR [r8+rax*4]
	mov	DWORD PTR [rdx+rcx*8+12], eax

; 432  : 	}

	jmp	SHORT $LN2@svga_video
$LN1@svga_video:

; 433  : 
; 434  : 	svga_fifo_commit_all();

	call	?svga_fifo_commit_all@@YAXXZ		; svga_fifo_commit_all

; 435  : }

	add	rsp, 72					; 00000048H
	ret	0
?svga_video_set_all_regs@@YAXIPEAUSVGAOverlayUnit@@I@Z ENDP ; svga_video_set_all_regs
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
cmd_size$ = 32
cmd$ = 40
stream_id$ = 64
num_items$ = 72
set_regs$ = 80
?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z PROC ; svga_begin_video_set_regs

; 409  : void svga_begin_video_set_regs (uint32_t stream_id, uint32_t num_items, SVGAEscapeVideoSetRegs **set_regs) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 410  : 	SVGAEscapeVideoSetRegs *cmd;
; 411  : 	uint32_t cmd_size = (sizeof *cmd - sizeof cmd->items + num_items * sizeof cmd->items[0]);

	mov	eax, DWORD PTR num_items$[rsp]
	lea	rax, QWORD PTR [rax*8+8]
	mov	DWORD PTR cmd_size$[rsp], eax

; 412  : 
; 413  : 	cmd = (SVGAEscapeVideoSetRegs*)svga_fifo_reserve_escape (SVGA_ESCAPE_NSID_VMWARE, cmd_size);

	mov	edx, DWORD PTR cmd_size$[rsp]
	xor	ecx, ecx
	call	?svga_fifo_reserve_escape@@YAPEAXII@Z	; svga_fifo_reserve_escape
	mov	QWORD PTR cmd$[rsp], rax

; 414  : 	cmd->header.cmdType = SVGA_ESCAPE_VMWARE_VIDEO_SET_REGS;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	DWORD PTR [rax], 131073			; 00020001H

; 415  : 	cmd->header.streamId = stream_id;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR stream_id$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 416  : 
; 417  : 	*set_regs = cmd;

	mov	rax, QWORD PTR set_regs$[rsp]
	mov	rcx, QWORD PTR cmd$[rsp]
	mov	QWORD PTR [rax], rcx

; 418  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z ENDP ; svga_begin_video_set_regs
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
visible$ = 48
x$ = 56
y$ = 64
screen_id$ = 72
?svga_move_cursor@@YAXIIII@Z PROC			; svga_move_cursor

; 394  : {

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 395  : 	if (svga_has_fifo_cap (SVGA_FIFO_CAP_SCREEN_OBJECT)) {

	mov	ecx, 128				; 00000080H
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@svga_move_

; 396  : 		svga_dev.fifo_mem[SVGA_FIFO_CURSOR_SCREEN_ID] = screen_id;

	mov	eax, 4
	imul	rax, 15
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	edx, DWORD PTR screen_id$[rsp]
	mov	DWORD PTR [rcx+rax], edx
$LN2@svga_move_:

; 397  : 	}
; 398  : 
; 399  : 	if (svga_has_fifo_cap (SVGA_FIFO_CAP_CURSOR_BYPASS_3)) {

	mov	ecx, 16
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@svga_move_

; 400  : 		printf ("Cursor Bypass 3 supported\n");

	lea	rcx, OFFSET FLAT:$SG5590
	call	?printf@@YAXPEBDZZ			; printf

; 401  : 		svga_dev.fifo_mem[SVGA_FIFO_CURSOR_ON] = visible;

	mov	eax, 4
	imul	rax, 9
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	edx, DWORD PTR visible$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 402  : 		svga_dev.fifo_mem[SVGA_FIFO_CURSOR_X] = x;

	mov	eax, 4
	imul	rax, 10
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	edx, DWORD PTR x$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 403  : 		svga_dev.fifo_mem[SVGA_FIFO_CURSOR_Y] = y;

	mov	eax, 4
	imul	rax, 11
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	edx, DWORD PTR y$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 404  : 		svga_dev.fifo_mem[SVGA_FIFO_CURSOR_COUNT]++;

	mov	eax, 4
	imul	rax, 12
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	eax, DWORD PTR [rcx+rax]
	inc	eax
	mov	ecx, 4
	imul	rcx, 12
	mov	rdx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	DWORD PTR [rdx+rcx], eax
$LN1@svga_move_:

; 405  : 	}
; 406  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_move_cursor@@YAXIIII@Z ENDP			; svga_move_cursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
image_size$ = 32
cmd$ = 40
cursor_info$ = 80
data$ = 88
?svga_begin_define_alpha_cursor@@YAXPEBUSVGAFifoCmdDefineAlphaCursor@@PEAPEAX@Z PROC ; svga_begin_define_alpha_cursor

; 381  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 382  : 	uint32_t image_size = cursor_info->width * cursor_info->height * sizeof(uint32_t);

	mov	rax, QWORD PTR cursor_info$[rsp]
	mov	rcx, QWORD PTR cursor_info$[rsp]
	mov	eax, DWORD PTR [rax+12]
	imul	eax, DWORD PTR [rcx+16]
	mov	eax, eax
	shl	rax, 2
	mov	DWORD PTR image_size$[rsp], eax

; 383  : 	SVGAFifoCmdDefineAlphaCursor *cmd =  (SVGAFifoCmdDefineAlphaCursor*)svga_fifo_reserved_cmd (SVGA_CMD_DEFINE_ALPHA_CURSOR,
; 384  : 		sizeof *cmd + image_size);

	mov	eax, DWORD PTR image_size$[rsp]
	add	rax, 20
	mov	edx, eax
	mov	ecx, 22
	call	?svga_fifo_reserved_cmd@@YAPEAXII@Z	; svga_fifo_reserved_cmd
	mov	QWORD PTR cmd$[rsp], rax

; 385  : 
; 386  : 	*cmd = *cursor_info;

	mov	rdi, QWORD PTR cmd$[rsp]
	mov	rsi, QWORD PTR cursor_info$[rsp]
	mov	ecx, 20
	rep movsb

; 387  : 	*data = (void*) (cmd + 1);

	mov	rax, QWORD PTR cmd$[rsp]
	add	rax, 20
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rcx], rax

; 388  : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?svga_begin_define_alpha_cursor@@YAXPEBUSVGAFifoCmdDefineAlphaCursor@@PEAPEAX@Z ENDP ; svga_begin_define_alpha_cursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
and_size$ = 32
and_pitch$ = 36
xor_pitch$ = 40
xor_size$ = 44
cmd$ = 48
cursor_info$ = 96
and_mask$ = 104
xor_mask$ = 112
?svga_begin_define_cursor@@YAXPEBUSVGAFifoCmdDefineCursor@@PEAPEAX1@Z PROC ; svga_begin_define_cursor

; 366  : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 367  :     uint32_t and_pitch = ((cursor_info->andMaskDepth * cursor_info->width + 31) >> 5) << 2;

	mov	rax, QWORD PTR cursor_info$[rsp]
	mov	rcx, QWORD PTR cursor_info$[rsp]
	mov	eax, DWORD PTR [rax+20]
	imul	eax, DWORD PTR [rcx+12]
	add	eax, 31
	shr	eax, 5
	shl	eax, 2
	mov	DWORD PTR and_pitch$[rsp], eax

; 368  : 	uint32_t and_size = and_pitch * cursor_info->height;

	mov	rax, QWORD PTR cursor_info$[rsp]
	mov	ecx, DWORD PTR and_pitch$[rsp]
	imul	ecx, DWORD PTR [rax+16]
	mov	eax, ecx
	mov	DWORD PTR and_size$[rsp], eax

; 369  : 	uint32_t xor_pitch = ((cursor_info->xorMaskDepth * cursor_info->width + 31) >> 5) << 2;

	mov	rax, QWORD PTR cursor_info$[rsp]
	mov	rcx, QWORD PTR cursor_info$[rsp]
	mov	eax, DWORD PTR [rax+24]
	imul	eax, DWORD PTR [rcx+12]
	add	eax, 31
	shr	eax, 5
	shl	eax, 2
	mov	DWORD PTR xor_pitch$[rsp], eax

; 370  : 	uint32_t xor_size = xor_pitch * cursor_info->height;

	mov	rax, QWORD PTR cursor_info$[rsp]
	mov	ecx, DWORD PTR xor_pitch$[rsp]
	imul	ecx, DWORD PTR [rax+16]
	mov	eax, ecx
	mov	DWORD PTR xor_size$[rsp], eax

; 371  : 
; 372  : 	SVGAFifoCmdDefineCursor *cmd = (SVGAFifoCmdDefineCursor*)svga_fifo_reserved_cmd (SVGA_CMD_DEFINE_CURSOR, sizeof *cmd + and_size + xor_size);

	mov	eax, DWORD PTR and_size$[rsp]
	mov	ecx, DWORD PTR xor_size$[rsp]
	lea	rax, QWORD PTR [rax+rcx+28]
	mov	edx, eax
	mov	ecx, 19
	call	?svga_fifo_reserved_cmd@@YAPEAXII@Z	; svga_fifo_reserved_cmd
	mov	QWORD PTR cmd$[rsp], rax

; 373  : 
; 374  : 	*cmd = *cursor_info;

	mov	rdi, QWORD PTR cmd$[rsp]
	mov	rsi, QWORD PTR cursor_info$[rsp]
	mov	ecx, 28
	rep movsb

; 375  : 	*and_mask = (void*)(cmd + 1);

	mov	rax, QWORD PTR cmd$[rsp]
	add	rax, 28
	mov	rcx, QWORD PTR and_mask$[rsp]
	mov	QWORD PTR [rcx], rax

; 376  : 	*xor_mask  = (void*)(and_size + (uint8_t*)*and_mask);

	mov	eax, DWORD PTR and_size$[rsp]
	mov	rcx, QWORD PTR and_mask$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR xor_mask$[rsp]
	mov	QWORD PTR [rcx], rax

; 377  : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?svga_begin_define_cursor@@YAXPEBUSVGAFifoCmdDefineCursor@@PEAPEAX1@Z ENDP ; svga_begin_define_cursor
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
cmd$ = 32
x$ = 64
y$ = 72
width$ = 80
height$ = 88
?svga_update@@YAXIIII@Z PROC				; svga_update

; 354  : void svga_update (uint32_t x, uint32_t y, uint32_t width, uint32_t height) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 355  : 	SVGAFifoCmdUpdate *cmd = (SVGAFifoCmdUpdate*)svga_fifo_reserved_cmd (SVGA_CMD_UPDATE, sizeof (SVGAFifoCmdUpdate));

	mov	edx, 16
	mov	ecx, 1
	call	?svga_fifo_reserved_cmd@@YAPEAXII@Z	; svga_fifo_reserved_cmd
	mov	QWORD PTR cmd$[rsp], rax

; 356  : 	cmd->x = x;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR x$[rsp]
	mov	DWORD PTR [rax], ecx

; 357  : 	cmd->y = y;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR y$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 358  : 	cmd->width = width;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR width$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 359  : 	cmd->height = height;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR height$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 360  : 	svga_fifo_commit_all ();

	call	?svga_fifo_commit_all@@YAXXZ		; svga_fifo_commit_all

; 361  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_update@@YAXIIII@Z ENDP				; svga_update
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
size$ = 8
ptr$ = 16
?svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z PROC	; svga_alloc_gmr

; 347  : void* svga_alloc_gmr (uint32 size, SVGAGuestPtr *ptr) {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx

; 348  : 	static SVGAGuestPtr next_ptr = {SVGA_GMR_FRAMEBUFFER, 0 };
; 349  : 	*ptr = next_ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	rcx, QWORD PTR ?next_ptr@?1??svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z@4U2@A
	mov	QWORD PTR [rax], rcx

; 350  : 	next_ptr.offset += size;

	mov	eax, DWORD PTR size$[rsp]
	mov	ecx, DWORD PTR ?next_ptr@?1??svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z@4U2@A+4
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ?next_ptr@?1??svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z@4U2@A+4, eax

; 351  : 	return svga_dev.fb_mem + ptr->offset;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	add	rcx, rax
	mov	rax, rcx

; 352  : }

	ret	0
?svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z ENDP	; svga_alloc_gmr
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
?svga_ring_doorbell@@YAXXZ PROC				; svga_ring_doorbell

; 340  : void svga_ring_doorbell () {

$LN4:
	sub	rsp, 40					; 00000028H

; 341  : 	if (svga_is_fifo_reg_valid (SVGA_FIFO_BUSY) && svga_dev.fifo_mem[SVGA_FIFO_BUSY] == false) {

	mov	ecx, 290				; 00000122H
	call	?svga_is_fifo_reg_valid@@YA_NH@Z	; svga_is_fifo_reg_valid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@svga_ring_
	mov	eax, 4
	imul	rax, 290				; 00000122H
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	cmp	DWORD PTR [rcx+rax], 0
	jne	SHORT $LN1@svga_ring_

; 342  : 		svga_dev.fifo_mem[SVGA_FIFO_BUSY] = true;

	mov	eax, 4
	imul	rax, 290				; 00000122H
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	DWORD PTR [rcx+rax], 1

; 343  : 		svga_write_reg (SVGA_REG_SYNC, 1);

	mov	edx, 1
	mov	ecx, 21
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg
$LN1@svga_ring_:

; 344  : 	}
; 345  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_ring_doorbell@@YAXXZ ENDP				; svga_ring_doorbell
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
padded_bytes$ = 32
h$ = 40
nsid$ = 64
bytes$ = 72
?svga_fifo_reserve_escape@@YAPEAXII@Z PROC		; svga_fifo_reserve_escape

; 304  : void* svga_fifo_reserve_escape (uint32_t nsid, uint32_t bytes) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 305  : 
; 306  : 	uint32_t padded_bytes = (bytes + 3) & ~3UL;

	mov	eax, DWORD PTR bytes$[rsp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	mov	DWORD PTR padded_bytes$[rsp], eax

; 307  : #pragma pack (push)
; 308  : 	struct header{
; 309  : 		uint32_t cmd;
; 310  : 		uint32_t nsid;
; 311  : 		uint32_t size;
; 312  : 	};
; 313  : #pragma pack (pop)
; 314  : 
; 315  : 	header *h = (header*)svga_fifo_reserve (padded_bytes + sizeof (header));

	mov	eax, DWORD PTR padded_bytes$[rsp]
	add	rax, 12
	mov	ecx, eax
	call	?svga_fifo_reserve@@YAPEAXI@Z		; svga_fifo_reserve
	mov	QWORD PTR h$[rsp], rax

; 316  : 	h->cmd = SVGA_CMD_ESCAPE;

	mov	rax, QWORD PTR h$[rsp]
	mov	DWORD PTR [rax], 33			; 00000021H

; 317  : 	h->nsid = nsid;

	mov	rax, QWORD PTR h$[rsp]
	mov	ecx, DWORD PTR nsid$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 318  : 	h->size = bytes;

	mov	rax, QWORD PTR h$[rsp]
	mov	ecx, DWORD PTR bytes$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 319  : 
; 320  : 	return h + 1;

	mov	rax, QWORD PTR h$[rsp]
	add	rax, 12

; 321  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_fifo_reserve_escape@@YAPEAXII@Z ENDP		; svga_fifo_reserve_escape
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
cmd$ = 32
type$ = 64
bytes$ = 72
?svga_fifo_reserved_cmd@@YAPEAXII@Z PROC		; svga_fifo_reserved_cmd

; 297  : void* svga_fifo_reserved_cmd (uint32_t type, uint32_t bytes) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 298  : 	uint32_t*cmd = (uint32_t*)svga_fifo_reserve (bytes + sizeof type);

	mov	eax, DWORD PTR bytes$[rsp]
	add	rax, 4
	mov	ecx, eax
	call	?svga_fifo_reserve@@YAPEAXI@Z		; svga_fifo_reserve
	mov	QWORD PTR cmd$[rsp], rax

; 299  : 	cmd[0] = type;

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR cmd$[rsp]
	mov	edx, DWORD PTR type$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 300  : 	return cmd + 1;

	mov	rax, QWORD PTR cmd$[rsp]
	add	rax, 4

; 301  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_fifo_reserved_cmd@@YAPEAXII@Z ENDP		; svga_fifo_reserved_cmd
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
?svga_fifo_commit_all@@YAXXZ PROC			; svga_fifo_commit_all

; 293  : void svga_fifo_commit_all () {

$LN3:
	sub	rsp, 40					; 00000028H

; 294  : 	svga_fifo_commit (svga_dev.fifo.reserved_size);

	mov	ecx, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+60
	call	?svga_fifo_commit@@YAXI@Z		; svga_fifo_commit

; 295  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_fifo_commit_all@@YAXXZ ENDP			; svga_fifo_commit_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
next_cmd$ = 32
reserveable$ = 36
max$ = 40
fifo$ = 48
min$ = 56
chunk_size$1 = 60
tv84 = 64
buffer$2 = 72
dword$3 = 80
tv130 = 88
bytes$ = 112
?svga_fifo_commit@@YAXI@Z PROC				; svga_fifo_commit

; 240  : void svga_fifo_commit (uint32_t bytes) {

$LN16:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 241  : 	
; 242  : 	volatile uint32_t *fifo = svga_dev.fifo_mem;

	mov	rax, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	QWORD PTR fifo$[rsp], rax

; 243  : 	//printf ("FIFO Commit address -> %x\n", fifo);
; 244  : 	uint32_t next_cmd = fifo[SVGA_FIFO_NEXT_CMD];

	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR next_cmd$[rsp], eax

; 245  : 	uint32_t max = fifo[SVGA_FIFO_MAX];

	mov	eax, 4
	imul	rax, 1
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR max$[rsp], eax

; 246  : 	uint32_t min = fifo[SVGA_FIFO_MIN];

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR min$[rsp], eax

; 247  : 
; 248  : 	bool reserveable = svga_has_fifo_cap (SVGA_FIFO_CAP_RESERVE);

	mov	ecx, 64					; 00000040H
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	mov	BYTE PTR reserveable$[rsp], al

; 249  : 
; 250  : 	if (svga_dev.fifo.reserved_size == 0) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+60, 0
	jne	SHORT $LN11@svga_fifo_

; 251  : 		printf ("[VMware SVGA]: FIFO commit before FIFO reserve\n");

	lea	rcx, OFFSET FLAT:$SG5492
	call	?printf@@YAXPEBDZZ			; printf
$LN11@svga_fifo_:

; 252  : 	}
; 253  : 	svga_dev.fifo.reserved_size = 0;

	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+60, 0

; 254  : 
; 255  : 	if (svga_dev.fifo.using_bounce_buffer) {

	movzx	eax, BYTE PTR ?svga_dev@@3U_svga_drive_@@A+64
	test	eax, eax
	je	$LN10@svga_fifo_

; 256  : 		//printf ("Commit using bounce buffer\n");
; 257  : 		uint8_t* buffer = svga_dev.fifo.bounce_buffer;

	lea	rax, OFFSET FLAT:?svga_dev@@3U_svga_drive_@@A+65
	mov	QWORD PTR buffer$2[rsp], rax

; 258  : 		//printf ("Bounce buffer -> %x\n", buffer);
; 259  : 		if (reserveable) {

	movzx	eax, BYTE PTR reserveable$[rsp]
	test	eax, eax
	je	$LN9@svga_fifo_

; 260  : 			//printf ("Reserved\n");
; 261  : 			uint32_t chunk_size = MIN (bytes, max - next_cmd);

	mov	eax, DWORD PTR next_cmd$[rsp]
	mov	ecx, DWORD PTR max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cmp	DWORD PTR bytes$[rsp], eax
	jae	SHORT $LN14@svga_fifo_
	mov	eax, DWORD PTR bytes$[rsp]
	mov	DWORD PTR tv84[rsp], eax
	jmp	SHORT $LN15@svga_fifo_
$LN14@svga_fifo_:
	mov	eax, DWORD PTR next_cmd$[rsp]
	mov	ecx, DWORD PTR max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv84[rsp], eax
$LN15@svga_fifo_:
	mov	eax, DWORD PTR tv84[rsp]
	mov	DWORD PTR chunk_size$1[rsp], eax

; 262  : 			fifo[SVGA_FIFO_RESERVED] = bytes;

	mov	eax, 4
	imul	rax, 14
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	edx, DWORD PTR bytes$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 263  : 			memcpy (next_cmd + (uint8_t*) fifo, buffer, chunk_size);

	mov	eax, DWORD PTR next_cmd$[rsp]
	mov	rcx, QWORD PTR fifo$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8d, DWORD PTR chunk_size$1[rsp]
	mov	rdx, QWORD PTR buffer$2[rsp]
	mov	rcx, rax
	call	memcpy

; 264  : 			memcpy (min + (uint8_t*)fifo, buffer + chunk_size, bytes - chunk_size);

	mov	eax, DWORD PTR chunk_size$1[rsp]
	mov	ecx, DWORD PTR bytes$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR chunk_size$1[rsp]
	mov	rdx, QWORD PTR buffer$2[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	edx, DWORD PTR min$[rsp]
	mov	r8, QWORD PTR fifo$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv130[rsp], rdx
	mov	r8d, eax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv130[rsp]
	mov	rcx, rax
	call	memcpy

; 265  : 		} else {

	jmp	SHORT $LN8@svga_fifo_
$LN9@svga_fifo_:

; 266  : 			uint32_t *dword = (uint32_t*) buffer;

	mov	rax, QWORD PTR buffer$2[rsp]
	mov	QWORD PTR dword$3[rsp], rax
$LN7@svga_fifo_:

; 267  : 			while (bytes > 0) {

	cmp	DWORD PTR bytes$[rsp], 0
	jbe	SHORT $LN6@svga_fifo_

; 268  : 				fifo[next_cmd / sizeof *dword] = *dword++;

	mov	eax, DWORD PTR next_cmd$[rsp]
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	rdx, QWORD PTR dword$3[rsp]
	mov	edx, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+rax*4], edx
	mov	rax, QWORD PTR dword$3[rsp]
	add	rax, 4
	mov	QWORD PTR dword$3[rsp], rax

; 269  : 				next_cmd += sizeof *dword;

	mov	eax, DWORD PTR next_cmd$[rsp]
	add	rax, 4
	mov	DWORD PTR next_cmd$[rsp], eax

; 270  : 				if (next_cmd == max) {

	mov	eax, DWORD PTR max$[rsp]
	cmp	DWORD PTR next_cmd$[rsp], eax
	jne	SHORT $LN5@svga_fifo_

; 271  : 					next_cmd = min;

	mov	eax, DWORD PTR min$[rsp]
	mov	DWORD PTR next_cmd$[rsp], eax
$LN5@svga_fifo_:

; 272  : 				}
; 273  : 				fifo[SVGA_FIFO_NEXT_CMD] = next_cmd;

	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	edx, DWORD PTR next_cmd$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 274  : 				bytes -= sizeof *dword;

	mov	eax, DWORD PTR bytes$[rsp]
	sub	rax, 4
	mov	DWORD PTR bytes$[rsp], eax

; 275  : 			}

	jmp	SHORT $LN7@svga_fifo_
$LN6@svga_fifo_:
$LN8@svga_fifo_:
$LN10@svga_fifo_:

; 276  : 		}
; 277  : 	}
; 278  : 
; 279  : 	if (!svga_dev.fifo.using_bounce_buffer || reserveable) {

	movzx	eax, BYTE PTR ?svga_dev@@3U_svga_drive_@@A+64
	test	eax, eax
	je	SHORT $LN3@svga_fifo_
	movzx	eax, BYTE PTR reserveable$[rsp]
	test	eax, eax
	je	SHORT $LN4@svga_fifo_
$LN3@svga_fifo_:

; 280  : 		next_cmd += bytes;

	mov	eax, DWORD PTR bytes$[rsp]
	mov	ecx, DWORD PTR next_cmd$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR next_cmd$[rsp], eax

; 281  : 		if (next_cmd >= max) {

	mov	eax, DWORD PTR max$[rsp]
	cmp	DWORD PTR next_cmd$[rsp], eax
	jb	SHORT $LN2@svga_fifo_

; 282  : 			next_cmd -= max - min;

	mov	eax, DWORD PTR min$[rsp]
	mov	ecx, DWORD PTR max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR next_cmd$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR next_cmd$[rsp], eax
$LN2@svga_fifo_:

; 283  : 		}
; 284  : 		fifo[SVGA_FIFO_NEXT_CMD] = next_cmd;

	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	edx, DWORD PTR next_cmd$[rsp]
	mov	DWORD PTR [rcx+rax], edx
$LN4@svga_fifo_:

; 285  : 	}
; 286  : 
; 287  : 	if (reserveable) {

	movzx	eax, BYTE PTR reserveable$[rsp]
	test	eax, eax
	je	SHORT $LN1@svga_fifo_

; 288  : 		fifo[SVGA_FIFO_RESERVED] = 0;

	mov	eax, 4
	imul	rax, 14
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	DWORD PTR [rcx+rax], 0
$LN1@svga_fifo_:

; 289  : 	}
; 290  : 	//printf ("Fifo commited\n");
; 291  : }

	add	rsp, 104				; 00000068H
	ret	0
?svga_fifo_commit@@YAXI@Z ENDP				; svga_fifo_commit
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
reserve_in_place$1 = 32
need_bounce$2 = 33
reserveable$ = 34
next_cmd$ = 36
stop$3 = 40
max$ = 44
min$ = 48
fifo$ = 56
bytes$ = 80
?svga_fifo_reserve@@YAPEAXI@Z PROC			; svga_fifo_reserve

; 166  : void* svga_fifo_reserve (uint32_t bytes) {

$LN23:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 167  : 
; 168  : 	volatile uint32_t *fifo = svga_dev.fifo_mem;

	mov	rax, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	QWORD PTR fifo$[rsp], rax

; 169  : 	uint32_t max = fifo[SVGA_FIFO_MAX];

	mov	eax, 4
	imul	rax, 1
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR max$[rsp], eax

; 170  : 	uint32_t min = fifo[SVGA_FIFO_MIN];

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR min$[rsp], eax

; 171  : 	uint32_t next_cmd = fifo[SVGA_FIFO_NEXT_CMD];

	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR next_cmd$[rsp], eax

; 172  : 	bool reserveable = svga_has_fifo_cap (SVGA_FIFO_CAP_RESERVE);

	mov	ecx, 64					; 00000040H
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	mov	BYTE PTR reserveable$[rsp], al

; 173  : 
; 174  : 	if (bytes  > sizeof (svga_dev.fifo.bounce_buffer)/* || bytes > (max - min)*/) {

	mov	eax, DWORD PTR bytes$[rsp]
	cmp	rax, 1048576				; 00100000H
	jbe	SHORT $LN20@svga_fifo_

; 175  : 		printf ("[VMware SVGA]: FIFO command too large %d bytes\n", bytes);

	mov	edx, DWORD PTR bytes$[rsp]
	lea	rcx, OFFSET FLAT:$SG5454
	call	?printf@@YAXPEBDZZ			; printf
$LN20@svga_fifo_:

; 176  : 		//for(;;);
; 177  : 	}
; 178  : 
; 179  : 	if (bytes % sizeof (uint32_t)) {

	mov	eax, DWORD PTR bytes$[rsp]
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN19@svga_fifo_

; 180  : 		printf ("[VMware SVGA]: FIFO command length not 32-bit aligned\n");

	lea	rcx, OFFSET FLAT:$SG5457
	call	?printf@@YAXPEBDZZ			; printf
$LN19@svga_fifo_:

; 181  : 		//for(;;);
; 182  : 	}
; 183  : 
; 184  : 	if (svga_dev.fifo.reserved_size != 0) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+60, 0
	je	SHORT $LN18@svga_fifo_

; 185  : 		printf ("[VMware SVGA]: FIFO reserve before FIFO commit\n");

	lea	rcx, OFFSET FLAT:$SG5459
	call	?printf@@YAXPEBDZZ			; printf
$LN18@svga_fifo_:

; 186  : 		//for(;;);
; 187  : 	}
; 188  : 
; 189  : 	svga_dev.fifo.reserved_size = bytes;

	mov	eax, DWORD PTR bytes$[rsp]
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+60, eax
$LN17@svga_fifo_:

; 190  : 
; 191  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN16@svga_fifo_

; 192  : 		uint32_t stop = fifo[SVGA_FIFO_STOP];

	mov	eax, 4
	imul	rax, 3
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR stop$3[rsp], eax

; 193  : 		bool reserve_in_place = false;

	mov	BYTE PTR reserve_in_place$1[rsp], 0

; 194  : 		bool need_bounce = false;

	mov	BYTE PTR need_bounce$2[rsp], 0

; 195  : 		//printf ("Stop -> %d\n", stop);
; 196  : 		if (next_cmd >= stop) {

	mov	eax, DWORD PTR stop$3[rsp]
	cmp	DWORD PTR next_cmd$[rsp], eax
	jb	SHORT $LN15@svga_fifo_

; 197  : 			//printf ("Debug Step[1]\n");
; 198  : 			if (next_cmd + bytes < max ||
; 199  : 				(next_cmd + bytes == max && stop > min)) {

	mov	eax, DWORD PTR bytes$[rsp]
	mov	ecx, DWORD PTR next_cmd$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR max$[rsp]
	jb	SHORT $LN13@svga_fifo_
	mov	eax, DWORD PTR bytes$[rsp]
	mov	ecx, DWORD PTR next_cmd$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR max$[rsp]
	jne	SHORT $LN14@svga_fifo_
	mov	eax, DWORD PTR min$[rsp]
	cmp	DWORD PTR stop$3[rsp], eax
	jbe	SHORT $LN14@svga_fifo_
$LN13@svga_fifo_:

; 200  : 					//printf ("Debug Step [2]\n");
; 201  : 					reserve_in_place = true;

	mov	BYTE PTR reserve_in_place$1[rsp], 1
	jmp	SHORT $LN12@svga_fifo_
$LN14@svga_fifo_:

; 202  : 			} else if ((max - next_cmd) + (stop - min) <= bytes) {

	mov	eax, DWORD PTR next_cmd$[rsp]
	mov	ecx, DWORD PTR max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR min$[rsp]
	mov	edx, DWORD PTR stop$3[rsp]
	sub	edx, ecx
	mov	ecx, edx
	add	eax, ecx
	cmp	eax, DWORD PTR bytes$[rsp]
	ja	SHORT $LN11@svga_fifo_

; 203  : 				svga_fifo_full ();

	call	?svga_fifo_full@@YAXXZ			; svga_fifo_full

; 204  : 				//printf ("Debug Step [4]\n");
; 205  : 			} else {

	jmp	SHORT $LN10@svga_fifo_
$LN11@svga_fifo_:

; 206  : 				need_bounce = true;

	mov	BYTE PTR need_bounce$2[rsp], 1
$LN10@svga_fifo_:
$LN12@svga_fifo_:

; 207  : 				//printf ("Debug Step [5]\n");
; 208  : 			}
; 209  : 		}else {

	jmp	SHORT $LN9@svga_fifo_
$LN15@svga_fifo_:

; 210  : 			if (next_cmd + bytes < stop) {

	mov	eax, DWORD PTR bytes$[rsp]
	mov	ecx, DWORD PTR next_cmd$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR stop$3[rsp]
	jae	SHORT $LN8@svga_fifo_

; 211  : 				reserve_in_place = true;

	mov	BYTE PTR reserve_in_place$1[rsp], 1

; 212  : 				//printf ("Debug Step [6]\n");
; 213  : 			}else {

	jmp	SHORT $LN7@svga_fifo_
$LN8@svga_fifo_:

; 214  : 				svga_fifo_full ();

	call	?svga_fifo_full@@YAXXZ			; svga_fifo_full
$LN7@svga_fifo_:
$LN9@svga_fifo_:

; 215  : 				//printf ("Debug Step [7]\n");
; 216  : 			}
; 217  : 		}
; 218  : 		if (reserve_in_place) {

	movzx	eax, BYTE PTR reserve_in_place$1[rsp]
	test	eax, eax
	je	SHORT $LN6@svga_fifo_

; 219  : 			if (reserveable || bytes <= sizeof (uint32_t)) {

	movzx	eax, BYTE PTR reserveable$[rsp]
	test	eax, eax
	jne	SHORT $LN4@svga_fifo_
	mov	eax, DWORD PTR bytes$[rsp]
	cmp	rax, 4
	ja	SHORT $LN5@svga_fifo_
$LN4@svga_fifo_:

; 220  : 				svga_dev.fifo.using_bounce_buffer = false;

	mov	BYTE PTR ?svga_dev@@3U_svga_drive_@@A+64, 0

; 221  : 				//printf ("Debug Step [9]\n");
; 222  : 				if (reserveable) {

	movzx	eax, BYTE PTR reserveable$[rsp]
	test	eax, eax
	je	SHORT $LN3@svga_fifo_

; 223  : 					//printf ("Reservable\n");
; 224  : 					fifo[SVGA_FIFO_RESERVED] = bytes;

	mov	eax, 4
	imul	rax, 14
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	edx, DWORD PTR bytes$[rsp]
	mov	DWORD PTR [rcx+rax], edx
$LN3@svga_fifo_:

; 225  : 				}
; 226  : 				return next_cmd + (uint8_t*)fifo;

	mov	eax, DWORD PTR next_cmd$[rsp]
	mov	rcx, QWORD PTR fifo$[rsp]
	add	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN21@svga_fifo_

; 227  : 			}else {

	jmp	SHORT $LN2@svga_fifo_
$LN5@svga_fifo_:

; 228  : 				//printf ("Debug Step [10]\n");
; 229  : 				need_bounce = true;

	mov	BYTE PTR need_bounce$2[rsp], 1
$LN2@svga_fifo_:
$LN6@svga_fifo_:

; 230  : 			}
; 231  : 		}
; 232  : 		if (need_bounce) {

	movzx	eax, BYTE PTR need_bounce$2[rsp]
	test	eax, eax
	je	SHORT $LN1@svga_fifo_

; 233  : 			svga_dev.fifo.using_bounce_buffer = true;

	mov	BYTE PTR ?svga_dev@@3U_svga_drive_@@A+64, 1

; 234  : 			return svga_dev.fifo.bounce_buffer;

	lea	rax, OFFSET FLAT:?svga_dev@@3U_svga_drive_@@A+65
	jmp	SHORT $LN21@svga_fifo_
$LN1@svga_fifo_:

; 235  : 		}
; 236  : 	}

	jmp	$LN17@svga_fifo_
$LN16@svga_fifo_:
$LN21@svga_fifo_:

; 237  : }

	add	rsp, 72					; 00000048H
	ret	0
?svga_fifo_reserve@@YAPEAXI@Z ENDP			; svga_fifo_reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
?svga_fifo_full@@YAXXZ PROC				; svga_fifo_full

; 323  : void svga_fifo_full () {

$LN5:
	sub	rsp, 40					; 00000028H

; 324  : 	if (svga_is_fifo_reg_valid (SVGA_FIFO_FENCE_GOAL) &&
; 325  : 		(svga_dev.capabilities & SVGA_CAP_IRQMASK)) {

	mov	ecx, 289				; 00000121H
	call	?svga_is_fifo_reg_valid@@YA_NH@Z	; svga_is_fifo_reg_valid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@svga_fifo_
	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+40
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN2@svga_fifo_

; 326  : 
; 327  : 			svga_write_reg (SVGA_REG_IRQMASK, SVGA_IRQFLAG_FIFO_PROGRESS);

	mov	edx, 2
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 328  : 			x64_cli();

	call	x64_cli

; 329  : 			svga_ring_doorbell ();

	call	?svga_ring_doorbell@@YAXXZ		; svga_ring_doorbell

; 330  : 			svga_wait_for_irq();

	call	?svga_wait_for_irq@@YAIXZ		; svga_wait_for_irq

; 331  : 			svga_write_reg (SVGA_REG_IRQMASK, 0);

	xor	edx, edx
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 332  : 			x64_sti();

	call	x64_sti

; 333  : 	} else {

	jmp	SHORT $LN1@svga_fifo_
$LN2@svga_fifo_:

; 334  : 		svga_write_reg (SVGA_REG_SYNC, 1);

	mov	edx, 1
	mov	ecx, 21
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 335  : 		svga_read_reg (SVGA_REG_BUSY);

	mov	ecx, 22
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
$LN1@svga_fifo_:

; 336  : 	}
; 337  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_fifo_full@@YAXXZ ENDP				; svga_fifo_full
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
width$ = 48
height$ = 56
bpp$ = 64
?svga_set_mode@@YAXIII@Z PROC				; svga_set_mode

; 154  : void svga_set_mode (uint32_t width, uint32_t height, uint32_t bpp) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 155  : 	svga_dev.width = width;

	mov	eax, DWORD PTR width$[rsp]
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+44, eax

; 156  : 	svga_dev.height = height;

	mov	eax, DWORD PTR height$[rsp]
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+48, eax

; 157  : 	svga_dev.bpp = bpp;

	mov	eax, DWORD PTR bpp$[rsp]
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+52, eax

; 158  : 
; 159  : 	svga_write_reg (SVGA_REG_WIDTH, width);

	mov	edx, DWORD PTR width$[rsp]
	mov	ecx, 2
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 160  : 	svga_write_reg (SVGA_REG_HEIGHT, height);

	mov	edx, DWORD PTR height$[rsp]
	mov	ecx, 3
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 161  : 	svga_write_reg (SVGA_REG_BITS_PER_PIXEL, bpp);

	mov	edx, DWORD PTR bpp$[rsp]
	mov	ecx, 7
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 162  : 	svga_write_reg (SVGA_REG_ENABLE, true);

	mov	edx, 1
	mov	ecx, 1
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 163  : 	svga_dev.pitch = svga_read_reg (SVGA_REG_BYTES_PER_LINE);

	mov	ecx, 12
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+56, eax

; 164  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_set_mode@@YAXIII@Z ENDP				; svga_set_mode
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
?svga_enable@@YAXXZ PROC				; svga_enable

; 109  : void svga_enable () {

$LN8:
	sub	rsp, 40					; 00000028H

; 110  : 
; 111  : 	svga_dev.fifo_mem[SVGA_FIFO_MIN] = SVGA_FIFO_NUM_REGS * sizeof(uint32_t);

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	DWORD PTR [rcx+rax], 1164		; 0000048cH

; 112  : 	svga_dev.fifo_mem[SVGA_FIFO_MAX] = svga_dev.fifo_size;

	mov	eax, 4
	imul	rax, 1
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	edx, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+24
	mov	DWORD PTR [rcx+rax], edx

; 113  : 	svga_dev.fifo_mem[SVGA_FIFO_NEXT_CMD] = svga_dev.fifo_mem[SVGA_FIFO_MIN];

	mov	eax, 4
	imul	rax, 0
	mov	ecx, 4
	imul	rcx, 2
	mov	rdx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	r8, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	eax, DWORD PTR [r8+rax]
	mov	DWORD PTR [rdx+rcx], eax

; 114  : 	svga_dev.fifo_mem[SVGA_FIFO_STOP] = svga_dev.fifo_mem[SVGA_FIFO_MIN];

	mov	eax, 4
	imul	rax, 0
	mov	ecx, 4
	imul	rcx, 3
	mov	rdx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	r8, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	eax, DWORD PTR [r8+rax]
	mov	DWORD PTR [rdx+rcx], eax

; 115  : 
; 116  : 	if (svga_has_fifo_cap (SVGA_CAP_EXTENDED_FIFO) &&
; 117  : 		svga_is_fifo_reg_valid (SVGA_FIFO_GUEST_3D_HWVERSION)) {

	mov	ecx, 32768				; 00008000H
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@svga_enabl
	mov	ecx, 288				; 00000120H
	call	?svga_is_fifo_reg_valid@@YA_NH@Z	; svga_is_fifo_reg_valid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@svga_enabl

; 118  : 			svga_dev.fifo_mem[SVGA_FIFO_GUEST_3D_HWVERSION] = SVGA3D_HWVERSION_CURRENT;

	mov	eax, 4
	imul	rax, 288				; 00000120H
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	DWORD PTR [rcx+rax], 131073		; 00020001H
$LN5@svga_enabl:

; 119  : 	}
; 120  : 
; 121  : 	//!Enable SVGA device and FIFO
; 122  : 	svga_write_reg (SVGA_REG_ENABLE, true);

	mov	edx, 1
	mov	ecx, 1
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 123  : 	svga_write_reg (SVGA_REG_CONFIG_DONE, true);

	mov	edx, 1
	mov	ecx, 20
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 124  : 
; 125  : 	if (svga_dev.capabilities & SVGA_CAP_IRQMASK) {

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+40
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN4@svga_enabl

; 126  : 		svga_write_reg (SVGA_REG_IRQMASK, SVGA_IRQFLAG_ANY_FENCE);

	mov	edx, 1
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 127  : 
; 128  : 		svga_insert_fence ();

	call	?svga_insert_fence@@YAIXZ		; svga_insert_fence

; 129  : 
; 130  : 		svga_write_reg (SVGA_REG_SYNC, 1);

	mov	edx, 1
	mov	ecx, 21
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg
$LN3@svga_enabl:

; 131  : 		while (svga_read_reg (SVGA_REG_BUSY) != false);

	mov	ecx, 22
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	test	eax, eax
	je	SHORT $LN2@svga_enabl
	jmp	SHORT $LN3@svga_enabl
$LN2@svga_enabl:

; 132  : 
; 133  : 		svga_write_reg (SVGA_REG_IRQMASK, 0);

	xor	edx, edx
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 134  : 
; 135  : 		if ((svga_dev.irq.pending & SVGA_IRQFLAG_ANY_FENCE) == 0) {

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048648
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN1@svga_enabl

; 136  : 			printf ("SVGA IRQ appears to be present but broken %d\n", svga_dev.irq.pending);

	mov	edx, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048648
	lea	rcx, OFFSET FLAT:$SG5434
	call	?printf@@YAXPEBDZZ			; printf
$LN1@svga_enabl:
$LN4@svga_enabl:

; 137  : 		}
; 138  : 		
; 139  : 	}
; 140  : 
; 141  : 	
; 142  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_enable@@YAXXZ ENDP				; svga_enable
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
irq$1 = 32
?svga_init@@YAXXZ PROC					; svga_init

; 43   : void svga_init () {

$LN15:
	sub	rsp, 56					; 00000038H

; 44   : 	
; 45   : 	if (!pci_find_device (PCI_VENDOR_ID_VMWARE, PCI_DEVICE_ID_VMWARE_SVGA2, &svga_dev.pci_addr)) {

	lea	r8, OFFSET FLAT:?svga_dev@@3U_svga_drive_@@A ; svga_dev
	mov	dx, 1029				; 00000405H
	mov	cx, 5549				; 000015adH
	call	?pci_find_device@@YA_NGGPEAU_pci_address_@@@Z ; pci_find_device
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@svga_init

; 46   : 		printf ("No VMware SVGA device found\n");

	lea	rcx, OFFSET FLAT:$SG5404
	call	?printf@@YAXPEBDZZ			; printf
$LN12@svga_init:

; 47   : 	}
; 48   : 
; 49   : 	pci_set_mem_enable (&svga_dev.pci_addr, true);

	mov	dl, 1
	lea	rcx, OFFSET FLAT:?svga_dev@@3U_svga_drive_@@A ; svga_dev
	call	?pci_set_mem_enable@@YAXPEBU_pci_address_@@_N@Z ; pci_set_mem_enable

; 50   : 	svga_dev.io_base = pci_get_bar_addr (&svga_dev.pci_addr,0);

	xor	edx, edx
	lea	rcx, OFFSET FLAT:?svga_dev@@3U_svga_drive_@@A ; svga_dev
	call	?pci_get_bar_addr@@YAIPEBU_pci_address_@@H@Z ; pci_get_bar_addr
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+4, eax

; 51   : 	svga_dev.fb_mem = (uint8_t*)pci_get_bar_addr (&svga_dev.pci_addr, 1);

	mov	edx, 1
	lea	rcx, OFFSET FLAT:?svga_dev@@3U_svga_drive_@@A ; svga_dev
	call	?pci_get_bar_addr@@YAIPEBU_pci_address_@@H@Z ; pci_get_bar_addr
	mov	eax, eax
	mov	QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16, rax

; 52   : 	svga_dev.fifo_mem = (uint32_t*)pci_get_bar_addr (&svga_dev.pci_addr, 2);

	mov	edx, 2
	lea	rcx, OFFSET FLAT:?svga_dev@@3U_svga_drive_@@A ; svga_dev
	call	?pci_get_bar_addr@@YAIPEBU_pci_address_@@H@Z ; pci_get_bar_addr
	mov	eax, eax
	mov	QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8, rax

; 53   : 
; 54   : 	svga_dev.device_version_id = SVGA_ID_2;

	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+36, -1879048190 ; 90000002H
$LN11@svga_init:

; 55   : 	do {
; 56   : 		svga_write_reg (SVGA_REG_ID, svga_dev.device_version_id);

	mov	edx, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+36
	xor	ecx, ecx
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 57   : 		if (svga_read_reg (SVGA_REG_ID) == svga_dev.device_version_id) {

	xor	ecx, ecx
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	cmp	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+36
	jne	SHORT $LN8@svga_init

; 58   : 			break;

	jmp	SHORT $LN9@svga_init

; 59   : 		}else {

	jmp	SHORT $LN7@svga_init
$LN8@svga_init:

; 60   : 			svga_dev.device_version_id--;

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+36
	dec	eax
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+36, eax
$LN7@svga_init:

; 61   : 		}
; 62   : 	}while (svga_dev.device_version_id >= SVGA_ID_0);

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+36, -1879048192 ; 90000000H
	jae	SHORT $LN11@svga_init
$LN9@svga_init:

; 63   : 
; 64   : 	if (svga_dev.device_version_id < SVGA_ID_0) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+36, -1879048192 ; 90000000H
	jae	SHORT $LN6@svga_init

; 65   : 		printf ("[VMware SVGA]: negotiating SVGA device version!\n");

	lea	rcx, OFFSET FLAT:$SG5413
	call	?printf@@YAXPEBDZZ			; printf
$LN6@svga_init:

; 66   : 	}
; 67   : 
; 68   : 	svga_dev.vram_size = svga_read_reg (SVGA_REG_VRAM_SIZE);

	mov	ecx, 15
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+32, eax

; 69   : 	svga_dev.fb_size = svga_read_reg (SVGA_REG_FB_SIZE);

	mov	ecx, 16
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+28, eax

; 70   : 	svga_dev.fifo_size = svga_read_reg (SVGA_REG_MEM_SIZE);

	mov	ecx, 19
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+24, eax

; 71   : 
; 72   : 	//! sanity check the fifo and framebuffer sizes
; 73   : 	if (svga_dev.fb_size < 0x100000) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+28, 1048576 ; 00100000H
	jae	SHORT $LN5@svga_init

; 74   : 		printf ("[VMware SVGA]: FrameBuffer size is very small, probably incorrect\n");

	lea	rcx, OFFSET FLAT:$SG5415
	call	?printf@@YAXPEBDZZ			; printf
$LN5@svga_init:

; 75   : 	}
; 76   : 
; 77   : 	if (svga_dev.fifo_size < 0x20000) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+24, 131072 ; 00020000H
	jae	SHORT $LN4@svga_init

; 78   : 		printf ("[VMware SVGA]: FIFO size is very small, probably incorrect\n");

	lea	rcx, OFFSET FLAT:$SG5417
	call	?printf@@YAXPEBDZZ			; printf
$LN4@svga_init:

; 79   : 	}
; 80   : 
; 81   : 	if (svga_dev.device_version_id >= SVGA_ID_1) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+36, -1879048191 ; 90000001H
	jb	SHORT $LN3@svga_init

; 82   : 		svga_dev.capabilities = svga_read_reg (SVGA_REG_CAPABILITIES);

	mov	ecx, 17
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+40, eax
$LN3@svga_init:

; 83   : 	}
; 84   : 
; 85   : 	//!interrupts
; 86   : 	if (svga_dev.capabilities & SVGA_CAP_IRQMASK) {

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+40
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN2@svga_init

; 87   : 		uint8_t irq = pci_config_read8 (&svga_dev.pci_addr, offsetof (pci_config_space,intr_line));

	mov	dx, 60					; 0000003cH
	lea	rcx, OFFSET FLAT:?svga_dev@@3U_svga_drive_@@A ; svga_dev
	call	?pci_config_read8@@YAEPEBU_pci_address_@@G@Z ; pci_config_read8
	mov	BYTE PTR irq$1[rsp], al

; 88   : 		svga_write_reg (SVGA_REG_IRQMASK, 0);

	xor	edx, edx
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 89   : 		printf ("Irq of svga -> %d\n", irq);

	movzx	eax, BYTE PTR irq$1[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG5423
	call	?printf@@YAXPEBDZZ			; printf

; 90   : 		outportd (svga_dev.io_base + SVGA_IRQSTATUS_PORT, 0xff);

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+4
	add	eax, 8
	mov	edx, 255				; 000000ffH
	movzx	ecx, ax
	call	?outportd@@YAXGI@Z			; outportd

; 91   : 		if (irq <= 244) {

	movzx	eax, BYTE PTR irq$1[rsp]
	cmp	eax, 244				; 000000f4H
	jg	SHORT $LN1@svga_init

; 92   : 		interrupt_set (irq, svga_interrupt_handler, irq);

	movzx	eax, BYTE PTR irq$1[rsp]
	movzx	r8d, BYTE PTR irq$1[rsp]
	lea	rdx, OFFSET FLAT:?svga_interrupt_handler@@YAX_KPEAX@Z ; svga_interrupt_handler
	mov	ecx, eax
	call	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z	; interrupt_set
$LN1@svga_init:
$LN2@svga_init:

; 93   : 		}
; 94   : 	}
; 95   : 
; 96   : 
; 97   : 	svga_enable();

	call	?svga_enable@@YAXXZ			; svga_enable

; 98   : 	svga_set_mode (1280,1024,32);

	mov	r8d, 32					; 00000020H
	mov	edx, 1024				; 00000400H
	mov	ecx, 1280				; 00000500H
	call	?svga_set_mode@@YAXIII@Z		; svga_set_mode

; 99   : 	gmr_init();

	call	?gmr_init@@YAXXZ			; gmr_init

; 100  : 	memset(svga_dev.fb_mem,0x40,svga_dev.width*svga_dev.height*32);

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+44
	imul	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+48
	imul	eax, 32					; 00000020H
	mov	r8d, eax
	mov	dl, 64					; 00000040H
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	call	?memset@@YAXPEAXEI@Z			; memset

; 101  : 	svga_update(0,0,svga_dev.width,svga_dev.height);

	mov	r9d, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+48
	mov	r8d, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+44
	xor	edx, edx
	xor	ecx, ecx
	call	?svga_update@@YAXIIII@Z			; svga_update

; 102  : 	screen_set_configuration(svga_dev.width,svga_dev.height);

	mov	edx, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+48
	mov	ecx, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+44
	call	?screen_set_configuration@@YAXII@Z	; screen_set_configuration

; 103  : 
; 104  : 	vm_backdoor_mouse_init (true);

	mov	cl, 1
	call	?vm_backdoor_mouse_init@@YAX_N@Z	; vm_backdoor_mouse_init

; 105  : 
; 106  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_init@@YAXXZ ENDP					; svga_init
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
tv68 = 0
cap$ = 32
?svga_has_fifo_cap@@YA_NH@Z PROC			; svga_has_fifo_cap

; 38   : bool svga_has_fifo_cap (int cap) {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 39   : 	return (svga_dev.fifo_mem[SVGA_FIFO_CAPABILITIES] & cap) != 0;

	mov	eax, 4
	imul	rax, 4
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	mov	edx, DWORD PTR cap$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, edx
	test	eax, eax
	je	SHORT $LN3@svga_has_f
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@svga_has_f
$LN3@svga_has_f:
	mov	DWORD PTR tv68[rsp], 0
$LN4@svga_has_f:
	movzx	eax, BYTE PTR tv68[rsp]

; 40   : }

	add	rsp, 24
	ret	0
?svga_has_fifo_cap@@YA_NH@Z ENDP			; svga_has_fifo_cap
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
tv68 = 0
reg$ = 32
?svga_is_fifo_reg_valid@@YA_NH@Z PROC			; svga_is_fifo_reg_valid

; 34   : bool svga_is_fifo_reg_valid (int reg) {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 35   : 	return svga_dev.fifo_mem[SVGA_FIFO_MIN] > (reg << 2);

	mov	eax, 4
	imul	rax, 0
	mov	ecx, DWORD PTR reg$[rsp]
	shl	ecx, 2
	mov	rdx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	cmp	DWORD PTR [rdx+rax], ecx
	jbe	SHORT $LN3@svga_is_fi
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@svga_is_fi
$LN3@svga_is_fi:
	mov	DWORD PTR tv68[rsp], 0
$LN4@svga_is_fi:
	movzx	eax, BYTE PTR tv68[rsp]

; 36   : }

	add	rsp, 24
	ret	0
?svga_is_fifo_reg_valid@@YA_NH@Z ENDP			; svga_is_fifo_reg_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
index$ = 48
value$ = 56
?svga_write_reg@@YAXII@Z PROC				; svga_write_reg

; 29   : void svga_write_reg (uint32_t index, uint32_t value) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 30   : 	outportd (svga_dev.io_base + SVGA_INDEX_PORT, index);

	mov	edx, DWORD PTR index$[rsp]
	movzx	ecx, WORD PTR ?svga_dev@@3U_svga_drive_@@A+4
	call	?outportd@@YAXGI@Z			; outportd

; 31   : 	outportd (svga_dev.io_base + SVGA_VALUE_PORT, value);

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+4
	inc	eax
	mov	edx, DWORD PTR value$[rsp]
	movzx	ecx, ax
	call	?outportd@@YAXGI@Z			; outportd

; 32   : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_write_reg@@YAXII@Z ENDP				; svga_write_reg
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
index$ = 48
?svga_read_reg@@YAII@Z PROC				; svga_read_reg

; 24   : uint32_t svga_read_reg (uint32_t index) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 25   : 	outportd (svga_dev.io_base + SVGA_INDEX_PORT, index);

	mov	edx, DWORD PTR index$[rsp]
	movzx	ecx, WORD PTR ?svga_dev@@3U_svga_drive_@@A+4
	call	?outportd@@YAXGI@Z			; outportd

; 26   : 	return inportd (svga_dev.io_base + SVGA_VALUE_PORT);

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+4
	inc	eax
	movzx	ecx, ax
	call	?inportd@@YAIG@Z			; inportd

; 27   : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_read_reg@@YAII@Z ENDP				; svga_read_reg
_TEXT	ENDS
END
