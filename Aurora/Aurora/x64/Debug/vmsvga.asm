; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?svga_dev@@3U_svga_drive_@@A			; svga_dev
_BSS	SEGMENT
?svga_dev@@3U_svga_drive_@@A DB 0100060H DUP (?)	; svga_dev
_BSS	ENDS
CONST	SEGMENT
$SG5804	DB	'No VMware SVGA device found', 0aH, 00H
	ORG $+3
$SG5814	DB	'[VMware SVGA]: negotiating SVGA device version!', 0aH, 00H
	ORG $+7
$SG5818	DB	'[VMware SVGA]: FIFO size is very small, probably incorre'
	DB	'ct', 0aH, 00H
$SG6124	DB	'svga', 00H
	ORG $+7
$SG5816	DB	'[VMware SVGA]: FrameBuffer size is very small, probably '
	DB	'incorrect', 0aH, 00H
	ORG $+5
$SG5822	DB	'Irq of svga -> %d', 0aH, 00H
	ORG $+5
$SG5823	DB	'SVGA initialized', 0aH, 00H
	ORG $+6
$SG5828	DB	'HW3D supported', 0aH, 00H
$SG5830	DB	'SVGA IRQMask', 0aH, 00H
	ORG $+2
$SG5835	DB	'SVGA IRQ appears to be present but broken %d', 0aH, 00H
	ORG $+2
$SG5849	DB	'[Aurora]: Actual Fifo Reserve function called', 0aH, 00H
	ORG $+1
$SG5854	DB	'[Aurora]: Fifo memory acquired', 0aH, 00H
$SG5857	DB	'[VMware SVGA]: FIFO command too large bytes', 0aH, 00H
	ORG $+3
$SG5860	DB	'[VMware SVGA]: FIFO command length not 32-bit aligned', 0aH
	DB	00H
	ORG $+1
$SG5862	DB	'[VMware SVGA]: FIFO reserve before FIFO commit', 0aH, 00H
$SG5869	DB	'[Aurora]: Stop -> %d', 0aH, 00H
	ORG $+2
$SG5871	DB	'[Aurora]: Debug Step[1]', 0aH, 00H
	ORG $+7
$SG5897	DB	'[VMware SVGA]: FIFO commit before FIFO reserve', 0aH, 00H
$SG5921	DB	'[Aurora]: Fifo Reserved function called', 0aH, 00H
	ORG $+7
$SG6078	DB	'SVGA interrupted', 0aH, 00H
	ORG $+6
$SG6081	DB	'Irq flags -> %d', 0aH, 00H
	ORG $+7
$SG6083	DB	'[VMware SVGA]: spurious SVGA IRQ', 0aH, 00H
	ORG $+6
$SG6125	DB	'/dev/svga', 00H
CONST	ENDS
PUBLIC	?svga_read_reg@@YAII@Z				; svga_read_reg
PUBLIC	?svga_write_reg@@YAXII@Z			; svga_write_reg
PUBLIC	?svga_is_fifo_reg_valid@@YA_NH@Z		; svga_is_fifo_reg_valid
PUBLIC	?svga_has_fifo_cap@@YA_NH@Z			; svga_has_fifo_cap
PUBLIC	?svga_init@@YAXXZ				; svga_init
PUBLIC	?svga_enable@@YAXXZ				; svga_enable
PUBLIC	?svga_disable@@YAXXZ				; svga_disable
PUBLIC	?svga_set_mode@@YAXIII@Z			; svga_set_mode
PUBLIC	?svga_fifo_full@@YAXXZ				; svga_fifo_full
PUBLIC	?svga_fifo_reserve@@YAPEAXI@Z			; svga_fifo_reserve
PUBLIC	?svga_fifo_commit@@YAXI@Z			; svga_fifo_commit
PUBLIC	?svga_fifo_commit_all@@YAXXZ			; svga_fifo_commit_all
PUBLIC	?svga_fifo_reserved_cmd@@YAPEAXII@Z		; svga_fifo_reserved_cmd
PUBLIC	?svga_fifo_reserve_escape@@YAPEAXII@Z		; svga_fifo_reserve_escape
PUBLIC	?svga_ring_doorbell@@YAXXZ			; svga_ring_doorbell
PUBLIC	?svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z	; svga_alloc_gmr
PUBLIC	?svga_update@@YAXIIII@Z				; svga_update
PUBLIC	?svga_begin_define_cursor@@YAXPEBUSVGAFifoCmdDefineCursor@@PEAPEAX1@Z ; svga_begin_define_cursor
PUBLIC	?svga_begin_define_alpha_cursor@@YAXPEBUSVGAFifoCmdDefineAlphaCursor@@PEAPEAX@Z ; svga_begin_define_alpha_cursor
PUBLIC	?svga_move_cursor@@YAXIIII@Z			; svga_move_cursor
PUBLIC	?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z ; svga_begin_video_set_regs
PUBLIC	?svga_video_set_all_regs@@YAXIPEAUSVGAOverlayUnit@@I@Z ; svga_video_set_all_regs
PUBLIC	?svga_video_set_reg@@YAXIII@Z			; svga_video_set_reg
PUBLIC	?svga_video_flush@@YAXI@Z			; svga_video_flush
PUBLIC	?svga_interrupt_handler@@YAX_KPEAX@Z		; svga_interrupt_handler
PUBLIC	?svga_panic@@YAXPEBD@Z				; svga_panic
PUBLIC	?svga_sync_to_fence@@YAXI@Z			; svga_sync_to_fence
PUBLIC	?svga_insert_fence@@YAIXZ			; svga_insert_fence
PUBLIC	?svga_wait_for_irq@@YAXXZ			; svga_wait_for_irq
PUBLIC	?svga_get_fb_mem@@YAPEAIXZ			; svga_get_fb_mem
PUBLIC	?svga_register_file@@YAXXZ			; svga_register_file
PUBLIC	?svga_has_fence_passed@@YA_NI@Z			; svga_has_fence_passed
PUBLIC	?svga_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z	; svga_io_query
EXTRN	x64_cli:PROC
EXTRN	x64_sti:PROC
EXTRN	?inportd@@YAIG@Z:PROC				; inportd
EXTRN	?outportd@@YAXGI@Z:PROC				; outportd
EXTRN	?interrupt_end@@YAXI@Z:PROC			; interrupt_end
EXTRN	?pci_find_device_class@@YA_NEEPEATpci_device_info@@PEAH11@Z:PROC ; pci_find_device_class
EXTRN	?strcpy@@YAPEADPEADPEBD@Z:PROC			; strcpy
EXTRN	?memset@@YAXPEAXEI@Z:PROC			; memset
EXTRN	memcpy:PROC
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
EXTRN	?pmmngr_alloc@@YAPEAXXZ:PROC			; pmmngr_alloc
EXTRN	?malloc@@YAPEAX_K@Z:PROC			; malloc
EXTRN	?gmr_init@@YAXXZ:PROC				; gmr_init
EXTRN	?vm_backdoor_mouse_init@@YAX_N@Z:PROC		; vm_backdoor_mouse_init
EXTRN	?get_screen_width@@YAIXZ:PROC			; get_screen_width
EXTRN	?get_screen_height@@YAIXZ:PROC			; get_screen_height
EXTRN	?get_bpp@@YAIXZ:PROC				; get_bpp
EXTRN	?get_screen_scanline@@YAGXZ:PROC		; get_screen_scanline
EXTRN	?debug_serial@@YAXPEAD@Z:PROC			; debug_serial
EXTRN	?hw_move_cursor@@YAXPEAIII@Z:PROC		; hw_move_cursor
EXTRN	?vfs_mount@@YAXPEADPEAU_vfs_node_@@@Z:PROC	; vfs_mount
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$?svga_read_reg@@YAII@Z DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?svga_read_reg@@YAII@Z
$pdata$?svga_write_reg@@YAXII@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?svga_write_reg@@YAXII@Z
$pdata$?svga_is_fifo_reg_valid@@YA_NH@Z DD imagerel $LN5
	DD	imagerel $LN5+61
	DD	imagerel $unwind$?svga_is_fifo_reg_valid@@YA_NH@Z
$pdata$?svga_has_fifo_cap@@YA_NH@Z DD imagerel $LN5
	DD	imagerel $LN5+62
	DD	imagerel $unwind$?svga_has_fifo_cap@@YA_NH@Z
$pdata$?svga_init@@YAXXZ DD imagerel $LN16
	DD	imagerel $LN16+680
	DD	imagerel $unwind$?svga_init@@YAXXZ
$pdata$?svga_enable@@YAXXZ DD imagerel $LN8
	DD	imagerel $LN8+368
	DD	imagerel $unwind$?svga_enable@@YAXXZ
$pdata$?svga_disable@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+21
	DD	imagerel $unwind$?svga_disable@@YAXXZ
$pdata$?svga_set_mode@@YAXIII@Z DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$?svga_set_mode@@YAXIII@Z
$pdata$?svga_fifo_full@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+115
	DD	imagerel $unwind$?svga_fifo_full@@YAXXZ
$pdata$?svga_fifo_reserve@@YAPEAXI@Z DD imagerel $LN23
	DD	imagerel $LN23+539
	DD	imagerel $unwind$?svga_fifo_reserve@@YAPEAXI@Z
$pdata$?svga_fifo_commit@@YAXI@Z DD imagerel $LN16
	DD	imagerel $LN16+593
	DD	imagerel $unwind$?svga_fifo_commit@@YAXI@Z
$pdata$?svga_fifo_commit_all@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+20
	DD	imagerel $unwind$?svga_fifo_commit_all@@YAXXZ
$pdata$?svga_fifo_reserved_cmd@@YAPEAXII@Z DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$?svga_fifo_reserved_cmd@@YAPEAXII@Z
$pdata$?svga_fifo_reserve_escape@@YAPEAXII@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?svga_fifo_reserve_escape@@YAPEAXII@Z
$pdata$?svga_ring_doorbell@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+92
	DD	imagerel $unwind$?svga_ring_doorbell@@YAXXZ
$pdata$?svga_update@@YAXIIII@Z DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$?svga_update@@YAXIIII@Z
$pdata$?svga_begin_define_cursor@@YAXPEBUSVGAFifoCmdDefineCursor@@PEAPEAX1@Z DD imagerel $LN3
	DD	imagerel $LN3+210
	DD	imagerel $unwind$?svga_begin_define_cursor@@YAXPEBUSVGAFifoCmdDefineCursor@@PEAPEAX1@Z
$pdata$?svga_begin_define_alpha_cursor@@YAXPEBUSVGAFifoCmdDefineAlphaCursor@@PEAPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$?svga_begin_define_alpha_cursor@@YAXPEBUSVGAFifoCmdDefineAlphaCursor@@PEAPEAX@Z
$pdata$?svga_move_cursor@@YAXIIII@Z DD imagerel $LN5
	DD	imagerel $LN5+193
	DD	imagerel $unwind$?svga_move_cursor@@YAXIIII@Z
$pdata$?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z
$pdata$?svga_video_set_all_regs@@YAXIPEAUSVGAOverlayUnit@@I@Z DD imagerel $LN6
	DD	imagerel $LN6+141
	DD	imagerel $unwind$?svga_video_set_all_regs@@YAXIPEAUSVGAOverlayUnit@@I@Z
$pdata$?svga_video_set_reg@@YAXIII@Z DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$?svga_video_set_reg@@YAXIII@Z
$pdata$?svga_video_flush@@YAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$?svga_video_flush@@YAXI@Z
$pdata$?svga_interrupt_handler@@YAX_KPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+148
	DD	imagerel $unwind$?svga_interrupt_handler@@YAX_KPEAX@Z
$pdata$?svga_panic@@YAXPEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?svga_panic@@YAXPEBD@Z
$pdata$?svga_sync_to_fence@@YAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+319
	DD	imagerel $unwind$?svga_sync_to_fence@@YAXI@Z
$pdata$?svga_insert_fence@@YAIXZ DD imagerel $LN5
	DD	imagerel $LN5+112
	DD	imagerel $unwind$?svga_insert_fence@@YAIXZ
$pdata$?svga_wait_for_irq@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+31
	DD	imagerel $unwind$?svga_wait_for_irq@@YAXXZ
$pdata$?svga_register_file@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+201
	DD	imagerel $unwind$?svga_register_file@@YAXXZ
$pdata$?svga_has_fence_passed@@YA_NI@Z DD imagerel $LN7
	DD	imagerel $LN7+97
	DD	imagerel $unwind$?svga_has_fence_passed@@YA_NI@Z
$pdata$?svga_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z DD imagerel $LN16
	DD	imagerel $LN16+408
	DD	imagerel $unwind$?svga_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z
pdata	ENDS
;	COMDAT ?next_ptr@?1??svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z@4U2@A
_DATA	SEGMENT
?next_ptr@?1??svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z@4U2@A DD 0fffffffeH ; `svga_alloc_gmr'::`2'::next_ptr
	DD	00H
_DATA	ENDS
xdata	SEGMENT
$unwind$?svga_read_reg@@YAII@Z DD 010801H
	DD	04208H
$unwind$?svga_write_reg@@YAXII@Z DD 010c01H
	DD	0420cH
$unwind$?svga_is_fifo_reg_valid@@YA_NH@Z DD 010801H
	DD	02208H
$unwind$?svga_has_fifo_cap@@YA_NH@Z DD 010801H
	DD	02208H
$unwind$?svga_init@@YAXXZ DD 010401H
	DD	0a204H
$unwind$?svga_enable@@YAXXZ DD 010401H
	DD	04204H
$unwind$?svga_disable@@YAXXZ DD 010401H
	DD	04204H
$unwind$?svga_set_mode@@YAXIII@Z DD 011101H
	DD	04211H
$unwind$?svga_fifo_full@@YAXXZ DD 010401H
	DD	04204H
$unwind$?svga_fifo_reserve@@YAPEAXI@Z DD 010801H
	DD	08208H
$unwind$?svga_fifo_commit@@YAXI@Z DD 010801H
	DD	0c208H
$unwind$?svga_fifo_commit_all@@YAXXZ DD 010401H
	DD	04204H
$unwind$?svga_fifo_reserved_cmd@@YAPEAXII@Z DD 010c01H
	DD	0620cH
$unwind$?svga_fifo_reserve_escape@@YAPEAXII@Z DD 010c01H
	DD	0620cH
$unwind$?svga_ring_doorbell@@YAXXZ DD 010401H
	DD	04204H
$unwind$?svga_update@@YAXIIII@Z DD 011601H
	DD	06216H
$unwind$?svga_begin_define_cursor@@YAXPEBUSVGAFifoCmdDefineCursor@@PEAPEAX1@Z DD 031501H
	DD	070118215H
	DD	06010H
$unwind$?svga_begin_define_alpha_cursor@@YAXPEBUSVGAFifoCmdDefineAlphaCursor@@PEAPEAX@Z DD 031001H
	DD	0700c6210H
	DD	0600bH
$unwind$?svga_move_cursor@@YAXIIII@Z DD 011601H
	DD	04216H
$unwind$?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z DD 011101H
	DD	06211H
$unwind$?svga_video_set_all_regs@@YAXIPEAUSVGAOverlayUnit@@I@Z DD 011201H
	DD	08212H
$unwind$?svga_video_set_reg@@YAXIII@Z DD 011101H
	DD	06211H
$unwind$?svga_video_flush@@YAXI@Z DD 010801H
	DD	06208H
$unwind$?svga_interrupt_handler@@YAX_KPEAX@Z DD 010e01H
	DD	0620eH
$unwind$?svga_panic@@YAXPEBD@Z DD 010901H
	DD	04209H
$unwind$?svga_sync_to_fence@@YAXI@Z DD 010801H
	DD	06208H
$unwind$?svga_insert_fence@@YAIXZ DD 010401H
	DD	06204H
$unwind$?svga_wait_for_irq@@YAXXZ DD 010401H
	DD	02204H
$unwind$?svga_register_file@@YAXXZ DD 010401H
	DD	06204H
$unwind$?svga_has_fence_passed@@YA_NI@Z DD 010801H
	DD	06208H
$unwind$?svga_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z DD 011201H
	DD	0c212H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
query_struct$ = 32
tv64 = 40
scanline$1 = 44
ycoord$2 = 48
xcoord$3 = 52
height$4 = 56
width$5 = 60
ycoord$6 = 64
height$7 = 68
xcoord$8 = 72
bpp$9 = 76
width$10 = 80
node$ = 112
code$ = 120
arg$ = 128
?svga_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z PROC		; svga_io_query

; 600  : int svga_io_query (vfs_node_t* node, int code, void* arg) {

$LN16:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 601  : 	svga_io_query_t *query_struct = (svga_io_query_t*)arg;

	mov	rax, QWORD PTR arg$[rsp]
	mov	QWORD PTR query_struct$[rsp], rax

; 602  : 	switch (code) {

	mov	eax, DWORD PTR code$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	mov	eax, DWORD PTR tv64[rsp]
	sub	eax, 512				; 00000200H
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 7
	ja	$LN1@svga_io_qu
	movsxd	rax, DWORD PTR tv64[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN15@svga_io_qu[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN10@svga_io_qu:

; 603  : 	case SVGA_SETMODE: {
; 604  : 		svga_set_mode (query_struct->value, query_struct->value2, query_struct->value3);

	mov	rax, QWORD PTR query_struct$[rsp]
	mov	r8d, DWORD PTR [rax+8]
	mov	rax, QWORD PTR query_struct$[rsp]
	mov	edx, DWORD PTR [rax+4]
	mov	rax, QWORD PTR query_struct$[rsp]
	mov	ecx, DWORD PTR [rax]
	call	?svga_set_mode@@YAXIII@Z		; svga_set_mode

; 605  : 		break;

	jmp	$LN11@svga_io_qu
$LN9@svga_io_qu:

; 606  : 	 }
; 607  : 	case SVGA_GETWIDTH:{
; 608  : 		uint32_t width = get_screen_width();

	call	?get_screen_width@@YAIXZ		; get_screen_width
	mov	DWORD PTR width$10[rsp], eax

; 609  : 		return width;

	mov	eax, DWORD PTR width$10[rsp]
	jmp	$LN13@svga_io_qu

; 610  : 		break;

	jmp	$LN11@svga_io_qu
$LN8@svga_io_qu:

; 611  : 	}
; 612  : 	case SVGA_GETHEIGHT:{
; 613  : 		uint32_t height = get_screen_height();

	call	?get_screen_height@@YAIXZ		; get_screen_height
	mov	DWORD PTR height$4[rsp], eax

; 614  : 		return height;

	mov	eax, DWORD PTR height$4[rsp]
	jmp	$LN13@svga_io_qu

; 615  : 		break;

	jmp	$LN11@svga_io_qu
$LN7@svga_io_qu:

; 616  : 	}
; 617  : 	case SVGA_GETBPP:{
; 618  : 		uint32_t bpp = get_bpp();

	call	?get_bpp@@YAIXZ				; get_bpp
	mov	DWORD PTR bpp$9[rsp], eax

; 619  : 		return bpp;

	mov	eax, DWORD PTR bpp$9[rsp]
	jmp	$LN13@svga_io_qu

; 620  : 		break;

	jmp	$LN11@svga_io_qu
$LN6@svga_io_qu:

; 621  : 	 }
; 622  : 	case SVGA_UPDATE:{	
; 623  : 		uint32_t xcoord = query_struct->value;

	mov	rax, QWORD PTR query_struct$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR xcoord$8[rsp], eax

; 624  : 		uint32_t ycoord = query_struct->value2;

	mov	rax, QWORD PTR query_struct$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR ycoord$6[rsp], eax

; 625  : 		uint32_t width = query_struct->value3;

	mov	rax, QWORD PTR query_struct$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR width$5[rsp], eax

; 626  : 		uint32_t height = query_struct->value4;

	mov	rax, QWORD PTR query_struct$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR height$7[rsp], eax

; 627  : 	
; 628  : 		svga_update(xcoord, ycoord, width, height);

	mov	r9d, DWORD PTR height$7[rsp]
	mov	r8d, DWORD PTR width$5[rsp]
	mov	edx, DWORD PTR ycoord$6[rsp]
	mov	ecx, DWORD PTR xcoord$8[rsp]
	call	?svga_update@@YAXIIII@Z			; svga_update

; 629  : 		break;

	jmp	SHORT $LN11@svga_io_qu
$LN5@svga_io_qu:

; 630  : 	}
; 631  : 	case SVGA_MOVE_CURSOR: {
; 632  : 		uint32_t xcoord = query_struct->value;

	mov	rax, QWORD PTR query_struct$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR xcoord$3[rsp], eax

; 633  : 		uint32_t ycoord = query_struct->value2;

	mov	rax, QWORD PTR query_struct$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR ycoord$2[rsp], eax

; 634  : 		if (query_struct->value6 == 103) //Standard Cursor Image

	mov	rax, QWORD PTR query_struct$[rsp]
	cmp	DWORD PTR [rax+20], 103			; 00000067H
	jne	SHORT $LN4@svga_io_qu

; 635  : 			hw_move_cursor (NULL,xcoord, ycoord);

	mov	r8d, DWORD PTR ycoord$2[rsp]
	mov	edx, DWORD PTR xcoord$3[rsp]
	xor	ecx, ecx
	call	?hw_move_cursor@@YAXPEAIII@Z		; hw_move_cursor

; 636  : 		else

	jmp	SHORT $LN3@svga_io_qu
$LN4@svga_io_qu:

; 637  : 			hw_move_cursor ((uint32_t*)0x0000070000001000,xcoord, ycoord);

	mov	r8d, DWORD PTR ycoord$2[rsp]
	mov	edx, DWORD PTR xcoord$3[rsp]
	mov	rcx, 7696581398528			; 0000070000001000H
	call	?hw_move_cursor@@YAXPEAIII@Z		; hw_move_cursor
$LN3@svga_io_qu:

; 638  : 		break;

	jmp	SHORT $LN11@svga_io_qu
$LN2@svga_io_qu:

; 639  : 	}
; 640  : 	case SVGA_GET_SCANLINE: {
; 641  : 		uint16_t scanline = get_screen_scanline();

	call	?get_screen_scanline@@YAGXZ		; get_screen_scanline
	mov	WORD PTR scanline$1[rsp], ax

; 642  : 		return scanline;

	movzx	eax, WORD PTR scanline$1[rsp]
	jmp	SHORT $LN13@svga_io_qu

; 643  : 		break;

	jmp	SHORT $LN11@svga_io_qu
$LN1@svga_io_qu:

; 644  : 	}
; 645  : 	default: 
; 646  : 		return 1;

	mov	eax, 1
	jmp	SHORT $LN13@svga_io_qu
$LN11@svga_io_qu:

; 647  : 	
; 648  : 	}
; 649  : 	return 1;

	mov	eax, 1
$LN13@svga_io_qu:

; 650  : }

	add	rsp, 104				; 00000068H
	ret	0
$LN15@svga_io_qu:
	DD	$LN10@svga_io_qu
	DD	$LN9@svga_io_qu
	DD	$LN8@svga_io_qu
	DD	$LN7@svga_io_qu
	DD	$LN1@svga_io_qu
	DD	$LN6@svga_io_qu
	DD	$LN5@svga_io_qu
	DD	$LN2@svga_io_qu
?svga_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z ENDP		; svga_io_query
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
tv73 = 32
fence$ = 64
?svga_has_fence_passed@@YA_NI@Z PROC			; svga_has_fence_passed

; 476  : bool svga_has_fence_passed (uint32_t fence) {

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 477  : 
; 478  : 	if (!fence) {

	cmp	DWORD PTR fence$[rsp], 0
	jne	SHORT $LN2@svga_has_f

; 479  : 		return true;

	mov	al, 1
	jmp	SHORT $LN3@svga_has_f
$LN2@svga_has_f:

; 480  : 	}
; 481  : 
; 482  : 	if (!svga_has_fifo_cap (SVGA_FIFO_CAP_FENCE)) {

	mov	ecx, 1
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@svga_has_f

; 483  : 		return false;

	xor	al, al
	jmp	SHORT $LN3@svga_has_f
$LN1@svga_has_f:

; 484  : 	}
; 485  : 
; 486  : 	return ((int32_t)(svga_dev.fifo_mem[SVGA_FIFO_FENCE] - fence)) >= 0;

	mov	eax, 4
	imul	rax, 6
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	edx, DWORD PTR fence$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	sub	eax, edx
	test	eax, eax
	jl	SHORT $LN5@svga_has_f
	mov	DWORD PTR tv73[rsp], 1
	jmp	SHORT $LN6@svga_has_f
$LN5@svga_has_f:
	mov	DWORD PTR tv73[rsp], 0
$LN6@svga_has_f:
	movzx	eax, BYTE PTR tv73[rsp]
$LN3@svga_has_f:

; 487  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_has_fence_passed@@YA_NI@Z ENDP			; svga_has_fence_passed
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
svga$ = 32
?svga_register_file@@YAXXZ PROC				; svga_register_file

; 652  : void svga_register_file () {

$LN3:
	sub	rsp, 56					; 00000038H

; 653  : 	vfs_node_t * svga = (vfs_node_t*)malloc(sizeof(vfs_node_t));

	mov	ecx, 104				; 00000068H
	call	?malloc@@YAPEAX_K@Z			; malloc
	mov	QWORD PTR svga$[rsp], rax

; 654  : 	strcpy (svga->filename, "svga");

	mov	rax, QWORD PTR svga$[rsp]
	lea	rdx, OFFSET FLAT:$SG6124
	mov	rcx, rax
	call	?strcpy@@YAPEADPEADPEBD@Z		; strcpy

; 655  : 	svga->size = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	DWORD PTR [rax+32], 0

; 656  : 	svga->eof = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	DWORD PTR [rax+36], 0

; 657  : 	svga->pos = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	DWORD PTR [rax+40], 0

; 658  : 	svga->current = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	DWORD PTR [rax+44], 0

; 659  : 	svga->flags = FS_FLAG_GENERAL;

	mov	rax, QWORD PTR svga$[rsp]
	mov	DWORD PTR [rax+48], 2

; 660  : 	svga->status = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	DWORD PTR [rax+52], 0

; 661  : 	svga->open = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	QWORD PTR [rax+64], 0

; 662  : 	svga->read = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	QWORD PTR [rax+72], 0

; 663  : 	svga->write = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	QWORD PTR [rax+80], 0

; 664  : 	svga->read_blk = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	QWORD PTR [rax+88], 0

; 665  : 	svga->ioquery = svga_io_query;

	mov	rax, QWORD PTR svga$[rsp]
	lea	rcx, OFFSET FLAT:?svga_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z ; svga_io_query
	mov	QWORD PTR [rax+96], rcx

; 666  : 	vfs_mount ("/dev/svga", svga);

	mov	rdx, QWORD PTR svga$[rsp]
	lea	rcx, OFFSET FLAT:$SG6125
	call	?vfs_mount@@YAXPEADPEAU_vfs_node_@@@Z	; vfs_mount

; 667  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_register_file@@YAXXZ ENDP				; svga_register_file
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
?svga_get_fb_mem@@YAPEAIXZ PROC				; svga_get_fb_mem

; 597  : 	return (uint32_t*)svga_dev.fb_mem;

	mov	rax, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+24

; 598  : }

	ret	0
?svga_get_fb_mem@@YAPEAIXZ ENDP				; svga_get_fb_mem
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
flags$ = 0
?svga_wait_for_irq@@YAXXZ PROC				; svga_wait_for_irq

; 568  : void svga_wait_for_irq () {

$LN6:
	sub	rsp, 24

; 569  : 	uint32_t flags = 0;

	mov	DWORD PTR flags$[rsp], 0
$LN3@svga_wait_:

; 570  : 	do {
; 571  : 		flags = svga_dev.irq.pending;

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048660
	mov	DWORD PTR flags$[rsp], eax

; 572  : 	}while (flags == 0);

	cmp	DWORD PTR flags$[rsp], 0
	je	SHORT $LN3@svga_wait_

; 573  : }

	add	rsp, 24
	ret	0
?svga_wait_for_irq@@YAXXZ ENDP				; svga_wait_for_irq
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
fence$ = 32
cmd$ = 40
?svga_insert_fence@@YAIXZ PROC				; svga_insert_fence

; 534  : uint32_t svga_insert_fence () {

$LN5:
	sub	rsp, 56					; 00000038H

; 535  : 	uint32_t fence;
; 536  : 
; 537  : #pragma pack (push)
; 538  : 	struct cmmnd{
; 539  : 		uint32_t id;
; 540  : 		uint32_t fence;
; 541  : 	};
; 542  : #pragma pack (pop)
; 543  : 
; 544  : 	cmmnd *cmd;
; 545  : 
; 546  : 	//printf ("Insert fence cmd size -> %d\n", sizeof *cmd);
; 547  : 	if (!svga_has_fifo_cap (SVGA_FIFO_CAP_FENCE)) {

	mov	ecx, 1
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	movzx	eax, al

; 548  : 		//printf ("Insert fence no cap\n");
; 549  : 		//return 1;
; 550  : 	}
; 551  : 
; 552  : 	if (svga_dev.fifo.next_fence == 0) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048656, 0
	jne	SHORT $LN1@svga_inser

; 553  : 		svga_dev.fifo.next_fence = 1;

	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048656, 1
$LN1@svga_inser:

; 554  : 	}
; 555  : 
; 556  : 	fence = svga_dev.fifo.next_fence++;

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048656
	mov	DWORD PTR fence$[rsp], eax
	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048656
	inc	eax
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048656, eax

; 557  : 	//printf ("Fence -> %x\n", fence);
; 558  : 	cmd = (cmmnd*)svga_fifo_reserve (sizeof *cmd);

	mov	ecx, 8
	call	?svga_fifo_reserve@@YAPEAXI@Z		; svga_fifo_reserve
	mov	QWORD PTR cmd$[rsp], rax

; 559  : 	cmd->id = SVGA_CMD_FENCE;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	DWORD PTR [rax], 30

; 560  : 	cmd->fence = fence;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR fence$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 561  : 
; 562  : 	svga_fifo_commit_all();

	call	?svga_fifo_commit_all@@YAXXZ		; svga_fifo_commit_all

; 563  : 
; 564  : 	return fence;

	mov	eax, DWORD PTR fence$[rsp]

; 565  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_insert_fence@@YAIXZ ENDP				; svga_insert_fence
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
busy$1 = 32
tv141 = 36
fence$ = 64
?svga_sync_to_fence@@YAXI@Z PROC			; svga_sync_to_fence

; 489  : void svga_sync_to_fence (uint32_t fence) {

$LN17:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 490  : 
; 491  : 	if (!fence) 

	cmp	DWORD PTR fence$[rsp], 0
	jne	SHORT $LN12@svga_sync_

; 492  : 		return;

	jmp	$LN13@svga_sync_
$LN12@svga_sync_:

; 493  : 
; 494  : 	if (!svga_has_fifo_cap (SVGA_FIFO_CAP_FENCE)) {

	mov	ecx, 1
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@svga_sync_

; 495  : 		//printf ("Fence Polling\n");
; 496  : 		svga_write_reg (SVGA_REG_SYNC, 1);

	mov	edx, 1
	mov	ecx, 21
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg
$LN10@svga_sync_:

; 497  : 		while (svga_read_reg (SVGA_REG_BUSY) != false) {}

	mov	ecx, 22
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	test	eax, eax
	je	SHORT $LN9@svga_sync_
	jmp	SHORT $LN10@svga_sync_
$LN9@svga_sync_:
$LN11@svga_sync_:

; 498  : 		//return;
; 499  : 	}
; 500  : 
; 501  : 	if (svga_has_fence_passed (fence)) {

	mov	ecx, DWORD PTR fence$[rsp]
	call	?svga_has_fence_passed@@YA_NI@Z		; svga_has_fence_passed
	movzx	eax, al

; 502  : 		//return;
; 503  : 	}
; 504  : 
; 505  : 	if (svga_is_fifo_reg_valid (SVGA_FIFO_FENCE_GOAL) &&
; 506  : 		(svga_dev.capabilities & SVGA_CAP_IRQMASK)) {

	mov	ecx, 289				; 00000121H
	call	?svga_is_fifo_reg_valid@@YA_NH@Z	; svga_is_fifo_reg_valid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@svga_sync_
	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+48
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN7@svga_sync_

; 507  : 			svga_dev.fifo_mem[SVGA_FIFO_FENCE_GOAL] = fence;

	mov	eax, 4
	imul	rax, 289				; 00000121H
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	edx, DWORD PTR fence$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 508  : 			svga_write_reg (SVGA_REG_IRQMASK, SVGA_IRQFLAG_FENCE_GOAL);

	mov	edx, 4
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 509  : 			x64_cli ();

	call	x64_cli

; 510  : 
; 511  : 			if (!svga_has_fence_passed(fence)) {

	mov	ecx, DWORD PTR fence$[rsp]
	call	?svga_has_fence_passed@@YA_NI@Z		; svga_has_fence_passed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN6@svga_sync_

; 512  : 				svga_ring_doorbell ();

	call	?svga_ring_doorbell@@YAXXZ		; svga_ring_doorbell

; 513  : 				if (!svga_has_fence_passed(fence)) {

	mov	ecx, DWORD PTR fence$[rsp]
	call	?svga_has_fence_passed@@YA_NI@Z		; svga_has_fence_passed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@svga_sync_

; 514  : 					svga_wait_for_irq();

	call	?svga_wait_for_irq@@YAXXZ		; svga_wait_for_irq
$LN5@svga_sync_:
$LN6@svga_sync_:

; 515  : 				}
; 516  : 			}
; 517  : 
; 518  : 			svga_write_reg (SVGA_REG_IRQMASK, 0);

	xor	edx, edx
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 519  : 	} else {

	jmp	SHORT $LN4@svga_sync_
$LN7@svga_sync_:

; 520  : 		bool busy = true;

	mov	BYTE PTR busy$1[rsp], 1

; 521  : 		svga_write_reg (SVGA_REG_SYNC, 1);

	mov	edx, 1
	mov	ecx, 21
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg
$LN3@svga_sync_:

; 522  : 
; 523  : 		while (!svga_has_fence_passed (fence) && busy) {

	mov	ecx, DWORD PTR fence$[rsp]
	call	?svga_has_fence_passed@@YA_NI@Z		; svga_has_fence_passed
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@svga_sync_
	movzx	eax, BYTE PTR busy$1[rsp]
	test	eax, eax
	je	SHORT $LN2@svga_sync_

; 524  : 			busy = (svga_read_reg (SVGA_REG_BUSY) != 0);

	mov	ecx, 22
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	test	eax, eax
	je	SHORT $LN15@svga_sync_
	mov	DWORD PTR tv141[rsp], 1
	jmp	SHORT $LN16@svga_sync_
$LN15@svga_sync_:
	mov	DWORD PTR tv141[rsp], 0
$LN16@svga_sync_:
	movzx	eax, BYTE PTR tv141[rsp]
	mov	BYTE PTR busy$1[rsp], al

; 525  : 		}

	jmp	SHORT $LN3@svga_sync_
$LN2@svga_sync_:
$LN4@svga_sync_:

; 526  : 	}
; 527  : 
; 528  : 	if (!svga_has_fence_passed (fence)) {

	mov	ecx, DWORD PTR fence$[rsp]
	call	?svga_has_fence_passed@@YA_NI@Z		; svga_has_fence_passed
	movzx	eax, al
$LN13@svga_sync_:

; 529  : 		//printf ("[VMware SVGA]: SyncToFence failed\n");
; 530  : 	}
; 531  : 
; 532  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_sync_to_fence@@YAXI@Z ENDP			; svga_sync_to_fence
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
text$ = 48
?svga_panic@@YAXPEBD@Z PROC				; svga_panic

; 170  : void svga_panic (const char* text) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 171  : 	svga_disable ();

	call	?svga_disable@@YAXXZ			; svga_disable

; 172  : 	printf (text);

	mov	rcx, QWORD PTR text$[rsp]
	call	?printf@@YAXPEBDZZ			; printf

; 173  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_panic@@YAXPEBD@Z ENDP				; svga_panic
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
port$ = 32
irq_flags$ = 36
s$ = 64
p$ = 72
?svga_interrupt_handler@@YAX_KPEAX@Z PROC		; svga_interrupt_handler

; 578  : void svga_interrupt_handler (size_t s, void* p) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 579  : 	x64_cli ();

	call	x64_cli

; 580  : 	printf ("SVGA interrupted\n");

	lea	rcx, OFFSET FLAT:$SG6078
	call	?printf@@YAXPEBDZZ			; printf

; 581  : 
; 582  : 	uint16_t port = svga_dev.io_base + SVGA_IRQSTATUS_PORT;

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	add	eax, 8
	mov	WORD PTR port$[rsp], ax

; 583  : 	uint32_t irq_flags = inportd (port);

	movzx	ecx, WORD PTR port$[rsp]
	call	?inportd@@YAIG@Z			; inportd
	mov	DWORD PTR irq_flags$[rsp], eax

; 584  : 	outportd (port, irq_flags);

	mov	edx, DWORD PTR irq_flags$[rsp]
	movzx	ecx, WORD PTR port$[rsp]
	call	?outportd@@YAXGI@Z			; outportd

; 585  : 	printf ("Irq flags -> %d\n", irq_flags);

	mov	edx, DWORD PTR irq_flags$[rsp]
	lea	rcx, OFFSET FLAT:$SG6081
	call	?printf@@YAXPEBDZZ			; printf

; 586  : 	svga_dev.irq.count++;

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048668
	inc	eax
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048668, eax

; 587  : 	svga_dev.irq.pending = irq_flags;

	mov	eax, DWORD PTR irq_flags$[rsp]
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048660, eax

; 588  : 	
; 589  : 	if (!irq_flags)

	cmp	DWORD PTR irq_flags$[rsp], 0
	jne	SHORT $LN1@svga_inter

; 590  : 		printf ("[VMware SVGA]: spurious SVGA IRQ\n");	

	lea	rcx, OFFSET FLAT:$SG6083
	call	?printf@@YAXPEBDZZ			; printf
$LN1@svga_inter:

; 591  : 	//svga_update(0,0,get_screen_width(), get_screen_height());
; 592  : 	interrupt_end(svga_dev.irq_line);

	mov	ecx, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+68
	call	?interrupt_end@@YAXI@Z			; interrupt_end

; 593  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_interrupt_handler@@YAX_KPEAX@Z ENDP		; svga_interrupt_handler
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
cmd$ = 32
stream_id$ = 64
?svga_video_flush@@YAXI@Z PROC				; svga_video_flush

; 465  : void svga_video_flush (uint32_t stream_id) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 466  : 	SVGAEscapeVideoFlush *cmd;
; 467  : 
; 468  : 	cmd = (SVGAEscapeVideoFlush*)svga_fifo_reserve_escape (SVGA_ESCAPE_NSID_VMWARE, sizeof *cmd);

	mov	edx, 8
	xor	ecx, ecx
	call	?svga_fifo_reserve_escape@@YAPEAXII@Z	; svga_fifo_reserve_escape
	mov	QWORD PTR cmd$[rsp], rax

; 469  : 	cmd->cmdType = SVGA_ESCAPE_VMWARE_VIDEO_FLUSH;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	DWORD PTR [rax], 131074			; 00020002H

; 470  : 	cmd->streamId = stream_id;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR stream_id$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 471  : 	svga_fifo_commit_all();

	call	?svga_fifo_commit_all@@YAXXZ		; svga_fifo_commit_all

; 472  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_video_flush@@YAXI@Z ENDP				; svga_video_flush
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
set_regs$ = 32
stream_id$ = 64
register_id$ = 72
value$ = 80
?svga_video_set_reg@@YAXIII@Z PROC			; svga_video_set_reg

; 454  : void svga_video_set_reg (uint32_t stream_id, uint32_t register_id, uint32_t value) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 455  : 
; 456  : 	SVGAEscapeVideoSetRegs *set_regs;
; 457  : 
; 458  : 	svga_begin_video_set_regs (stream_id, 1, &set_regs);

	lea	r8, QWORD PTR set_regs$[rsp]
	mov	edx, 1
	mov	ecx, DWORD PTR stream_id$[rsp]
	call	?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z ; svga_begin_video_set_regs

; 459  : 	set_regs->items[0].registerId = register_id;

	mov	eax, 8
	imul	rax, 0
	mov	rcx, QWORD PTR set_regs$[rsp]
	mov	edx, DWORD PTR register_id$[rsp]
	mov	DWORD PTR [rcx+rax+8], edx

; 460  : 	set_regs->items[0].value = value;

	mov	eax, 8
	imul	rax, 0
	mov	rcx, QWORD PTR set_regs$[rsp]
	mov	edx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rcx+rax+12], edx

; 461  : 	svga_fifo_commit_all();

	call	?svga_fifo_commit_all@@YAXXZ		; svga_fifo_commit_all

; 462  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_video_set_reg@@YAXIII@Z ENDP			; svga_video_set_reg
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
i$ = 32
num_regs$ = 36
set_regs$ = 40
reg_array$ = 48
stream_id$ = 80
regs$ = 88
max_reg$ = 96
?svga_video_set_all_regs@@YAXIPEAUSVGAOverlayUnit@@I@Z PROC ; svga_video_set_all_regs

; 435  : void svga_video_set_all_regs (uint32_t stream_id, SVGAOverlayUnit *regs, uint32_t max_reg) {

$LN6:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 436  : 
; 437  : 	uint32_t *reg_array = (uint32_t*) regs;

	mov	rax, QWORD PTR regs$[rsp]
	mov	QWORD PTR reg_array$[rsp], rax

; 438  : 	const uint32_t num_regs = max_reg + 1;

	mov	eax, DWORD PTR max_reg$[rsp]
	inc	eax
	mov	DWORD PTR num_regs$[rsp], eax

; 439  : 	SVGAEscapeVideoSetRegs *set_regs;
; 440  : 	uint32_t i;
; 441  : 
; 442  : 	svga_begin_video_set_regs (stream_id, num_regs, &set_regs);

	lea	r8, QWORD PTR set_regs$[rsp]
	mov	edx, DWORD PTR num_regs$[rsp]
	mov	ecx, DWORD PTR stream_id$[rsp]
	call	?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z ; svga_begin_video_set_regs

; 443  : 
; 444  : 	for (i = 0; i < num_regs; i++) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN3@svga_video
$LN2@svga_video:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN3@svga_video:
	mov	eax, DWORD PTR num_regs$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN1@svga_video

; 445  : 		set_regs->items[i].registerId = i;

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR set_regs$[rsp]
	mov	edx, DWORD PTR i$[rsp]
	mov	DWORD PTR [rcx+rax*8+8], edx

; 446  : 		set_regs->items[i].value = reg_array[i];

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR set_regs$[rsp]
	mov	r8, QWORD PTR reg_array$[rsp]
	mov	eax, DWORD PTR [r8+rax*4]
	mov	DWORD PTR [rdx+rcx*8+12], eax

; 447  : 	}

	jmp	SHORT $LN2@svga_video
$LN1@svga_video:

; 448  : 
; 449  : 	svga_fifo_commit_all();

	call	?svga_fifo_commit_all@@YAXXZ		; svga_fifo_commit_all

; 450  : }

	add	rsp, 72					; 00000048H
	ret	0
?svga_video_set_all_regs@@YAXIPEAUSVGAOverlayUnit@@I@Z ENDP ; svga_video_set_all_regs
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
cmd_size$ = 32
cmd$ = 40
stream_id$ = 64
num_items$ = 72
set_regs$ = 80
?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z PROC ; svga_begin_video_set_regs

; 424  : void svga_begin_video_set_regs (uint32_t stream_id, uint32_t num_items, SVGAEscapeVideoSetRegs **set_regs) {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 425  : 	SVGAEscapeVideoSetRegs *cmd;
; 426  : 	uint32_t cmd_size = (sizeof *cmd - sizeof cmd->items + num_items * sizeof cmd->items[0]);

	mov	eax, DWORD PTR num_items$[rsp]
	lea	rax, QWORD PTR [rax*8+8]
	mov	DWORD PTR cmd_size$[rsp], eax

; 427  : 
; 428  : 	cmd = (SVGAEscapeVideoSetRegs*)svga_fifo_reserve_escape (SVGA_ESCAPE_NSID_VMWARE, cmd_size);

	mov	edx, DWORD PTR cmd_size$[rsp]
	xor	ecx, ecx
	call	?svga_fifo_reserve_escape@@YAPEAXII@Z	; svga_fifo_reserve_escape
	mov	QWORD PTR cmd$[rsp], rax

; 429  : 	cmd->header.cmdType = SVGA_ESCAPE_VMWARE_VIDEO_SET_REGS;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	DWORD PTR [rax], 131073			; 00020001H

; 430  : 	cmd->header.streamId = stream_id;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR stream_id$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 431  : 
; 432  : 	*set_regs = cmd;

	mov	rax, QWORD PTR set_regs$[rsp]
	mov	rcx, QWORD PTR cmd$[rsp]
	mov	QWORD PTR [rax], rcx

; 433  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_begin_video_set_regs@@YAXIIPEAPEAUSVGAEscapeVideoSetRegs@@@Z ENDP ; svga_begin_video_set_regs
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
visible$ = 48
x$ = 56
y$ = 64
screen_id$ = 72
?svga_move_cursor@@YAXIIII@Z PROC			; svga_move_cursor

; 409  : {

$LN5:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 410  : 	if (svga_has_fifo_cap (SVGA_FIFO_CAP_SCREEN_OBJECT)) {

	mov	ecx, 128				; 00000080H
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@svga_move_

; 411  : 		svga_dev.fifo_mem[SVGA_FIFO_CURSOR_SCREEN_ID] = screen_id;

	mov	eax, 4
	imul	rax, 15
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	edx, DWORD PTR screen_id$[rsp]
	mov	DWORD PTR [rcx+rax], edx
$LN2@svga_move_:

; 412  : 	}
; 413  : 
; 414  : 	if (svga_has_fifo_cap (SVGA_FIFO_CAP_CURSOR_BYPASS_3)) {

	mov	ecx, 16
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@svga_move_

; 415  : 		//printf ("Cursor Bypass 3 supported\n");
; 416  : 		svga_dev.fifo_mem[SVGA_FIFO_CURSOR_ON] = visible;

	mov	eax, 4
	imul	rax, 9
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	edx, DWORD PTR visible$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 417  : 		svga_dev.fifo_mem[SVGA_FIFO_CURSOR_X] = x;

	mov	eax, 4
	imul	rax, 10
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	edx, DWORD PTR x$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 418  : 		svga_dev.fifo_mem[SVGA_FIFO_CURSOR_Y] = y;

	mov	eax, 4
	imul	rax, 11
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	edx, DWORD PTR y$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 419  : 		svga_dev.fifo_mem[SVGA_FIFO_CURSOR_COUNT]++;

	mov	eax, 4
	imul	rax, 12
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	eax, DWORD PTR [rcx+rax]
	inc	eax
	mov	ecx, 4
	imul	rcx, 12
	mov	rdx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	DWORD PTR [rdx+rcx], eax
$LN1@svga_move_:

; 420  : 	}
; 421  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_move_cursor@@YAXIIII@Z ENDP			; svga_move_cursor
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
image_size$ = 32
cmd$ = 40
cursor_info$ = 80
data$ = 88
?svga_begin_define_alpha_cursor@@YAXPEBUSVGAFifoCmdDefineAlphaCursor@@PEAPEAX@Z PROC ; svga_begin_define_alpha_cursor

; 396  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 397  : 	uint32_t image_size = cursor_info->width * cursor_info->height * sizeof(uint32_t);

	mov	rax, QWORD PTR cursor_info$[rsp]
	mov	rcx, QWORD PTR cursor_info$[rsp]
	mov	eax, DWORD PTR [rax+12]
	imul	eax, DWORD PTR [rcx+16]
	mov	eax, eax
	shl	rax, 2
	mov	DWORD PTR image_size$[rsp], eax

; 398  : 	SVGAFifoCmdDefineAlphaCursor *cmd =  (SVGAFifoCmdDefineAlphaCursor*)svga_fifo_reserved_cmd (SVGA_CMD_DEFINE_ALPHA_CURSOR,
; 399  : 		sizeof(cmd) + image_size);  //sizeof *cmd;

	mov	eax, DWORD PTR image_size$[rsp]
	add	rax, 8
	mov	edx, eax
	mov	ecx, 22
	call	?svga_fifo_reserved_cmd@@YAPEAXII@Z	; svga_fifo_reserved_cmd
	mov	QWORD PTR cmd$[rsp], rax

; 400  : 	//printf ("Cmd address -> %x, %x\n", cmd, *cmd);
; 401  : 	*cmd = *cursor_info;

	mov	rdi, QWORD PTR cmd$[rsp]
	mov	rsi, QWORD PTR cursor_info$[rsp]
	mov	ecx, 20
	rep movsb

; 402  : 	*data = (void*) (cmd + 1);

	mov	rax, QWORD PTR cmd$[rsp]
	add	rax, 20
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rcx], rax

; 403  : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?svga_begin_define_alpha_cursor@@YAXPEBUSVGAFifoCmdDefineAlphaCursor@@PEAPEAX@Z ENDP ; svga_begin_define_alpha_cursor
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
and_size$ = 32
and_pitch$ = 36
xor_pitch$ = 40
xor_size$ = 44
cmd$ = 48
cursor_info$ = 96
and_mask$ = 104
xor_mask$ = 112
?svga_begin_define_cursor@@YAXPEBUSVGAFifoCmdDefineCursor@@PEAPEAX1@Z PROC ; svga_begin_define_cursor

; 381  : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 382  :     uint32_t and_pitch = ((cursor_info->andMaskDepth * cursor_info->width + 31) >> 5) << 2;

	mov	rax, QWORD PTR cursor_info$[rsp]
	mov	rcx, QWORD PTR cursor_info$[rsp]
	mov	eax, DWORD PTR [rax+20]
	imul	eax, DWORD PTR [rcx+12]
	add	eax, 31
	shr	eax, 5
	shl	eax, 2
	mov	DWORD PTR and_pitch$[rsp], eax

; 383  : 	uint32_t and_size = and_pitch * cursor_info->height;

	mov	rax, QWORD PTR cursor_info$[rsp]
	mov	ecx, DWORD PTR and_pitch$[rsp]
	imul	ecx, DWORD PTR [rax+16]
	mov	eax, ecx
	mov	DWORD PTR and_size$[rsp], eax

; 384  : 	uint32_t xor_pitch = ((cursor_info->xorMaskDepth * cursor_info->width + 31) >> 5) << 2;

	mov	rax, QWORD PTR cursor_info$[rsp]
	mov	rcx, QWORD PTR cursor_info$[rsp]
	mov	eax, DWORD PTR [rax+24]
	imul	eax, DWORD PTR [rcx+12]
	add	eax, 31
	shr	eax, 5
	shl	eax, 2
	mov	DWORD PTR xor_pitch$[rsp], eax

; 385  : 	uint32_t xor_size = xor_pitch * cursor_info->height;

	mov	rax, QWORD PTR cursor_info$[rsp]
	mov	ecx, DWORD PTR xor_pitch$[rsp]
	imul	ecx, DWORD PTR [rax+16]
	mov	eax, ecx
	mov	DWORD PTR xor_size$[rsp], eax

; 386  : 
; 387  : 	SVGAFifoCmdDefineCursor *cmd = (SVGAFifoCmdDefineCursor*)svga_fifo_reserved_cmd (SVGA_CMD_DEFINE_CURSOR, sizeof *cmd + and_size + xor_size);

	mov	eax, DWORD PTR and_size$[rsp]
	mov	ecx, DWORD PTR xor_size$[rsp]
	lea	rax, QWORD PTR [rax+rcx+28]
	mov	edx, eax
	mov	ecx, 19
	call	?svga_fifo_reserved_cmd@@YAPEAXII@Z	; svga_fifo_reserved_cmd
	mov	QWORD PTR cmd$[rsp], rax

; 388  : 
; 389  : 	*cmd = *cursor_info;

	mov	rdi, QWORD PTR cmd$[rsp]
	mov	rsi, QWORD PTR cursor_info$[rsp]
	mov	ecx, 28
	rep movsb

; 390  : 	*and_mask = (void*)(cmd + 1);

	mov	rax, QWORD PTR cmd$[rsp]
	add	rax, 28
	mov	rcx, QWORD PTR and_mask$[rsp]
	mov	QWORD PTR [rcx], rax

; 391  : 	*xor_mask  = (void*)(and_size + (uint8_t*)*and_mask);

	mov	eax, DWORD PTR and_size$[rsp]
	mov	rcx, QWORD PTR and_mask$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rcx, QWORD PTR xor_mask$[rsp]
	mov	QWORD PTR [rcx], rax

; 392  : }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?svga_begin_define_cursor@@YAXPEBUSVGAFifoCmdDefineCursor@@PEAPEAX1@Z ENDP ; svga_begin_define_cursor
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
cmd$ = 32
x$ = 64
y$ = 72
width$ = 80
height$ = 88
?svga_update@@YAXIIII@Z PROC				; svga_update

; 369  : void svga_update (uint32_t x, uint32_t y, uint32_t width, uint32_t height) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 370  : 	SVGAFifoCmdUpdate *cmd = (SVGAFifoCmdUpdate*)svga_fifo_reserved_cmd (SVGA_CMD_UPDATE, sizeof (SVGAFifoCmdUpdate));

	mov	edx, 16
	mov	ecx, 1
	call	?svga_fifo_reserved_cmd@@YAPEAXII@Z	; svga_fifo_reserved_cmd
	mov	QWORD PTR cmd$[rsp], rax

; 371  : 	cmd->x = x;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR x$[rsp]
	mov	DWORD PTR [rax], ecx

; 372  : 	cmd->y = y;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR y$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 373  : 	cmd->width = width;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR width$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 374  : 	cmd->height = height;

	mov	rax, QWORD PTR cmd$[rsp]
	mov	ecx, DWORD PTR height$[rsp]
	mov	DWORD PTR [rax+12], ecx

; 375  : 	svga_fifo_commit_all ();

	call	?svga_fifo_commit_all@@YAXXZ		; svga_fifo_commit_all

; 376  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_update@@YAXIIII@Z ENDP				; svga_update
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
size$ = 8
ptr$ = 16
?svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z PROC	; svga_alloc_gmr

; 362  : void* svga_alloc_gmr (uint32 size, SVGAGuestPtr *ptr) {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx

; 363  : 	static SVGAGuestPtr next_ptr = {SVGA_GMR_FRAMEBUFFER, 0 };
; 364  : 	*ptr = next_ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	rcx, QWORD PTR ?next_ptr@?1??svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z@4U2@A
	mov	QWORD PTR [rax], rcx

; 365  : 	next_ptr.offset += size;

	mov	eax, DWORD PTR size$[rsp]
	mov	ecx, DWORD PTR ?next_ptr@?1??svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z@4U2@A+4
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ?next_ptr@?1??svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z@4U2@A+4, eax

; 366  : 	return svga_dev.fb_mem + ptr->offset;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+24
	add	rcx, rax
	mov	rax, rcx

; 367  : }

	ret	0
?svga_alloc_gmr@@YAPEAXIPEAUSVGAGuestPtr@@@Z ENDP	; svga_alloc_gmr
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
?svga_ring_doorbell@@YAXXZ PROC				; svga_ring_doorbell

; 355  : void svga_ring_doorbell () {

$LN4:
	sub	rsp, 40					; 00000028H

; 356  : 	if (svga_is_fifo_reg_valid (SVGA_FIFO_BUSY) && svga_dev.fifo_mem[SVGA_FIFO_BUSY] == false) {

	mov	ecx, 290				; 00000122H
	call	?svga_is_fifo_reg_valid@@YA_NH@Z	; svga_is_fifo_reg_valid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@svga_ring_
	mov	eax, 4
	imul	rax, 290				; 00000122H
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	cmp	DWORD PTR [rcx+rax], 0
	jne	SHORT $LN1@svga_ring_

; 357  : 		svga_dev.fifo_mem[SVGA_FIFO_BUSY] = true;

	mov	eax, 4
	imul	rax, 290				; 00000122H
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	DWORD PTR [rcx+rax], 1

; 358  : 		svga_write_reg (SVGA_REG_SYNC, 1);

	mov	edx, 1
	mov	ecx, 21
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg
$LN1@svga_ring_:

; 359  : 	}
; 360  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_ring_doorbell@@YAXXZ ENDP				; svga_ring_doorbell
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
padded_bytes$ = 32
h$ = 40
nsid$ = 64
bytes$ = 72
?svga_fifo_reserve_escape@@YAPEAXII@Z PROC		; svga_fifo_reserve_escape

; 319  : void* svga_fifo_reserve_escape (uint32_t nsid, uint32_t bytes) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 320  : 
; 321  : 	uint32_t padded_bytes = (bytes + 3) & ~3UL;

	mov	eax, DWORD PTR bytes$[rsp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	mov	DWORD PTR padded_bytes$[rsp], eax

; 322  : #pragma pack (push)
; 323  : 	struct header{
; 324  : 		uint32_t cmd;
; 325  : 		uint32_t nsid;
; 326  : 		uint32_t size;
; 327  : 	};
; 328  : #pragma pack (pop)
; 329  : 
; 330  : 	header *h = (header*)svga_fifo_reserve (padded_bytes + sizeof (header));

	mov	eax, DWORD PTR padded_bytes$[rsp]
	add	rax, 12
	mov	ecx, eax
	call	?svga_fifo_reserve@@YAPEAXI@Z		; svga_fifo_reserve
	mov	QWORD PTR h$[rsp], rax

; 331  : 	h->cmd = SVGA_CMD_ESCAPE;

	mov	rax, QWORD PTR h$[rsp]
	mov	DWORD PTR [rax], 33			; 00000021H

; 332  : 	h->nsid = nsid;

	mov	rax, QWORD PTR h$[rsp]
	mov	ecx, DWORD PTR nsid$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 333  : 	h->size = bytes;

	mov	rax, QWORD PTR h$[rsp]
	mov	ecx, DWORD PTR bytes$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 334  : 
; 335  : 	return h + 1;

	mov	rax, QWORD PTR h$[rsp]
	add	rax, 12

; 336  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_fifo_reserve_escape@@YAPEAXII@Z ENDP		; svga_fifo_reserve_escape
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
cmd$ = 32
type$ = 64
bytes$ = 72
?svga_fifo_reserved_cmd@@YAPEAXII@Z PROC		; svga_fifo_reserved_cmd

; 311  : void* svga_fifo_reserved_cmd (uint32_t type, uint32_t bytes) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 312  : 	debug_serial ("[Aurora]: Fifo Reserved function called\n");

	lea	rcx, OFFSET FLAT:$SG5921
	call	?debug_serial@@YAXPEAD@Z		; debug_serial

; 313  : 	uint32_t*cmd = (uint32_t*)svga_fifo_reserve (bytes + sizeof type);

	mov	eax, DWORD PTR bytes$[rsp]
	add	rax, 4
	mov	ecx, eax
	call	?svga_fifo_reserve@@YAPEAXI@Z		; svga_fifo_reserve
	mov	QWORD PTR cmd$[rsp], rax

; 314  : 	cmd[0] = type;

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR cmd$[rsp]
	mov	edx, DWORD PTR type$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 315  : 	return cmd + 1;

	mov	rax, QWORD PTR cmd$[rsp]
	add	rax, 4

; 316  : }

	add	rsp, 56					; 00000038H
	ret	0
?svga_fifo_reserved_cmd@@YAPEAXII@Z ENDP		; svga_fifo_reserved_cmd
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
?svga_fifo_commit_all@@YAXXZ PROC			; svga_fifo_commit_all

; 307  : void svga_fifo_commit_all () {

$LN3:
	sub	rsp, 40					; 00000028H

; 308  : 	svga_fifo_commit (svga_dev.fifo.reserved_size);

	mov	ecx, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+72
	call	?svga_fifo_commit@@YAXI@Z		; svga_fifo_commit

; 309  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_fifo_commit_all@@YAXXZ ENDP			; svga_fifo_commit_all
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
next_cmd$ = 32
reserveable$ = 36
max$ = 40
fifo$ = 48
min$ = 56
chunk_size$1 = 60
tv84 = 64
buffer$2 = 72
dword$3 = 80
tv130 = 88
bytes$ = 112
?svga_fifo_commit@@YAXI@Z PROC				; svga_fifo_commit

; 254  : void svga_fifo_commit (uint32_t bytes) {

$LN16:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 255  : 	
; 256  : 	volatile uint32_t *fifo = svga_dev.fifo_mem;

	mov	rax, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	QWORD PTR fifo$[rsp], rax

; 257  : 	//printf ("FIFO Commit address -> %x\n", fifo);
; 258  : 	uint32_t next_cmd = fifo[SVGA_FIFO_NEXT_CMD];

	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR next_cmd$[rsp], eax

; 259  : 	uint32_t max = fifo[SVGA_FIFO_MAX];

	mov	eax, 4
	imul	rax, 1
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR max$[rsp], eax

; 260  : 	uint32_t min = fifo[SVGA_FIFO_MIN];

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR min$[rsp], eax

; 261  : 
; 262  : 	bool reserveable = svga_has_fifo_cap (SVGA_FIFO_CAP_RESERVE);

	mov	ecx, 64					; 00000040H
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	mov	BYTE PTR reserveable$[rsp], al

; 263  : 
; 264  : 	if (svga_dev.fifo.reserved_size == 0) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+72, 0
	jne	SHORT $LN11@svga_fifo_

; 265  : 		printf ("[VMware SVGA]: FIFO commit before FIFO reserve\n");

	lea	rcx, OFFSET FLAT:$SG5897
	call	?printf@@YAXPEBDZZ			; printf
$LN11@svga_fifo_:

; 266  : 	}
; 267  : 	svga_dev.fifo.reserved_size = 0;

	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+72, 0

; 268  : 
; 269  : 	if (svga_dev.fifo.using_bounce_buffer) {

	movzx	eax, BYTE PTR ?svga_dev@@3U_svga_drive_@@A+76
	test	eax, eax
	je	$LN10@svga_fifo_

; 270  : 		//printf ("Commit using bounce buffer\n");
; 271  : 		uint8_t* buffer = svga_dev.fifo.bounce_buffer;

	lea	rax, OFFSET FLAT:?svga_dev@@3U_svga_drive_@@A+77
	mov	QWORD PTR buffer$2[rsp], rax

; 272  : 		//printf ("Bounce buffer -> %x\n", buffer);
; 273  : 		if (reserveable) {

	movzx	eax, BYTE PTR reserveable$[rsp]
	test	eax, eax
	je	$LN9@svga_fifo_

; 274  : 			//printf ("Reserved\n");
; 275  : 			uint32_t chunk_size = MIN (bytes, max - next_cmd);

	mov	eax, DWORD PTR next_cmd$[rsp]
	mov	ecx, DWORD PTR max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	cmp	DWORD PTR bytes$[rsp], eax
	jae	SHORT $LN14@svga_fifo_
	mov	eax, DWORD PTR bytes$[rsp]
	mov	DWORD PTR tv84[rsp], eax
	jmp	SHORT $LN15@svga_fifo_
$LN14@svga_fifo_:
	mov	eax, DWORD PTR next_cmd$[rsp]
	mov	ecx, DWORD PTR max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv84[rsp], eax
$LN15@svga_fifo_:
	mov	eax, DWORD PTR tv84[rsp]
	mov	DWORD PTR chunk_size$1[rsp], eax

; 276  : 			fifo[SVGA_FIFO_RESERVED] = bytes;

	mov	eax, 4
	imul	rax, 14
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	edx, DWORD PTR bytes$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 277  : 			memcpy (next_cmd + (uint8_t*) fifo, buffer, chunk_size);

	mov	eax, DWORD PTR next_cmd$[rsp]
	mov	rcx, QWORD PTR fifo$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8d, DWORD PTR chunk_size$1[rsp]
	mov	rdx, QWORD PTR buffer$2[rsp]
	mov	rcx, rax
	call	memcpy

; 278  : 			memcpy (min + (uint8_t*)fifo, buffer + chunk_size, bytes - chunk_size);

	mov	eax, DWORD PTR chunk_size$1[rsp]
	mov	ecx, DWORD PTR bytes$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR chunk_size$1[rsp]
	mov	rdx, QWORD PTR buffer$2[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	edx, DWORD PTR min$[rsp]
	mov	r8, QWORD PTR fifo$[rsp]
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv130[rsp], rdx
	mov	r8d, eax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv130[rsp]
	mov	rcx, rax
	call	memcpy

; 279  : 		} else {

	jmp	SHORT $LN8@svga_fifo_
$LN9@svga_fifo_:

; 280  : 			uint32_t *dword = (uint32_t*) buffer;

	mov	rax, QWORD PTR buffer$2[rsp]
	mov	QWORD PTR dword$3[rsp], rax
$LN7@svga_fifo_:

; 281  : 			while (bytes > 0) {

	cmp	DWORD PTR bytes$[rsp], 0
	jbe	SHORT $LN6@svga_fifo_

; 282  : 				fifo[next_cmd / sizeof *dword] = *dword++;

	mov	eax, DWORD PTR next_cmd$[rsp]
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	rdx, QWORD PTR dword$3[rsp]
	mov	edx, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+rax*4], edx
	mov	rax, QWORD PTR dword$3[rsp]
	add	rax, 4
	mov	QWORD PTR dword$3[rsp], rax

; 283  : 				next_cmd += sizeof *dword;

	mov	eax, DWORD PTR next_cmd$[rsp]
	add	rax, 4
	mov	DWORD PTR next_cmd$[rsp], eax

; 284  : 				if (next_cmd == max) {

	mov	eax, DWORD PTR max$[rsp]
	cmp	DWORD PTR next_cmd$[rsp], eax
	jne	SHORT $LN5@svga_fifo_

; 285  : 					next_cmd = min;

	mov	eax, DWORD PTR min$[rsp]
	mov	DWORD PTR next_cmd$[rsp], eax
$LN5@svga_fifo_:

; 286  : 				}
; 287  : 				fifo[SVGA_FIFO_NEXT_CMD] = next_cmd;

	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	edx, DWORD PTR next_cmd$[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 288  : 				bytes -= sizeof *dword;

	mov	eax, DWORD PTR bytes$[rsp]
	sub	rax, 4
	mov	DWORD PTR bytes$[rsp], eax

; 289  : 			}

	jmp	SHORT $LN7@svga_fifo_
$LN6@svga_fifo_:
$LN8@svga_fifo_:
$LN10@svga_fifo_:

; 290  : 		}
; 291  : 	}
; 292  : 
; 293  : 	if (!svga_dev.fifo.using_bounce_buffer || reserveable) {

	movzx	eax, BYTE PTR ?svga_dev@@3U_svga_drive_@@A+76
	test	eax, eax
	je	SHORT $LN3@svga_fifo_
	movzx	eax, BYTE PTR reserveable$[rsp]
	test	eax, eax
	je	SHORT $LN4@svga_fifo_
$LN3@svga_fifo_:

; 294  : 		next_cmd += bytes;

	mov	eax, DWORD PTR bytes$[rsp]
	mov	ecx, DWORD PTR next_cmd$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR next_cmd$[rsp], eax

; 295  : 		if (next_cmd >= max) {

	mov	eax, DWORD PTR max$[rsp]
	cmp	DWORD PTR next_cmd$[rsp], eax
	jb	SHORT $LN2@svga_fifo_

; 296  : 			next_cmd -= max - min;

	mov	eax, DWORD PTR min$[rsp]
	mov	ecx, DWORD PTR max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR next_cmd$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR next_cmd$[rsp], eax
$LN2@svga_fifo_:

; 297  : 		}
; 298  : 		fifo[SVGA_FIFO_NEXT_CMD] = next_cmd;

	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	edx, DWORD PTR next_cmd$[rsp]
	mov	DWORD PTR [rcx+rax], edx
$LN4@svga_fifo_:

; 299  : 	}
; 300  : 
; 301  : 	if (reserveable) {

	movzx	eax, BYTE PTR reserveable$[rsp]
	test	eax, eax
	je	SHORT $LN1@svga_fifo_

; 302  : 		fifo[SVGA_FIFO_RESERVED] = 0;

	mov	eax, 4
	imul	rax, 14
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	DWORD PTR [rcx+rax], 0
$LN1@svga_fifo_:

; 303  : 	}
; 304  : 	//printf ("Fifo commited\n");
; 305  : }

	add	rsp, 104				; 00000068H
	ret	0
?svga_fifo_commit@@YAXI@Z ENDP				; svga_fifo_commit
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
reserve_in_place$1 = 32
need_bounce$2 = 33
reserveable$ = 34
next_cmd$ = 36
stop$3 = 40
max$ = 44
min$ = 48
fifo$ = 56
bytes$ = 80
?svga_fifo_reserve@@YAPEAXI@Z PROC			; svga_fifo_reserve

; 186  : void* svga_fifo_reserve (uint32_t bytes) {

$LN23:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 187  : 	debug_serial ("[Aurora]: Actual Fifo Reserve function called\n");

	lea	rcx, OFFSET FLAT:$SG5849
	call	?debug_serial@@YAXPEAD@Z		; debug_serial

; 188  : 	volatile uint32_t *fifo = svga_dev.fifo_mem;

	mov	rax, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	QWORD PTR fifo$[rsp], rax

; 189  : 	uint32_t max = fifo[SVGA_FIFO_MAX];

	mov	eax, 4
	imul	rax, 1
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR max$[rsp], eax

; 190  : 	uint32_t min = fifo[SVGA_FIFO_MIN];

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR min$[rsp], eax

; 191  : 	uint32_t next_cmd = fifo[SVGA_FIFO_NEXT_CMD];

	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR next_cmd$[rsp], eax

; 192  : 	debug_serial ("[Aurora]: Fifo memory acquired\n");

	lea	rcx, OFFSET FLAT:$SG5854
	call	?debug_serial@@YAXPEAD@Z		; debug_serial

; 193  : 	bool reserveable = svga_has_fifo_cap (SVGA_FIFO_CAP_RESERVE);

	mov	ecx, 64					; 00000040H
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	mov	BYTE PTR reserveable$[rsp], al

; 194  : 
; 195  : 	if (bytes  > sizeof (svga_dev.fifo.bounce_buffer)/* || bytes > (max - min)*/) {

	mov	eax, DWORD PTR bytes$[rsp]
	cmp	rax, 1048576				; 00100000H
	jbe	SHORT $LN20@svga_fifo_

; 196  : 		debug_serial ("[VMware SVGA]: FIFO command too large bytes\n");

	lea	rcx, OFFSET FLAT:$SG5857
	call	?debug_serial@@YAXPEAD@Z		; debug_serial
$LN20@svga_fifo_:

; 197  : 		//for(;;);
; 198  : 	}
; 199  : 
; 200  : 	if (bytes % sizeof (uint32_t)) {

	mov	eax, DWORD PTR bytes$[rsp]
	xor	edx, edx
	mov	ecx, 4
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN19@svga_fifo_

; 201  : 		debug_serial ("[VMware SVGA]: FIFO command length not 32-bit aligned\n");

	lea	rcx, OFFSET FLAT:$SG5860
	call	?debug_serial@@YAXPEAD@Z		; debug_serial
$LN19@svga_fifo_:

; 202  : 		//for(;;);
; 203  : 	}
; 204  : 
; 205  : 	if (svga_dev.fifo.reserved_size != 0) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+72, 0
	je	SHORT $LN18@svga_fifo_

; 206  : 		debug_serial ("[VMware SVGA]: FIFO reserve before FIFO commit\n");

	lea	rcx, OFFSET FLAT:$SG5862
	call	?debug_serial@@YAXPEAD@Z		; debug_serial
$LN18@svga_fifo_:

; 207  : 		//for(;;);
; 208  : 	}
; 209  : 
; 210  : 	svga_dev.fifo.reserved_size = bytes;

	mov	eax, DWORD PTR bytes$[rsp]
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+72, eax
$LN17@svga_fifo_:

; 211  : 
; 212  : 	while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN16@svga_fifo_

; 213  : 		uint32_t stop = fifo[SVGA_FIFO_STOP];

	mov	eax, 4
	imul	rax, 3
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR stop$3[rsp], eax

; 214  : 		bool reserve_in_place = false;

	mov	BYTE PTR reserve_in_place$1[rsp], 0

; 215  : 		bool need_bounce = false;

	mov	BYTE PTR need_bounce$2[rsp], 0

; 216  : 		debug_serial("[Aurora]: Stop -> %d\n");

	lea	rcx, OFFSET FLAT:$SG5869
	call	?debug_serial@@YAXPEAD@Z		; debug_serial

; 217  : 		if (next_cmd >= stop) {

	mov	eax, DWORD PTR stop$3[rsp]
	cmp	DWORD PTR next_cmd$[rsp], eax
	jb	SHORT $LN15@svga_fifo_

; 218  : 			debug_serial ("[Aurora]: Debug Step[1]\n");

	lea	rcx, OFFSET FLAT:$SG5871
	call	?debug_serial@@YAXPEAD@Z		; debug_serial

; 219  : 			if (next_cmd + bytes < max ||
; 220  : 				(next_cmd + bytes == max && stop > min)) {

	mov	eax, DWORD PTR bytes$[rsp]
	mov	ecx, DWORD PTR next_cmd$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR max$[rsp]
	jb	SHORT $LN13@svga_fifo_
	mov	eax, DWORD PTR bytes$[rsp]
	mov	ecx, DWORD PTR next_cmd$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR max$[rsp]
	jne	SHORT $LN14@svga_fifo_
	mov	eax, DWORD PTR min$[rsp]
	cmp	DWORD PTR stop$3[rsp], eax
	jbe	SHORT $LN14@svga_fifo_
$LN13@svga_fifo_:

; 221  : 					reserve_in_place = true;

	mov	BYTE PTR reserve_in_place$1[rsp], 1
	jmp	SHORT $LN12@svga_fifo_
$LN14@svga_fifo_:

; 222  : 			} else if ((max - next_cmd) + (stop - min) <= bytes) {

	mov	eax, DWORD PTR next_cmd$[rsp]
	mov	ecx, DWORD PTR max$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR min$[rsp]
	mov	edx, DWORD PTR stop$3[rsp]
	sub	edx, ecx
	mov	ecx, edx
	add	eax, ecx
	cmp	eax, DWORD PTR bytes$[rsp]
	ja	SHORT $LN11@svga_fifo_

; 223  : 				svga_fifo_full ();

	call	?svga_fifo_full@@YAXXZ			; svga_fifo_full

; 224  : 			} else {

	jmp	SHORT $LN10@svga_fifo_
$LN11@svga_fifo_:

; 225  : 				need_bounce = true;

	mov	BYTE PTR need_bounce$2[rsp], 1
$LN10@svga_fifo_:
$LN12@svga_fifo_:

; 226  : 			}
; 227  : 		}else {

	jmp	SHORT $LN9@svga_fifo_
$LN15@svga_fifo_:

; 228  : 			if (next_cmd + bytes < stop) {

	mov	eax, DWORD PTR bytes$[rsp]
	mov	ecx, DWORD PTR next_cmd$[rsp]
	add	ecx, eax
	mov	eax, ecx
	cmp	eax, DWORD PTR stop$3[rsp]
	jae	SHORT $LN8@svga_fifo_

; 229  : 				reserve_in_place = true;

	mov	BYTE PTR reserve_in_place$1[rsp], 1

; 230  : 			}else {

	jmp	SHORT $LN7@svga_fifo_
$LN8@svga_fifo_:

; 231  : 				svga_fifo_full ();

	call	?svga_fifo_full@@YAXXZ			; svga_fifo_full
$LN7@svga_fifo_:
$LN9@svga_fifo_:

; 232  : 			}
; 233  : 		}
; 234  : 		if (reserve_in_place) {

	movzx	eax, BYTE PTR reserve_in_place$1[rsp]
	test	eax, eax
	je	SHORT $LN6@svga_fifo_

; 235  : 
; 236  : 			if (reserveable || bytes <= sizeof (uint32_t)) {

	movzx	eax, BYTE PTR reserveable$[rsp]
	test	eax, eax
	jne	SHORT $LN4@svga_fifo_
	mov	eax, DWORD PTR bytes$[rsp]
	cmp	rax, 4
	ja	SHORT $LN5@svga_fifo_
$LN4@svga_fifo_:

; 237  : 				svga_dev.fifo.using_bounce_buffer = false;

	mov	BYTE PTR ?svga_dev@@3U_svga_drive_@@A+76, 0

; 238  : 				if (reserveable) {

	movzx	eax, BYTE PTR reserveable$[rsp]
	test	eax, eax
	je	SHORT $LN3@svga_fifo_

; 239  : 					fifo[SVGA_FIFO_RESERVED] = bytes;

	mov	eax, 4
	imul	rax, 14
	mov	rcx, QWORD PTR fifo$[rsp]
	mov	edx, DWORD PTR bytes$[rsp]
	mov	DWORD PTR [rcx+rax], edx
$LN3@svga_fifo_:

; 240  : 				}
; 241  : 				return next_cmd + (uint8_t*)fifo;

	mov	eax, DWORD PTR next_cmd$[rsp]
	mov	rcx, QWORD PTR fifo$[rsp]
	add	rcx, rax
	mov	rax, rcx
	jmp	SHORT $LN21@svga_fifo_

; 242  : 			}else {

	jmp	SHORT $LN2@svga_fifo_
$LN5@svga_fifo_:

; 243  : 				need_bounce = true;

	mov	BYTE PTR need_bounce$2[rsp], 1
$LN2@svga_fifo_:
$LN6@svga_fifo_:

; 244  : 			}
; 245  : 		}
; 246  : 		if (need_bounce) {

	movzx	eax, BYTE PTR need_bounce$2[rsp]
	test	eax, eax
	je	SHORT $LN1@svga_fifo_

; 247  : 			svga_dev.fifo.using_bounce_buffer = true;

	mov	BYTE PTR ?svga_dev@@3U_svga_drive_@@A+76, 1

; 248  : 			return svga_dev.fifo.bounce_buffer;

	lea	rax, OFFSET FLAT:?svga_dev@@3U_svga_drive_@@A+77
	jmp	SHORT $LN21@svga_fifo_
$LN1@svga_fifo_:

; 249  : 		}
; 250  : 	}

	jmp	$LN17@svga_fifo_
$LN16@svga_fifo_:
$LN21@svga_fifo_:

; 251  : }

	add	rsp, 72					; 00000048H
	ret	0
?svga_fifo_reserve@@YAPEAXI@Z ENDP			; svga_fifo_reserve
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
?svga_fifo_full@@YAXXZ PROC				; svga_fifo_full

; 338  : void svga_fifo_full () {

$LN5:
	sub	rsp, 40					; 00000028H

; 339  : 	if (svga_is_fifo_reg_valid (SVGA_FIFO_FENCE_GOAL) &&
; 340  : 		(svga_dev.capabilities & SVGA_CAP_IRQMASK)) {

	mov	ecx, 289				; 00000121H
	call	?svga_is_fifo_reg_valid@@YA_NH@Z	; svga_is_fifo_reg_valid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@svga_fifo_
	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+48
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN2@svga_fifo_

; 341  : 
; 342  : 			svga_write_reg (SVGA_REG_IRQMASK, SVGA_IRQFLAG_FIFO_PROGRESS);

	mov	edx, 2
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 343  : 			x64_cli();

	call	x64_cli

; 344  : 			svga_ring_doorbell ();

	call	?svga_ring_doorbell@@YAXXZ		; svga_ring_doorbell

; 345  : 			svga_wait_for_irq();

	call	?svga_wait_for_irq@@YAXXZ		; svga_wait_for_irq

; 346  : 			svga_write_reg (SVGA_REG_IRQMASK, 0);

	xor	edx, edx
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 347  : 			x64_sti();

	call	x64_sti

; 348  : 	} else {

	jmp	SHORT $LN1@svga_fifo_
$LN2@svga_fifo_:

; 349  : 		svga_write_reg (SVGA_REG_SYNC, 1);

	mov	edx, 1
	mov	ecx, 21
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 350  : 		svga_read_reg (SVGA_REG_BUSY);

	mov	ecx, 22
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
$LN1@svga_fifo_:

; 351  : 	}
; 352  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_fifo_full@@YAXXZ ENDP				; svga_fifo_full
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
width$ = 48
height$ = 56
bpp$ = 64
?svga_set_mode@@YAXIII@Z PROC				; svga_set_mode

; 174  : void svga_set_mode (uint32_t width, uint32_t height, uint32_t bpp) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 175  : 	svga_dev.width = width;

	mov	eax, DWORD PTR width$[rsp]
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+52, eax

; 176  : 	svga_dev.height = height;

	mov	eax, DWORD PTR height$[rsp]
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+56, eax

; 177  : 	svga_dev.bpp = bpp;

	mov	eax, DWORD PTR bpp$[rsp]
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+60, eax

; 178  : 
; 179  : 	svga_write_reg (SVGA_REG_WIDTH, width);

	mov	edx, DWORD PTR width$[rsp]
	mov	ecx, 2
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 180  : 	svga_write_reg (SVGA_REG_HEIGHT, height);

	mov	edx, DWORD PTR height$[rsp]
	mov	ecx, 3
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 181  : 	svga_write_reg (SVGA_REG_BITS_PER_PIXEL, bpp);

	mov	edx, DWORD PTR bpp$[rsp]
	mov	ecx, 7
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 182  : 	svga_write_reg (SVGA_REG_ENABLE, true);

	mov	edx, 1
	mov	ecx, 1
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 183  : 	svga_dev.pitch = svga_read_reg (SVGA_REG_BYTES_PER_LINE);

	mov	ecx, 12
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+64, eax

; 184  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_set_mode@@YAXIII@Z ENDP				; svga_set_mode
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
?svga_disable@@YAXXZ PROC				; svga_disable

; 165  : void svga_disable () {

$LN3:
	sub	rsp, 40					; 00000028H

; 166  : 	svga_write_reg (SVGA_REG_ENABLE, false);

	xor	edx, edx
	mov	ecx, 1
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 167  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_disable@@YAXXZ ENDP				; svga_disable
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
?svga_enable@@YAXXZ PROC				; svga_enable

; 129  : void svga_enable () {

$LN8:
	sub	rsp, 40					; 00000028H

; 130  : 
; 131  : 	svga_dev.fifo_mem[SVGA_FIFO_MIN] = SVGA_FIFO_NUM_REGS * sizeof(uint32_t);

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	DWORD PTR [rcx+rax], 1164		; 0000048cH

; 132  : 	svga_dev.fifo_mem[SVGA_FIFO_MAX] = svga_dev.fifo_size;

	mov	eax, 4
	imul	rax, 1
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	edx, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+32
	mov	DWORD PTR [rcx+rax], edx

; 133  : 	svga_dev.fifo_mem[SVGA_FIFO_NEXT_CMD] = svga_dev.fifo_mem[SVGA_FIFO_MIN];

	mov	eax, 4
	imul	rax, 0
	mov	ecx, 4
	imul	rcx, 2
	mov	rdx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	r8, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	eax, DWORD PTR [r8+rax]
	mov	DWORD PTR [rdx+rcx], eax

; 134  : 	svga_dev.fifo_mem[SVGA_FIFO_STOP] = svga_dev.fifo_mem[SVGA_FIFO_MIN];

	mov	eax, 4
	imul	rax, 0
	mov	ecx, 4
	imul	rcx, 3
	mov	rdx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	r8, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	eax, DWORD PTR [r8+rax]
	mov	DWORD PTR [rdx+rcx], eax

; 135  : 
; 136  : 	if (svga_has_fifo_cap (SVGA_CAP_EXTENDED_FIFO) &&
; 137  : 		svga_is_fifo_reg_valid (SVGA_FIFO_GUEST_3D_HWVERSION)) {

	mov	ecx, 32768				; 00008000H
	call	?svga_has_fifo_cap@@YA_NH@Z		; svga_has_fifo_cap
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@svga_enabl
	mov	ecx, 288				; 00000120H
	call	?svga_is_fifo_reg_valid@@YA_NH@Z	; svga_is_fifo_reg_valid
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@svga_enabl

; 138  : 			svga_dev.fifo_mem[SVGA_FIFO_GUEST_3D_HWVERSION] = SVGA3D_HWVERSION_CURRENT;

	mov	eax, 4
	imul	rax, 288				; 00000120H
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	DWORD PTR [rcx+rax], 131073		; 00020001H

; 139  : 			printf ("HW3D supported\n");

	lea	rcx, OFFSET FLAT:$SG5828
	call	?printf@@YAXPEBDZZ			; printf
$LN5@svga_enabl:

; 140  : 	}
; 141  : 
; 142  : 	//!Enable SVGA device and FIFO
; 143  : 	svga_write_reg (SVGA_REG_ENABLE, true);

	mov	edx, 1
	mov	ecx, 1
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 144  : 	svga_write_reg (SVGA_REG_CONFIG_DONE, true);

	mov	edx, 1
	mov	ecx, 20
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 145  : 
; 146  : 	if (svga_dev.capabilities & SVGA_CAP_IRQMASK) {

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+48
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN4@svga_enabl

; 147  : 		svga_write_reg (SVGA_REG_IRQMASK, SVGA_IRQFLAG_ANY_FENCE);

	mov	edx, 1
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 148  : 		printf ("SVGA IRQMask\n");

	lea	rcx, OFFSET FLAT:$SG5830
	call	?printf@@YAXPEBDZZ			; printf

; 149  : 		svga_dev.irq.pending = 0;

	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048660, 0

; 150  : 		svga_insert_fence ();

	call	?svga_insert_fence@@YAIXZ		; svga_insert_fence

; 151  : 
; 152  : 		svga_write_reg (SVGA_REG_SYNC, 1);

	mov	edx, 1
	mov	ecx, 21
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg
$LN3@svga_enabl:

; 153  : 		while (svga_read_reg (SVGA_REG_BUSY) != false);

	mov	ecx, 22
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	test	eax, eax
	je	SHORT $LN2@svga_enabl
	jmp	SHORT $LN3@svga_enabl
$LN2@svga_enabl:

; 154  : 
; 155  : 		svga_write_reg (SVGA_REG_IRQMASK, 0);

	xor	edx, edx
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 156  : 
; 157  : 		if ((svga_dev.irq.pending & SVGA_IRQFLAG_ANY_FENCE) == 0) {

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048660
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN1@svga_enabl

; 158  : 			printf ("SVGA IRQ appears to be present but broken %d\n", svga_dev.irq.pending);

	mov	edx, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048660
	lea	rcx, OFFSET FLAT:$SG5835
	call	?printf@@YAXPEBDZZ			; printf
$LN1@svga_enabl:
$LN4@svga_enabl:

; 159  : 		}
; 160  : 	}
; 161  : 
; 162  : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_enable@@YAXXZ ENDP				; svga_enable
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
irq$1 = 48
tv82 = 52
mask$ = 56
tv174 = 60
func$ = 64
dev$ = 68
bus$ = 72
?svga_init@@YAXXZ PROC					; svga_init

; 51   : void svga_init () {

$LN16:
	sub	rsp, 88					; 00000058H

; 52   : 	svga_dev.pci_addr = (pci_device_info*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR ?svga_dev@@3U_svga_drive_@@A, rax

; 53   : 	int bus, dev, func;
; 54   : 	if (!pci_find_device_class (0x03, 0x00, svga_dev.pci_addr, &bus, &dev, &func)) {

	lea	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR dev$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR bus$[rsp]
	mov	r8, QWORD PTR ?svga_dev@@3U_svga_drive_@@A
	xor	edx, edx
	mov	cl, 3
	call	?pci_find_device_class@@YA_NEEPEATpci_device_info@@PEAH11@Z ; pci_find_device_class
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN11@svga_init

; 55   : 		printf ("No VMware SVGA device found\n");

	lea	rcx, OFFSET FLAT:$SG5804
	call	?printf@@YAXPEBDZZ			; printf

; 56   : 		return;

	jmp	$LN12@svga_init
$LN11@svga_init:

; 57   : 	}
; 58   : 
; 59   : 	//for I/O base
; 60   : 	uint32_t mask = (svga_dev.pci_addr->device.nonBridge.baseAddress[0] & PCI_CONF_BAR_IO) ? 0x3 : 0xf;

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A
	mov	eax, DWORD PTR [rcx+rax+16]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN14@svga_init
	mov	DWORD PTR tv82[rsp], 3
	jmp	SHORT $LN15@svga_init
$LN14@svga_init:
	mov	DWORD PTR tv82[rsp], 15
$LN15@svga_init:
	mov	eax, DWORD PTR tv82[rsp]
	mov	DWORD PTR mask$[rsp], eax

; 61   : 
; 62   : 	//bar & ~mask;
; 63   : 	svga_dev.io_base =  svga_dev.pci_addr->device.nonBridge.baseAddress[0] & ~mask;         //pci_get_bar_addr (&svga_dev.pci_addr,0);

	mov	eax, 4
	imul	rax, 0
	mov	ecx, DWORD PTR mask$[rsp]
	not	ecx
	mov	rdx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A
	mov	eax, DWORD PTR [rdx+rax+16]
	and	eax, ecx
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+8, eax

; 64   : 	svga_dev.fb_mem =   (uint8_t*)(svga_dev.pci_addr->device.nonBridge.baseAddress[1] & ~0xf);  //(uint8_t*)pci_get_bar_addr (&svga_dev.pci_addr, 1);

	mov	eax, 4
	imul	rax, 1
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A
	mov	eax, DWORD PTR [rcx+rax+16]
	and	eax, -16				; fffffff0H
	mov	eax, eax
	mov	QWORD PTR ?svga_dev@@3U_svga_drive_@@A+24, rax

; 65   : 	svga_dev.fifo_mem = (uint32_t*)(svga_dev.pci_addr->device.nonBridge.baseAddress[2] & ~0xf);  //(uint32_t*)pci_get_bar_addr (&svga_dev.pci_addr, 2);

	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A
	mov	eax, DWORD PTR [rcx+rax+16]
	and	eax, -16				; fffffff0H
	mov	eax, eax
	mov	QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16, rax

; 66   : 	
; 67   : 
; 68   : 	svga_dev.device_version_id = SVGA_ID_2;

	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+44, -1879048190 ; 90000002H
$LN10@svga_init:

; 69   : 	do {
; 70   : 		svga_write_reg (SVGA_REG_ID, svga_dev.device_version_id);

	mov	edx, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+44
	xor	ecx, ecx
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 71   : 		if (svga_read_reg (SVGA_REG_ID) == svga_dev.device_version_id) {

	xor	ecx, ecx
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	cmp	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+44
	jne	SHORT $LN7@svga_init

; 72   : 			break;

	jmp	SHORT $LN8@svga_init

; 73   : 		}else {

	jmp	SHORT $LN6@svga_init
$LN7@svga_init:

; 74   : 			svga_dev.device_version_id--;

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+44
	dec	eax
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+44, eax
$LN6@svga_init:

; 75   : 		}
; 76   : 	}while (svga_dev.device_version_id >= SVGA_ID_0);

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+44, -1879048192 ; 90000000H
	jae	SHORT $LN10@svga_init
$LN8@svga_init:

; 77   : 
; 78   : 	if (svga_dev.device_version_id < SVGA_ID_0) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+44, -1879048192 ; 90000000H
	jae	SHORT $LN5@svga_init

; 79   : 		printf ("[VMware SVGA]: negotiating SVGA device version!\n");

	lea	rcx, OFFSET FLAT:$SG5814
	call	?printf@@YAXPEBDZZ			; printf
$LN5@svga_init:

; 80   : 	}
; 81   : 
; 82   : 	svga_dev.vram_size = svga_read_reg (SVGA_REG_VRAM_SIZE);

	mov	ecx, 15
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+40, eax

; 83   : 	svga_dev.fb_size = svga_read_reg (SVGA_REG_FB_SIZE);

	mov	ecx, 16
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+36, eax

; 84   : 	svga_dev.fifo_size = svga_read_reg (SVGA_REG_MEM_SIZE);

	mov	ecx, 19
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+32, eax

; 85   : 	//! sanity check the fifo and framebuffer sizes
; 86   : 	if (svga_dev.fb_size < 0x100000) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+36, 1048576 ; 00100000H
	jae	SHORT $LN4@svga_init

; 87   : 		printf ("[VMware SVGA]: FrameBuffer size is very small, probably incorrect\n");

	lea	rcx, OFFSET FLAT:$SG5816
	call	?printf@@YAXPEBDZZ			; printf
$LN4@svga_init:

; 88   : 	}
; 89   : 
; 90   : 	if (svga_dev.fifo_size < 0x20000) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+32, 131072 ; 00020000H
	jae	SHORT $LN3@svga_init

; 91   : 		printf ("[VMware SVGA]: FIFO size is very small, probably incorrect\n");

	lea	rcx, OFFSET FLAT:$SG5818
	call	?printf@@YAXPEBDZZ			; printf
$LN3@svga_init:

; 92   : 	}
; 93   : 
; 94   : 	if (svga_dev.device_version_id >= SVGA_ID_1) {

	cmp	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+44, -1879048191 ; 90000001H
	jb	SHORT $LN2@svga_init

; 95   : 		svga_dev.capabilities = svga_read_reg (SVGA_REG_CAPABILITIES);

	mov	ecx, 17
	call	?svga_read_reg@@YAII@Z			; svga_read_reg
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+48, eax
$LN2@svga_init:

; 96   : 	}
; 97   : 
; 98   : 	//!interrupts
; 99   : 	if (svga_dev.capabilities & SVGA_CAP_IRQMASK) {

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+48
	and	eax, 262144				; 00040000H
	test	eax, eax
	je	SHORT $LN1@svga_init

; 100  : 		uint8_t irq = svga_dev.pci_addr->device.nonBridge.interruptLine;//pci_config_read8 (&svga_dev.pci_addr, offsetof (pci_config_space,intr_line));	

	mov	rax, QWORD PTR ?svga_dev@@3U_svga_drive_@@A
	movzx	eax, BYTE PTR [rax+60]
	mov	BYTE PTR irq$1[rsp], al

; 101  : 		svga_dev.irq_line = irq;

	movzx	eax, BYTE PTR irq$1[rsp]
	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+68, eax

; 102  : 		svga_write_reg (SVGA_REG_IRQMASK, 0);

	xor	edx, edx
	mov	ecx, 33					; 00000021H
	call	?svga_write_reg@@YAXII@Z		; svga_write_reg

; 103  : 		printf ("Irq of svga -> %d\n", irq);

	movzx	eax, BYTE PTR irq$1[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG5822
	call	?printf@@YAXPEBDZZ			; printf

; 104  : 		outportd (svga_dev.io_base + SVGA_IRQSTATUS_PORT, 0xff);

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	add	eax, 8
	mov	edx, 255				; 000000ffH
	movzx	ecx, ax
	call	?outportd@@YAXGI@Z			; outportd

; 105  : 
; 106  : 		svga_dev.irq.pending = 0;

	mov	DWORD PTR ?svga_dev@@3U_svga_drive_@@A+1048660, 0
$LN1@svga_init:

; 107  : 		//if (irq <= 244)
; 108  : 		//	interrupt_set (irq, svga_interrupt_handler, irq);
; 109  : 		//irq_mask (irq, true);
; 110  : 
; 111  : 	}
; 112  : 
; 113  : 	svga_register_file ();

	call	?svga_register_file@@YAXXZ		; svga_register_file

; 114  : 
; 115  : 
; 116  : 	svga_enable();

	call	?svga_enable@@YAXXZ			; svga_enable

; 117  : 	svga_set_mode (get_screen_width(),get_screen_height(),32);

	call	?get_screen_height@@YAIXZ		; get_screen_height
	mov	DWORD PTR tv174[rsp], eax
	call	?get_screen_width@@YAIXZ		; get_screen_width
	mov	r8d, 32					; 00000020H
	mov	ecx, DWORD PTR tv174[rsp]
	mov	edx, ecx
	mov	ecx, eax
	call	?svga_set_mode@@YAXIII@Z		; svga_set_mode

; 118  : 	//svga_set_mode (1920,1080,32);
; 119  : 	gmr_init();

	call	?gmr_init@@YAXXZ			; gmr_init

; 120  : 	memset(svga_dev.fb_mem,0x40,svga_dev.width*svga_dev.height*32);

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+52
	imul	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+56
	imul	eax, 32					; 00000020H
	mov	r8d, eax
	mov	dl, 64					; 00000040H
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+24
	call	?memset@@YAXPEAXEI@Z			; memset

; 121  : 	svga_update(0,0,svga_dev.width,svga_dev.height);

	mov	r9d, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+56
	mov	r8d, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+52
	xor	edx, edx
	xor	ecx, ecx
	call	?svga_update@@YAXIIII@Z			; svga_update

; 122  : 	//screen_set_configuration(svga_dev.width,svga_dev.height);
; 123  : 	vm_backdoor_mouse_init (true);

	mov	cl, 1
	call	?vm_backdoor_mouse_init@@YAX_N@Z	; vm_backdoor_mouse_init

; 124  : 
; 125  : 	printf ("SVGA initialized\n");

	lea	rcx, OFFSET FLAT:$SG5823
	call	?printf@@YAXPEBDZZ			; printf
$LN12@svga_init:

; 126  : }

	add	rsp, 88					; 00000058H
	ret	0
?svga_init@@YAXXZ ENDP					; svga_init
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
tv68 = 0
cap$ = 32
?svga_has_fifo_cap@@YA_NH@Z PROC			; svga_has_fifo_cap

; 44   : bool svga_has_fifo_cap (int cap) {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 45   : 	return (svga_dev.fifo_mem[SVGA_FIFO_CAPABILITIES] & cap) != 0;

	mov	eax, 4
	imul	rax, 4
	mov	rcx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	mov	edx, DWORD PTR cap$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	and	eax, edx
	test	eax, eax
	je	SHORT $LN3@svga_has_f
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@svga_has_f
$LN3@svga_has_f:
	mov	DWORD PTR tv68[rsp], 0
$LN4@svga_has_f:
	movzx	eax, BYTE PTR tv68[rsp]

; 46   : }

	add	rsp, 24
	ret	0
?svga_has_fifo_cap@@YA_NH@Z ENDP			; svga_has_fifo_cap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
tv68 = 0
reg$ = 32
?svga_is_fifo_reg_valid@@YA_NH@Z PROC			; svga_is_fifo_reg_valid

; 40   : bool svga_is_fifo_reg_valid (int reg) {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 41   : 	return svga_dev.fifo_mem[SVGA_FIFO_MIN] > (reg << 2);

	mov	eax, 4
	imul	rax, 0
	mov	ecx, DWORD PTR reg$[rsp]
	shl	ecx, 2
	mov	rdx, QWORD PTR ?svga_dev@@3U_svga_drive_@@A+16
	cmp	DWORD PTR [rdx+rax], ecx
	jbe	SHORT $LN3@svga_is_fi
	mov	DWORD PTR tv68[rsp], 1
	jmp	SHORT $LN4@svga_is_fi
$LN3@svga_is_fi:
	mov	DWORD PTR tv68[rsp], 0
$LN4@svga_is_fi:
	movzx	eax, BYTE PTR tv68[rsp]

; 42   : }

	add	rsp, 24
	ret	0
?svga_is_fifo_reg_valid@@YA_NH@Z ENDP			; svga_is_fifo_reg_valid
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
index$ = 48
value$ = 56
?svga_write_reg@@YAXII@Z PROC				; svga_write_reg

; 35   : void svga_write_reg (uint32_t index, uint32_t value) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 36   : 	outportd (svga_dev.io_base + SVGA_INDEX_PORT, index);

	mov	edx, DWORD PTR index$[rsp]
	movzx	ecx, WORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	call	?outportd@@YAXGI@Z			; outportd

; 37   : 	outportd (svga_dev.io_base + SVGA_VALUE_PORT, value);

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	inc	eax
	mov	edx, DWORD PTR value$[rsp]
	movzx	ecx, ax
	call	?outportd@@YAXGI@Z			; outportd

; 38   : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_write_reg@@YAXII@Z ENDP				; svga_write_reg
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\svga\vmsvga.cpp
_TEXT	SEGMENT
index$ = 48
?svga_read_reg@@YAII@Z PROC				; svga_read_reg

; 30   : uint32_t svga_read_reg (uint32_t index) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 31   : 	outportd (svga_dev.io_base + SVGA_INDEX_PORT, index);

	mov	edx, DWORD PTR index$[rsp]
	movzx	ecx, WORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	call	?outportd@@YAXGI@Z			; outportd

; 32   : 	return inportd (svga_dev.io_base + SVGA_VALUE_PORT);

	mov	eax, DWORD PTR ?svga_dev@@3U_svga_drive_@@A+8
	inc	eax
	movzx	ecx, ax
	call	?inportd@@YAIG@Z			; inportd

; 33   : }

	add	rsp, 40					; 00000028H
	ret	0
?svga_read_reg@@YAII@Z ENDP				; svga_read_reg
_TEXT	ENDS
END
