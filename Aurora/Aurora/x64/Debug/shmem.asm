; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?shared_mem_list@@3PEAU_list_@@EA		; shared_mem_list
PUBLIC	?sh_id@@3IA					; sh_id
_BSS	SEGMENT
?shared_mem_list@@3PEAU_list_@@EA DQ 01H DUP (?)	; shared_mem_list
?sh_id@@3IA DD	01H DUP (?)				; sh_id
_BSS	ENDS
PUBLIC	?AuInitializeShMem@@YAXXZ			; AuInitializeShMem
PUBLIC	?AuCreateShMem@@YAII_KI@Z			; AuCreateShMem
PUBLIC	?AuObtainShMem@@YAPEAXIPEAXH@Z			; AuObtainShMem
EXTRN	memset:PROC
EXTRN	?initialize_list@@YAPEAU_list_@@XZ:PROC		; initialize_list
EXTRN	?list_add@@YAXPEAU_list_@@PEAX@Z:PROC		; list_add
EXTRN	?list_get_at@@YAPEAXPEAU_list_@@I@Z:PROC	; list_get_at
EXTRN	AuPmmngrAlloc:PROC
EXTRN	v2p:PROC
EXTRN	x64_cli:PROC
EXTRN	AuMapPage:PROC
EXTRN	?AuGetPhysicalAddress@@YAPEA_K_K0@Z:PROC	; AuGetPhysicalAddress
EXTRN	AuGetFreePage:PROC
EXTRN	malloc:PROC
EXTRN	?get_current_thread@@YAPEAU_thread_@@XZ:PROC	; get_current_thread
pdata	SEGMENT
$pdata$?AuInitializeShMem@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?AuInitializeShMem@@YAXXZ
$pdata$?AuCreateShMem@@YAII_KI@Z DD imagerel $LN7
	DD	imagerel $LN7+284
	DD	imagerel $unwind$?AuCreateShMem@@YAII_KI@Z
$pdata$?AuObtainShMem@@YAPEAXIPEAXH@Z DD imagerel $LN17
	DD	imagerel $LN17+450
	DD	imagerel $unwind$?AuObtainShMem@@YAPEAXIPEAXH@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuInitializeShMem@@YAXXZ DD 010401H
	DD	04204H
$unwind$?AuCreateShMem@@YAII_KI@Z DD 011201H
	DD	08212H
$unwind$?AuObtainShMem@@YAPEAXIPEAXH@Z DD 011201H
	DD	0e212H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\mmngr\shmem.cpp
_TEXT	SEGMENT
mem$ = 32
i$1 = 40
i$2 = 44
i$3 = 48
ret_addre$ = 56
current_virt$4 = 64
virt$5 = 72
cr3$6 = 80
phys_addr$7 = 88
virtual_addr$8 = 96
p$9 = 104
id$ = 128
shmaddr$ = 136
shmflg$ = 144
?AuObtainShMem@@YAPEAXIPEAXH@Z PROC			; AuObtainShMem

; 81   : void* AuObtainShMem (uint32_t id, void * shmaddr, int shmflg) {

$LN17:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 120				; 00000078H

; 82   : 	x64_cli();

	call	x64_cli

; 83   : 	shared_mem_t *mem = NULL;

	mov	QWORD PTR mem$[rsp], 0

; 84   : 	for (int i = 0; i < shared_mem_list->pointer; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN14@AuObtainSh
$LN13@AuObtainSh:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN14@AuObtainSh:
	mov	rax, QWORD PTR ?shared_mem_list@@3PEAU_list_@@EA ; shared_mem_list
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$2[rsp], eax
	jae	SHORT $LN12@AuObtainSh

; 85   : 		mem = (shared_mem_t*)list_get_at(shared_mem_list, i);

	mov	edx, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR ?shared_mem_list@@3PEAU_list_@@EA ; shared_mem_list
	call	?list_get_at@@YAPEAXPEAU_list_@@I@Z	; list_get_at
	mov	QWORD PTR mem$[rsp], rax

; 86   : 		if (mem->id == id){

	mov	rax, QWORD PTR mem$[rsp]
	mov	ecx, DWORD PTR id$[rsp]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN11@AuObtainSh

; 87   : 			break;

	jmp	SHORT $LN12@AuObtainSh
$LN11@AuObtainSh:

; 88   : 		}
; 89   : 	}

	jmp	SHORT $LN13@AuObtainSh
$LN12@AuObtainSh:

; 90   : 
; 91   : 	void* ret_addre = NULL;

	mov	QWORD PTR ret_addre$[rsp], 0

; 92   : 	/* Shared memory was already mapped so, 
; 93   : 	 * lets copy the physical frames from that process's
; 94   : 	 * address space */
; 95   : 	if (mem->map_in_thread) {

	mov	rax, QWORD PTR mem$[rsp]
	cmp	QWORD PTR [rax+40], 0
	je	$LN10@AuObtainSh

; 96   : 		uint64_t cr3 = mem->map_in_thread->cr3;

	mov	rax, QWORD PTR mem$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	rax, QWORD PTR [rax+192]
	mov	QWORD PTR cr3$6[rsp], rax

; 97   : 		uint64_t virtual_addr = (uint64_t)mem->first_process_vaddr;

	mov	rax, QWORD PTR mem$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR virtual_addr$8[rsp], rax

; 98   : 		/*Now we have the first virtual address, lets map in */
; 99   : 		for (int i = 0; i < mem->num_frames; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN9@AuObtainSh
$LN8@AuObtainSh:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN9@AuObtainSh:
	mov	rax, QWORD PTR mem$[rsp]
	mov	eax, DWORD PTR [rax+36]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN7@AuObtainSh

; 100  : 			uint64_t *phys_addr = (uint64_t*)AuGetPhysicalAddress(cr3,virtual_addr + i * 4096);

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR virtual_addr$8[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR cr3$6[rsp]
	call	?AuGetPhysicalAddress@@YAPEA_K_K0@Z	; AuGetPhysicalAddress
	mov	QWORD PTR phys_addr$7[rsp], rax

; 101  : 			uint64_t current_virt = (uint64_t)AuGetFreePage(0,true);

	mov	dl, 1
	xor	ecx, ecx
	call	AuGetFreePage
	mov	QWORD PTR current_virt$4[rsp], rax

; 102  : 			AuMapPage(v2p((uint64_t)phys_addr),current_virt,PAGING_USER);

	mov	rcx, QWORD PTR phys_addr$7[rsp]
	call	v2p
	mov	r8b, 4
	mov	rdx, QWORD PTR current_virt$4[rsp]
	mov	rcx, rax
	call	AuMapPage

; 103  : 			if (ret_addre == NULL)

	cmp	QWORD PTR ret_addre$[rsp], 0
	jne	SHORT $LN6@AuObtainSh

; 104  : 				ret_addre = (void*)current_virt;

	mov	rax, QWORD PTR current_virt$4[rsp]
	mov	QWORD PTR ret_addre$[rsp], rax
$LN6@AuObtainSh:

; 105  : 		}

	jmp	SHORT $LN8@AuObtainSh
$LN7@AuObtainSh:
	jmp	$LN5@AuObtainSh
$LN10@AuObtainSh:

; 106  : 	}else {
; 107  : 		/* No process has mapped the shared memory, let this process's
; 108  : 		   thread map in some memory for other process to use */
; 109  : 		mem->map_in_thread = get_current_thread();

	call	?get_current_thread@@YAPEAU_thread_@@XZ	; get_current_thread
	mov	rcx, QWORD PTR mem$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 110  : 
; 111  : 		/* Allocate some memory for this process */
; 112  : 		for (int i = 0; i < mem->num_frames; i++) {

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN4@AuObtainSh
$LN3@AuObtainSh:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN4@AuObtainSh:
	mov	rax, QWORD PTR mem$[rsp]
	mov	eax, DWORD PTR [rax+36]
	cmp	DWORD PTR i$3[rsp], eax
	jae	SHORT $LN2@AuObtainSh

; 113  : 			void* p = AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR p$9[rsp], rax

; 114  : 			uint64_t virt = (uint64_t)AuGetFreePage(0,true);

	mov	dl, 1
	xor	ecx, ecx
	call	AuGetFreePage
	mov	QWORD PTR virt$5[rsp], rax

; 115  : 			AuMapPage ((uint64_t)p,virt, PAGING_USER);

	mov	r8b, 4
	mov	rdx, QWORD PTR virt$5[rsp]
	mov	rcx, QWORD PTR p$9[rsp]
	call	AuMapPage

; 116  : 
; 117  : 			/* Store the first virtual address */
; 118  : 			if (mem->first_process_vaddr == NULL)

	mov	rax, QWORD PTR mem$[rsp]
	cmp	QWORD PTR [rax+48], 0
	jne	SHORT $LN1@AuObtainSh

; 119  : 				mem->first_process_vaddr = (void*)virt;

	mov	rax, QWORD PTR mem$[rsp]
	mov	rcx, QWORD PTR virt$5[rsp]
	mov	QWORD PTR [rax+48], rcx
$LN1@AuObtainSh:

; 120  : 		}

	jmp	SHORT $LN3@AuObtainSh
$LN2@AuObtainSh:

; 121  : 		ret_addre = mem->first_process_vaddr;

	mov	rax, QWORD PTR mem$[rsp]
	mov	rax, QWORD PTR [rax+48]
	mov	QWORD PTR ret_addre$[rsp], rax
$LN5@AuObtainSh:

; 122  : 	}
; 123  : 
; 124  : 	return ret_addre;

	mov	rax, QWORD PTR ret_addre$[rsp]

; 125  : }

	add	rsp, 120				; 00000078H
	ret	0
?AuObtainShMem@@YAPEAXIPEAXH@Z ENDP			; AuObtainShMem
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\mmngr\shmem.cpp
_TEXT	SEGMENT
i$1 = 32
sh_mem$ = 40
mem$2 = 48
key$ = 80
size$ = 88
flags$ = 96
?AuCreateShMem@@YAII_KI@Z PROC				; AuCreateShMem

; 53   : uint32_t AuCreateShMem (uint32_t key,size_t size, uint32_t flags) {

$LN7:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 54   : 	x64_cli();

	call	x64_cli

; 55   : 	for (int i = 0; i < shared_mem_list->pointer; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuCreateSh
$LN3@AuCreateSh:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuCreateSh:
	mov	rax, QWORD PTR ?shared_mem_list@@3PEAU_list_@@EA ; shared_mem_list
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@AuCreateSh

; 56   : 		shared_mem_t *mem = (shared_mem_t*)list_get_at(shared_mem_list, i);

	mov	edx, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR ?shared_mem_list@@3PEAU_list_@@EA ; shared_mem_list
	call	?list_get_at@@YAPEAXPEAU_list_@@I@Z	; list_get_at
	mov	QWORD PTR mem$2[rsp], rax

; 57   : 		if (mem->key == key)

	mov	rax, QWORD PTR mem$2[rsp]
	mov	ecx, DWORD PTR key$[rsp]
	cmp	DWORD PTR [rax+16], ecx
	jne	SHORT $LN1@AuCreateSh

; 58   : 			return mem->id;

	mov	rax, QWORD PTR mem$2[rsp]
	mov	eax, DWORD PTR [rax]
	jmp	$LN5@AuCreateSh
$LN1@AuCreateSh:

; 59   : 	}

	jmp	SHORT $LN3@AuCreateSh
$LN2@AuCreateSh:

; 60   : 	shared_mem_t *sh_mem = (shared_mem_t*)malloc(sizeof(shared_mem_t));

	mov	ecx, 56					; 00000038H
	call	malloc
	mov	QWORD PTR sh_mem$[rsp], rax

; 61   : 	memset(sh_mem, 0, sizeof(shared_mem_t));

	mov	r8d, 56					; 00000038H
	xor	edx, edx
	mov	rcx, QWORD PTR sh_mem$[rsp]
	call	memset

; 62   : 	sh_mem->id = sh_id;

	mov	rax, QWORD PTR sh_mem$[rsp]
	mov	ecx, DWORD PTR ?sh_id@@3IA		; sh_id
	mov	DWORD PTR [rax], ecx

; 63   : 	sh_mem->ptr = 0;

	mov	rax, QWORD PTR sh_mem$[rsp]
	mov	QWORD PTR [rax+8], 0

; 64   : 	sh_mem->key = key;

	mov	rax, QWORD PTR sh_mem$[rsp]
	mov	ecx, DWORD PTR key$[rsp]
	mov	DWORD PTR [rax+16], ecx

; 65   : 	sh_mem->size = size;

	mov	rax, QWORD PTR sh_mem$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 66   : 	sh_mem->num_frames = (size / 4096);

	xor	edx, edx
	mov	rax, QWORD PTR size$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rcx, QWORD PTR sh_mem$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 67   : 	sh_mem->map_in_thread = NULL;

	mov	rax, QWORD PTR sh_mem$[rsp]
	mov	QWORD PTR [rax+40], 0

; 68   : 	sh_mem->first_process_vaddr = NULL;

	mov	rax, QWORD PTR sh_mem$[rsp]
	mov	QWORD PTR [rax+48], 0

; 69   : 	list_add(shared_mem_list, sh_mem);

	mov	rdx, QWORD PTR sh_mem$[rsp]
	mov	rcx, QWORD PTR ?shared_mem_list@@3PEAU_list_@@EA ; shared_mem_list
	call	?list_add@@YAXPEAU_list_@@PEAX@Z	; list_add

; 70   : 	sh_id++;

	mov	eax, DWORD PTR ?sh_id@@3IA		; sh_id
	inc	eax
	mov	DWORD PTR ?sh_id@@3IA, eax		; sh_id

; 71   : 	return sh_mem->id;

	mov	rax, QWORD PTR sh_mem$[rsp]
	mov	eax, DWORD PTR [rax]
$LN5@AuCreateSh:

; 72   : }

	add	rsp, 72					; 00000048H
	ret	0
?AuCreateShMem@@YAII_KI@Z ENDP				; AuCreateShMem
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\mmngr\shmem.cpp
_TEXT	SEGMENT
?AuInitializeShMem@@YAXXZ PROC				; AuInitializeShMem

; 44   : void AuInitializeShMem () {

$LN3:
	sub	rsp, 40					; 00000028H

; 45   : 	shared_mem_list = initialize_list();

	call	?initialize_list@@YAPEAU_list_@@XZ	; initialize_list
	mov	QWORD PTR ?shared_mem_list@@3PEAU_list_@@EA, rax ; shared_mem_list

; 46   : 	sh_id = 1;

	mov	DWORD PTR ?sh_id@@3IA, 1		; sh_id

; 47   : }

	add	rsp, 40					; 00000028H
	ret	0
?AuInitializeShMem@@YAXXZ ENDP				; AuInitializeShMem
_TEXT	ENDS
END
