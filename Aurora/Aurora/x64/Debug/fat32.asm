; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?part_lba@@3IA					; part_lba
PUBLIC	?fat_begin_lba@@3KA				; fat_begin_lba
PUBLIC	?cluster_begin_lba@@3KA				; cluster_begin_lba
PUBLIC	?sectors_per_cluster@@3EA			; sectors_per_cluster
PUBLIC	?root_dir_first_cluster@@3KA			; root_dir_first_cluster
PUBLIC	?root_sector@@3KA				; root_sector
PUBLIC	?sectors_per_fat32@@3IA				; sectors_per_fat32
PUBLIC	?alloc_counter@@3HA				; alloc_counter
PUBLIC	?total_clusters@@3IA				; total_clusters
PUBLIC	?root_dir_cache@@3PEAEEA			; root_dir_cache
_BSS	SEGMENT
?part_lba@@3IA DD 01H DUP (?)				; part_lba
?fat_begin_lba@@3KA DD 01H DUP (?)			; fat_begin_lba
?cluster_begin_lba@@3KA DD 01H DUP (?)			; cluster_begin_lba
?sectors_per_cluster@@3EA DB 01H DUP (?)		; sectors_per_cluster
	ALIGN	4

?root_dir_first_cluster@@3KA DD 01H DUP (?)		; root_dir_first_cluster
?root_sector@@3KA DD 01H DUP (?)			; root_sector
?sectors_per_fat32@@3IA DD 01H DUP (?)			; sectors_per_fat32
?alloc_counter@@3HA DD 01H DUP (?)			; alloc_counter
?total_clusters@@3IA DD 01H DUP (?)			; total_clusters
	ALIGN	8

?root_dir_cache@@3PEAEEA DQ 01H DUP (?)			; root_dir_cache
_BSS	ENDS
CONST	SEGMENT
$SG3319	DB	'%s             %d bytes', 0aH, 00H
	ORG $+7
$SG3327	DB	'%s             %d bytes', 0aH, 00H
	ORG $+3
$SG3569	DB	'/', 00H
	ORG $+2
$SG3454	DB	'Root Dir entries scanning', 0aH, 00H
	ORG $+1
$SG3570	DB	'/', 00H
	ORG $+2
$SG3469	DB	'Other file size -> %s, dirent attrib -> %x, count ->%d', 0aH
	DB	00H
$SG3551	DB	'Empty entry found', 0aH, 00H
	ORG $+5
$SG3571	DB	'File System registered', 0aH, 00H
CONST	ENDS
PUBLIC	?initialize_fat32@@YAXXZ			; initialize_fat32
PUBLIC	?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z	; fat32_open
PUBLIC	?fat32_read_file@@YAXPEAU_vfs_node_@@PEAEI@Z	; fat32_read_file
PUBLIC	?fat32_read@@YAXPEAU_vfs_node_@@PEAE@Z		; fat32_read
PUBLIC	?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z	; fat32_locate_dir
PUBLIC	?list_fat_entries@@YAXXZ			; list_fat_entries
PUBLIC	?fat32_create_file@@YAIPEADPEAEI@Z		; fat32_create_file
PUBLIC	?create_dir@@YAXPEBD@Z				; create_dir
PUBLIC	?fat32_self_register@@YAXXZ			; fat32_self_register
PUBLIC	?fat32_list_files@@YAXXZ			; fat32_list_files
PUBLIC	?cluster_to_sector32@@YA_K_K@Z			; cluster_to_sector32
PUBLIC	?to_dos_file_name32@@YAXPEBDPEADI@Z		; to_dos_file_name32
PUBLIC	?fat32_read_fat@@YAII@Z				; fat32_read_fat
PUBLIC	?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z ; fat32_locate_subdir
PUBLIC	?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z	; convert_fat83_32
PUBLIC	?find_free_cluster@@YAIXZ			; find_free_cluster
PUBLIC	?alloc_cluster@@YAIHI@Z				; alloc_cluster
PUBLIC	?find_cluster@@YAII@Z				; find_cluster
PUBLIC	?get_cluster@@YAII@Z				; get_cluster
PUBLIC	?format_fat83_32@@YAXPEADQEAD0@Z		; format_fat83_32
PUBLIC	?fat32_write_content@@YAXPEAEII@Z		; fat32_write_content
EXTRN	?strcmp@@YAHPEBD0@Z:PROC			; strcmp
EXTRN	?strcpy@@YAPEADPEADPEBD@Z:PROC			; strcpy
EXTRN	?strlen@@YA_KPEBD@Z:PROC			; strlen
EXTRN	?strchr@@YAPEADPEADH@Z:PROC			; strchr
EXTRN	?memset@@YAXPEAXEI@Z:PROC			; memset
EXTRN	memcpy:PROC
EXTRN	?vfs_mount@@YAXPEADPEAU_vfs_node_@@@Z:PROC	; vfs_mount
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
EXTRN	?ata_read_28@@YAEIGPEAE@Z:PROC			; ata_read_28
EXTRN	?ata_write_one@@YAEPEAEI@Z:PROC			; ata_write_one
EXTRN	?pmmngr_alloc@@YAPEAXXZ:PROC			; pmmngr_alloc
EXTRN	?pmmngr_free@@YAXPEAX@Z:PROC			; pmmngr_free
EXTRN	?malloc@@YAPEAXI@Z:PROC				; malloc
EXTRN	?putc@@YAXD@Z:PROC				; putc
pdata	SEGMENT
$pdata$?initialize_fat32@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+321
	DD	imagerel $unwind$?initialize_fat32@@YAXXZ
$pdata$?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z DD imagerel $LN17
	DD	imagerel $LN17+720
	DD	imagerel $unwind$?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z
$pdata$?fat32_read_file@@YAXPEAU_vfs_node_@@PEAEI@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?fat32_read_file@@YAXPEAU_vfs_node_@@PEAEI@Z
$pdata$?fat32_read@@YAXPEAU_vfs_node_@@PEAE@Z DD imagerel $LN8
	DD	imagerel $LN8+199
	DD	imagerel $unwind$?fat32_read@@YAXPEAU_vfs_node_@@PEAE@Z
$pdata$?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+500
	DD	imagerel $unwind$?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z
$pdata$?list_fat_entries@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+202
	DD	imagerel $unwind$?list_fat_entries@@YAXXZ
$pdata$?fat32_create_file@@YAIPEADPEAEI@Z DD imagerel $LN18
	DD	imagerel $LN18+704
	DD	imagerel $unwind$?fat32_create_file@@YAIPEADPEAEI@Z
$pdata$?create_dir@@YAXPEBD@Z DD imagerel $LN14
	DD	imagerel $LN14+921
	DD	imagerel $unwind$?create_dir@@YAXPEBD@Z
$pdata$?fat32_self_register@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+219
	DD	imagerel $unwind$?fat32_self_register@@YAXXZ
$pdata$?fat32_list_files@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+259
	DD	imagerel $unwind$?fat32_list_files@@YAXXZ
$pdata$?to_dos_file_name32@@YAXPEBDPEADI@Z DD imagerel $LN23
	DD	imagerel $LN23+511
	DD	imagerel $unwind$?to_dos_file_name32@@YAXPEBDPEADI@Z
$pdata$?fat32_read_fat@@YAII@Z DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$?fat32_read_fat@@YAII@Z
$pdata$?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+418
	DD	imagerel $unwind$?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z
$pdata$?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z DD imagerel $LN8
	DD	imagerel $LN8+268
	DD	imagerel $unwind$?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z
$pdata$?clear_cluster@@YAXI@Z DD imagerel ?clear_cluster@@YAXI@Z
	DD	imagerel ?clear_cluster@@YAXI@Z+144
	DD	imagerel $unwind$?clear_cluster@@YAXI@Z
$pdata$?find_free_cluster@@YAIXZ DD imagerel $LN7
	DD	imagerel $LN7+191
	DD	imagerel $unwind$?find_free_cluster@@YAIXZ
$pdata$?alloc_cluster@@YAIHI@Z DD imagerel $LN3
	DD	imagerel $LN3+205
	DD	imagerel $unwind$?alloc_cluster@@YAIHI@Z
$pdata$?find_cluster@@YAII@Z DD imagerel $LN3
	DD	imagerel $LN3+135
	DD	imagerel $unwind$?find_cluster@@YAII@Z
$pdata$?get_cluster@@YAII@Z DD imagerel $LN3
	DD	imagerel $LN3+135
	DD	imagerel $unwind$?get_cluster@@YAII@Z
$pdata$?format_fat83_32@@YAXPEADQEAD0@Z DD imagerel $LN8
	DD	imagerel $LN8+269
	DD	imagerel $unwind$?format_fat83_32@@YAXPEADQEAD0@Z
$pdata$?fat32_write_content@@YAXPEAEII@Z DD imagerel $LN15
	DD	imagerel $LN15+371
	DD	imagerel $unwind$?fat32_write_content@@YAXPEAEII@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?initialize_fat32@@YAXXZ DD 010401H
	DD	08204H
$unwind$?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z DD 041801H
	DD	0830118H
	DD	060107011H
$unwind$?fat32_read_file@@YAXPEAU_vfs_node_@@PEAEI@Z DD 011301H
	DD	06213H
$unwind$?fat32_read@@YAXPEAU_vfs_node_@@PEAE@Z DD 010e01H
	DD	0620eH
$unwind$?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z DD 041301H
	DD	0190113H
	DD	0600b700cH
$unwind$?list_fat_entries@@YAXXZ DD 020701H
	DD	04b0107H
$unwind$?fat32_create_file@@YAIPEADPEAEI@Z DD 021601H
	DD	04f0116H
$unwind$?create_dir@@YAXPEBD@Z DD 020c01H
	DD	04f010cH
$unwind$?fat32_self_register@@YAXXZ DD 010401H
	DD	06204H
$unwind$?fat32_list_files@@YAXXZ DD 020701H
	DD	0910107H
$unwind$?to_dos_file_name32@@YAXPEBDPEADI@Z DD 011301H
	DD	08213H
$unwind$?fat32_read_fat@@YAII@Z DD 020b01H
	DD	049010bH
$unwind$?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z DD 041801H
	DD	0190118H
	DD	060107011H
$unwind$?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z DD 010e01H
	DD	0420eH
$unwind$?clear_cluster@@YAXI@Z DD 010801H
	DD	06208H
$unwind$?find_free_cluster@@YAIXZ DD 010401H
	DD	0a204H
$unwind$?alloc_cluster@@YAIHI@Z DD 010c01H
	DD	0a20cH
$unwind$?find_cluster@@YAII@Z DD 010801H
	DD	08208H
$unwind$?get_cluster@@YAII@Z DD 010801H
	DD	08208H
$unwind$?format_fat83_32@@YAXPEADQEAD0@Z DD 011301H
	DD	04213H
$unwind$?fat32_write_content@@YAXPEAEII@Z DD 011201H
	DD	08212H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
parse_fat$ = 32
i$1 = 36
i$2 = 40
k$3 = 44
cluster_value$4 = 48
num_cluster$ = 52
sector_first$ = 56
sector$5 = 60
buffer$ = 80
first_cluster$ = 88
length$ = 96
?fat32_write_content@@YAXPEAEII@Z PROC			; fat32_write_content

; 567  : void fat32_write_content (uint8_t *buffer, uint32_t first_cluster, unsigned int length) {

$LN15:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 568  : 	bool parse_fat = false;

	mov	BYTE PTR parse_fat$[rsp], 0

; 569  : 	uint32_t num_cluster = 0;

	mov	DWORD PTR num_cluster$[rsp], 0

; 570  : 	uint32_t sector_first = cluster_to_sector32 (first_cluster);

	mov	eax, DWORD PTR first_cluster$[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR sector_first$[rsp], eax

; 571  : 	for (int i = 0; i < sectors_per_cluster; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN12@fat32_writ
$LN11@fat32_writ:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN12@fat32_writ:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN10@fat32_writ

; 572  : 		ata_write_one (buffer + (i * 512), sector_first + i);

	mov	eax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR sector_first$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR i$1[rsp]
	imul	ecx, 512				; 00000200H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR buffer$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 573  : 	}

	jmp	SHORT $LN11@fat32_writ
$LN10@fat32_writ:

; 574  : 	buffer += 4096;

	mov	rax, QWORD PTR buffer$[rsp]
	add	rax, 4096				; 00001000H
	mov	QWORD PTR buffer$[rsp], rax

; 575  : 
; 576  : 	if (length > 4096) {

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jbe	SHORT $LN9@fat32_writ

; 577  : 		parse_fat = true;

	mov	BYTE PTR parse_fat$[rsp], 1

; 578  : 		num_cluster = length / 4096;

	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	mov	DWORD PTR num_cluster$[rsp], eax
$LN9@fat32_writ:

; 579  : 	}
; 580  : 
; 581  : 	if (parse_fat) {

	movzx	eax, BYTE PTR parse_fat$[rsp]
	test	eax, eax
	je	$LN8@fat32_writ

; 582  : 		for (int k = 0; k < num_cluster; k++) {

	mov	DWORD PTR k$3[rsp], 0
	jmp	SHORT $LN7@fat32_writ
$LN6@fat32_writ:
	mov	eax, DWORD PTR k$3[rsp]
	inc	eax
	mov	DWORD PTR k$3[rsp], eax
$LN7@fat32_writ:
	mov	eax, DWORD PTR num_cluster$[rsp]
	cmp	DWORD PTR k$3[rsp], eax
	jae	$LN5@fat32_writ

; 583  : 			uint32_t cluster_value = get_cluster (first_cluster);

	mov	ecx, DWORD PTR first_cluster$[rsp]
	call	?get_cluster@@YAII@Z			; get_cluster
	mov	DWORD PTR cluster_value$4[rsp], eax

; 584  : 			if (cluster_value >= 0x0FFFFFF8)

	cmp	DWORD PTR cluster_value$4[rsp], 268435448 ; 0ffffff8H
	jb	SHORT $LN4@fat32_writ

; 585  : 				return;

	jmp	SHORT $LN13@fat32_writ
$LN4@fat32_writ:

; 586  : 			uint32_t sector = cluster_to_sector32 (cluster_value);

	mov	eax, DWORD PTR cluster_value$4[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR sector$5[rsp], eax

; 587  : 			for (int i = 0; i < sectors_per_cluster; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@fat32_writ
$LN2@fat32_writ:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@fat32_writ:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR i$2[rsp], eax
	jge	SHORT $LN1@fat32_writ

; 588  : 				ata_write_one (buffer + (i * 512), sector + i);

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR sector$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR i$2[rsp]
	imul	ecx, 512				; 00000200H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR buffer$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 589  : 			}

	jmp	SHORT $LN2@fat32_writ
$LN1@fat32_writ:

; 590  : 			buffer += 4096;

	mov	rax, QWORD PTR buffer$[rsp]
	add	rax, 4096				; 00001000H
	mov	QWORD PTR buffer$[rsp], rax

; 591  : 			first_cluster = cluster_value;

	mov	eax, DWORD PTR cluster_value$4[rsp]
	mov	DWORD PTR first_cluster$[rsp], eax

; 592  : 		}

	jmp	$LN6@fat32_writ
$LN5@fat32_writ:
$LN8@fat32_writ:
$LN13@fat32_writ:

; 593  : 	}
; 594  : }

	add	rsp, 72					; 00000048H
	ret	0
?fat32_write_content@@YAXPEAEII@Z ENDP			; fat32_write_content
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$ = 0
f$ = 8
p$ = 16
string_to_format$ = 48
ext$ = 56
filename$ = 64
?format_fat83_32@@YAXPEADQEAD0@Z PROC			; format_fat83_32

; 510  : {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 511  : 	char *p;
; 512  : 	char *f = filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR f$[rsp], rax

; 513  : 	int i;
; 514  : 
; 515  : 	p = string_to_format;

	mov	rax, QWORD PTR string_to_format$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 516  : 	i = 8;

	mov	DWORD PTR i$[rsp], 8
$LN5@format_fat:

; 517  : 	while ((*p != 0x20) && i)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN4@format_fat
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN4@format_fat

; 518  : 	{
; 519  : 		*f++ = *p++;

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 520  : 		i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 521  : 	}

	jmp	SHORT $LN5@format_fat
$LN4@format_fat:

; 522  : 
; 523  : 	*f++ = '.';

	mov	rax, QWORD PTR f$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax

; 524  : 
; 525  : 	p = (char*)ext;

	mov	rax, QWORD PTR ext$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 526  : 	i = 3;

	mov	DWORD PTR i$[rsp], 3
$LN3@format_fat:

; 527  : 	while ((*p != 0x20) && i)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN2@format_fat
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN2@format_fat

; 528  : 	{
; 529  : 		*f++ = *p++;

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 530  : 		i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 531  : 	}

	jmp	SHORT $LN3@format_fat
$LN2@format_fat:

; 532  : 
; 533  : 	if (i == 3)

	cmp	DWORD PTR i$[rsp], 3
	jne	SHORT $LN1@format_fat

; 534  : 		f--;

	mov	rax, QWORD PTR f$[rsp]
	dec	rax
	mov	QWORD PTR f$[rsp], rax
$LN1@format_fat:

; 535  : 
; 536  : 	*f++ = '\0';

	mov	rax, QWORD PTR f$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax

; 537  : }

	add	rsp, 40					; 00000028H
	ret	0
?format_fat83_32@@YAXPEADQEAD0@Z ENDP			; format_fat83_32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
buf$ = 40
fat_sector$ = 48
ent_offset$ = 56
cluster$ = 80
?get_cluster@@YAII@Z PROC				; get_cluster

; 498  : uint32_t get_cluster (uint32_t cluster) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 499  : 	auto fat_offset = cluster * 4;

	mov	eax, DWORD PTR cluster$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 500  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 501  : 	size_t ent_offset = fat_offset  % 512;

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	mov	eax, eax
	mov	QWORD PTR ent_offset$[rsp], rax

; 502  : 	unsigned char *buf = (unsigned char*)malloc(512);

	mov	ecx, 512				; 00000200H
	call	?malloc@@YAPEAXI@Z			; malloc
	mov	QWORD PTR buf$[rsp], rax

; 503  : 	ata_read_28 (fat_sector,1,buf);

	mov	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, DWORD PTR fat_sector$[rsp]
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 504  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];		

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 505  : 	return value;

	mov	eax, DWORD PTR value$[rsp]

; 506  : }

	add	rsp, 72					; 00000048H
	ret	0
?get_cluster@@YAII@Z ENDP				; get_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
buf$ = 40
fat_sector$ = 48
ent_offset$ = 56
new_cluster$ = 80
?find_cluster@@YAII@Z PROC				; find_cluster

; 487  : uint32_t find_cluster (uint32_t new_cluster) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 488  : 	auto fat_offset = new_cluster * 4;

	mov	eax, DWORD PTR new_cluster$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 489  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 490  : 	size_t ent_offset = fat_offset  % 512;

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	mov	eax, eax
	mov	QWORD PTR ent_offset$[rsp], rax

; 491  : 	unsigned char *buf = (unsigned char*)malloc(512);

	mov	ecx, 512				; 00000200H
	call	?malloc@@YAPEAXI@Z			; malloc
	mov	QWORD PTR buf$[rsp], rax

; 492  : 	ata_read_28 (fat_sector,1,buf);

	mov	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, DWORD PTR fat_sector$[rsp]
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 493  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];		

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 494  : 	return value;

	mov	eax, DWORD PTR value$[rsp]

; 495  : }

	add	rsp, 72					; 00000048H
	ret	0
?find_cluster@@YAII@Z ENDP				; find_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value2$ = 36
value$ = 40
buf$ = 48
ent_offset$ = 56
fat_sector$ = 64
position$ = 96
n_value$ = 104
?alloc_cluster@@YAIHI@Z PROC				; alloc_cluster

; 471  : uint32_t alloc_cluster (int position, uint32_t n_value) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 472  : 	auto fat_offset = position * 4;

	mov	eax, DWORD PTR position$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 473  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	mov	eax, DWORD PTR fat_offset$[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 474  : 	size_t ent_offset = fat_offset  % 512;

	mov	eax, DWORD PTR fat_offset$[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	and	eax, 511				; 000001ffH
	sub	eax, edx
	cdqe
	mov	QWORD PTR ent_offset$[rsp], rax

; 475  : 	unsigned char *buf = (unsigned char*)malloc(512);

	mov	ecx, 512				; 00000200H
	call	?malloc@@YAPEAXI@Z			; malloc
	mov	QWORD PTR buf$[rsp], rax

; 476  : 	ata_read_28 (fat_sector,1,buf);

	mov	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, DWORD PTR fat_sector$[rsp]
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 477  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 478  : 		
; 479  : 	*(uint32_t*)&buf[ent_offset] = n_value;// & 0x0FFFFFFF;

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR n_value$[rsp]
	mov	DWORD PTR [rax], ecx

; 480  : 	ata_write_one (buf,fat_sector);

	mov	edx, DWORD PTR fat_sector$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 481  : 	uint32_t value2 = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value2$[rsp], eax

; 482  : 	return value2;

	mov	eax, DWORD PTR value2$[rsp]

; 483  : }

	add	rsp, 88					; 00000058H
	ret	0
?alloc_cluster@@YAIHI@Z ENDP				; alloc_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
fat_offset$2 = 36
value$3 = 40
buf$4 = 48
fat_sector$5 = 56
ent_offset$6 = 64
?find_free_cluster@@YAIXZ PROC				; find_free_cluster

; 451  : uint32_t find_free_cluster () {

$LN7:
	sub	rsp, 88					; 00000058H

; 452  : 	//!iterate through every sectors in fat32 table
; 453  : 	for (int i = 2; i < total_clusters; i++) {

	mov	DWORD PTR i$1[rsp], 2
	jmp	SHORT $LN4@find_free_
$LN3@find_free_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@find_free_:
	mov	eax, DWORD PTR ?total_clusters@@3IA	; total_clusters
	cmp	DWORD PTR i$1[rsp], eax
	jae	$LN2@find_free_

; 454  : 		auto fat_offset = i * 4;

	mov	eax, DWORD PTR i$1[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$2[rsp], eax

; 455  : 		uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	mov	eax, DWORD PTR fat_offset$2[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$5[rsp], rax

; 456  : 		size_t ent_offset = fat_offset  % 512;

	mov	eax, DWORD PTR fat_offset$2[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	and	eax, 511				; 000001ffH
	sub	eax, edx
	cdqe
	mov	QWORD PTR ent_offset$6[rsp], rax

; 457  : 		unsigned char *buf = (unsigned char*)malloc(512);

	mov	ecx, 512				; 00000200H
	call	?malloc@@YAPEAXI@Z			; malloc
	mov	QWORD PTR buf$4[rsp], rax

; 458  : 		ata_read_28 (fat_sector,1,buf);

	mov	r8, QWORD PTR buf$4[rsp]
	mov	dx, 1
	mov	ecx, DWORD PTR fat_sector$5[rsp]
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 459  : 		uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$6[rsp]
	mov	rcx, QWORD PTR buf$4[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$3[rsp], eax

; 460  : 		
; 461  : 		//! Found a free cluster return the value
; 462  : 		if (value == 0x0) {

	cmp	DWORD PTR value$3[rsp], 0
	jne	SHORT $LN1@find_free_

; 463  : 			return i;

	mov	eax, DWORD PTR i$1[rsp]
	jmp	SHORT $LN5@find_free_
$LN1@find_free_:

; 464  : 		}
; 465  : 	}

	jmp	$LN3@find_free_
$LN2@find_free_:

; 466  : 
; 467  : 	return 0;

	xor	eax, eax
$LN5@find_free_:

; 468  : }

	add	rsp, 88					; 00000058H
	ret	0
?find_free_cluster@@YAIXZ ENDP				; find_free_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
sector$ = 36
buffer$ = 40
cluster$ = 64
?clear_cluster@@YAXI@Z PROC				; clear_cluster

; 438  : static void clear_cluster (uint32_t cluster) {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 439  : 	uint8_t *buffer = (uint8_t*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buffer$[rsp], rax

; 440  : 	memset (buffer, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 441  : 	//update_cluster (buffer,cluster);
; 442  : 	uint32_t sector = cluster_to_sector32 (cluster);

	mov	eax, DWORD PTR cluster$[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR sector$[rsp], eax

; 443  : 	for (int i = 0; i < sectors_per_cluster; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@clear_clus
$LN2@clear_clus:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@clear_clus:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN1@clear_clus

; 444  : 		ata_write_one(buffer + (i*512),sector + i);

	mov	eax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR sector$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR i$1[rsp]
	imul	ecx, 512				; 00000200H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR buffer$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 445  : 	}

	jmp	SHORT $LN2@clear_clus
$LN1@clear_clus:

; 446  : 	pmmngr_free (buffer);

	mov	rcx, QWORD PTR buffer$[rsp]
	call	?pmmngr_free@@YAXPEAX@Z			; pmmngr_free

; 447  : }

	add	rsp, 56					; 00000038H
	ret	0
?clear_cluster@@YAXI@Z ENDP				; clear_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$ = 0
f$ = 8
p$ = 16
root$ = 48
filename$ = 56
?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z PROC	; convert_fat83_32

; 284  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 285  : 	char *p;
; 286  : 	char *f = filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR f$[rsp], rax

; 287  : 	int i;
; 288  : 
; 289  : 	p = (char*)root->filename;

	mov	rax, QWORD PTR root$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 290  : 	i = 8;

	mov	DWORD PTR i$[rsp], 8
$LN5@convert_fa:

; 291  : 	while ((*p != 0x20) && i)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN4@convert_fa
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN4@convert_fa

; 292  : 	{
; 293  : 		*f++ = *p++;

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 294  : 		i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 295  : 	}

	jmp	SHORT $LN5@convert_fa
$LN4@convert_fa:

; 296  : 
; 297  : 	*f++ = '.';

	mov	rax, QWORD PTR f$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax

; 298  : 
; 299  : 	p = (char*)root->ext;

	mov	rax, QWORD PTR root$[rsp]
	add	rax, 8
	mov	QWORD PTR p$[rsp], rax

; 300  : 	i = 3;

	mov	DWORD PTR i$[rsp], 3
$LN3@convert_fa:

; 301  : 	while ((*p != 0x20) && i)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN2@convert_fa
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN2@convert_fa

; 302  : 	{
; 303  : 		*f++ = *p++;

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 304  : 		i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 305  : 	}

	jmp	SHORT $LN3@convert_fa
$LN2@convert_fa:

; 306  : 
; 307  : 	if (i == 3)

	cmp	DWORD PTR i$[rsp], 3
	jne	SHORT $LN1@convert_fa

; 308  : 		f--;

	mov	rax, QWORD PTR f$[rsp]
	dec	rax
	mov	QWORD PTR f$[rsp], rax
$LN1@convert_fa:

; 309  : 
; 310  : 	*f++ = '\0';

	mov	rax, QWORD PTR f$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax

; 311  : }

	add	rsp, 40					; 00000028H
	ret	0
?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z ENDP	; convert_fat83_32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
pkDir$2 = 40
buf$ = 48
name$3 = 56
dos_file_name$ = 72
file$ = 96
$T4 = 224
kfile$ = 232
filename$ = 240
?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z PROC	; fat32_locate_subdir

; 225  : vfs_node_t fat32_locate_subdir (vfs_node_t kfile, const char* filename) {

$LN12:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H

; 226  : 
; 227  : 	vfs_node_t file;
; 228  : 
; 229  : 	char dos_file_name[11];
; 230  : 	to_dos_file_name32 (filename, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?to_dos_file_name32@@YAXPEBDPEADI@Z	; to_dos_file_name32

; 231  : 	//dos_file_name[11] = 0;
; 232  : 	unsigned char* buf = (unsigned char*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buf$[rsp], rax

; 233  : 	if (kfile.flags != FS_FLAG_INVALID) {

	mov	rax, QWORD PTR kfile$[rsp]
	cmp	DWORD PTR [rax+48], 3
	je	$LN9@fat32_loca
$LN8@fat32_loca:

; 234  : 		
; 235  : 		//! read the directory
; 236  : 		while (!kfile.eof) {

	mov	rax, QWORD PTR kfile$[rsp]
	cmp	DWORD PTR [rax+36], 0
	jne	$LN7@fat32_loca

; 237  : 
; 238  : 			//! read 
; 239  : 		
; 240  : 			fat32_read (&kfile, buf);

	mov	rdx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR kfile$[rsp]
	call	?fat32_read@@YAXPEAU_vfs_node_@@PEAE@Z	; fat32_read

; 241  : 			//! set directory
; 242  : 			fat32_dir* pkDir = (fat32_dir*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR pkDir$2[rsp], rax

; 243  : 
; 244  : 			//! 16 entries
; 245  : 			for (unsigned int i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@fat32_loca
$LN5@fat32_loca:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@fat32_loca:
	cmp	DWORD PTR i$1[rsp], 16
	jae	$LN4@fat32_loca

; 246  : 
; 247  : 				//! get current filename;
; 248  : 				char name[11];
; 249  : 				memcpy (name, pkDir->filename, 11);

	mov	rax, QWORD PTR pkDir$2[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rsp]
	call	memcpy

; 250  : 				//name[11] = 0;
; 251  : 
; 252  : 				if (strcmp (name, dos_file_name) == 0) {

	lea	rdx, QWORD PTR dos_file_name$[rsp]
	lea	rcx, QWORD PTR name$3[rsp]
	call	?strcmp@@YAHPEBD0@Z			; strcmp
	test	eax, eax
	jne	$LN3@fat32_loca

; 253  : 
; 254  : 					//! found file
; 255  : 					strcpy (file.filename, filename);

	mov	rdx, QWORD PTR filename$[rsp]
	lea	rcx, QWORD PTR file$[rsp]
	call	?strcpy@@YAPEADPEADPEBD@Z		; strcpy

; 256  : 					file.current = pkDir->first_cluster;

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	DWORD PTR file$[rsp+44], eax

; 257  : 					file.size = pkDir->file_size;

	mov	rax, QWORD PTR pkDir$2[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR file$[rsp+32], eax

; 258  : 					file.eof = 0;

	mov	DWORD PTR file$[rsp+36], 0

; 259  : 					file.status = FS_STATUS_FOUND;

	mov	DWORD PTR file$[rsp+52], 4

; 260  : 					//! set file type
; 261  : 					if (pkDir->attrib == 0x10)

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	eax, 16
	jne	SHORT $LN2@fat32_loca

; 262  : 						file.flags = FS_FLAG_DIRECTORY;

	mov	DWORD PTR file$[rsp+48], 1

; 263  : 					else

	jmp	SHORT $LN1@fat32_loca
$LN2@fat32_loca:

; 264  : 						file.flags = FS_FLAG_GENERAL;

	mov	DWORD PTR file$[rsp+48], 2
$LN1@fat32_loca:

; 265  : 
; 266  : 					//!return file
; 267  : 					return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T4[rsp]
	mov	rsi, rax
	mov	ecx, 96					; 00000060H
	rep movsb
	mov	rax, QWORD PTR $T4[rsp]
	jmp	SHORT $LN10@fat32_loca
$LN3@fat32_loca:

; 268  : 				}
; 269  : 
; 270  : 				//! go to next entry
; 271  : 				pkDir++;

	mov	rax, QWORD PTR pkDir$2[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR pkDir$2[rsp], rax

; 272  : 			}

	jmp	$LN5@fat32_loca
$LN4@fat32_loca:

; 273  : 
; 274  : 			//pmmngr_free (buf);
; 275  : 		}

	jmp	$LN8@fat32_loca
$LN7@fat32_loca:
$LN9@fat32_loca:

; 276  : 	}
; 277  : 
; 278  : 	file.flags = FS_FLAG_INVALID;

	mov	DWORD PTR file$[rsp+48], 3

; 279  : 	return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T4[rsp]
	mov	rsi, rax
	mov	ecx, 96					; 00000060H
	rep movsb
	mov	rax, QWORD PTR $T4[rsp]
$LN10@fat32_loca:

; 280  : }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z ENDP	; fat32_locate_subdir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
fat_sector$ = 40
ent_offset$ = 48
buf$ = 64
cluster_index$ = 592
?fat32_read_fat@@YAII@Z PROC				; fat32_read_fat

; 134  : uint32_t fat32_read_fat (uint32_t cluster_index) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 584				; 00000248H

; 135  : 	auto fat_offset = cluster_index * 4;

	mov	eax, DWORD PTR cluster_index$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 136  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 137  : 	size_t ent_offset = fat_offset  % 512;

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	mov	eax, eax
	mov	QWORD PTR ent_offset$[rsp], rax

; 138  : 	unsigned char buf[512];
; 139  : 	ata_read_28 (fat_sector,1,buf);

	lea	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, DWORD PTR fat_sector$[rsp]
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 140  : 	uint32_t value = *(uint32_t*) &buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	eax, DWORD PTR buf$[rsp+rax]
	mov	DWORD PTR value$[rsp], eax

; 141  : 	return value & 0x0FFFFFFF;

	mov	eax, DWORD PTR value$[rsp]
	and	eax, 268435455				; 0fffffffH

; 142  : }

	add	rsp, 584				; 00000248H
	ret	0
?fat32_read_fat@@YAII@Z ENDP				; fat32_read_fat
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$ = 32
k$1 = 36
tv132 = 40
tv179 = 44
tv71 = 48
filename$ = 80
fname$ = 88
fname_length$ = 96
?to_dos_file_name32@@YAXPEBDPEADI@Z PROC		; to_dos_file_name32

; 46   : {

$LN23:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 47   : 	unsigned int i=0;

	mov	DWORD PTR i$[rsp], 0

; 48   : 
; 49   : 	if (fname_length > 11)

	cmp	DWORD PTR fname_length$[rsp], 11
	jbe	SHORT $LN16@to_dos_fil

; 50   : 		return;

	jmp	$LN17@to_dos_fil
$LN16@to_dos_fil:

; 51   : 
; 52   : 	if (!fname || !filename)

	cmp	QWORD PTR fname$[rsp], 0
	je	SHORT $LN14@to_dos_fil
	cmp	QWORD PTR filename$[rsp], 0
	jne	SHORT $LN15@to_dos_fil
$LN14@to_dos_fil:

; 53   : 		return;

	jmp	$LN17@to_dos_fil
$LN15@to_dos_fil:

; 54   : 
; 55   : 	memset (fname, ' ', fname_length);

	mov	r8d, DWORD PTR fname_length$[rsp]
	mov	dl, 32					; 00000020H
	mov	rcx, QWORD PTR fname$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 56   : 
; 57   : 	for (i=0; i < strlen (filename)-1 && i < fname_length; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN13@to_dos_fil
$LN12@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN13@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	mov	QWORD PTR tv71[rsp], rax
	mov	rcx, QWORD PTR filename$[rsp]
	call	?strlen@@YA_KPEBD@Z			; strlen
	dec	rax
	mov	rcx, QWORD PTR tv71[rsp]
	cmp	rcx, rax
	jae	$LN11@to_dos_fil
	mov	eax, DWORD PTR fname_length$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN11@to_dos_fil

; 58   : 	{
; 59   : 		if (filename[i] == '.' || i==8)

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN9@to_dos_fil
	cmp	DWORD PTR i$[rsp], 8
	jne	SHORT $LN10@to_dos_fil
$LN9@to_dos_fil:

; 60   : 			break;

	jmp	SHORT $LN11@to_dos_fil
$LN10@to_dos_fil:

; 61   : 
; 62   : 		fname[i] = toupper (filename[i]);

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN19@to_dos_fil
	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN19@to_dos_fil
	mov	DWORD PTR tv132[rsp], 1
	jmp	SHORT $LN20@to_dos_fil
$LN19@to_dos_fil:
	mov	DWORD PTR tv132[rsp], 0
$LN20@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR tv132[rsp]
	imul	ecx, 32					; 00000020H
	sub	eax, ecx
	mov	ecx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR fname$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 63   : 	}

	jmp	$LN12@to_dos_fil
$LN11@to_dos_fil:

; 64   : 
; 65   : 	if (filename[i] =='.')

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN8@to_dos_fil

; 66   : 	{
; 67   : 		for (int k=0; k < 3; k++)

	mov	DWORD PTR k$1[rsp], 0
	jmp	SHORT $LN7@to_dos_fil
$LN6@to_dos_fil:
	mov	eax, DWORD PTR k$1[rsp]
	inc	eax
	mov	DWORD PTR k$1[rsp], eax
$LN7@to_dos_fil:
	cmp	DWORD PTR k$1[rsp], 3
	jge	SHORT $LN5@to_dos_fil

; 68   : 		{
; 69   : 			 ++i;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 70   : 			 if (filename[i])

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN4@to_dos_fil

; 71   : 				 fname[8+k] = filename[i];

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR k$1[rsp]
	add	ecx, 8
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR fname$[rsp]
	mov	r8, QWORD PTR filename$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
$LN4@to_dos_fil:

; 72   : 		}

	jmp	SHORT $LN6@to_dos_fil
$LN5@to_dos_fil:
$LN8@to_dos_fil:

; 73   : 	}
; 74   : 
; 75   : 	for (i = 0; i < 3; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN3@to_dos_fil
$LN2@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN3@to_dos_fil:
	cmp	DWORD PTR i$[rsp], 3
	jae	SHORT $LN1@to_dos_fil

; 76   : 		fname[8+i] = toupper (fname[8+i]);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 8
	mov	eax, eax
	mov	rcx, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN21@to_dos_fil
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 8
	mov	eax, eax
	mov	rcx, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN21@to_dos_fil
	mov	DWORD PTR tv179[rsp], 1
	jmp	SHORT $LN22@to_dos_fil
$LN21@to_dos_fil:
	mov	DWORD PTR tv179[rsp], 0
$LN22@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 8
	mov	eax, eax
	mov	rcx, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR tv179[rsp]
	imul	ecx, 32					; 00000020H
	sub	eax, ecx
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, 8
	mov	ecx, ecx
	mov	rdx, QWORD PTR fname$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN2@to_dos_fil
$LN1@to_dos_fil:
$LN17@to_dos_fil:

; 77   : }

	add	rsp, 72					; 00000048H
	ret	0
?to_dos_file_name32@@YAXPEBDPEADI@Z ENDP		; to_dos_file_name32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
cluster$ = 8
?cluster_to_sector32@@YA_K_K@Z PROC			; cluster_to_sector32

; 39   : {

	mov	QWORD PTR [rsp+8], rcx

; 40   : 	return cluster_begin_lba + (cluster - 2) * sectors_per_cluster ;

	mov	eax, DWORD PTR ?cluster_begin_lba@@3KA	; cluster_begin_lba
	mov	rcx, QWORD PTR cluster$[rsp]
	sub	rcx, 2
	movzx	edx, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	imul	rcx, rdx
	add	rax, rcx

; 41   : }

	ret	0
?cluster_to_sector32@@YA_K_K@Z ENDP			; cluster_to_sector32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
dir2$ = 40
dir$ = 48
filename2$ = 56
filename$ = 88
buf$ = 128
buf2$ = 640
?fat32_list_files@@YAXXZ PROC				; fat32_list_files

; 313  : void fat32_list_files() {

$LN9:
	sub	rsp, 1160				; 00000488H

; 314  : 	unsigned char buf[512];
; 315  : 	unsigned char buf2[512];
; 316  : 	char filename[32];
; 317  : 	ata_read_28(root_sector, 1, buf);

	lea	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 318  : 	ata_read_28(root_sector + 1, 1, buf2);

	mov	eax, DWORD PTR ?root_sector@@3KA	; root_sector
	inc	eax
	lea	r8, QWORD PTR buf2$[rsp]
	mov	dx, 1
	mov	ecx, eax
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 319  : 	fat32_dir *dir = (fat32_dir*)buf;

	lea	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dir$[rsp], rax

; 320  : 	for (int i=0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@fat32_list
$LN5@fat32_list:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@fat32_list:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN4@fat32_list

; 321  : 		convert_fat83_32(dir,filename);

	lea	rdx, QWORD PTR filename$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z ; convert_fat83_32

; 322  : 		printf ("%s             %d bytes\n",filename, dir->file_size);

	mov	rax, QWORD PTR dir$[rsp]
	mov	r8d, DWORD PTR [rax+28]
	lea	rdx, QWORD PTR filename$[rsp]
	lea	rcx, OFFSET FLAT:$SG3319
	call	?printf@@YAXPEBDZZ			; printf

; 323  : 		dir++;

	mov	rax, QWORD PTR dir$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dir$[rsp], rax

; 324  : 	}

	jmp	SHORT $LN5@fat32_list
$LN4@fat32_list:

; 325  : 
; 326  : 	char filename2[32];
; 327  : 	fat32_dir *dir2 = (fat32_dir*)buf2;

	lea	rax, QWORD PTR buf2$[rsp]
	mov	QWORD PTR dir2$[rsp], rax

; 328  : 	for (int i=0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@fat32_list
$LN2@fat32_list:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@fat32_list:
	cmp	DWORD PTR i$2[rsp], 16
	jge	SHORT $LN1@fat32_list

; 329  : 		convert_fat83_32(dir2,filename2);

	lea	rdx, QWORD PTR filename2$[rsp]
	mov	rcx, QWORD PTR dir2$[rsp]
	call	?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z ; convert_fat83_32

; 330  : 		printf ("%s             %d bytes\n",filename2, dir2->file_size);

	mov	rax, QWORD PTR dir2$[rsp]
	mov	r8d, DWORD PTR [rax+28]
	lea	rdx, QWORD PTR filename2$[rsp]
	lea	rcx, OFFSET FLAT:$SG3327
	call	?printf@@YAXPEBDZZ			; printf

; 331  : 		dir2++;

	mov	rax, QWORD PTR dir2$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dir2$[rsp], rax

; 332  : 	}

	jmp	SHORT $LN2@fat32_list
$LN1@fat32_list:

; 333  : }

	add	rsp, 1160				; 00000488H
	ret	0
?fat32_list_files@@YAXXZ ENDP				; fat32_list_files
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
fsys$ = 32
?fat32_self_register@@YAXXZ PROC			; fat32_self_register

; 769  : void fat32_self_register () {

$LN3:
	sub	rsp, 56					; 00000038H

; 770  : 	vfs_node_t *fsys = (vfs_node_t*)malloc(sizeof(vfs_node_t));

	mov	ecx, 96					; 00000060H
	call	?malloc@@YAPEAXI@Z			; malloc
	mov	QWORD PTR fsys$[rsp], rax

; 771  : 	strcpy (fsys->filename, "/");

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rdx, OFFSET FLAT:$SG3569
	mov	rcx, rax
	call	?strcpy@@YAPEADPEADPEBD@Z		; strcpy

; 772  : 	fsys->size = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+32], 0

; 773  : 	fsys->eof = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+36], 0

; 774  : 	fsys->pos = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+40], 0

; 775  : 	fsys->current = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+44], 0

; 776  : 	fsys->flags = FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+48], 1

; 777  : 	fsys->status = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+52], 0

; 778  : 	fsys->open = fat32_open;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z ; fat32_open
	mov	QWORD PTR [rax+56], rcx

; 779  : 	fsys->read = fat32_read_file;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?fat32_read_file@@YAXPEAU_vfs_node_@@PEAEI@Z ; fat32_read_file
	mov	QWORD PTR [rax+64], rcx

; 780  : 	fsys->write = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+72], 0

; 781  : 	fsys->read_blk = fat32_read;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?fat32_read@@YAXPEAU_vfs_node_@@PEAE@Z ; fat32_read
	mov	QWORD PTR [rax+80], rcx

; 782  : 	fsys->ioquery = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+88], 0

; 783  : 	vfs_mount ("/", fsys);

	mov	rdx, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:$SG3570
	call	?vfs_mount@@YAXPEADPEAU_vfs_node_@@@Z	; vfs_mount

; 784  : 	printf ("File System registered\n");

	lea	rcx, OFFSET FLAT:$SG3571
	call	?printf@@YAXPEBDZZ			; printf

; 785  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_self_register@@YAXXZ ENDP			; fat32_self_register
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
dirent$1 = 32
first_cluster$ = 40
i$2 = 44
sector$3 = 48
dot_dot_entry$4 = 56
dot_entry$5 = 64
i$6 = 72
cluster_first$ = 76
dir_content$7 = 80
sector_d$8 = 88
status$ = 92
formated_name$ = 96
buf$ = 112
filename$ = 640
?create_dir@@YAXPEBD@Z PROC				; create_dir

; 685  : void create_dir (const char* filename) {

$LN14:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 632				; 00000278H

; 686  : 	/**
; 687  : 	 * First we scan the FAT table for free cluster which will
; 688  : 	 * be used as first cluster and store it in a temporary variable
; 689  : 	 */
; 690  : 	uint32_t first_cluster = 0;

	mov	DWORD PTR first_cluster$[rsp], 0

; 691  : 	uint32_t cluster_first = find_free_cluster ();

	call	?find_free_cluster@@YAIXZ		; find_free_cluster
	mov	DWORD PTR cluster_first$[rsp], eax

; 692  : 	first_cluster = cluster_first;

	mov	eax, DWORD PTR cluster_first$[rsp]
	mov	DWORD PTR first_cluster$[rsp], eax

; 693  : 	uint32_t status = alloc_cluster (cluster_first, 0x0FFFFFF8);

	mov	edx, 268435448				; 0ffffff8H
	mov	ecx, DWORD PTR cluster_first$[rsp]
	call	?alloc_cluster@@YAIHI@Z			; alloc_cluster
	mov	DWORD PTR status$[rsp], eax

; 694  : 
; 695  : 	//! Clear the cluster
; 696  : 	clear_cluster (cluster_first);

	mov	ecx, DWORD PTR cluster_first$[rsp]
	call	?clear_cluster@@YAXI@Z			; clear_cluster

; 697  : 
; 698  : 	char formated_name[11];
; 699  : 	to_dos_file_name32 (filename, formated_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR formated_name$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?to_dos_file_name32@@YAXPEBDPEADI@Z	; to_dos_file_name32

; 700  :     unsigned char buf[512];
; 701  : 	//! now it's time to parse the root directory
; 702  : 	//! Root Directory Entries scanning goes here
; 703  : 	for (int sector = 0; sector < sectors_per_cluster; sector++) {

	mov	DWORD PTR sector$3[rsp], 0
	jmp	SHORT $LN11@create_dir
$LN10@create_dir:
	mov	eax, DWORD PTR sector$3[rsp]
	inc	eax
	mov	DWORD PTR sector$3[rsp], eax
$LN11@create_dir:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR sector$3[rsp], eax
	jge	$LN9@create_dir

; 704  : 		
; 705  : 		ata_read_28 (root_sector + sector,1, buf);

	mov	eax, DWORD PTR sector$3[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	lea	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, eax
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 706  : 		fat32_dir *dirent = (fat32_dir*)buf;

	lea	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dirent$1[rsp], rax

; 707  : 		for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$6[rsp], 0
	jmp	SHORT $LN8@create_dir
$LN7@create_dir:
	mov	eax, DWORD PTR i$6[rsp]
	inc	eax
	mov	DWORD PTR i$6[rsp], eax
$LN8@create_dir:
	cmp	DWORD PTR i$6[rsp], 16
	jge	$LN6@create_dir

; 708  : 
; 709  : 
; 710  : 			//! scan for free directory entry
; 711  : 			if (dirent->filename[0] == 0x00 || dirent->filename[0] == 0xE5){

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN4@create_dir
	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 229				; 000000e5H
	jne	$LN5@create_dir
$LN4@create_dir:

; 712  : 				printf ("Empty entry found\n");

	lea	rcx, OFFSET FLAT:$SG3551
	call	?printf@@YAXPEBDZZ			; printf

; 713  : 				memset(dirent, 0, sizeof(fat32_dir));

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR dirent$1[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 714  : 				memcpy (dirent->filename, formated_name, 11);

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	r8d, 11
	lea	rdx, QWORD PTR formated_name$[rsp]
	mov	rcx, rax
	call	memcpy

; 715  : 				dirent->attrib = ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	BYTE PTR [rax+11], 16

; 716  : 				dirent->time_created_ms = 2021;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	BYTE PTR [rax+13], 229			; 000000e5H

; 717  : 				dirent->time_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+14], ax

; 718  : 				dirent->date_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+16], ax

; 719  : 				dirent->date_last_accessed = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+18], ax

; 720  : 				dirent->first_cluster_hi_bytes = (first_cluster >> 16) & 0xFFFF;

	mov	eax, DWORD PTR first_cluster$[rsp]
	shr	eax, 16
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+20], ax

; 721  : 				dirent->last_mod_time = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+22], ax

; 722  : 				dirent->last_mod_date = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+24], ax

; 723  : 				dirent->first_cluster = first_cluster & 0xFFFF;

	mov	eax, DWORD PTR first_cluster$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+26], ax

; 724  : 				dirent->file_size = 0;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	DWORD PTR [rax+28], 0

; 725  : 
; 726  : 				//! write the dir entry and go for writing the contents of the file
; 727  : 				ata_write_one (buf, root_sector + sector);

	mov	eax, DWORD PTR sector$3[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	lea	rcx, QWORD PTR buf$[rsp]
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 728  : 
; 729  : 				unsigned char* dir_content = (unsigned char*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR dir_content$7[rsp], rax

; 730  : 				memset(dir_content, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR dir_content$7[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 731  : 				uint32_t sector_d = cluster_to_sector32 (first_cluster);

	mov	eax, DWORD PTR first_cluster$[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR sector_d$8[rsp], eax

; 732  : 				fat32_dir *dot_entry = (fat32_dir*)dir_content;

	mov	rax, QWORD PTR dir_content$7[rsp]
	mov	QWORD PTR dot_entry$5[rsp], rax

; 733  : 				dot_entry->attrib = ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	BYTE PTR [rax+11], 16

; 734  : 				dot_entry->time_created_ms = 2021;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	BYTE PTR [rax+13], 229			; 000000e5H

; 735  : 				dot_entry->time_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+14], ax

; 736  : 				dot_entry->date_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+16], ax

; 737  : 				dot_entry->date_last_accessed = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+18], ax

; 738  : 				dot_entry->first_cluster_hi_bytes = (first_cluster >> 16) & 0xFFFF;

	mov	eax, DWORD PTR first_cluster$[rsp]
	shr	eax, 16
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+20], ax

; 739  : 				dot_entry->last_mod_time = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+22], ax

; 740  : 				dot_entry->last_mod_date = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+24], ax

; 741  : 				dot_entry->first_cluster = first_cluster & 0xFFFF;

	mov	eax, DWORD PTR first_cluster$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+26], ax

; 742  : 				dot_entry->file_size = 0;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	DWORD PTR [rax+28], 0

; 743  : 
; 744  : 
; 745  : 				fat32_dir* dot_dot_entry = (fat32_dir*)(dir_content + 32);

	mov	rax, QWORD PTR dir_content$7[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dot_dot_entry$4[rsp], rax

; 746  : 				dot_dot_entry->attrib = ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dot_dot_entry$4[rsp]
	mov	BYTE PTR [rax+11], 16

; 747  : 				dot_dot_entry->time_created_ms = 2021;

	mov	rax, QWORD PTR dot_dot_entry$4[rsp]
	mov	BYTE PTR [rax+13], 229			; 000000e5H

; 748  : 				dot_dot_entry->time_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+14], ax

; 749  : 				dot_dot_entry->date_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+16], ax

; 750  : 				dot_dot_entry->date_last_accessed = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+18], ax

; 751  : 				dot_dot_entry->first_cluster_hi_bytes = (root_dir_first_cluster >> 16) & 0xFFFF;

	mov	eax, DWORD PTR ?root_dir_first_cluster@@3KA ; root_dir_first_cluster
	shr	eax, 16
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+20], ax

; 752  : 				dot_dot_entry->last_mod_time = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+22], ax

; 753  : 				dot_dot_entry->last_mod_date = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+24], ax

; 754  : 				dot_dot_entry->first_cluster = root_dir_first_cluster & 0xFFFF;

	mov	eax, DWORD PTR ?root_dir_first_cluster@@3KA ; root_dir_first_cluster
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+26], ax

; 755  : 				dot_dot_entry->file_size = 0;

	mov	rax, QWORD PTR dot_dot_entry$4[rsp]
	mov	DWORD PTR [rax+28], 0

; 756  : 
; 757  : 				for (int i = 0; i < 8; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@create_dir
$LN2@create_dir:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@create_dir:
	cmp	DWORD PTR i$2[rsp], 8
	jge	SHORT $LN1@create_dir

; 758  : 					ata_write_one (dir_content + (i * 512),sector_d + i);

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR sector_d$8[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR i$2[rsp]
	imul	ecx, 512				; 00000200H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR dir_content$7[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 759  : 				}

	jmp	SHORT $LN2@create_dir
$LN1@create_dir:

; 760  : 				return;

	jmp	SHORT $LN12@create_dir
$LN5@create_dir:

; 761  : 			}
; 762  : 			dirent++;

	mov	rax, QWORD PTR dirent$1[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$1[rsp], rax

; 763  : 		}

	jmp	$LN7@create_dir
$LN6@create_dir:

; 764  : 	}

	jmp	$LN10@create_dir
$LN9@create_dir:
$LN12@create_dir:

; 765  : 
; 766  : }

	add	rsp, 632				; 00000278H
	ret	0
?create_dir@@YAXPEBD@Z ENDP				; create_dir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
dirent$1 = 32
sector$2 = 40
cluster_first$ = 44
cluster$ = 48
first_cluster$ = 52
i$3 = 56
i$4 = 60
required_cluster$ = 64
i$5 = 68
stat$6 = 72
status$ = 76
status2$ = 80
formated_name$ = 88
buf$ = 112
filename$ = 640
buffer$ = 648
length$ = 656
?fat32_create_file@@YAIPEADPEAEI@Z PROC			; fat32_create_file

; 605  : uint32_t fat32_create_file  (char* filename, uint8_t *buffer, unsigned int length) {

$LN18:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 632				; 00000278H

; 606  : 
; 607  : 	/**
; 608  : 	 * First we scan the FAT table for free cluster which will
; 609  : 	 * be used as first cluster and store it in a temporary variable
; 610  : 	 */
; 611  : 	uint32_t first_cluster = 0;

	mov	DWORD PTR first_cluster$[rsp], 0

; 612  : 	uint32_t cluster_first = find_free_cluster ();

	call	?find_free_cluster@@YAIXZ		; find_free_cluster
	mov	DWORD PTR cluster_first$[rsp], eax

; 613  : 	first_cluster = cluster_first;

	mov	eax, DWORD PTR cluster_first$[rsp]
	mov	DWORD PTR first_cluster$[rsp], eax

; 614  : 	uint32_t status = alloc_cluster (cluster_first, 0x0FFFFFF8);

	mov	edx, 268435448				; 0ffffff8H
	mov	ecx, DWORD PTR cluster_first$[rsp]
	call	?alloc_cluster@@YAIHI@Z			; alloc_cluster
	mov	DWORD PTR status$[rsp], eax

; 615  : 
; 616  : 	//! Clear the cluster
; 617  : 	clear_cluster (cluster_first);

	mov	ecx, DWORD PTR cluster_first$[rsp]
	call	?clear_cluster@@YAXI@Z			; clear_cluster

; 618  : 
; 619  : 	//! Now calculate the number of clusters required 
; 620  : 	//! for the file
; 621  : 	uint32_t required_cluster = 0;

	mov	DWORD PTR required_cluster$[rsp], 0

; 622  : 	if (length > 4096) {

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jbe	SHORT $LN15@fat32_crea

; 623  : 		for (int i = 0; i < length / 4096; i++) {

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN14@fat32_crea
$LN13@fat32_crea:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
$LN14@fat32_crea:
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	cmp	DWORD PTR i$5[rsp], eax
	jae	SHORT $LN12@fat32_crea

; 624  : 			required_cluster++;

	mov	eax, DWORD PTR required_cluster$[rsp]
	inc	eax
	mov	DWORD PTR required_cluster$[rsp], eax

; 625  : 		}

	jmp	SHORT $LN13@fat32_crea
$LN12@fat32_crea:
$LN15@fat32_crea:

; 626  : 	}
; 627  : 
; 628  : 	//! Now allocate each clusters in the fat table
; 629  : 	//! [Knowledge]: In FAT table if the file requires more cluster
; 630  : 	//! than the file's first cluster points to next cluster
; 631  : 	//! kind of linked list data structure
; 632  :     uint32_t cluster = 0;

	mov	DWORD PTR cluster$[rsp], 0

; 633  : 	for (int i = 0; i < required_cluster; i++) {

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN11@fat32_crea
$LN10@fat32_crea:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN11@fat32_crea:
	mov	eax, DWORD PTR required_cluster$[rsp]
	cmp	DWORD PTR i$3[rsp], eax
	jae	SHORT $LN9@fat32_crea

; 634  : 		cluster = find_free_cluster ();

	call	?find_free_cluster@@YAIXZ		; find_free_cluster
	mov	DWORD PTR cluster$[rsp], eax

; 635  : 		uint32_t stat = alloc_cluster (cluster_first, cluster);

	mov	edx, DWORD PTR cluster$[rsp]
	mov	ecx, DWORD PTR cluster_first$[rsp]
	call	?alloc_cluster@@YAIHI@Z			; alloc_cluster
	mov	DWORD PTR stat$6[rsp], eax

; 636  : 		clear_cluster (cluster);

	mov	ecx, DWORD PTR cluster$[rsp]
	call	?clear_cluster@@YAXI@Z			; clear_cluster

; 637  : 		cluster_first = cluster;

	mov	eax, DWORD PTR cluster$[rsp]
	mov	DWORD PTR cluster_first$[rsp], eax

; 638  : 	}

	jmp	SHORT $LN10@fat32_crea
$LN9@fat32_crea:

; 639  : 
; 640  : 	//! the last cluster should be marked as EOC {0x0FFFFFF8}
; 641  : 	uint32_t status2 = alloc_cluster (cluster, 0x0FFFFFF8);

	mov	edx, 268435448				; 0ffffff8H
	mov	ecx, DWORD PTR cluster$[rsp]
	call	?alloc_cluster@@YAIHI@Z			; alloc_cluster
	mov	DWORD PTR status2$[rsp], eax

; 642  : 
; 643  : 	//! Finally format the name 
; 644  : 	//! for now Aurora's Xeneva support only short name MSDOS 8.3
; 645  : 	char formated_name[11];
; 646  : 	to_dos_file_name32 (filename, formated_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR formated_name$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?to_dos_file_name32@@YAXPEBDPEADI@Z	; to_dos_file_name32

; 647  : 
; 648  : 	//! now it's time to parse the root directory
; 649  : 	unsigned char buf[512];
; 650  : 	//! Root Directory Entries scanning goes here
; 651  : 	for (int sector = 0; sector < sectors_per_cluster; sector++) {

	mov	DWORD PTR sector$2[rsp], 0
	jmp	SHORT $LN8@fat32_crea
$LN7@fat32_crea:
	mov	eax, DWORD PTR sector$2[rsp]
	inc	eax
	mov	DWORD PTR sector$2[rsp], eax
$LN8@fat32_crea:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR sector$2[rsp], eax
	jge	$LN6@fat32_crea

; 652  : 		ata_read_28 (root_sector + sector,1, buf);	

	mov	eax, DWORD PTR sector$2[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	lea	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, eax
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 653  : 		fat32_dir *dirent = (fat32_dir*)buf;

	lea	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dirent$1[rsp], rax

; 654  : 		for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$4[rsp], 0
	jmp	SHORT $LN5@fat32_crea
$LN4@fat32_crea:
	mov	eax, DWORD PTR i$4[rsp]
	inc	eax
	mov	DWORD PTR i$4[rsp], eax
$LN5@fat32_crea:
	cmp	DWORD PTR i$4[rsp], 16
	jge	$LN3@fat32_crea

; 655  : 		
; 656  : 			//! scan for free directory entry
; 657  : 			if (dirent->filename[0] == 0x00 || dirent->filename[0] == 0xE5){

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN1@fat32_crea
	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 229				; 000000e5H
	jne	$LN2@fat32_crea
$LN1@fat32_crea:

; 658  : 				
; 659  : 				memset(dirent, 0, sizeof(fat32_dir));

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR dirent$1[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 660  : 				memcpy (dirent->filename, formated_name, 11);

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	r8d, 11
	lea	rdx, QWORD PTR formated_name$[rsp]
	mov	rcx, rax
	call	memcpy

; 661  : 				dirent->attrib = ATTRIBUTE_ARCHIVE;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	BYTE PTR [rax+11], 32			; 00000020H

; 662  : 				dirent->time_created_ms = 2021;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	BYTE PTR [rax+13], 229			; 000000e5H

; 663  : 				dirent->time_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+14], ax

; 664  : 				dirent->date_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+16], ax

; 665  : 				dirent->date_last_accessed = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+18], ax

; 666  : 				dirent->first_cluster_hi_bytes = (first_cluster >> 16) & 0xFFFF;

	mov	eax, DWORD PTR first_cluster$[rsp]
	shr	eax, 16
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+20], ax

; 667  : 				dirent->last_mod_time = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+22], ax

; 668  : 				dirent->last_mod_date = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+24], ax

; 669  : 				dirent->first_cluster = first_cluster & 0xFFFF;

	mov	eax, DWORD PTR first_cluster$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+26], ax

; 670  : 				dirent->file_size = length;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	ecx, DWORD PTR length$[rsp]
	mov	DWORD PTR [rax+28], ecx

; 671  : 				//! write the dir entry and go for writing the contents of the file
; 672  : 				ata_write_one (buf, root_sector + sector);

	mov	eax, DWORD PTR sector$2[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	lea	rcx, QWORD PTR buf$[rsp]
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 673  : 				//! actuall file writing process begins here
; 674  : 				fat32_write_content (buffer, first_cluster,length);

	mov	r8d, DWORD PTR length$[rsp]
	mov	edx, DWORD PTR first_cluster$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	?fat32_write_content@@YAXPEAEII@Z	; fat32_write_content

; 675  : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN16@fat32_crea
$LN2@fat32_crea:

; 676  : 			}
; 677  : 			dirent++;

	mov	rax, QWORD PTR dirent$1[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$1[rsp], rax

; 678  : 		}

	jmp	$LN4@fat32_crea
$LN3@fat32_crea:

; 679  : 	
; 680  : 	}

	jmp	$LN7@fat32_crea
$LN6@fat32_crea:
$LN16@fat32_crea:

; 681  : 	//!free every allocated memories
; 682  : }

	add	rsp, 632				; 00000278H
	ret	0
?fat32_create_file@@YAIPEADPEAEI@Z ENDP			; fat32_create_file
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
j$2 = 36
dirent$ = 40
filename2$ = 48
buf$ = 80
?list_fat_entries@@YAXXZ PROC				; list_fat_entries

; 539  : void list_fat_entries () {

$LN9:
	sub	rsp, 600				; 00000258H

; 540  : 
; 541  : 	printf ("Root Dir entries scanning\n");

	lea	rcx, OFFSET FLAT:$SG3454
	call	?printf@@YAXPEBDZZ			; printf

; 542  : 	fat32_dir *dirent;
; 543  : 	char filename2[32];
; 544  : 	char format_name[11];
; 545  : 
; 546  : 	unsigned char buf[512];
; 547  : 	for (int i = 0; i < sectors_per_cluster; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@list_fat_e
$LN5@list_fat_e:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@list_fat_e:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN4@list_fat_e

; 548  : 		ata_read_28 (root_sector + i, 1,buf);

	mov	eax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	lea	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, eax
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 549  : 		dirent = (fat32_dir*)buf;

	lea	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dirent$[rsp], rax

; 550  : 		for (int j = 0; j < 16; j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN3@list_fat_e
$LN2@list_fat_e:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN3@list_fat_e:
	cmp	DWORD PTR j$2[rsp], 16
	jge	SHORT $LN1@list_fat_e

; 551  : 			convert_fat83_32(dirent,filename2);

	lea	rdx, QWORD PTR filename2$[rsp]
	mov	rcx, QWORD PTR dirent$[rsp]
	call	?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z ; convert_fat83_32

; 552  : 			printf ("Other file size -> %s, dirent attrib -> %x, count ->%d\n", filename2, *(uint8_t*)&buf[j], i);

	movsxd	rax, DWORD PTR j$2[rsp]
	movzx	eax, BYTE PTR buf$[rsp+rax]
	mov	r9d, DWORD PTR i$1[rsp]
	mov	r8d, eax
	lea	rdx, QWORD PTR filename2$[rsp]
	lea	rcx, OFFSET FLAT:$SG3469
	call	?printf@@YAXPEBDZZ			; printf

; 553  : 			dirent++;

	mov	rax, QWORD PTR dirent$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$[rsp], rax

; 554  : 		}

	jmp	SHORT $LN2@list_fat_e
$LN1@list_fat_e:

; 555  : 	}

	jmp	$LN5@list_fat_e
$LN4@list_fat_e:

; 556  : }

	add	rsp, 600				; 00000258H
	ret	0
?list_fat_entries@@YAXXZ ENDP				; list_fat_entries
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
sector$1 = 32
i$2 = 36
dirent$ = 40
buf$ = 48
name$3 = 56
dos_file_name$ = 72
file$ = 96
$T4 = 224
dir$ = 232
?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z PROC		; fat32_locate_dir

; 179  : vfs_node_t fat32_locate_dir (const char* dir) {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 200				; 000000c8H

; 180  : 	vfs_node_t file;
; 181  : 	unsigned char* buf;
; 182  : 	fat32_dir *dirent;
; 183  : 
; 184  : 	char dos_file_name[11];
; 185  : 	to_dos_file_name32 (dir, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	?to_dos_file_name32@@YAXPEBDPEADI@Z	; to_dos_file_name32

; 186  : 	//dos_file_name[11]=0;	
; 187  : 	buf = (unsigned char*)pmmngr_alloc ();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buf$[rsp], rax

; 188  : 	for (unsigned int sector = 0; sector < sectors_per_cluster; sector++) {

	mov	DWORD PTR sector$1[rsp], 0
	jmp	SHORT $LN9@fat32_loca
$LN8@fat32_loca:
	mov	eax, DWORD PTR sector$1[rsp]
	inc	eax
	mov	DWORD PTR sector$1[rsp], eax
$LN9@fat32_loca:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR sector$1[rsp], eax
	jae	$LN7@fat32_loca

; 189  : 	
; 190  : 		memset (buf, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 191  : 		ata_read_28 (root_sector + sector,1, buf);

	mov	eax, DWORD PTR sector$1[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	mov	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, eax
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 192  : 		dirent = (fat32_dir*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dirent$[rsp], rax

; 193  : 		for (int i=0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN6@fat32_loca
$LN5@fat32_loca:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN6@fat32_loca:
	cmp	DWORD PTR i$2[rsp], 16
	jge	$LN4@fat32_loca

; 194  : 			
; 195  : 			char name[11];
; 196  : 			memcpy (name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rsp]
	call	memcpy

; 197  : 			name[11] = 0;

	mov	eax, 1
	imul	rax, 11
	mov	BYTE PTR name$3[rsp+rax], 0

; 198  : 			if (strcmp (dos_file_name, name) == 0) {

	lea	rdx, QWORD PTR name$3[rsp]
	lea	rcx, QWORD PTR dos_file_name$[rsp]
	call	?strcmp@@YAHPEBD0@Z			; strcmp
	test	eax, eax
	jne	$LN3@fat32_loca

; 199  : 				strcpy (file.filename, dir);

	mov	rdx, QWORD PTR dir$[rsp]
	lea	rcx, QWORD PTR file$[rsp]
	call	?strcpy@@YAPEADPEADPEBD@Z		; strcpy

; 200  : 				file.current = dirent->first_cluster;

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	DWORD PTR file$[rsp+44], eax

; 201  : 				file.size = dirent->file_size;

	mov	rax, QWORD PTR dirent$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR file$[rsp+32], eax

; 202  : 				file.eof = 0;

	mov	DWORD PTR file$[rsp+36], 0

; 203  : 				file.status = FS_STATUS_FOUND;

	mov	DWORD PTR file$[rsp+52], 4

; 204  : 
; 205  : 				if (dirent->attrib == 0x10)

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	eax, 16
	jne	SHORT $LN2@fat32_loca

; 206  : 					file.flags = FS_FLAG_DIRECTORY;

	mov	DWORD PTR file$[rsp+48], 1

; 207  : 				else

	jmp	SHORT $LN1@fat32_loca
$LN2@fat32_loca:

; 208  : 					file.flags = FS_FLAG_GENERAL;

	mov	DWORD PTR file$[rsp+48], 2
$LN1@fat32_loca:

; 209  : 				
; 210  : 				pmmngr_free(buf);

	mov	rcx, QWORD PTR buf$[rsp]
	call	?pmmngr_free@@YAXPEAX@Z			; pmmngr_free

; 211  : 				return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T4[rsp]
	mov	rsi, rax
	mov	ecx, 96					; 00000060H
	rep movsb
	mov	rax, QWORD PTR $T4[rsp]
	jmp	SHORT $LN10@fat32_loca
$LN3@fat32_loca:

; 212  : 			}
; 213  : 			dirent++;

	mov	rax, QWORD PTR dirent$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$[rsp], rax

; 214  : 		}

	jmp	$LN5@fat32_loca
$LN4@fat32_loca:

; 215  : 		pmmngr_free(buf);		

	mov	rcx, QWORD PTR buf$[rsp]
	call	?pmmngr_free@@YAXPEAX@Z			; pmmngr_free

; 216  : 	}

	jmp	$LN8@fat32_loca
$LN7@fat32_loca:

; 217  : 
; 218  : 	file.status = FS_FLAG_INVALID;

	mov	DWORD PTR file$[rsp+52], 3

; 219  : 	file.size = 0;

	mov	DWORD PTR file$[rsp+32], 0

; 220  : 	file.eof = 0;

	mov	DWORD PTR file$[rsp+36], 0

; 221  : 	return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T4[rsp]
	mov	rsi, rax
	mov	ecx, 96					; 00000060H
	rep movsb
	mov	rax, QWORD PTR $T4[rsp]
$LN10@fat32_loca:

; 222  : }

	add	rsp, 200				; 000000c8H
	pop	rdi
	pop	rsi
	ret	0
?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z ENDP		; fat32_locate_dir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
value$ = 36
lba$ = 40
file$ = 64
buf$ = 72
?fat32_read@@YAXPEAU_vfs_node_@@PEAE@Z PROC		; fat32_read

; 146  : void fat32_read (vfs_node_t *file, unsigned char* buf) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 147  : 
; 148  : 	auto lba = cluster_to_sector32 (file->current); 	

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+44]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	QWORD PTR lba$[rsp], rax

; 149  : 
; 150  : 	for (int i = 0; i < sectors_per_cluster; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN5@fat32_read
$LN4@fat32_read:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN5@fat32_read:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN3@fat32_read

; 151  : 		ata_read_28 (lba+i,1,buf);

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR lba$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, eax
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 152  : 		buf += 512;

	mov	rax, QWORD PTR buf$[rsp]
	add	rax, 512				; 00000200H
	mov	QWORD PTR buf$[rsp], rax

; 153  : 	}

	jmp	SHORT $LN4@fat32_read
$LN3@fat32_read:

; 154  : 	uint32_t value = fat32_read_fat (file->current);

	mov	rax, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR [rax+44]
	call	?fat32_read_fat@@YAII@Z			; fat32_read_fat
	mov	DWORD PTR value$[rsp], eax

; 155  : 	if (value  >= 0x0FFFFFF8) {

	cmp	DWORD PTR value$[rsp], 268435448	; 0ffffff8H
	jb	SHORT $LN2@fat32_read

; 156  : 	    file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+36], 1

; 157  : 		return;

	jmp	SHORT $LN6@fat32_read
$LN2@fat32_read:

; 158  : 	}
; 159  : 
; 160  : 	if (value  == 0x0FFFFFF7) {

	cmp	DWORD PTR value$[rsp], 268435447	; 0ffffff7H
	jne	SHORT $LN1@fat32_read

; 161  : 	    file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+36], 1

; 162  : 		return;

	jmp	SHORT $LN6@fat32_read
$LN1@fat32_read:

; 163  : 	}
; 164  : 	
; 165  : 	file->current = value;

	mov	rax, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+44], ecx
$LN6@fat32_read:

; 166  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_read@@YAXPEAU_vfs_node_@@PEAE@Z ENDP		; fat32_read
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
file$ = 64
buf$ = 72
count$ = 80
?fat32_read_file@@YAXPEAU_vfs_node_@@PEAEI@Z PROC	; fat32_read_file

; 169  : void fat32_read_file (vfs_node_t *file, unsigned char* buf, uint32_t count) {

$LN7:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 170  : 	for (int i=0; i < count; i+= 8) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@fat32_read
$LN3@fat32_read:
	mov	eax, DWORD PTR i$1[rsp]
	add	eax, 8
	mov	DWORD PTR i$1[rsp], eax
$LN4@fat32_read:
	mov	eax, DWORD PTR count$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@fat32_read

; 171  : 		fat32_read(file,buf);

	mov	rdx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	call	?fat32_read@@YAXPEAU_vfs_node_@@PEAE@Z	; fat32_read

; 172  : 		if(file->eof) {

	mov	rax, QWORD PTR file$[rsp]
	cmp	DWORD PTR [rax+36], 0
	je	SHORT $LN1@fat32_read

; 173  : 			break;

	jmp	SHORT $LN2@fat32_read
$LN1@fat32_read:

; 174  : 		}
; 175  : 		buf += 4096;

	mov	rax, QWORD PTR buf$[rsp]
	add	rax, 4096				; 00001000H
	mov	QWORD PTR buf$[rsp], rax

; 176  : 	}

	jmp	SHORT $LN3@fat32_read
$LN2@fat32_read:

; 177  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_read_file@@YAXPEAU_vfs_node_@@PEAEI@Z ENDP	; fat32_read_file
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
root_dir$ = 32
i$1 = 36
p$ = 40
path$ = 48
pathname$2 = 56
cur_dir$ = 80
ret$3 = 176
$T4 = 272
ret$ = 368
$T5 = 464
$T6 = 560
$T7 = 656
$T8 = 752
$T9 = 848
$T10 = 944
$T11 = 1072
node$ = 1080
filename$ = 1088
?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z PROC		; fat32_open

; 340  : vfs_node_t fat32_open (vfs_node_t * node, char* filename) {

$LN17:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 1048				; 00000418H

; 341  : 	vfs_node_t cur_dir;
; 342  : 	char* p = 0;

	mov	QWORD PTR p$[rsp], 0

; 343  : 	bool  root_dir = true;

	mov	BYTE PTR root_dir$[rsp], 1

; 344  : 	char* path = (char*) filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR path$[rsp], rax

; 345  : 
; 346  : 	//! any '\'s in path ?
; 347  : 	p = strchr (path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	?strchr@@YAPEADPEADH@Z			; strchr
	mov	QWORD PTR p$[rsp], rax

; 348  : 	if (!p) {

	cmp	QWORD PTR p$[rsp], 0
	jne	$LN14@fat32_open

; 349  : 
; 350  : 		//! nope, must be in root directory, search it
; 351  : 		cur_dir = fat32_locate_dir (path);

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z ; fat32_locate_dir
	lea	rcx, QWORD PTR $T6[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 96					; 00000060H
	rep movsb
	lea	rax, QWORD PTR cur_dir$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 96					; 00000060H
	rep movsb

; 352  : 
; 353  : 		//! found file ?
; 354  : 		if (cur_dir.flags == FS_FLAG_GENERAL) {

	cmp	DWORD PTR cur_dir$[rsp+48], 2
	jne	SHORT $LN13@fat32_open

; 355  : 			return cur_dir;

	lea	rax, QWORD PTR cur_dir$[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 96					; 00000060H
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN15@fat32_open
$LN13@fat32_open:

; 356  : 		}
; 357  : 
; 358  : 		//! unable to find
; 359  : 		vfs_node_t ret;
; 360  : 		ret.flags = FS_FLAG_INVALID;

	mov	DWORD PTR ret$3[rsp+48], 3

; 361  : 		return ret;

	lea	rax, QWORD PTR ret$3[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 96					; 00000060H
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN15@fat32_open
$LN14@fat32_open:

; 362  : 	}
; 363  : 
; 364  : 	//! go to next character after first '\'
; 365  : 	p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN12@fat32_open:

; 366  : 
; 367  : 	while (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	$LN11@fat32_open

; 368  : 
; 369  : 		//! get pathname
; 370  : 		char pathname[16];
; 371  : 		int i=0;

	mov	DWORD PTR i$1[rsp], 0

; 372  : 		for (i=0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN10@fat32_open
$LN9@fat32_open:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN10@fat32_open:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN8@fat32_open

; 373  : 
; 374  : 			//! if another '\' or end of line is reached, we are done
; 375  : 			if (p[i] == '/' || p[i]=='\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN6@fat32_open
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN7@fat32_open
$LN6@fat32_open:

; 376  : 				break;

	jmp	SHORT $LN8@fat32_open
$LN7@fat32_open:

; 377  : 
; 378  : 			//! copy character
; 379  : 			pathname[i]=p[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$2[rsp+rcx], al

; 380  : 		}

	jmp	SHORT $LN9@fat32_open
$LN8@fat32_open:

; 381  : 		pathname[i]=0; //null terminate

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$2[rsp+rax], 0

; 382  : 
; 383  : 		//! open subdirectory or file
; 384  : 		if (root_dir) {

	movzx	eax, BYTE PTR root_dir$[rsp]
	test	eax, eax
	je	SHORT $LN5@fat32_open

; 385  : 			//! search root dir -- open pathname
; 386  : 			cur_dir = fat32_locate_dir (pathname);

	lea	rdx, QWORD PTR pathname$2[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z ; fat32_locate_dir
	lea	rcx, QWORD PTR $T5[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 96					; 00000060H
	rep movsb
	lea	rax, QWORD PTR cur_dir$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 96					; 00000060H
	rep movsb

; 387  : 			root_dir = false;

	mov	BYTE PTR root_dir$[rsp], 0

; 388  : 		}
; 389  : 		else {

	jmp	SHORT $LN4@fat32_open
$LN5@fat32_open:

; 390  : 			//! search a sub directory instead for pathname
; 391  : 			cur_dir = fat32_locate_subdir (cur_dir, pathname);

	lea	rax, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR cur_dir$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 96					; 00000060H
	rep movsb
	lea	r8, QWORD PTR pathname$2[rsp]
	lea	rdx, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z ; fat32_locate_subdir
	lea	rcx, QWORD PTR $T4[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 96					; 00000060H
	rep movsb
	lea	rax, QWORD PTR cur_dir$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 96					; 00000060H
	rep movsb
$LN4@fat32_open:

; 392  : 		}
; 393  : 
; 394  : 		//! found directory or file?
; 395  : 		if (cur_dir.flags == FS_FLAG_INVALID)

	cmp	DWORD PTR cur_dir$[rsp+48], 3
	jne	SHORT $LN3@fat32_open

; 396  : 			break;

	jmp	SHORT $LN11@fat32_open
$LN3@fat32_open:

; 397  : 
; 398  : 		//! found file?
; 399  : 		if (cur_dir.flags == FS_FLAG_GENERAL)

	cmp	DWORD PTR cur_dir$[rsp+48], 2
	jne	SHORT $LN2@fat32_open

; 400  : 			return cur_dir;

	lea	rax, QWORD PTR cur_dir$[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 96					; 00000060H
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
	jmp	SHORT $LN15@fat32_open
$LN2@fat32_open:

; 401  : 
; 402  : 		//! find next '\'
; 403  : 		p=strchr(p+1, '/');

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	?strchr@@YAPEADPEADH@Z			; strchr
	mov	QWORD PTR p$[rsp], rax

; 404  : 		if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN1@fat32_open

; 405  : 			p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN1@fat32_open:

; 406  : 	}

	jmp	$LN12@fat32_open
$LN11@fat32_open:

; 407  : 
; 408  : 	//! unable to find
; 409  : 	vfs_node_t ret;
; 410  : 	ret.flags = FS_FLAG_INVALID;

	mov	DWORD PTR ret$[rsp+48], 3

; 411  : 	return ret;

	lea	rax, QWORD PTR ret$[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 96					; 00000060H
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
$LN15@fat32_open:

; 412  : }

	add	rsp, 1048				; 00000418H
	pop	rdi
	pop	rsi
	ret	0
?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z ENDP		; fat32_open
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
tv143 = 40
fat32_data$ = 48
buf$ = 56
?initialize_fat32@@YAXXZ PROC				; initialize_fat32

; 91   : void initialize_fat32 () {

$LN9:
	sub	rsp, 72					; 00000048H

; 92   : 
; 93   : 	unsigned char *buf = (unsigned char*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buf$[rsp], rax

; 94   : 	ata_read_28 (2048,1,buf); //partition_begin_lba = 2048

	mov	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, 2048				; 00000800H
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 95   : 
; 96   : 	BPB *fat32_data = (BPB*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR fat32_data$[rsp], rax

; 97   : 
; 98   : 	part_lba = 2048;

	mov	DWORD PTR ?part_lba@@3IA, 2048		; part_lba, 00000800H

; 99   : 
; 100  : #if 0
; 101  : 	printf ("FAT32 BOOT PARAMETER BLOCK\n");
; 102  : 	printf ("Bytes/Sector -> %d\n", fat32_data->bytes_per_sector);
; 103  : 	printf ("Sectors/Cluster -> %d\n", fat32_data->sectors_per_cluster);
; 104  : 	printf ("Reserved Sectors -> %d\n", fat32_data->reserved_sectors);
; 105  : 	printf ("Number Of FATs -> %d\n", fat32_data->num_fats);
; 106  : 	printf ("Root Base Cluster -> %d\n", fat32_data->info.FAT32.root_dir_cluster);
; 107  : 	printf ("Sector/FAT32 -> %d\n", fat32_data->info.FAT32.sect_per_fat32);
; 108  : #endif
; 109  : 	for (int i=0; i <12; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@initialize
$LN5@initialize:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@initialize:
	cmp	DWORD PTR i$1[rsp], 12
	jge	SHORT $LN4@initialize

; 110  : 		putc(fat32_data->info.FAT32.vol_label[i]);

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movzx	ecx, BYTE PTR [rcx+rax+71]
	call	?putc@@YAXD@Z				; putc

; 111  : 	}

	jmp	SHORT $LN5@initialize
$LN4@initialize:

; 112  : 	for (int i=0; i <9; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@initialize
$LN2@initialize:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@initialize:
	cmp	DWORD PTR i$2[rsp], 9
	jge	SHORT $LN1@initialize

; 113  : 		putc(fat32_data->info.FAT32.sys_id[i]);

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movzx	ecx, BYTE PTR [rcx+rax+82]
	call	?putc@@YAXD@Z				; putc

; 114  : 	}

	jmp	SHORT $LN2@initialize
$LN1@initialize:

; 115  : 
; 116  : 
; 117  : 	fat_begin_lba = part_lba + fat32_data->reserved_sectors;

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	ecx, DWORD PTR ?part_lba@@3IA		; part_lba
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ?fat_begin_lba@@3KA, eax	; fat_begin_lba

; 118  : 	cluster_begin_lba = part_lba + fat32_data->reserved_sectors + (fat32_data->num_fats * fat32_data->info.FAT32.sect_per_fat32);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	ecx, DWORD PTR ?part_lba@@3IA		; part_lba
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movzx	ecx, BYTE PTR [rcx+16]
	mov	rdx, QWORD PTR fat32_data$[rsp]
	imul	ecx, DWORD PTR [rdx+36]
	add	eax, ecx
	mov	DWORD PTR ?cluster_begin_lba@@3KA, eax	; cluster_begin_lba

; 119  : 	sectors_per_cluster = fat32_data->sectors_per_cluster;

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, BYTE PTR [rax+13]
	mov	BYTE PTR ?sectors_per_cluster@@3EA, al	; sectors_per_cluster

; 120  : 	root_dir_first_cluster = fat32_data->info.FAT32.root_dir_cluster;

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rax+44]
	mov	DWORD PTR ?root_dir_first_cluster@@3KA, eax ; root_dir_first_cluster

; 121  : 	root_sector = cluster_to_sector32 (root_dir_first_cluster);

	mov	eax, DWORD PTR ?root_dir_first_cluster@@3KA ; root_dir_first_cluster
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR ?root_sector@@3KA, eax	; root_sector

; 122  : 	sectors_per_fat32 = fat32_data->info.FAT32.sect_per_fat32;

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR ?sectors_per_fat32@@3IA, eax	; sectors_per_fat32

; 123  : 
; 124  : 	total_clusters = fat32_data->large_sector_count / sectors_per_cluster;

	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	mov	DWORD PTR tv143[rsp], eax
	xor	edx, edx
	mov	rcx, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rcx+32]
	mov	ecx, DWORD PTR tv143[rsp]
	div	ecx
	mov	DWORD PTR ?total_clusters@@3IA, eax	; total_clusters

; 125  : 	//fat32_list_files();
; 126  : 	//for (int i = 0; i < sectors_per_cluster; i++) {
; 127  : 	//	ata_read_28 (root_sector + i, 1, root_dir_cache);
; 128  : 	//	root_dir_cache += 512;
; 129  : 	//}
; 130  : 
; 131  : }

	add	rsp, 72					; 00000048H
	ret	0
?initialize_fat32@@YAXXZ ENDP				; initialize_fat32
_TEXT	ENDS
END
