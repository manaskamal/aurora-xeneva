; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?part_lba@@3IA					; part_lba
PUBLIC	?fat_begin_lba@@3KA				; fat_begin_lba
PUBLIC	?cluster_begin_lba@@3KA				; cluster_begin_lba
PUBLIC	?sectors_per_cluster@@3EA			; sectors_per_cluster
PUBLIC	?root_dir_first_cluster@@3KA			; root_dir_first_cluster
PUBLIC	?root_sector@@3KA				; root_sector
PUBLIC	?sectors_per_fat32@@3IA				; sectors_per_fat32
PUBLIC	?alloc_counter@@3HA				; alloc_counter
PUBLIC	?total_clusters@@3IA				; total_clusters
PUBLIC	?root_dir_cache@@3PEAEEA			; root_dir_cache
_BSS	SEGMENT
?part_lba@@3IA DD 01H DUP (?)				; part_lba
?fat_begin_lba@@3KA DD 01H DUP (?)			; fat_begin_lba
?cluster_begin_lba@@3KA DD 01H DUP (?)			; cluster_begin_lba
?sectors_per_cluster@@3EA DB 01H DUP (?)		; sectors_per_cluster
	ALIGN	4

?root_dir_first_cluster@@3KA DD 01H DUP (?)		; root_dir_first_cluster
?root_sector@@3KA DD 01H DUP (?)			; root_sector
?sectors_per_fat32@@3IA DD 01H DUP (?)			; sectors_per_fat32
?alloc_counter@@3HA DD 01H DUP (?)			; alloc_counter
?total_clusters@@3IA DD 01H DUP (?)			; total_clusters
	ALIGN	8

?root_dir_cache@@3PEAEEA DQ 01H DUP (?)			; root_dir_cache
_BSS	ENDS
CONST	SEGMENT
$SG3513	DB	'FAT32 BOOT PARAMETER BLOCK', 0aH, 00H
$SG3524	DB	'%c', 00H
	ORG $+1
$SG3514	DB	'Bytes/Sector -> %d', 0aH, 00H
$SG3529	DB	'%c', 00H
	ORG $+1
$SG3515	DB	'Sectors/Cluster -> %d', 0aH, 00H
	ORG $+1
$SG3516	DB	'Reserved Sectors -> %d', 0aH, 00H
$SG3517	DB	'Number Of FATs -> %d', 0aH, 00H
	ORG $+2
$SG3518	DB	'Root Base Cluster -> %d', 0aH, 00H
	ORG $+3
$SG3884	DB	'/', 00H
	ORG $+2
$SG3519	DB	'Sector/FAT32 -> %d', 0aH, 00H
$SG3885	DB	'/', 00H
	ORG $+2
$SG3634	DB	'%s             %d bytes', 0aH, 00H
	ORG $+7
$SG3642	DB	'%s             %d bytes', 0aH, 00H
	ORG $+7
$SG3769	DB	'Root Dir entries scanning', 0aH, 00H
	ORG $+5
$SG3784	DB	'Other file size -> %s, dirent attrib -> %x, count ->%d', 0aH
	DB	00H
$SG3866	DB	'Empty entry found', 0aH, 00H
	ORG $+5
$SG3886	DB	'File System registered', 0aH, 00H
CONST	ENDS
PUBLIC	?initialize_fat32@@YAXXZ			; initialize_fat32
PUBLIC	?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z	; fat32_open
PUBLIC	?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z	; fat32_read_file
PUBLIC	?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z		; fat32_read
PUBLIC	?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z	; fat32_locate_dir
PUBLIC	?list_fat_entries@@YAXXZ			; list_fat_entries
PUBLIC	?fat32_create_file@@YAIPEADPEAEI@Z		; fat32_create_file
PUBLIC	?create_dir@@YAXPEBD@Z				; create_dir
PUBLIC	?fat32_self_register@@YAXXZ			; fat32_self_register
PUBLIC	?fat32_list_files@@YAXXZ			; fat32_list_files
PUBLIC	?cluster_to_sector32@@YA_K_K@Z			; cluster_to_sector32
PUBLIC	?to_dos_file_name32@@YAXPEBDPEADI@Z		; to_dos_file_name32
PUBLIC	?fat32_read_fat@@YAII@Z				; fat32_read_fat
PUBLIC	?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z ; fat32_locate_subdir
PUBLIC	?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z	; convert_fat83_32
PUBLIC	?find_free_cluster@@YAIXZ			; find_free_cluster
PUBLIC	?alloc_cluster@@YAIHI@Z				; alloc_cluster
PUBLIC	?find_cluster@@YAII@Z				; find_cluster
PUBLIC	?get_cluster@@YAII@Z				; get_cluster
PUBLIC	?format_fat83_32@@YAXPEADQEAD0@Z		; format_fat83_32
PUBLIC	?fat32_write_content@@YAXPEAEII@Z		; fat32_write_content
EXTRN	?strcmp@@YAHPEBD0@Z:PROC			; strcmp
EXTRN	?strcpy@@YAPEADPEADPEBD@Z:PROC			; strcpy
EXTRN	?strlen@@YA_KPEBD@Z:PROC			; strlen
EXTRN	?strchr@@YAPEADPEADH@Z:PROC			; strchr
EXTRN	?memset@@YAXPEAXEI@Z:PROC			; memset
EXTRN	memcpy:PROC
EXTRN	?vfs_mount@@YAXPEADPEAU_vfs_node_@@@Z:PROC	; vfs_mount
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
EXTRN	?ata_read_28@@YAEIGPEAE@Z:PROC			; ata_read_28
EXTRN	?ata_write_one@@YAEPEAEI@Z:PROC			; ata_write_one
EXTRN	?pmmngr_alloc@@YAPEAXXZ:PROC			; pmmngr_alloc
EXTRN	?pmmngr_free@@YAXPEAX@Z:PROC			; pmmngr_free
EXTRN	?malloc@@YAPEAX_K@Z:PROC			; malloc
EXTRN	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z:PROC ; ahci_disk_read
EXTRN	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ:PROC	; ahci_disk_get_port
pdata	SEGMENT
$pdata$?initialize_fat32@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+493
	DD	imagerel $unwind$?initialize_fat32@@YAXXZ
$pdata$?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z DD imagerel $LN17
	DD	imagerel $LN17+742
	DD	imagerel $unwind$?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z
$pdata$?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z
$pdata$?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z DD imagerel $LN5
	DD	imagerel $LN5+145
	DD	imagerel $unwind$?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z
$pdata$?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+513
	DD	imagerel $unwind$?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z
$pdata$?list_fat_entries@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+202
	DD	imagerel $unwind$?list_fat_entries@@YAXXZ
$pdata$?fat32_create_file@@YAIPEADPEAEI@Z DD imagerel $LN18
	DD	imagerel $LN18+704
	DD	imagerel $unwind$?fat32_create_file@@YAIPEADPEAEI@Z
$pdata$?create_dir@@YAXPEBD@Z DD imagerel $LN14
	DD	imagerel $LN14+921
	DD	imagerel $unwind$?create_dir@@YAXPEBD@Z
$pdata$?fat32_self_register@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+219
	DD	imagerel $unwind$?fat32_self_register@@YAXXZ
$pdata$?fat32_list_files@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+349
	DD	imagerel $unwind$?fat32_list_files@@YAXXZ
$pdata$?to_dos_file_name32@@YAXPEBDPEADI@Z DD imagerel $LN23
	DD	imagerel $LN23+511
	DD	imagerel $unwind$?to_dos_file_name32@@YAXPEBDPEADI@Z
$pdata$?fat32_read_fat@@YAII@Z DD imagerel $LN3
	DD	imagerel $LN3+184
	DD	imagerel $unwind$?fat32_read_fat@@YAII@Z
$pdata$?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+418
	DD	imagerel $unwind$?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z
$pdata$?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z DD imagerel $LN8
	DD	imagerel $LN8+268
	DD	imagerel $unwind$?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z
$pdata$?clear_cluster@@YAXI@Z DD imagerel ?clear_cluster@@YAXI@Z
	DD	imagerel ?clear_cluster@@YAXI@Z+144
	DD	imagerel $unwind$?clear_cluster@@YAXI@Z
$pdata$?find_free_cluster@@YAIXZ DD imagerel $LN7
	DD	imagerel $LN7+191
	DD	imagerel $unwind$?find_free_cluster@@YAIXZ
$pdata$?alloc_cluster@@YAIHI@Z DD imagerel $LN3
	DD	imagerel $LN3+205
	DD	imagerel $unwind$?alloc_cluster@@YAIHI@Z
$pdata$?find_cluster@@YAII@Z DD imagerel $LN3
	DD	imagerel $LN3+135
	DD	imagerel $unwind$?find_cluster@@YAII@Z
$pdata$?get_cluster@@YAII@Z DD imagerel $LN3
	DD	imagerel $LN3+135
	DD	imagerel $unwind$?get_cluster@@YAII@Z
$pdata$?format_fat83_32@@YAXPEADQEAD0@Z DD imagerel $LN8
	DD	imagerel $LN8+269
	DD	imagerel $unwind$?format_fat83_32@@YAXPEADQEAD0@Z
$pdata$?fat32_write_content@@YAXPEAEII@Z DD imagerel $LN15
	DD	imagerel $LN15+371
	DD	imagerel $unwind$?fat32_write_content@@YAXPEAEII@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?initialize_fat32@@YAXXZ DD 010401H
	DD	08204H
$unwind$?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z DD 041801H
	DD	0910118H
	DD	060107011H
$unwind$?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z DD 011301H
	DD	06213H
$unwind$?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z DD 010e01H
	DD	0620eH
$unwind$?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z DD 041301H
	DD	01b0113H
	DD	0600b700cH
$unwind$?list_fat_entries@@YAXXZ DD 020701H
	DD	04b0107H
$unwind$?fat32_create_file@@YAIPEADPEAEI@Z DD 021601H
	DD	04f0116H
$unwind$?create_dir@@YAXPEBD@Z DD 020c01H
	DD	04f010cH
$unwind$?fat32_self_register@@YAXXZ DD 010401H
	DD	06204H
$unwind$?fat32_list_files@@YAXXZ DD 020701H
	DD	0150107H
$unwind$?to_dos_file_name32@@YAXPEBDPEADI@Z DD 011301H
	DD	08213H
$unwind$?fat32_read_fat@@YAII@Z DD 010801H
	DD	0a208H
$unwind$?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z DD 041801H
	DD	01b0118H
	DD	060107011H
$unwind$?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z DD 010e01H
	DD	0420eH
$unwind$?clear_cluster@@YAXI@Z DD 010801H
	DD	06208H
$unwind$?find_free_cluster@@YAIXZ DD 010401H
	DD	0a204H
$unwind$?alloc_cluster@@YAIHI@Z DD 010c01H
	DD	0a20cH
$unwind$?find_cluster@@YAII@Z DD 010801H
	DD	08208H
$unwind$?get_cluster@@YAII@Z DD 010801H
	DD	08208H
$unwind$?format_fat83_32@@YAXPEADQEAD0@Z DD 011301H
	DD	04213H
$unwind$?fat32_write_content@@YAXPEAEII@Z DD 011201H
	DD	08212H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
parse_fat$ = 32
i$1 = 36
i$2 = 40
k$3 = 44
cluster_value$4 = 48
num_cluster$ = 52
sector_first$ = 56
sector$5 = 60
buffer$ = 80
first_cluster$ = 88
length$ = 96
?fat32_write_content@@YAXPEAEII@Z PROC			; fat32_write_content

; 589  : void fat32_write_content (uint8_t *buffer, uint32_t first_cluster, unsigned int length) {

$LN15:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 590  : 	bool parse_fat = false;

	mov	BYTE PTR parse_fat$[rsp], 0

; 591  : 	uint32_t num_cluster = 0;

	mov	DWORD PTR num_cluster$[rsp], 0

; 592  : 	uint32_t sector_first = cluster_to_sector32 (first_cluster);

	mov	eax, DWORD PTR first_cluster$[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR sector_first$[rsp], eax

; 593  : 	for (int i = 0; i < sectors_per_cluster; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN12@fat32_writ
$LN11@fat32_writ:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN12@fat32_writ:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN10@fat32_writ

; 594  : 		ata_write_one (buffer + (i * 512), sector_first + i);

	mov	eax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR sector_first$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR i$1[rsp]
	imul	ecx, 512				; 00000200H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR buffer$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 595  : 	}

	jmp	SHORT $LN11@fat32_writ
$LN10@fat32_writ:

; 596  : 	buffer += 4096;

	mov	rax, QWORD PTR buffer$[rsp]
	add	rax, 4096				; 00001000H
	mov	QWORD PTR buffer$[rsp], rax

; 597  : 
; 598  : 	if (length > 4096) {

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jbe	SHORT $LN9@fat32_writ

; 599  : 		parse_fat = true;

	mov	BYTE PTR parse_fat$[rsp], 1

; 600  : 		num_cluster = length / 4096;

	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	mov	DWORD PTR num_cluster$[rsp], eax
$LN9@fat32_writ:

; 601  : 	}
; 602  : 
; 603  : 	if (parse_fat) {

	movzx	eax, BYTE PTR parse_fat$[rsp]
	test	eax, eax
	je	$LN8@fat32_writ

; 604  : 		for (int k = 0; k < num_cluster; k++) {

	mov	DWORD PTR k$3[rsp], 0
	jmp	SHORT $LN7@fat32_writ
$LN6@fat32_writ:
	mov	eax, DWORD PTR k$3[rsp]
	inc	eax
	mov	DWORD PTR k$3[rsp], eax
$LN7@fat32_writ:
	mov	eax, DWORD PTR num_cluster$[rsp]
	cmp	DWORD PTR k$3[rsp], eax
	jae	$LN5@fat32_writ

; 605  : 			uint32_t cluster_value = get_cluster (first_cluster);

	mov	ecx, DWORD PTR first_cluster$[rsp]
	call	?get_cluster@@YAII@Z			; get_cluster
	mov	DWORD PTR cluster_value$4[rsp], eax

; 606  : 			if (cluster_value >= 0x0FFFFFF8)

	cmp	DWORD PTR cluster_value$4[rsp], 268435448 ; 0ffffff8H
	jb	SHORT $LN4@fat32_writ

; 607  : 				return;

	jmp	SHORT $LN13@fat32_writ
$LN4@fat32_writ:

; 608  : 			uint32_t sector = cluster_to_sector32 (cluster_value);

	mov	eax, DWORD PTR cluster_value$4[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR sector$5[rsp], eax

; 609  : 			for (int i = 0; i < sectors_per_cluster; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@fat32_writ
$LN2@fat32_writ:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@fat32_writ:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR i$2[rsp], eax
	jge	SHORT $LN1@fat32_writ

; 610  : 				ata_write_one (buffer + (i * 512), sector + i);

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR sector$5[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR i$2[rsp]
	imul	ecx, 512				; 00000200H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR buffer$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 611  : 			}

	jmp	SHORT $LN2@fat32_writ
$LN1@fat32_writ:

; 612  : 			buffer += 4096;

	mov	rax, QWORD PTR buffer$[rsp]
	add	rax, 4096				; 00001000H
	mov	QWORD PTR buffer$[rsp], rax

; 613  : 			first_cluster = cluster_value;

	mov	eax, DWORD PTR cluster_value$4[rsp]
	mov	DWORD PTR first_cluster$[rsp], eax

; 614  : 		}

	jmp	$LN6@fat32_writ
$LN5@fat32_writ:
$LN8@fat32_writ:
$LN13@fat32_writ:

; 615  : 	}
; 616  : }

	add	rsp, 72					; 00000048H
	ret	0
?fat32_write_content@@YAXPEAEII@Z ENDP			; fat32_write_content
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$ = 0
f$ = 8
p$ = 16
string_to_format$ = 48
ext$ = 56
filename$ = 64
?format_fat83_32@@YAXPEADQEAD0@Z PROC			; format_fat83_32

; 532  : {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 533  : 	char *p;
; 534  : 	char *f = filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR f$[rsp], rax

; 535  : 	int i;
; 536  : 
; 537  : 	p = string_to_format;

	mov	rax, QWORD PTR string_to_format$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 538  : 	i = 8;

	mov	DWORD PTR i$[rsp], 8
$LN5@format_fat:

; 539  : 	while ((*p != 0x20) && i)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN4@format_fat
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN4@format_fat

; 540  : 	{
; 541  : 		*f++ = *p++;

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 542  : 		i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 543  : 	}

	jmp	SHORT $LN5@format_fat
$LN4@format_fat:

; 544  : 
; 545  : 	*f++ = '.';

	mov	rax, QWORD PTR f$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax

; 546  : 
; 547  : 	p = (char*)ext;

	mov	rax, QWORD PTR ext$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 548  : 	i = 3;

	mov	DWORD PTR i$[rsp], 3
$LN3@format_fat:

; 549  : 	while ((*p != 0x20) && i)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN2@format_fat
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN2@format_fat

; 550  : 	{
; 551  : 		*f++ = *p++;

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 552  : 		i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 553  : 	}

	jmp	SHORT $LN3@format_fat
$LN2@format_fat:

; 554  : 
; 555  : 	if (i == 3)

	cmp	DWORD PTR i$[rsp], 3
	jne	SHORT $LN1@format_fat

; 556  : 		f--;

	mov	rax, QWORD PTR f$[rsp]
	dec	rax
	mov	QWORD PTR f$[rsp], rax
$LN1@format_fat:

; 557  : 
; 558  : 	*f++ = '\0';

	mov	rax, QWORD PTR f$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax

; 559  : }

	add	rsp, 40					; 00000028H
	ret	0
?format_fat83_32@@YAXPEADQEAD0@Z ENDP			; format_fat83_32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
buf$ = 40
fat_sector$ = 48
ent_offset$ = 56
cluster$ = 80
?get_cluster@@YAII@Z PROC				; get_cluster

; 520  : uint32_t get_cluster (uint32_t cluster) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 521  : 	auto fat_offset = cluster * 4;

	mov	eax, DWORD PTR cluster$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 522  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 523  : 	size_t ent_offset = fat_offset  % 512;

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	mov	eax, eax
	mov	QWORD PTR ent_offset$[rsp], rax

; 524  : 	unsigned char *buf = (unsigned char*)malloc(512);

	mov	ecx, 512				; 00000200H
	call	?malloc@@YAPEAX_K@Z			; malloc
	mov	QWORD PTR buf$[rsp], rax

; 525  : 	ata_read_28 (fat_sector,1,buf);

	mov	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, DWORD PTR fat_sector$[rsp]
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 526  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];		

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 527  : 	return value;

	mov	eax, DWORD PTR value$[rsp]

; 528  : }

	add	rsp, 72					; 00000048H
	ret	0
?get_cluster@@YAII@Z ENDP				; get_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
buf$ = 40
fat_sector$ = 48
ent_offset$ = 56
new_cluster$ = 80
?find_cluster@@YAII@Z PROC				; find_cluster

; 509  : uint32_t find_cluster (uint32_t new_cluster) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 510  : 	auto fat_offset = new_cluster * 4;

	mov	eax, DWORD PTR new_cluster$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 511  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 512  : 	size_t ent_offset = fat_offset  % 512;

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	mov	eax, eax
	mov	QWORD PTR ent_offset$[rsp], rax

; 513  : 	unsigned char *buf = (unsigned char*)malloc(512);

	mov	ecx, 512				; 00000200H
	call	?malloc@@YAPEAX_K@Z			; malloc
	mov	QWORD PTR buf$[rsp], rax

; 514  : 	ata_read_28 (fat_sector,1,buf);

	mov	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, DWORD PTR fat_sector$[rsp]
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 515  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];		

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 516  : 	return value;

	mov	eax, DWORD PTR value$[rsp]

; 517  : }

	add	rsp, 72					; 00000048H
	ret	0
?find_cluster@@YAII@Z ENDP				; find_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value2$ = 36
value$ = 40
buf$ = 48
ent_offset$ = 56
fat_sector$ = 64
position$ = 96
n_value$ = 104
?alloc_cluster@@YAIHI@Z PROC				; alloc_cluster

; 493  : uint32_t alloc_cluster (int position, uint32_t n_value) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 494  : 	auto fat_offset = position * 4;

	mov	eax, DWORD PTR position$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 495  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	mov	eax, DWORD PTR fat_offset$[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 496  : 	size_t ent_offset = fat_offset  % 512;

	mov	eax, DWORD PTR fat_offset$[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	and	eax, 511				; 000001ffH
	sub	eax, edx
	cdqe
	mov	QWORD PTR ent_offset$[rsp], rax

; 497  : 	unsigned char *buf = (unsigned char*)malloc(512);

	mov	ecx, 512				; 00000200H
	call	?malloc@@YAPEAX_K@Z			; malloc
	mov	QWORD PTR buf$[rsp], rax

; 498  : 	ata_read_28 (fat_sector,1,buf);

	mov	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, DWORD PTR fat_sector$[rsp]
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 499  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 500  : 		
; 501  : 	*(uint32_t*)&buf[ent_offset] = n_value;// & 0x0FFFFFFF;

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR n_value$[rsp]
	mov	DWORD PTR [rax], ecx

; 502  : 	ata_write_one (buf,fat_sector);

	mov	edx, DWORD PTR fat_sector$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 503  : 	uint32_t value2 = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value2$[rsp], eax

; 504  : 	return value2;

	mov	eax, DWORD PTR value2$[rsp]

; 505  : }

	add	rsp, 88					; 00000058H
	ret	0
?alloc_cluster@@YAIHI@Z ENDP				; alloc_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
fat_offset$2 = 36
value$3 = 40
buf$4 = 48
fat_sector$5 = 56
ent_offset$6 = 64
?find_free_cluster@@YAIXZ PROC				; find_free_cluster

; 473  : uint32_t find_free_cluster () {

$LN7:
	sub	rsp, 88					; 00000058H

; 474  : 	//!iterate through every sectors in fat32 table
; 475  : 	for (int i = 2; i < total_clusters; i++) {

	mov	DWORD PTR i$1[rsp], 2
	jmp	SHORT $LN4@find_free_
$LN3@find_free_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@find_free_:
	mov	eax, DWORD PTR ?total_clusters@@3IA	; total_clusters
	cmp	DWORD PTR i$1[rsp], eax
	jae	$LN2@find_free_

; 476  : 		auto fat_offset = i * 4;

	mov	eax, DWORD PTR i$1[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$2[rsp], eax

; 477  : 		uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	mov	eax, DWORD PTR fat_offset$2[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$5[rsp], rax

; 478  : 		size_t ent_offset = fat_offset  % 512;

	mov	eax, DWORD PTR fat_offset$2[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	and	eax, 511				; 000001ffH
	sub	eax, edx
	cdqe
	mov	QWORD PTR ent_offset$6[rsp], rax

; 479  : 		unsigned char *buf = (unsigned char*)malloc(512);

	mov	ecx, 512				; 00000200H
	call	?malloc@@YAPEAX_K@Z			; malloc
	mov	QWORD PTR buf$4[rsp], rax

; 480  : 		ata_read_28 (fat_sector,1,buf);

	mov	r8, QWORD PTR buf$4[rsp]
	mov	dx, 1
	mov	ecx, DWORD PTR fat_sector$5[rsp]
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 481  : 		uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$6[rsp]
	mov	rcx, QWORD PTR buf$4[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$3[rsp], eax

; 482  : 		
; 483  : 		//! Found a free cluster return the value
; 484  : 		if (value == 0x0) {

	cmp	DWORD PTR value$3[rsp], 0
	jne	SHORT $LN1@find_free_

; 485  : 			return i;

	mov	eax, DWORD PTR i$1[rsp]
	jmp	SHORT $LN5@find_free_
$LN1@find_free_:

; 486  : 		}
; 487  : 	}

	jmp	$LN3@find_free_
$LN2@find_free_:

; 488  : 
; 489  : 	return 0;

	xor	eax, eax
$LN5@find_free_:

; 490  : }

	add	rsp, 88					; 00000058H
	ret	0
?find_free_cluster@@YAIXZ ENDP				; find_free_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
sector$ = 36
buffer$ = 40
cluster$ = 64
?clear_cluster@@YAXI@Z PROC				; clear_cluster

; 460  : static void clear_cluster (uint32_t cluster) {

	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 461  : 	uint8_t *buffer = (uint8_t*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buffer$[rsp], rax

; 462  : 	memset (buffer, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 463  : 	//update_cluster (buffer,cluster);
; 464  : 	uint32_t sector = cluster_to_sector32 (cluster);

	mov	eax, DWORD PTR cluster$[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR sector$[rsp], eax

; 465  : 	for (int i = 0; i < sectors_per_cluster; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@clear_clus
$LN2@clear_clus:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@clear_clus:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN1@clear_clus

; 466  : 		ata_write_one(buffer + (i*512),sector + i);

	mov	eax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR sector$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR i$1[rsp]
	imul	ecx, 512				; 00000200H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR buffer$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 467  : 	}

	jmp	SHORT $LN2@clear_clus
$LN1@clear_clus:

; 468  : 	pmmngr_free (buffer);

	mov	rcx, QWORD PTR buffer$[rsp]
	call	?pmmngr_free@@YAXPEAX@Z			; pmmngr_free

; 469  : }

	add	rsp, 56					; 00000038H
	ret	0
?clear_cluster@@YAXI@Z ENDP				; clear_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$ = 0
f$ = 8
p$ = 16
root$ = 48
filename$ = 56
?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z PROC	; convert_fat83_32

; 300  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 301  : 	char *p;
; 302  : 	char *f = filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR f$[rsp], rax

; 303  : 	int i;
; 304  : 
; 305  : 	p = (char*)root->filename;

	mov	rax, QWORD PTR root$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 306  : 	i = 8;

	mov	DWORD PTR i$[rsp], 8
$LN5@convert_fa:

; 307  : 	while ((*p != 0x20) && i)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN4@convert_fa
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN4@convert_fa

; 308  : 	{
; 309  : 		*f++ = *p++;

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 310  : 		i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 311  : 	}

	jmp	SHORT $LN5@convert_fa
$LN4@convert_fa:

; 312  : 
; 313  : 	*f++ = '.';

	mov	rax, QWORD PTR f$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax

; 314  : 
; 315  : 	p = (char*)root->ext;

	mov	rax, QWORD PTR root$[rsp]
	add	rax, 8
	mov	QWORD PTR p$[rsp], rax

; 316  : 	i = 3;

	mov	DWORD PTR i$[rsp], 3
$LN3@convert_fa:

; 317  : 	while ((*p != 0x20) && i)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN2@convert_fa
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN2@convert_fa

; 318  : 	{
; 319  : 		*f++ = *p++;

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 320  : 		i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 321  : 	}

	jmp	SHORT $LN3@convert_fa
$LN2@convert_fa:

; 322  : 
; 323  : 	if (i == 3)

	cmp	DWORD PTR i$[rsp], 3
	jne	SHORT $LN1@convert_fa

; 324  : 		f--;

	mov	rax, QWORD PTR f$[rsp]
	dec	rax
	mov	QWORD PTR f$[rsp], rax
$LN1@convert_fa:

; 325  : 
; 326  : 	*f++ = '\0';

	mov	rax, QWORD PTR f$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax

; 327  : }

	add	rsp, 40					; 00000028H
	ret	0
?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z ENDP	; convert_fat83_32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
pkDir$2 = 40
buf$ = 48
name$3 = 56
dos_file_name$ = 72
file$ = 96
$T4 = 240
kfile$ = 248
filename$ = 256
?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z PROC	; fat32_locate_subdir

; 241  : vfs_node_t fat32_locate_subdir (vfs_node_t kfile, const char* filename) {

$LN12:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 216				; 000000d8H

; 242  : 
; 243  : 	vfs_node_t file;
; 244  : 
; 245  : 	char dos_file_name[11];
; 246  : 	to_dos_file_name32 (filename, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?to_dos_file_name32@@YAXPEBDPEADI@Z	; to_dos_file_name32

; 247  : 	//dos_file_name[11] = 0;
; 248  : 	uint64_t* buf = (uint64_t*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buf$[rsp], rax

; 249  : 	if (kfile.flags != FS_FLAG_INVALID) {

	mov	rax, QWORD PTR kfile$[rsp]
	cmp	DWORD PTR [rax+48], 3
	je	$LN9@fat32_loca
$LN8@fat32_loca:

; 250  : 		
; 251  : 		//! read the directory
; 252  : 		while (!kfile.eof) {

	mov	rax, QWORD PTR kfile$[rsp]
	cmp	DWORD PTR [rax+36], 0
	jne	$LN7@fat32_loca

; 253  : 
; 254  : 			//! read 
; 255  : 		
; 256  : 			fat32_read (&kfile, buf);

	mov	rdx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR kfile$[rsp]
	call	?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z	; fat32_read

; 257  : 			//! set directory
; 258  : 			fat32_dir* pkDir = (fat32_dir*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR pkDir$2[rsp], rax

; 259  : 
; 260  : 			//! 16 entries
; 261  : 			for (unsigned int i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@fat32_loca
$LN5@fat32_loca:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@fat32_loca:
	cmp	DWORD PTR i$1[rsp], 16
	jae	$LN4@fat32_loca

; 262  : 
; 263  : 				//! get current filename;
; 264  : 				char name[11];
; 265  : 				memcpy (name, pkDir->filename, 11);

	mov	rax, QWORD PTR pkDir$2[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rsp]
	call	memcpy

; 266  : 				//name[11] = 0;
; 267  : 
; 268  : 				if (strcmp (name, dos_file_name) == 0) {

	lea	rdx, QWORD PTR dos_file_name$[rsp]
	lea	rcx, QWORD PTR name$3[rsp]
	call	?strcmp@@YAHPEBD0@Z			; strcmp
	test	eax, eax
	jne	$LN3@fat32_loca

; 269  : 
; 270  : 					//! found file
; 271  : 					strcpy (file.filename, filename);

	mov	rdx, QWORD PTR filename$[rsp]
	lea	rcx, QWORD PTR file$[rsp]
	call	?strcpy@@YAPEADPEADPEBD@Z		; strcpy

; 272  : 					file.current = pkDir->first_cluster;

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	DWORD PTR file$[rsp+44], eax

; 273  : 					file.size = pkDir->file_size;

	mov	rax, QWORD PTR pkDir$2[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR file$[rsp+32], eax

; 274  : 					file.eof = 0;

	mov	DWORD PTR file$[rsp+36], 0

; 275  : 					file.status = FS_STATUS_FOUND;

	mov	DWORD PTR file$[rsp+52], 4

; 276  : 					//! set file type
; 277  : 					if (pkDir->attrib == 0x10)

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	eax, 16
	jne	SHORT $LN2@fat32_loca

; 278  : 						file.flags = FS_FLAG_DIRECTORY;

	mov	DWORD PTR file$[rsp+48], 1

; 279  : 					else

	jmp	SHORT $LN1@fat32_loca
$LN2@fat32_loca:

; 280  : 						file.flags = FS_FLAG_GENERAL;

	mov	DWORD PTR file$[rsp+48], 2
$LN1@fat32_loca:

; 281  : 
; 282  : 					//!return file
; 283  : 					return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T4[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T4[rsp]
	jmp	SHORT $LN10@fat32_loca
$LN3@fat32_loca:

; 284  : 				}
; 285  : 
; 286  : 				//! go to next entry
; 287  : 				pkDir++;

	mov	rax, QWORD PTR pkDir$2[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR pkDir$2[rsp], rax

; 288  : 			}

	jmp	$LN5@fat32_loca
$LN4@fat32_loca:

; 289  : 
; 290  : 			//pmmngr_free (buf);
; 291  : 		}

	jmp	$LN8@fat32_loca
$LN7@fat32_loca:
$LN9@fat32_loca:

; 292  : 	}
; 293  : 
; 294  : 	file.flags = FS_FLAG_INVALID;

	mov	DWORD PTR file$[rsp+48], 3

; 295  : 	return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T4[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T4[rsp]
$LN10@fat32_loca:

; 296  : }

	add	rsp, 216				; 000000d8H
	pop	rdi
	pop	rsi
	ret	0
?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z ENDP	; fat32_locate_subdir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
buf_area$ = 40
fat_sector$ = 48
ent_offset$ = 56
buf$ = 64
cluster_index$ = 96
?fat32_read_fat@@YAII@Z PROC				; fat32_read_fat

; 138  : uint32_t fat32_read_fat (uint32_t cluster_index) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 139  : 	auto fat_offset = cluster_index * 4;

	mov	eax, DWORD PTR cluster_index$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 140  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 141  : 	size_t ent_offset = fat_offset  % 512;

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	mov	eax, eax
	mov	QWORD PTR ent_offset$[rsp], rax

; 142  : 	uint64_t *buf_area = (uint64_t*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buf_area$[rsp], rax

; 143  : 	memset(buf_area,0,4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf_area$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 144  : 	//ata_read_28 (fat_sector,1,buf);
; 145  : 	ahci_disk_read (ahci_disk_get_port(),fat_sector,1,buf_area);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buf_area$[rsp]
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 146  : 	unsigned char *buf = (unsigned char*)buf_area;

	mov	rax, QWORD PTR buf_area$[rsp]
	mov	QWORD PTR buf$[rsp], rax

; 147  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 148  : 	pmmngr_free(buf_area);

	mov	rcx, QWORD PTR buf_area$[rsp]
	call	?pmmngr_free@@YAXPEAX@Z			; pmmngr_free

; 149  : 	return value & 0x0FFFFFFF;

	mov	eax, DWORD PTR value$[rsp]
	and	eax, 268435455				; 0fffffffH

; 150  : }

	add	rsp, 88					; 00000058H
	ret	0
?fat32_read_fat@@YAII@Z ENDP				; fat32_read_fat
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$ = 32
k$1 = 36
tv132 = 40
tv179 = 44
tv71 = 48
filename$ = 80
fname$ = 88
fname_length$ = 96
?to_dos_file_name32@@YAXPEBDPEADI@Z PROC		; to_dos_file_name32

; 48   : {

$LN23:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 49   : 	unsigned int i=0;

	mov	DWORD PTR i$[rsp], 0

; 50   : 
; 51   : 	if (fname_length > 11)

	cmp	DWORD PTR fname_length$[rsp], 11
	jbe	SHORT $LN16@to_dos_fil

; 52   : 		return;

	jmp	$LN17@to_dos_fil
$LN16@to_dos_fil:

; 53   : 
; 54   : 	if (!fname || !filename)

	cmp	QWORD PTR fname$[rsp], 0
	je	SHORT $LN14@to_dos_fil
	cmp	QWORD PTR filename$[rsp], 0
	jne	SHORT $LN15@to_dos_fil
$LN14@to_dos_fil:

; 55   : 		return;

	jmp	$LN17@to_dos_fil
$LN15@to_dos_fil:

; 56   : 
; 57   : 	memset (fname, ' ', fname_length);

	mov	r8d, DWORD PTR fname_length$[rsp]
	mov	dl, 32					; 00000020H
	mov	rcx, QWORD PTR fname$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 58   : 
; 59   : 	for (i=0; i < strlen (filename)-1 && i < fname_length; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN13@to_dos_fil
$LN12@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN13@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	mov	QWORD PTR tv71[rsp], rax
	mov	rcx, QWORD PTR filename$[rsp]
	call	?strlen@@YA_KPEBD@Z			; strlen
	dec	rax
	mov	rcx, QWORD PTR tv71[rsp]
	cmp	rcx, rax
	jae	$LN11@to_dos_fil
	mov	eax, DWORD PTR fname_length$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN11@to_dos_fil

; 60   : 	{
; 61   : 		if (filename[i] == '.' || i==8)

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN9@to_dos_fil
	cmp	DWORD PTR i$[rsp], 8
	jne	SHORT $LN10@to_dos_fil
$LN9@to_dos_fil:

; 62   : 			break;

	jmp	SHORT $LN11@to_dos_fil
$LN10@to_dos_fil:

; 63   : 
; 64   : 		fname[i] = toupper (filename[i]);

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN19@to_dos_fil
	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN19@to_dos_fil
	mov	DWORD PTR tv132[rsp], 1
	jmp	SHORT $LN20@to_dos_fil
$LN19@to_dos_fil:
	mov	DWORD PTR tv132[rsp], 0
$LN20@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR tv132[rsp]
	imul	ecx, 32					; 00000020H
	sub	eax, ecx
	mov	ecx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR fname$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 65   : 	}

	jmp	$LN12@to_dos_fil
$LN11@to_dos_fil:

; 66   : 
; 67   : 	if (filename[i] =='.')

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN8@to_dos_fil

; 68   : 	{
; 69   : 		for (int k=0; k < 3; k++)

	mov	DWORD PTR k$1[rsp], 0
	jmp	SHORT $LN7@to_dos_fil
$LN6@to_dos_fil:
	mov	eax, DWORD PTR k$1[rsp]
	inc	eax
	mov	DWORD PTR k$1[rsp], eax
$LN7@to_dos_fil:
	cmp	DWORD PTR k$1[rsp], 3
	jge	SHORT $LN5@to_dos_fil

; 70   : 		{
; 71   : 			 ++i;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 72   : 			 if (filename[i])

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN4@to_dos_fil

; 73   : 				 fname[8+k] = filename[i];

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR k$1[rsp]
	add	ecx, 8
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR fname$[rsp]
	mov	r8, QWORD PTR filename$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
$LN4@to_dos_fil:

; 74   : 		}

	jmp	SHORT $LN6@to_dos_fil
$LN5@to_dos_fil:
$LN8@to_dos_fil:

; 75   : 	}
; 76   : 
; 77   : 	for (i = 0; i < 3; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN3@to_dos_fil
$LN2@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN3@to_dos_fil:
	cmp	DWORD PTR i$[rsp], 3
	jae	SHORT $LN1@to_dos_fil

; 78   : 		fname[8+i] = toupper (fname[8+i]);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 8
	mov	eax, eax
	mov	rcx, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN21@to_dos_fil
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 8
	mov	eax, eax
	mov	rcx, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN21@to_dos_fil
	mov	DWORD PTR tv179[rsp], 1
	jmp	SHORT $LN22@to_dos_fil
$LN21@to_dos_fil:
	mov	DWORD PTR tv179[rsp], 0
$LN22@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 8
	mov	eax, eax
	mov	rcx, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR tv179[rsp]
	imul	ecx, 32					; 00000020H
	sub	eax, ecx
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, 8
	mov	ecx, ecx
	mov	rdx, QWORD PTR fname$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN2@to_dos_fil
$LN1@to_dos_fil:
$LN17@to_dos_fil:

; 79   : }

	add	rsp, 72					; 00000048H
	ret	0
?to_dos_file_name32@@YAXPEBDPEADI@Z ENDP		; to_dos_file_name32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
cluster$ = 8
?cluster_to_sector32@@YA_K_K@Z PROC			; cluster_to_sector32

; 41   : {

	mov	QWORD PTR [rsp+8], rcx

; 42   : 	return cluster_begin_lba + (cluster - 2) * sectors_per_cluster ;

	mov	eax, DWORD PTR ?cluster_begin_lba@@3KA	; cluster_begin_lba
	mov	rcx, QWORD PTR cluster$[rsp]
	sub	rcx, 2
	movzx	edx, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	imul	rcx, rdx
	add	rax, rcx

; 43   : }

	ret	0
?cluster_to_sector32@@YA_K_K@Z ENDP			; cluster_to_sector32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
dir$ = 40
dir2$ = 48
buf$ = 56
buf2$ = 64
tv81 = 72
tv74 = 80
filename$ = 88
filename2$ = 120
?fat32_list_files@@YAXXZ PROC				; fat32_list_files

; 329  : void fat32_list_files() {

$LN9:
	sub	rsp, 168				; 000000a8H

; 330  : 	uint64_t *buf = (uint64_t*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buf$[rsp], rax

; 331  : 	uint64_t *buf2 = (uint64_t*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buf2$[rsp], rax

; 332  : 	memset(buf, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 333  : 	memset(buf2, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf2$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 334  : 	char filename[32];
; 335  : 	//ata_read_28(root_sector, 1, buf);
; 336  : 	//ata_read_28(root_sector + 1, 1, buf2);
; 337  : 	ahci_disk_read(ahci_disk_get_port(),root_sector, 1, buf);

	mov	eax, DWORD PTR ?root_sector@@3KA	; root_sector
	mov	QWORD PTR tv74[rsp], rax
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buf$[rsp]
	mov	r8d, 1
	mov	rcx, QWORD PTR tv74[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 338  : 	ahci_disk_read(ahci_disk_get_port(), root_sector + 1, 1,buf2);

	mov	eax, DWORD PTR ?root_sector@@3KA	; root_sector
	inc	eax
	mov	eax, eax
	mov	QWORD PTR tv81[rsp], rax
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buf2$[rsp]
	mov	r8d, 1
	mov	rcx, QWORD PTR tv81[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 339  : 	fat32_dir *dir = (fat32_dir*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dir$[rsp], rax

; 340  : 	for (int i=0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN6@fat32_list
$LN5@fat32_list:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN6@fat32_list:
	cmp	DWORD PTR i$2[rsp], 16
	jge	SHORT $LN4@fat32_list

; 341  : 		convert_fat83_32(dir,filename);

	lea	rdx, QWORD PTR filename$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z ; convert_fat83_32

; 342  : 		printf ("%s             %d bytes\n",filename, dir->file_size);

	mov	rax, QWORD PTR dir$[rsp]
	mov	r8d, DWORD PTR [rax+28]
	lea	rdx, QWORD PTR filename$[rsp]
	lea	rcx, OFFSET FLAT:$SG3634
	call	?printf@@YAXPEBDZZ			; printf

; 343  : 		dir++;

	mov	rax, QWORD PTR dir$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dir$[rsp], rax

; 344  : 	}

	jmp	SHORT $LN5@fat32_list
$LN4@fat32_list:

; 345  : 
; 346  : 	char filename2[32];
; 347  : 	fat32_dir *dir2 = (fat32_dir*)buf2;

	mov	rax, QWORD PTR buf2$[rsp]
	mov	QWORD PTR dir2$[rsp], rax

; 348  : 	for (int i=0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@fat32_list
$LN2@fat32_list:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@fat32_list:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN1@fat32_list

; 349  : 		convert_fat83_32(dir2,filename2);

	lea	rdx, QWORD PTR filename2$[rsp]
	mov	rcx, QWORD PTR dir2$[rsp]
	call	?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z ; convert_fat83_32

; 350  : 		printf ("%s             %d bytes\n",filename2, dir2->file_size);

	mov	rax, QWORD PTR dir2$[rsp]
	mov	r8d, DWORD PTR [rax+28]
	lea	rdx, QWORD PTR filename2$[rsp]
	lea	rcx, OFFSET FLAT:$SG3642
	call	?printf@@YAXPEBDZZ			; printf

; 351  : 		dir2++;

	mov	rax, QWORD PTR dir2$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dir2$[rsp], rax

; 352  : 	}

	jmp	SHORT $LN2@fat32_list
$LN1@fat32_list:

; 353  : }

	add	rsp, 168				; 000000a8H
	ret	0
?fat32_list_files@@YAXXZ ENDP				; fat32_list_files
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
fsys$ = 32
?fat32_self_register@@YAXXZ PROC			; fat32_self_register

; 791  : void fat32_self_register () {

$LN3:
	sub	rsp, 56					; 00000038H

; 792  : 	vfs_node_t *fsys = (vfs_node_t*)malloc(sizeof(vfs_node_t));

	mov	ecx, 104				; 00000068H
	call	?malloc@@YAPEAX_K@Z			; malloc
	mov	QWORD PTR fsys$[rsp], rax

; 793  : 	strcpy (fsys->filename, "/");

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rdx, OFFSET FLAT:$SG3884
	mov	rcx, rax
	call	?strcpy@@YAPEADPEADPEBD@Z		; strcpy

; 794  : 	fsys->size = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+32], 0

; 795  : 	fsys->eof = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+36], 0

; 796  : 	fsys->pos = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+40], 0

; 797  : 	fsys->current = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+44], 0

; 798  : 	fsys->flags = FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+48], 1

; 799  : 	fsys->status = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+52], 0

; 800  : 	fsys->open = fat32_open;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z ; fat32_open
	mov	QWORD PTR [rax+64], rcx

; 801  : 	fsys->read = fat32_read_file;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z ; fat32_read_file
	mov	QWORD PTR [rax+72], rcx

; 802  : 	fsys->write = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+80], 0

; 803  : 	fsys->read_blk = fat32_read;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z ; fat32_read
	mov	QWORD PTR [rax+88], rcx

; 804  : 	fsys->ioquery = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+96], 0

; 805  : 	vfs_mount ("/", fsys);

	mov	rdx, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:$SG3885
	call	?vfs_mount@@YAXPEADPEAU_vfs_node_@@@Z	; vfs_mount

; 806  : 	printf ("File System registered\n");

	lea	rcx, OFFSET FLAT:$SG3886
	call	?printf@@YAXPEBDZZ			; printf

; 807  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_self_register@@YAXXZ ENDP			; fat32_self_register
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
dirent$1 = 32
first_cluster$ = 40
i$2 = 44
sector$3 = 48
dot_dot_entry$4 = 56
dot_entry$5 = 64
i$6 = 72
cluster_first$ = 76
dir_content$7 = 80
sector_d$8 = 88
status$ = 92
formated_name$ = 96
buf$ = 112
filename$ = 640
?create_dir@@YAXPEBD@Z PROC				; create_dir

; 707  : void create_dir (const char* filename) {

$LN14:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 632				; 00000278H

; 708  : 	/**
; 709  : 	 * First we scan the FAT table for free cluster which will
; 710  : 	 * be used as first cluster and store it in a temporary variable
; 711  : 	 */
; 712  : 	uint32_t first_cluster = 0;

	mov	DWORD PTR first_cluster$[rsp], 0

; 713  : 	uint32_t cluster_first = find_free_cluster ();

	call	?find_free_cluster@@YAIXZ		; find_free_cluster
	mov	DWORD PTR cluster_first$[rsp], eax

; 714  : 	first_cluster = cluster_first;

	mov	eax, DWORD PTR cluster_first$[rsp]
	mov	DWORD PTR first_cluster$[rsp], eax

; 715  : 	uint32_t status = alloc_cluster (cluster_first, 0x0FFFFFF8);

	mov	edx, 268435448				; 0ffffff8H
	mov	ecx, DWORD PTR cluster_first$[rsp]
	call	?alloc_cluster@@YAIHI@Z			; alloc_cluster
	mov	DWORD PTR status$[rsp], eax

; 716  : 
; 717  : 	//! Clear the cluster
; 718  : 	clear_cluster (cluster_first);

	mov	ecx, DWORD PTR cluster_first$[rsp]
	call	?clear_cluster@@YAXI@Z			; clear_cluster

; 719  : 
; 720  : 	char formated_name[11];
; 721  : 	to_dos_file_name32 (filename, formated_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR formated_name$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?to_dos_file_name32@@YAXPEBDPEADI@Z	; to_dos_file_name32

; 722  :     unsigned char buf[512];
; 723  : 	//! now it's time to parse the root directory
; 724  : 	//! Root Directory Entries scanning goes here
; 725  : 	for (int sector = 0; sector < sectors_per_cluster; sector++) {

	mov	DWORD PTR sector$3[rsp], 0
	jmp	SHORT $LN11@create_dir
$LN10@create_dir:
	mov	eax, DWORD PTR sector$3[rsp]
	inc	eax
	mov	DWORD PTR sector$3[rsp], eax
$LN11@create_dir:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR sector$3[rsp], eax
	jge	$LN9@create_dir

; 726  : 		
; 727  : 		ata_read_28 (root_sector + sector,1, buf);

	mov	eax, DWORD PTR sector$3[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	lea	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, eax
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 728  : 		fat32_dir *dirent = (fat32_dir*)buf;

	lea	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dirent$1[rsp], rax

; 729  : 		for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$6[rsp], 0
	jmp	SHORT $LN8@create_dir
$LN7@create_dir:
	mov	eax, DWORD PTR i$6[rsp]
	inc	eax
	mov	DWORD PTR i$6[rsp], eax
$LN8@create_dir:
	cmp	DWORD PTR i$6[rsp], 16
	jge	$LN6@create_dir

; 730  : 
; 731  : 
; 732  : 			//! scan for free directory entry
; 733  : 			if (dirent->filename[0] == 0x00 || dirent->filename[0] == 0xE5){

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN4@create_dir
	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 229				; 000000e5H
	jne	$LN5@create_dir
$LN4@create_dir:

; 734  : 				printf ("Empty entry found\n");

	lea	rcx, OFFSET FLAT:$SG3866
	call	?printf@@YAXPEBDZZ			; printf

; 735  : 				memset(dirent, 0, sizeof(fat32_dir));

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR dirent$1[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 736  : 				memcpy (dirent->filename, formated_name, 11);

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	r8d, 11
	lea	rdx, QWORD PTR formated_name$[rsp]
	mov	rcx, rax
	call	memcpy

; 737  : 				dirent->attrib = ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	BYTE PTR [rax+11], 16

; 738  : 				dirent->time_created_ms = 2021;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	BYTE PTR [rax+13], 229			; 000000e5H

; 739  : 				dirent->time_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+14], ax

; 740  : 				dirent->date_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+16], ax

; 741  : 				dirent->date_last_accessed = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+18], ax

; 742  : 				dirent->first_cluster_hi_bytes = (first_cluster >> 16) & 0xFFFF;

	mov	eax, DWORD PTR first_cluster$[rsp]
	shr	eax, 16
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+20], ax

; 743  : 				dirent->last_mod_time = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+22], ax

; 744  : 				dirent->last_mod_date = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+24], ax

; 745  : 				dirent->first_cluster = first_cluster & 0xFFFF;

	mov	eax, DWORD PTR first_cluster$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+26], ax

; 746  : 				dirent->file_size = 0;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	DWORD PTR [rax+28], 0

; 747  : 
; 748  : 				//! write the dir entry and go for writing the contents of the file
; 749  : 				ata_write_one (buf, root_sector + sector);

	mov	eax, DWORD PTR sector$3[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	lea	rcx, QWORD PTR buf$[rsp]
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 750  : 
; 751  : 				unsigned char* dir_content = (unsigned char*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR dir_content$7[rsp], rax

; 752  : 				memset(dir_content, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR dir_content$7[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 753  : 				uint32_t sector_d = cluster_to_sector32 (first_cluster);

	mov	eax, DWORD PTR first_cluster$[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR sector_d$8[rsp], eax

; 754  : 				fat32_dir *dot_entry = (fat32_dir*)dir_content;

	mov	rax, QWORD PTR dir_content$7[rsp]
	mov	QWORD PTR dot_entry$5[rsp], rax

; 755  : 				dot_entry->attrib = ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	BYTE PTR [rax+11], 16

; 756  : 				dot_entry->time_created_ms = 2021;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	BYTE PTR [rax+13], 229			; 000000e5H

; 757  : 				dot_entry->time_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+14], ax

; 758  : 				dot_entry->date_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+16], ax

; 759  : 				dot_entry->date_last_accessed = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+18], ax

; 760  : 				dot_entry->first_cluster_hi_bytes = (first_cluster >> 16) & 0xFFFF;

	mov	eax, DWORD PTR first_cluster$[rsp]
	shr	eax, 16
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+20], ax

; 761  : 				dot_entry->last_mod_time = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+22], ax

; 762  : 				dot_entry->last_mod_date = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+24], ax

; 763  : 				dot_entry->first_cluster = first_cluster & 0xFFFF;

	mov	eax, DWORD PTR first_cluster$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dot_entry$5[rsp]
	mov	WORD PTR [rcx+26], ax

; 764  : 				dot_entry->file_size = 0;

	mov	rax, QWORD PTR dot_entry$5[rsp]
	mov	DWORD PTR [rax+28], 0

; 765  : 
; 766  : 
; 767  : 				fat32_dir* dot_dot_entry = (fat32_dir*)(dir_content + 32);

	mov	rax, QWORD PTR dir_content$7[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dot_dot_entry$4[rsp], rax

; 768  : 				dot_dot_entry->attrib = ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dot_dot_entry$4[rsp]
	mov	BYTE PTR [rax+11], 16

; 769  : 				dot_dot_entry->time_created_ms = 2021;

	mov	rax, QWORD PTR dot_dot_entry$4[rsp]
	mov	BYTE PTR [rax+13], 229			; 000000e5H

; 770  : 				dot_dot_entry->time_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+14], ax

; 771  : 				dot_dot_entry->date_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+16], ax

; 772  : 				dot_dot_entry->date_last_accessed = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+18], ax

; 773  : 				dot_dot_entry->first_cluster_hi_bytes = (root_dir_first_cluster >> 16) & 0xFFFF;

	mov	eax, DWORD PTR ?root_dir_first_cluster@@3KA ; root_dir_first_cluster
	shr	eax, 16
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+20], ax

; 774  : 				dot_dot_entry->last_mod_time = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+22], ax

; 775  : 				dot_dot_entry->last_mod_date = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+24], ax

; 776  : 				dot_dot_entry->first_cluster = root_dir_first_cluster & 0xFFFF;

	mov	eax, DWORD PTR ?root_dir_first_cluster@@3KA ; root_dir_first_cluster
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dot_dot_entry$4[rsp]
	mov	WORD PTR [rcx+26], ax

; 777  : 				dot_dot_entry->file_size = 0;

	mov	rax, QWORD PTR dot_dot_entry$4[rsp]
	mov	DWORD PTR [rax+28], 0

; 778  : 
; 779  : 				for (int i = 0; i < 8; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@create_dir
$LN2@create_dir:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@create_dir:
	cmp	DWORD PTR i$2[rsp], 8
	jge	SHORT $LN1@create_dir

; 780  : 					ata_write_one (dir_content + (i * 512),sector_d + i);

	mov	eax, DWORD PTR i$2[rsp]
	mov	ecx, DWORD PTR sector_d$8[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR i$2[rsp]
	imul	ecx, 512				; 00000200H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR dir_content$7[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	edx, eax
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 781  : 				}

	jmp	SHORT $LN2@create_dir
$LN1@create_dir:

; 782  : 				return;

	jmp	SHORT $LN12@create_dir
$LN5@create_dir:

; 783  : 			}
; 784  : 			dirent++;

	mov	rax, QWORD PTR dirent$1[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$1[rsp], rax

; 785  : 		}

	jmp	$LN7@create_dir
$LN6@create_dir:

; 786  : 	}

	jmp	$LN10@create_dir
$LN9@create_dir:
$LN12@create_dir:

; 787  : 
; 788  : }

	add	rsp, 632				; 00000278H
	ret	0
?create_dir@@YAXPEBD@Z ENDP				; create_dir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
dirent$1 = 32
sector$2 = 40
cluster_first$ = 44
cluster$ = 48
first_cluster$ = 52
i$3 = 56
i$4 = 60
required_cluster$ = 64
i$5 = 68
stat$6 = 72
status$ = 76
status2$ = 80
formated_name$ = 88
buf$ = 112
filename$ = 640
buffer$ = 648
length$ = 656
?fat32_create_file@@YAIPEADPEAEI@Z PROC			; fat32_create_file

; 627  : uint32_t fat32_create_file  (char* filename, uint8_t *buffer, unsigned int length) {

$LN18:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 632				; 00000278H

; 628  : 
; 629  : 	/**
; 630  : 	 * First we scan the FAT table for free cluster which will
; 631  : 	 * be used as first cluster and store it in a temporary variable
; 632  : 	 */
; 633  : 	uint32_t first_cluster = 0;

	mov	DWORD PTR first_cluster$[rsp], 0

; 634  : 	uint32_t cluster_first = find_free_cluster ();

	call	?find_free_cluster@@YAIXZ		; find_free_cluster
	mov	DWORD PTR cluster_first$[rsp], eax

; 635  : 	first_cluster = cluster_first;

	mov	eax, DWORD PTR cluster_first$[rsp]
	mov	DWORD PTR first_cluster$[rsp], eax

; 636  : 	uint32_t status = alloc_cluster (cluster_first, 0x0FFFFFF8);

	mov	edx, 268435448				; 0ffffff8H
	mov	ecx, DWORD PTR cluster_first$[rsp]
	call	?alloc_cluster@@YAIHI@Z			; alloc_cluster
	mov	DWORD PTR status$[rsp], eax

; 637  : 
; 638  : 	//! Clear the cluster
; 639  : 	clear_cluster (cluster_first);

	mov	ecx, DWORD PTR cluster_first$[rsp]
	call	?clear_cluster@@YAXI@Z			; clear_cluster

; 640  : 
; 641  : 	//! Now calculate the number of clusters required 
; 642  : 	//! for the file
; 643  : 	uint32_t required_cluster = 0;

	mov	DWORD PTR required_cluster$[rsp], 0

; 644  : 	if (length > 4096) {

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jbe	SHORT $LN15@fat32_crea

; 645  : 		for (int i = 0; i < length / 4096; i++) {

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN14@fat32_crea
$LN13@fat32_crea:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
$LN14@fat32_crea:
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	cmp	DWORD PTR i$5[rsp], eax
	jae	SHORT $LN12@fat32_crea

; 646  : 			required_cluster++;

	mov	eax, DWORD PTR required_cluster$[rsp]
	inc	eax
	mov	DWORD PTR required_cluster$[rsp], eax

; 647  : 		}

	jmp	SHORT $LN13@fat32_crea
$LN12@fat32_crea:
$LN15@fat32_crea:

; 648  : 	}
; 649  : 
; 650  : 	//! Now allocate each clusters in the fat table
; 651  : 	//! [Knowledge]: In FAT table if the file requires more cluster
; 652  : 	//! than the file's first cluster points to next cluster
; 653  : 	//! kind of linked list data structure
; 654  :     uint32_t cluster = 0;

	mov	DWORD PTR cluster$[rsp], 0

; 655  : 	for (int i = 0; i < required_cluster; i++) {

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN11@fat32_crea
$LN10@fat32_crea:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN11@fat32_crea:
	mov	eax, DWORD PTR required_cluster$[rsp]
	cmp	DWORD PTR i$3[rsp], eax
	jae	SHORT $LN9@fat32_crea

; 656  : 		cluster = find_free_cluster ();

	call	?find_free_cluster@@YAIXZ		; find_free_cluster
	mov	DWORD PTR cluster$[rsp], eax

; 657  : 		uint32_t stat = alloc_cluster (cluster_first, cluster);

	mov	edx, DWORD PTR cluster$[rsp]
	mov	ecx, DWORD PTR cluster_first$[rsp]
	call	?alloc_cluster@@YAIHI@Z			; alloc_cluster
	mov	DWORD PTR stat$6[rsp], eax

; 658  : 		clear_cluster (cluster);

	mov	ecx, DWORD PTR cluster$[rsp]
	call	?clear_cluster@@YAXI@Z			; clear_cluster

; 659  : 		cluster_first = cluster;

	mov	eax, DWORD PTR cluster$[rsp]
	mov	DWORD PTR cluster_first$[rsp], eax

; 660  : 	}

	jmp	SHORT $LN10@fat32_crea
$LN9@fat32_crea:

; 661  : 
; 662  : 	//! the last cluster should be marked as EOC {0x0FFFFFF8}
; 663  : 	uint32_t status2 = alloc_cluster (cluster, 0x0FFFFFF8);

	mov	edx, 268435448				; 0ffffff8H
	mov	ecx, DWORD PTR cluster$[rsp]
	call	?alloc_cluster@@YAIHI@Z			; alloc_cluster
	mov	DWORD PTR status2$[rsp], eax

; 664  : 
; 665  : 	//! Finally format the name 
; 666  : 	//! for now Aurora's Xeneva support only short name MSDOS 8.3
; 667  : 	char formated_name[11];
; 668  : 	to_dos_file_name32 (filename, formated_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR formated_name$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?to_dos_file_name32@@YAXPEBDPEADI@Z	; to_dos_file_name32

; 669  : 
; 670  : 	//! now it's time to parse the root directory
; 671  : 	unsigned char buf[512];
; 672  : 	//! Root Directory Entries scanning goes here
; 673  : 	for (int sector = 0; sector < sectors_per_cluster; sector++) {

	mov	DWORD PTR sector$2[rsp], 0
	jmp	SHORT $LN8@fat32_crea
$LN7@fat32_crea:
	mov	eax, DWORD PTR sector$2[rsp]
	inc	eax
	mov	DWORD PTR sector$2[rsp], eax
$LN8@fat32_crea:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR sector$2[rsp], eax
	jge	$LN6@fat32_crea

; 674  : 		ata_read_28 (root_sector + sector,1, buf);	

	mov	eax, DWORD PTR sector$2[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	lea	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, eax
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 675  : 		fat32_dir *dirent = (fat32_dir*)buf;

	lea	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dirent$1[rsp], rax

; 676  : 		for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$4[rsp], 0
	jmp	SHORT $LN5@fat32_crea
$LN4@fat32_crea:
	mov	eax, DWORD PTR i$4[rsp]
	inc	eax
	mov	DWORD PTR i$4[rsp], eax
$LN5@fat32_crea:
	cmp	DWORD PTR i$4[rsp], 16
	jge	$LN3@fat32_crea

; 677  : 		
; 678  : 			//! scan for free directory entry
; 679  : 			if (dirent->filename[0] == 0x00 || dirent->filename[0] == 0xE5){

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN1@fat32_crea
	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 229				; 000000e5H
	jne	$LN2@fat32_crea
$LN1@fat32_crea:

; 680  : 				
; 681  : 				memset(dirent, 0, sizeof(fat32_dir));

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR dirent$1[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 682  : 				memcpy (dirent->filename, formated_name, 11);

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	r8d, 11
	lea	rdx, QWORD PTR formated_name$[rsp]
	mov	rcx, rax
	call	memcpy

; 683  : 				dirent->attrib = ATTRIBUTE_ARCHIVE;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	BYTE PTR [rax+11], 32			; 00000020H

; 684  : 				dirent->time_created_ms = 2021;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	BYTE PTR [rax+13], 229			; 000000e5H

; 685  : 				dirent->time_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+14], ax

; 686  : 				dirent->date_created = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+16], ax

; 687  : 				dirent->date_last_accessed = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+18], ax

; 688  : 				dirent->first_cluster_hi_bytes = (first_cluster >> 16) & 0xFFFF;

	mov	eax, DWORD PTR first_cluster$[rsp]
	shr	eax, 16
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+20], ax

; 689  : 				dirent->last_mod_time = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+22], ax

; 690  : 				dirent->last_mod_date = 2021;

	mov	eax, 2021				; 000007e5H
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+24], ax

; 691  : 				dirent->first_cluster = first_cluster & 0xFFFF;

	mov	eax, DWORD PTR first_cluster$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+26], ax

; 692  : 				dirent->file_size = length;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	ecx, DWORD PTR length$[rsp]
	mov	DWORD PTR [rax+28], ecx

; 693  : 				//! write the dir entry and go for writing the contents of the file
; 694  : 				ata_write_one (buf, root_sector + sector);

	mov	eax, DWORD PTR sector$2[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	mov	edx, eax
	lea	rcx, QWORD PTR buf$[rsp]
	call	?ata_write_one@@YAEPEAEI@Z		; ata_write_one

; 695  : 				//! actuall file writing process begins here
; 696  : 				fat32_write_content (buffer, first_cluster,length);

	mov	r8d, DWORD PTR length$[rsp]
	mov	edx, DWORD PTR first_cluster$[rsp]
	mov	rcx, QWORD PTR buffer$[rsp]
	call	?fat32_write_content@@YAXPEAEII@Z	; fat32_write_content

; 697  : 				return 0;

	xor	eax, eax
	jmp	SHORT $LN16@fat32_crea
$LN2@fat32_crea:

; 698  : 			}
; 699  : 			dirent++;

	mov	rax, QWORD PTR dirent$1[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$1[rsp], rax

; 700  : 		}

	jmp	$LN4@fat32_crea
$LN3@fat32_crea:

; 701  : 	
; 702  : 	}

	jmp	$LN7@fat32_crea
$LN6@fat32_crea:
$LN16@fat32_crea:

; 703  : 	//!free every allocated memories
; 704  : }

	add	rsp, 632				; 00000278H
	ret	0
?fat32_create_file@@YAIPEADPEAEI@Z ENDP			; fat32_create_file
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
j$2 = 36
dirent$ = 40
filename2$ = 48
buf$ = 80
?list_fat_entries@@YAXXZ PROC				; list_fat_entries

; 561  : void list_fat_entries () {

$LN9:
	sub	rsp, 600				; 00000258H

; 562  : 
; 563  : 	printf ("Root Dir entries scanning\n");

	lea	rcx, OFFSET FLAT:$SG3769
	call	?printf@@YAXPEBDZZ			; printf

; 564  : 	fat32_dir *dirent;
; 565  : 	char filename2[32];
; 566  : 	char format_name[11];
; 567  : 
; 568  : 	unsigned char buf[512];
; 569  : 	for (int i = 0; i < sectors_per_cluster; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@list_fat_e
$LN5@list_fat_e:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@list_fat_e:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR i$1[rsp], eax
	jge	$LN4@list_fat_e

; 570  : 		ata_read_28 (root_sector + i, 1,buf);

	mov	eax, DWORD PTR i$1[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	lea	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, eax
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 571  : 		dirent = (fat32_dir*)buf;

	lea	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dirent$[rsp], rax

; 572  : 		for (int j = 0; j < 16; j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN3@list_fat_e
$LN2@list_fat_e:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN3@list_fat_e:
	cmp	DWORD PTR j$2[rsp], 16
	jge	SHORT $LN1@list_fat_e

; 573  : 			convert_fat83_32(dirent,filename2);

	lea	rdx, QWORD PTR filename2$[rsp]
	mov	rcx, QWORD PTR dirent$[rsp]
	call	?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z ; convert_fat83_32

; 574  : 			printf ("Other file size -> %s, dirent attrib -> %x, count ->%d\n", filename2, *(uint8_t*)&buf[j], i);

	movsxd	rax, DWORD PTR j$2[rsp]
	movzx	eax, BYTE PTR buf$[rsp+rax]
	mov	r9d, DWORD PTR i$1[rsp]
	mov	r8d, eax
	lea	rdx, QWORD PTR filename2$[rsp]
	lea	rcx, OFFSET FLAT:$SG3784
	call	?printf@@YAXPEBDZZ			; printf

; 575  : 			dirent++;

	mov	rax, QWORD PTR dirent$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$[rsp], rax

; 576  : 		}

	jmp	SHORT $LN2@list_fat_e
$LN1@list_fat_e:

; 577  : 	}

	jmp	$LN5@list_fat_e
$LN4@list_fat_e:

; 578  : }

	add	rsp, 600				; 00000258H
	ret	0
?list_fat_entries@@YAXXZ ENDP				; list_fat_entries
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
sector$1 = 32
i$2 = 36
dirent$ = 40
buf$ = 48
name$3 = 56
tv77 = 72
dos_file_name$ = 80
file$ = 96
$T4 = 240
dir$ = 248
?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z PROC		; fat32_locate_dir

; 196  : vfs_node_t fat32_locate_dir (const char* dir) {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 216				; 000000d8H

; 197  : 	vfs_node_t file;
; 198  : 	uint64_t* buf;
; 199  : 	fat32_dir *dirent;
; 200  : 	char dos_file_name[11];
; 201  : 	to_dos_file_name32 (dir, dos_file_name, 11);	

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	?to_dos_file_name32@@YAXPEBDPEADI@Z	; to_dos_file_name32

; 202  : 	buf = (uint64_t*)pmmngr_alloc ();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buf$[rsp], rax

; 203  : 	for (unsigned int sector = 0; sector < sectors_per_cluster; sector++) {

	mov	DWORD PTR sector$1[rsp], 0
	jmp	SHORT $LN9@fat32_loca
$LN8@fat32_loca:
	mov	eax, DWORD PTR sector$1[rsp]
	inc	eax
	mov	DWORD PTR sector$1[rsp], eax
$LN9@fat32_loca:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR sector$1[rsp], eax
	jae	$LN7@fat32_loca

; 204  : 	
; 205  : 		memset (buf, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 206  : 		//ata_read_28 (root_sector + sector,1, buf);
; 207  : 		ahci_disk_read(ahci_disk_get_port(),root_sector + sector,1,buf);

	mov	eax, DWORD PTR sector$1[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR tv77[rsp], rax
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buf$[rsp]
	mov	r8d, 1
	mov	rcx, QWORD PTR tv77[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 208  : 		dirent = (fat32_dir*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dirent$[rsp], rax

; 209  : 		for (int i=0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN6@fat32_loca
$LN5@fat32_loca:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN6@fat32_loca:
	cmp	DWORD PTR i$2[rsp], 16
	jge	$LN4@fat32_loca

; 210  : 			
; 211  : 			char name[11];
; 212  : 			memcpy (name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rsp]
	call	memcpy

; 213  : 
; 214  : 			name[11] = 0;

	mov	eax, 1
	imul	rax, 11
	mov	BYTE PTR name$3[rsp+rax], 0

; 215  : 			if (strcmp (dos_file_name, name) == 0) {

	lea	rdx, QWORD PTR name$3[rsp]
	lea	rcx, QWORD PTR dos_file_name$[rsp]
	call	?strcmp@@YAHPEBD0@Z			; strcmp
	test	eax, eax
	jne	$LN3@fat32_loca

; 216  : 				strcpy (file.filename, dir);

	mov	rdx, QWORD PTR dir$[rsp]
	lea	rcx, QWORD PTR file$[rsp]
	call	?strcpy@@YAPEADPEADPEBD@Z		; strcpy

; 217  : 				file.current = dirent->first_cluster;

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	DWORD PTR file$[rsp+44], eax

; 218  : 				file.size = dirent->file_size;

	mov	rax, QWORD PTR dirent$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR file$[rsp+32], eax

; 219  : 				file.eof = 0;

	mov	DWORD PTR file$[rsp+36], 0

; 220  : 				file.status = FS_STATUS_FOUND;

	mov	DWORD PTR file$[rsp+52], 4

; 221  : 
; 222  : 				if (dirent->attrib == 0x10)

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	eax, 16
	jne	SHORT $LN2@fat32_loca

; 223  : 					file.flags = FS_FLAG_DIRECTORY;

	mov	DWORD PTR file$[rsp+48], 1

; 224  : 				else

	jmp	SHORT $LN1@fat32_loca
$LN2@fat32_loca:

; 225  : 					file.flags = FS_FLAG_GENERAL;

	mov	DWORD PTR file$[rsp+48], 2
$LN1@fat32_loca:

; 226  : 				
; 227  : 				pmmngr_free(buf);

	mov	rcx, QWORD PTR buf$[rsp]
	call	?pmmngr_free@@YAXPEAX@Z			; pmmngr_free

; 228  : 				return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T4[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T4[rsp]
	jmp	SHORT $LN10@fat32_loca
$LN3@fat32_loca:

; 229  : 			}
; 230  : 			dirent++;

	mov	rax, QWORD PTR dirent$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$[rsp], rax

; 231  : 		}

	jmp	$LN5@fat32_loca
$LN4@fat32_loca:

; 232  : 	}

	jmp	$LN8@fat32_loca
$LN7@fat32_loca:

; 233  : 
; 234  : 	file.status = FS_FLAG_INVALID;

	mov	DWORD PTR file$[rsp+52], 3

; 235  : 	file.size = 0;

	mov	DWORD PTR file$[rsp+32], 0

; 236  : 	file.eof = 0;

	mov	DWORD PTR file$[rsp+36], 0

; 237  : 	return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T4[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T4[rsp]
$LN10@fat32_loca:

; 238  : }

	add	rsp, 216				; 000000d8H
	pop	rdi
	pop	rsi
	ret	0
?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z ENDP		; fat32_locate_dir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
value$ = 32
lba$ = 40
file$ = 64
buf$ = 72
?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z PROC		; fat32_read

; 154  : void fat32_read (vfs_node_t *file, uint64_t* buf) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 155  : 	//printf ("Buffer -> %x\n", buf);
; 156  : 	auto lba = cluster_to_sector32 (file->current); 

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+44]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	QWORD PTR lba$[rsp], rax

; 157  : 
; 158  : 	//for (int i = 0; i < sectors_per_cluster; i++) {
; 159  : 		//ata_read_28 (lba+i,1,buffer);
; 160  : 		
; 161  : 	//	printf ("Buff -> %x\n", buf);
; 162  : 		//buf += 512;
; 163  : 	//}
; 164  : 	ahci_disk_read(ahci_disk_get_port(), lba, 8,buf);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buf$[rsp]
	mov	r8d, 8
	mov	rdx, QWORD PTR lba$[rsp]
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 165  : 	//printf ("Buff ->%x\n", buf);
; 166  : 
; 167  : 	uint32_t value = fat32_read_fat (file->current);

	mov	rax, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR [rax+44]
	call	?fat32_read_fat@@YAII@Z			; fat32_read_fat
	mov	DWORD PTR value$[rsp], eax

; 168  : 	//printf ("FAT Value ->%x\n", value);
; 169  : 	if (value  >= 0x0FFFFFF8) {

	cmp	DWORD PTR value$[rsp], 268435448	; 0ffffff8H
	jb	SHORT $LN2@fat32_read

; 170  : 	    file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+36], 1

; 171  : 		return;

	jmp	SHORT $LN3@fat32_read
$LN2@fat32_read:

; 172  : 	}
; 173  : 
; 174  : 	if (value  == 0x0FFFFFF7) {

	cmp	DWORD PTR value$[rsp], 268435447	; 0ffffff7H
	jne	SHORT $LN1@fat32_read

; 175  : 	    file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+36], 1

; 176  : 		return;

	jmp	SHORT $LN3@fat32_read
$LN1@fat32_read:

; 177  : 	}
; 178  : 	
; 179  : 	file->current = value;

	mov	rax, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+44], ecx
$LN3@fat32_read:

; 180  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z ENDP		; fat32_read
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
file$ = 64
buffer$ = 72
count$ = 80
?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z PROC	; fat32_read_file

; 183  : void fat32_read_file (vfs_node_t *file, uint64_t* buffer, uint32_t count) {

$LN7:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 184  : 	/*while(file->eof != 1) {
; 185  : 		fat32_read (file,buffer);
; 186  : 		buffer += 4096;
; 187  : 	}*/
; 188  : 	for (int i=0; i < count; i+= 8) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@fat32_read
$LN3@fat32_read:
	mov	eax, DWORD PTR i$1[rsp]
	add	eax, 8
	mov	DWORD PTR i$1[rsp], eax
$LN4@fat32_read:
	mov	eax, DWORD PTR count$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@fat32_read

; 189  : 		fat32_read (file, buffer);

	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	call	?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z	; fat32_read

; 190  : 		if (file->eof) 

	mov	rax, QWORD PTR file$[rsp]
	cmp	DWORD PTR [rax+36], 0
	je	SHORT $LN1@fat32_read

; 191  : 			break;

	jmp	SHORT $LN2@fat32_read
$LN1@fat32_read:

; 192  : 		buffer += 4096;

	mov	rax, QWORD PTR buffer$[rsp]
	add	rax, 32768				; 00008000H
	mov	QWORD PTR buffer$[rsp], rax

; 193  : 	}

	jmp	SHORT $LN3@fat32_read
$LN2@fat32_read:

; 194  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z ENDP	; fat32_read_file
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
root_dir$ = 32
i$1 = 36
p$ = 40
path$ = 48
pathname$2 = 56
cur_dir$ = 80
ret$ = 192
ret$3 = 304
$T4 = 416
$T5 = 528
$T6 = 632
$T7 = 736
$T8 = 840
$T9 = 944
$T10 = 1048
$T11 = 1184
node$ = 1192
filename$ = 1200
?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z PROC		; fat32_open

; 360  : vfs_node_t fat32_open (vfs_node_t * node, char* filename) {

$LN17:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 1160				; 00000488H

; 361  : 	vfs_node_t cur_dir;
; 362  : 	char* p = 0;

	mov	QWORD PTR p$[rsp], 0

; 363  : 	bool  root_dir = true;

	mov	BYTE PTR root_dir$[rsp], 1

; 364  : 	char* path = (char*) filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR path$[rsp], rax

; 365  : 
; 366  : 	//! any '\'s in path ?
; 367  : 	p = strchr (path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	?strchr@@YAPEADPEADH@Z			; strchr
	mov	QWORD PTR p$[rsp], rax

; 368  : 	if (!p) {

	cmp	QWORD PTR p$[rsp], 0
	jne	$LN14@fat32_open

; 369  : 		//! nope, must be in root directory, search it
; 370  : 		cur_dir = fat32_locate_dir (path);

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z ; fat32_locate_dir
	lea	rcx, QWORD PTR $T6[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	lea	rax, QWORD PTR cur_dir$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 104				; 00000068H
	rep movsb

; 371  : 
; 372  : 		//! found file ?
; 373  : 		if (cur_dir.flags == FS_FLAG_GENERAL) {

	cmp	DWORD PTR cur_dir$[rsp+48], 2
	jne	SHORT $LN13@fat32_open

; 374  : 			return cur_dir;

	lea	rax, QWORD PTR cur_dir$[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN15@fat32_open
$LN13@fat32_open:

; 375  : 		}
; 376  : 
; 377  : 		//! unable to find
; 378  : 		vfs_node_t ret;
; 379  : 		ret.flags = FS_FLAG_INVALID;

	mov	DWORD PTR ret$3[rsp+48], 3

; 380  : 		ret.size = 0;

	mov	DWORD PTR ret$3[rsp+32], 0

; 381  : 		return ret;

	lea	rax, QWORD PTR ret$3[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN15@fat32_open
$LN14@fat32_open:

; 382  : 	}
; 383  : 
; 384  : 	//! go to next character after first '\'
; 385  : 	p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN12@fat32_open:

; 386  : 
; 387  : 	while (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	$LN11@fat32_open

; 388  : 
; 389  : 		//! get pathname
; 390  : 		char pathname[16];
; 391  : 		int i=0;

	mov	DWORD PTR i$1[rsp], 0

; 392  : 		for (i=0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN10@fat32_open
$LN9@fat32_open:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN10@fat32_open:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN8@fat32_open

; 393  : 
; 394  : 			//! if another '\' or end of line is reached, we are done
; 395  : 			if (p[i] == '/' || p[i]=='\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN6@fat32_open
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN7@fat32_open
$LN6@fat32_open:

; 396  : 				break;

	jmp	SHORT $LN8@fat32_open
$LN7@fat32_open:

; 397  : 
; 398  : 			//! copy character
; 399  : 			pathname[i]=p[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$2[rsp+rcx], al

; 400  : 		}

	jmp	SHORT $LN9@fat32_open
$LN8@fat32_open:

; 401  : 		pathname[i]=0; //null terminate

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$2[rsp+rax], 0

; 402  : 
; 403  : 		//! open subdirectory or file
; 404  : 		if (root_dir) {

	movzx	eax, BYTE PTR root_dir$[rsp]
	test	eax, eax
	je	SHORT $LN5@fat32_open

; 405  : 			//! search root dir -- open pathname
; 406  : 			cur_dir = fat32_locate_dir (pathname);

	lea	rdx, QWORD PTR pathname$2[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z ; fat32_locate_dir
	lea	rcx, QWORD PTR $T7[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	lea	rax, QWORD PTR cur_dir$[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 104				; 00000068H
	rep movsb

; 407  : 			root_dir = false;

	mov	BYTE PTR root_dir$[rsp], 0

; 408  : 		}
; 409  : 		else {

	jmp	SHORT $LN4@fat32_open
$LN5@fat32_open:

; 410  : 			//! search a sub directory instead for pathname
; 411  : 			cur_dir = fat32_locate_subdir (cur_dir, pathname);

	lea	rax, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR cur_dir$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 104				; 00000068H
	rep movsb
	lea	r8, QWORD PTR pathname$2[rsp]
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z ; fat32_locate_subdir
	lea	rcx, QWORD PTR $T5[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	lea	rax, QWORD PTR cur_dir$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 104				; 00000068H
	rep movsb
$LN4@fat32_open:

; 412  : 		}
; 413  : 
; 414  : 		//! found directory or file?
; 415  : 		if (cur_dir.flags == FS_FLAG_INVALID)

	cmp	DWORD PTR cur_dir$[rsp+48], 3
	jne	SHORT $LN3@fat32_open

; 416  : 			break;

	jmp	SHORT $LN11@fat32_open
$LN3@fat32_open:

; 417  : 
; 418  : 		//! found file?
; 419  : 		if (cur_dir.flags == FS_FLAG_GENERAL){

	cmp	DWORD PTR cur_dir$[rsp+48], 2
	jne	SHORT $LN2@fat32_open

; 420  : 			return cur_dir;

	lea	rax, QWORD PTR cur_dir$[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
	jmp	SHORT $LN15@fat32_open
$LN2@fat32_open:

; 421  : 		}
; 422  : 
; 423  : 		//! find next '\'
; 424  : 		p=strchr(p+1, '/');

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	?strchr@@YAPEADPEADH@Z			; strchr
	mov	QWORD PTR p$[rsp], rax

; 425  : 		if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN1@fat32_open

; 426  : 			p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN1@fat32_open:

; 427  : 	}

	jmp	$LN12@fat32_open
$LN11@fat32_open:

; 428  : 
; 429  : 	//! unable to find
; 430  : 	vfs_node_t ret;
; 431  : 	ret.flags = FS_FLAG_INVALID;

	mov	DWORD PTR ret$[rsp+48], 3

; 432  : 	ret.size = 0;

	mov	DWORD PTR ret$[rsp+32], 0

; 433  : 	return ret;

	lea	rax, QWORD PTR ret$[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
$LN15@fat32_open:

; 434  : }

	add	rsp, 1160				; 00000488H
	pop	rdi
	pop	rsi
	ret	0
?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z ENDP		; fat32_open
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
tv176 = 40
fat32_data$ = 48
buf$ = 56
?initialize_fat32@@YAXXZ PROC				; initialize_fat32

; 93   : void initialize_fat32 () {

$LN9:
	sub	rsp, 72					; 00000048H

; 94   : 
; 95   : 	uint64_t *buf = (uint64_t*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buf$[rsp], rax

; 96   : 	//ata_read_28 (2048,1,buf); //partition_begin_lba = 2048
; 97   : 	ahci_disk_read (ahci_disk_get_port(),2048,1,buf);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buf$[rsp]
	mov	r8d, 1
	mov	edx, 2048				; 00000800H
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 98   : 
; 99   : 
; 100  : 	BPB *fat32_data = (BPB*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR fat32_data$[rsp], rax

; 101  : 
; 102  : 	part_lba = 2048;

	mov	DWORD PTR ?part_lba@@3IA, 2048		; part_lba, 00000800H

; 103  : 
; 104  : 
; 105  : 	printf ("FAT32 BOOT PARAMETER BLOCK\n");

	lea	rcx, OFFSET FLAT:$SG3513
	call	?printf@@YAXPEBDZZ			; printf

; 106  : 	printf ("Bytes/Sector -> %d\n", fat32_data->bytes_per_sector);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+11]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3514
	call	?printf@@YAXPEBDZZ			; printf

; 107  : 	printf ("Sectors/Cluster -> %d\n", fat32_data->sectors_per_cluster);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, BYTE PTR [rax+13]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3515
	call	?printf@@YAXPEBDZZ			; printf

; 108  : 	printf ("Reserved Sectors -> %d\n", fat32_data->reserved_sectors);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3516
	call	?printf@@YAXPEBDZZ			; printf

; 109  : 	printf ("Number Of FATs -> %d\n", fat32_data->num_fats);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3517
	call	?printf@@YAXPEBDZZ			; printf

; 110  : 	printf ("Root Base Cluster -> %d\n", fat32_data->info.FAT32.root_dir_cluster);

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	edx, DWORD PTR [rax+44]
	lea	rcx, OFFSET FLAT:$SG3518
	call	?printf@@YAXPEBDZZ			; printf

; 111  : 	printf ("Sector/FAT32 -> %d\n", fat32_data->info.FAT32.sect_per_fat32);

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	edx, DWORD PTR [rax+36]
	lea	rcx, OFFSET FLAT:$SG3519
	call	?printf@@YAXPEBDZZ			; printf

; 112  : 
; 113  : 	for (int i=0; i <12; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@initialize
$LN5@initialize:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@initialize:
	cmp	DWORD PTR i$1[rsp], 12
	jge	SHORT $LN4@initialize

; 114  : 		printf("%c",fat32_data->info.FAT32.vol_label[i]);

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+71]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3524
	call	?printf@@YAXPEBDZZ			; printf

; 115  : 	}

	jmp	SHORT $LN5@initialize
$LN4@initialize:

; 116  : 	for (int i=0; i <9; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@initialize
$LN2@initialize:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@initialize:
	cmp	DWORD PTR i$2[rsp], 9
	jge	SHORT $LN1@initialize

; 117  : 		printf("%c",fat32_data->info.FAT32.sys_id[i]);

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+82]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3529
	call	?printf@@YAXPEBDZZ			; printf

; 118  : 	}

	jmp	SHORT $LN2@initialize
$LN1@initialize:

; 119  : 
; 120  : 
; 121  : 	fat_begin_lba = part_lba + fat32_data->reserved_sectors;

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	ecx, DWORD PTR ?part_lba@@3IA		; part_lba
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ?fat_begin_lba@@3KA, eax	; fat_begin_lba

; 122  : 	cluster_begin_lba = part_lba + fat32_data->reserved_sectors + (fat32_data->num_fats * fat32_data->info.FAT32.sect_per_fat32);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	ecx, DWORD PTR ?part_lba@@3IA		; part_lba
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movzx	ecx, BYTE PTR [rcx+16]
	mov	rdx, QWORD PTR fat32_data$[rsp]
	imul	ecx, DWORD PTR [rdx+36]
	add	eax, ecx
	mov	DWORD PTR ?cluster_begin_lba@@3KA, eax	; cluster_begin_lba

; 123  : 	sectors_per_cluster = fat32_data->sectors_per_cluster;

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, BYTE PTR [rax+13]
	mov	BYTE PTR ?sectors_per_cluster@@3EA, al	; sectors_per_cluster

; 124  : 	root_dir_first_cluster = fat32_data->info.FAT32.root_dir_cluster;

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rax+44]
	mov	DWORD PTR ?root_dir_first_cluster@@3KA, eax ; root_dir_first_cluster

; 125  : 	root_sector = cluster_to_sector32 (root_dir_first_cluster);

	mov	eax, DWORD PTR ?root_dir_first_cluster@@3KA ; root_dir_first_cluster
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR ?root_sector@@3KA, eax	; root_sector

; 126  : 	sectors_per_fat32 = fat32_data->info.FAT32.sect_per_fat32;

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR ?sectors_per_fat32@@3IA, eax	; sectors_per_fat32

; 127  : 
; 128  : 	total_clusters = fat32_data->large_sector_count / sectors_per_cluster;

	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	mov	DWORD PTR tv176[rsp], eax
	xor	edx, edx
	mov	rcx, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rcx+32]
	mov	ecx, DWORD PTR tv176[rsp]
	div	ecx
	mov	DWORD PTR ?total_clusters@@3IA, eax	; total_clusters

; 129  : 	//fat32_list_files();
; 130  : 	//for (int i = 0; i < sectors_per_cluster; i++) {
; 131  : 	//	ata_read_28 (root_sector + i, 1, root_dir_cache);
; 132  : 	//	root_dir_cache += 512;
; 133  : 	//}
; 134  : 
; 135  : }

	add	rsp, 72					; 00000048H
	ret	0
?initialize_fat32@@YAXXZ ENDP				; initialize_fat32
_TEXT	ENDS
END
