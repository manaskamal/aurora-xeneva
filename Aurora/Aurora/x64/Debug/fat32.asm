; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?alloc_counter@@3HA				; alloc_counter
PUBLIC	?part_lba@@3IA					; part_lba
PUBLIC	?fat_begin_lba@@3KA				; fat_begin_lba
PUBLIC	?cluster_begin_lba@@3KA				; cluster_begin_lba
PUBLIC	?sectors_per_cluster@@3EA			; sectors_per_cluster
PUBLIC	?root_dir_first_cluster@@3KA			; root_dir_first_cluster
PUBLIC	?root_sector@@3KA				; root_sector
PUBLIC	?sectors_per_fat32@@3IA				; sectors_per_fat32
_BSS	SEGMENT
?alloc_counter@@3HA DD 01H DUP (?)			; alloc_counter
?part_lba@@3IA DD 01H DUP (?)				; part_lba
?fat_begin_lba@@3KA DD 01H DUP (?)			; fat_begin_lba
?cluster_begin_lba@@3KA DD 01H DUP (?)			; cluster_begin_lba
?sectors_per_cluster@@3EA DB 01H DUP (?)		; sectors_per_cluster
	ALIGN	4

?root_dir_first_cluster@@3KA DD 01H DUP (?)		; root_dir_first_cluster
?root_sector@@3KA DD 01H DUP (?)			; root_sector
?sectors_per_fat32@@3IA DD 01H DUP (?)			; sectors_per_fat32
_BSS	ENDS
CONST	SEGMENT
$SG3213	DB	'%s             %d bytes', 0aH, 00H
	ORG $+7
$SG3221	DB	'%s             %d bytes', 0aH, 00H
CONST	ENDS
PUBLIC	?initialize_fat32@@YAXXZ			; initialize_fat32
PUBLIC	?fat32_open@@YA?AU_file_@@PEBD@Z		; fat32_open
PUBLIC	?fat32_read_file@@YAXPEAU_file_@@PEAEH@Z	; fat32_read_file
PUBLIC	?fat32_read@@YAXPEAU_file_@@PEAE@Z		; fat32_read
PUBLIC	?fat32_locate_dir@@YA?AU_file_@@PEBD@Z		; fat32_locate_dir
PUBLIC	?cluster_to_sector32@@YA_K_K@Z			; cluster_to_sector32
PUBLIC	?to_dos_file_name32@@YAXPEBDPEADI@Z		; to_dos_file_name32
PUBLIC	?fat32_read_fat@@YAII@Z				; fat32_read_fat
PUBLIC	?fat32_locate_subdir@@YA?AU_file_@@U1@PEBD@Z	; fat32_locate_subdir
PUBLIC	?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z	; convert_fat83_32
PUBLIC	?fat32_list_files@@YAXXZ			; fat32_list_files
EXTRN	?strcmp@@YAHPEBD0@Z:PROC			; strcmp
EXTRN	?strcpy@@YAPEADPEADPEBD@Z:PROC			; strcpy
EXTRN	?strlen@@YA_KPEBD@Z:PROC			; strlen
EXTRN	?strchr@@YAPEADPEADH@Z:PROC			; strchr
EXTRN	?memset@@YAXPEAXEI@Z:PROC			; memset
EXTRN	memcpy:PROC
EXTRN	?pmmngr_alloc@@YAPEAXXZ:PROC			; pmmngr_alloc
EXTRN	?pmmngr_free@@YAXPEAX@Z:PROC			; pmmngr_free
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
EXTRN	?ata_read_28@@YAEIGPEAE@Z:PROC			; ata_read_28
pdata	SEGMENT
$pdata$?initialize_fat32@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+190
	DD	imagerel $unwind$?initialize_fat32@@YAXXZ
$pdata$?fat32_open@@YA?AU_file_@@PEBD@Z DD imagerel $LN17
	DD	imagerel $LN17+706
	DD	imagerel $unwind$?fat32_open@@YA?AU_file_@@PEBD@Z
$pdata$?fat32_read_file@@YAXPEAU_file_@@PEAEH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?fat32_read_file@@YAXPEAU_file_@@PEAEH@Z
$pdata$?fat32_read@@YAXPEAU_file_@@PEAE@Z DD imagerel $LN8
	DD	imagerel $LN8+189
	DD	imagerel $unwind$?fat32_read@@YAXPEAU_file_@@PEAE@Z
$pdata$?fat32_locate_dir@@YA?AU_file_@@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+457
	DD	imagerel $unwind$?fat32_locate_dir@@YA?AU_file_@@PEBD@Z
$pdata$?to_dos_file_name32@@YAXPEBDPEADI@Z DD imagerel $LN23
	DD	imagerel $LN23+511
	DD	imagerel $unwind$?to_dos_file_name32@@YAXPEBDPEADI@Z
$pdata$?fat32_read_fat@@YAII@Z DD imagerel $LN3
	DD	imagerel $LN3+125
	DD	imagerel $unwind$?fat32_read_fat@@YAII@Z
$pdata$?fat32_locate_subdir@@YA?AU_file_@@U1@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+411
	DD	imagerel $unwind$?fat32_locate_subdir@@YA?AU_file_@@U1@PEBD@Z
$pdata$?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z DD imagerel $LN8
	DD	imagerel $LN8+268
	DD	imagerel $unwind$?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z
$pdata$?fat32_list_files@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+259
	DD	imagerel $unwind$?fat32_list_files@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?initialize_fat32@@YAXXZ DD 010401H
	DD	06204H
$unwind$?fat32_open@@YA?AU_file_@@PEBD@Z DD 041301H
	DD	0590113H
	DD	0600b700cH
$unwind$?fat32_read_file@@YAXPEAU_file_@@PEAEH@Z DD 011301H
	DD	06213H
$unwind$?fat32_read@@YAXPEAU_file_@@PEAE@Z DD 010e01H
	DD	0620eH
$unwind$?fat32_locate_dir@@YA?AU_file_@@PEBD@Z DD 041301H
	DD	0150113H
	DD	0600b700cH
$unwind$?to_dos_file_name32@@YAXPEBDPEADI@Z DD 011301H
	DD	08213H
$unwind$?fat32_read_fat@@YAII@Z DD 020b01H
	DD	049010bH
$unwind$?fat32_locate_subdir@@YA?AU_file_@@U1@PEBD@Z DD 041801H
	DD	0150118H
	DD	060107011H
$unwind$?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z DD 010e01H
	DD	0420eH
$unwind$?fat32_list_files@@YAXXZ DD 020701H
	DD	0910107H
xdata	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
dir2$ = 40
dir$ = 48
filename2$ = 56
filename$ = 88
buf$ = 128
buf2$ = 640
?fat32_list_files@@YAXXZ PROC				; fat32_list_files

; 310  : void fat32_list_files() {

$LN9:
	sub	rsp, 1160				; 00000488H

; 311  : 	unsigned char buf[512];
; 312  : 	unsigned char buf2[512];
; 313  : 	char filename[32];
; 314  : 	ata_read_28(root_sector, 1, buf);

	lea	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 315  : 	ata_read_28(root_sector + 1, 1, buf2);

	mov	eax, DWORD PTR ?root_sector@@3KA	; root_sector
	inc	eax
	lea	r8, QWORD PTR buf2$[rsp]
	mov	dx, 1
	mov	ecx, eax
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 316  : 	fat32_dir *dir = (fat32_dir*)buf;

	lea	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dir$[rsp], rax

; 317  : 	for (int i=0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@fat32_list
$LN5@fat32_list:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@fat32_list:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN4@fat32_list

; 318  : 		convert_fat83_32(dir,filename);

	lea	rdx, QWORD PTR filename$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z ; convert_fat83_32

; 319  : 		printf ("%s             %d bytes\n",filename, dir->file_size);

	mov	rax, QWORD PTR dir$[rsp]
	mov	r8d, DWORD PTR [rax+28]
	lea	rdx, QWORD PTR filename$[rsp]
	lea	rcx, OFFSET FLAT:$SG3213
	call	?printf@@YAXPEBDZZ			; printf

; 320  : 		dir++;

	mov	rax, QWORD PTR dir$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dir$[rsp], rax

; 321  : 	}

	jmp	SHORT $LN5@fat32_list
$LN4@fat32_list:

; 322  : 
; 323  : 	char filename2[32];
; 324  : 	fat32_dir *dir2 = (fat32_dir*)buf2;

	lea	rax, QWORD PTR buf2$[rsp]
	mov	QWORD PTR dir2$[rsp], rax

; 325  : 	for (int i=0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@fat32_list
$LN2@fat32_list:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@fat32_list:
	cmp	DWORD PTR i$2[rsp], 16
	jge	SHORT $LN1@fat32_list

; 326  : 		convert_fat83_32(dir2,filename2);

	lea	rdx, QWORD PTR filename2$[rsp]
	mov	rcx, QWORD PTR dir2$[rsp]
	call	?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z ; convert_fat83_32

; 327  : 		printf ("%s             %d bytes\n",filename2, dir2->file_size);

	mov	rax, QWORD PTR dir2$[rsp]
	mov	r8d, DWORD PTR [rax+28]
	lea	rdx, QWORD PTR filename2$[rsp]
	lea	rcx, OFFSET FLAT:$SG3221
	call	?printf@@YAXPEBDZZ			; printf

; 328  : 		dir2++;

	mov	rax, QWORD PTR dir2$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dir2$[rsp], rax

; 329  : 	}

	jmp	SHORT $LN2@fat32_list
$LN1@fat32_list:

; 330  : }

	add	rsp, 1160				; 00000488H
	ret	0
?fat32_list_files@@YAXXZ ENDP				; fat32_list_files
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$ = 0
f$ = 8
p$ = 16
root$ = 48
filename$ = 56
?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z PROC	; convert_fat83_32

; 281  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 282  : 	char *p;
; 283  : 	char *f = filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR f$[rsp], rax

; 284  : 	int i;
; 285  : 
; 286  : 	p = (char*)root->filename;

	mov	rax, QWORD PTR root$[rsp]
	mov	QWORD PTR p$[rsp], rax

; 287  : 	i = 8;

	mov	DWORD PTR i$[rsp], 8
$LN5@convert_fa:

; 288  : 	while ((*p != 0x20) && i)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN4@convert_fa
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN4@convert_fa

; 289  : 	{
; 290  : 		*f++ = *p++;

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 291  : 		i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 292  : 	}

	jmp	SHORT $LN5@convert_fa
$LN4@convert_fa:

; 293  : 
; 294  : 	*f++ = '.';

	mov	rax, QWORD PTR f$[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax

; 295  : 
; 296  : 	p = (char*)root->ext;

	mov	rax, QWORD PTR root$[rsp]
	add	rax, 8
	mov	QWORD PTR p$[rsp], rax

; 297  : 	i = 3;

	mov	DWORD PTR i$[rsp], 3
$LN3@convert_fa:

; 298  : 	while ((*p != 0x20) && i)

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN2@convert_fa
	cmp	DWORD PTR i$[rsp], 0
	je	SHORT $LN2@convert_fa

; 299  : 	{
; 300  : 		*f++ = *p++;

	mov	rax, QWORD PTR f$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax
	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 301  : 		i--;

	mov	eax, DWORD PTR i$[rsp]
	dec	eax
	mov	DWORD PTR i$[rsp], eax

; 302  : 	}

	jmp	SHORT $LN3@convert_fa
$LN2@convert_fa:

; 303  : 
; 304  : 	if (i == 3)

	cmp	DWORD PTR i$[rsp], 3
	jne	SHORT $LN1@convert_fa

; 305  : 		f--;

	mov	rax, QWORD PTR f$[rsp]
	dec	rax
	mov	QWORD PTR f$[rsp], rax
$LN1@convert_fa:

; 306  : 
; 307  : 	*f++ = '\0';

	mov	rax, QWORD PTR f$[rsp]
	mov	BYTE PTR [rax], 0
	mov	rax, QWORD PTR f$[rsp]
	inc	rax
	mov	QWORD PTR f$[rsp], rax

; 308  : }

	add	rsp, 40					; 00000028H
	ret	0
?convert_fat83_32@@YAXPEAU_fat32_dir_@@PEAD@Z ENDP	; convert_fat83_32
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
pkDir$2 = 40
buf$3 = 48
file$ = 56
name$4 = 120
dos_file_name$ = 136
$T5 = 192
kfile$ = 200
filename$ = 208
?fat32_locate_subdir@@YA?AU_file_@@U1@PEBD@Z PROC	; fat32_locate_subdir

; 221  : FILE fat32_locate_subdir (FILE kfile, const char* filename) {

$LN12:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 168				; 000000a8H

; 222  : 
; 223  : 	FILE file;
; 224  : 
; 225  : 	char dos_file_name[11];
; 226  : 	to_dos_file_name32 (filename, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?to_dos_file_name32@@YAXPEBDPEADI@Z	; to_dos_file_name32

; 227  : 	//dos_file_name[11] = 0;
; 228  : 
; 229  : 	if (kfile.flags != FILE_FLAG_INVALID) {

	mov	rax, QWORD PTR kfile$[rsp]
	cmp	DWORD PTR [rax+52], 3
	je	$LN9@fat32_loca
$LN8@fat32_loca:

; 230  : 		
; 231  : 		//! read the directory
; 232  : 		while (!kfile.eof) {

	mov	rax, QWORD PTR kfile$[rsp]
	cmp	DWORD PTR [rax+40], 0
	jne	$LN7@fat32_loca

; 233  : 
; 234  : 			//! read 
; 235  : 			unsigned char* buf = (unsigned char*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buf$3[rsp], rax

; 236  : 			fat32_read (&kfile, buf);

	mov	rdx, QWORD PTR buf$3[rsp]
	mov	rcx, QWORD PTR kfile$[rsp]
	call	?fat32_read@@YAXPEAU_file_@@PEAE@Z	; fat32_read

; 237  : 			//! set directory
; 238  : 			fat32_dir* pkDir = (fat32_dir*)buf;

	mov	rax, QWORD PTR buf$3[rsp]
	mov	QWORD PTR pkDir$2[rsp], rax

; 239  : 
; 240  : 			//! 16 entries
; 241  : 			for (unsigned int i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@fat32_loca
$LN5@fat32_loca:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@fat32_loca:
	cmp	DWORD PTR i$1[rsp], 16
	jae	$LN4@fat32_loca

; 242  : 
; 243  : 				//! get current filename;
; 244  : 				char name[11];
; 245  : 				memcpy (name, pkDir->filename, 11);

	mov	rax, QWORD PTR pkDir$2[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$4[rsp]
	call	memcpy

; 246  : 				//name[11] = 0;
; 247  : 
; 248  : 				if (strcmp (name, dos_file_name) == 0) {

	lea	rdx, QWORD PTR dos_file_name$[rsp]
	lea	rcx, QWORD PTR name$4[rsp]
	call	?strcmp@@YAHPEBD0@Z			; strcmp
	test	eax, eax
	jne	$LN3@fat32_loca

; 249  : 
; 250  : 					//! found file
; 251  : 					strcpy (file.filename, filename);

	mov	rdx, QWORD PTR filename$[rsp]
	lea	rcx, QWORD PTR file$[rsp]
	call	?strcpy@@YAPEADPEADPEBD@Z		; strcpy

; 252  : 					file.id = 0;

	mov	DWORD PTR file$[rsp+32], 0

; 253  : 					file.start_cluster = pkDir->first_cluster;

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	DWORD PTR file$[rsp+48], eax

; 254  : 					file.size = pkDir->file_size;

	mov	rax, QWORD PTR pkDir$2[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR file$[rsp+36], eax

; 255  : 					file.eof = 0;

	mov	DWORD PTR file$[rsp+40], 0

; 256  : 					file.status = FILE_STATUS_FOUND;

	mov	DWORD PTR file$[rsp+56], 1

; 257  : 					//! set file type
; 258  : 					if (pkDir->attrib == 0x10)

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	eax, 16
	jne	SHORT $LN2@fat32_loca

; 259  : 						file.flags = FILE_FLAG_DIRECTORY;

	mov	DWORD PTR file$[rsp+52], 1

; 260  : 					else

	jmp	SHORT $LN1@fat32_loca
$LN2@fat32_loca:

; 261  : 						file.flags = FILE_FLAG_GENERAL;

	mov	DWORD PTR file$[rsp+52], 2
$LN1@fat32_loca:

; 262  : 
; 263  : 					//!return file
; 264  : 					return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T5[rsp]
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	mov	rax, QWORD PTR $T5[rsp]
	jmp	SHORT $LN10@fat32_loca
$LN3@fat32_loca:

; 265  : 				}
; 266  : 
; 267  : 				//! go to next entry
; 268  : 				pkDir++;

	mov	rax, QWORD PTR pkDir$2[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR pkDir$2[rsp], rax

; 269  : 			}

	jmp	$LN5@fat32_loca
$LN4@fat32_loca:

; 270  : 
; 271  : 			//pmmngr_free (buf);
; 272  : 		}

	jmp	$LN8@fat32_loca
$LN7@fat32_loca:
$LN9@fat32_loca:

; 273  : 	}
; 274  : 
; 275  : 	file.flags = FILE_FLAG_INVALID;

	mov	DWORD PTR file$[rsp+52], 3

; 276  : 	return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T5[rsp]
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	mov	rax, QWORD PTR $T5[rsp]
$LN10@fat32_loca:

; 277  : }

	add	rsp, 168				; 000000a8H
	pop	rdi
	pop	rsi
	ret	0
?fat32_locate_subdir@@YA?AU_file_@@U1@PEBD@Z ENDP	; fat32_locate_subdir
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
fat_sector$ = 40
ent_offset$ = 48
buf$ = 64
cluster_index$ = 592
?fat32_read_fat@@YAII@Z PROC				; fat32_read_fat

; 120  : uint32_t fat32_read_fat (uint32_t cluster_index) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 584				; 00000248H

; 121  : 	auto fat_offset = cluster_index * 4;

	mov	eax, DWORD PTR cluster_index$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 122  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 123  : 	size_t ent_offset = fat_offset  % 512;

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	mov	eax, eax
	mov	QWORD PTR ent_offset$[rsp], rax

; 124  : 	unsigned char buf[512];
; 125  : 	ata_read_28 (fat_sector,1,buf);

	lea	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, DWORD PTR fat_sector$[rsp]
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 126  : 	uint32_t value = *(uint32_t*) &buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	eax, DWORD PTR buf$[rsp+rax]
	mov	DWORD PTR value$[rsp], eax

; 127  : 	return value & 0x0FFFFFFF;

	mov	eax, DWORD PTR value$[rsp]
	and	eax, 268435455				; 0fffffffH

; 128  : }

	add	rsp, 584				; 00000248H
	ret	0
?fat32_read_fat@@YAII@Z ENDP				; fat32_read_fat
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$ = 32
k$1 = 36
tv132 = 40
tv179 = 44
tv71 = 48
filename$ = 80
fname$ = 88
fname_length$ = 96
?to_dos_file_name32@@YAXPEBDPEADI@Z PROC		; to_dos_file_name32

; 40   : {

$LN23:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 41   : 	unsigned int i=0;

	mov	DWORD PTR i$[rsp], 0

; 42   : 
; 43   : 	if (fname_length > 11)

	cmp	DWORD PTR fname_length$[rsp], 11
	jbe	SHORT $LN16@to_dos_fil

; 44   : 		return;

	jmp	$LN17@to_dos_fil
$LN16@to_dos_fil:

; 45   : 
; 46   : 	if (!fname || !filename)

	cmp	QWORD PTR fname$[rsp], 0
	je	SHORT $LN14@to_dos_fil
	cmp	QWORD PTR filename$[rsp], 0
	jne	SHORT $LN15@to_dos_fil
$LN14@to_dos_fil:

; 47   : 		return;

	jmp	$LN17@to_dos_fil
$LN15@to_dos_fil:

; 48   : 
; 49   : 	memset (fname, ' ', fname_length);

	mov	r8d, DWORD PTR fname_length$[rsp]
	mov	dl, 32					; 00000020H
	mov	rcx, QWORD PTR fname$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 50   : 
; 51   : 	for (i=0; i < strlen (filename)-1 && i < fname_length; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN13@to_dos_fil
$LN12@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN13@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	mov	QWORD PTR tv71[rsp], rax
	mov	rcx, QWORD PTR filename$[rsp]
	call	?strlen@@YA_KPEBD@Z			; strlen
	dec	rax
	mov	rcx, QWORD PTR tv71[rsp]
	cmp	rcx, rax
	jae	$LN11@to_dos_fil
	mov	eax, DWORD PTR fname_length$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jae	SHORT $LN11@to_dos_fil

; 52   : 	{
; 53   : 		if (filename[i] == '.' || i==8)

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN9@to_dos_fil
	cmp	DWORD PTR i$[rsp], 8
	jne	SHORT $LN10@to_dos_fil
$LN9@to_dos_fil:

; 54   : 			break;

	jmp	SHORT $LN11@to_dos_fil
$LN10@to_dos_fil:

; 55   : 
; 56   : 		fname[i] = toupper (filename[i]);

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN19@to_dos_fil
	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN19@to_dos_fil
	mov	DWORD PTR tv132[rsp], 1
	jmp	SHORT $LN20@to_dos_fil
$LN19@to_dos_fil:
	mov	DWORD PTR tv132[rsp], 0
$LN20@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR tv132[rsp]
	imul	ecx, 32					; 00000020H
	sub	eax, ecx
	mov	ecx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR fname$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 57   : 	}

	jmp	$LN12@to_dos_fil
$LN11@to_dos_fil:

; 58   : 
; 59   : 	if (filename[i] =='.')

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 46					; 0000002eH
	jne	SHORT $LN8@to_dos_fil

; 60   : 	{
; 61   : 		for (int k=0; k < 3; k++)

	mov	DWORD PTR k$1[rsp], 0
	jmp	SHORT $LN7@to_dos_fil
$LN6@to_dos_fil:
	mov	eax, DWORD PTR k$1[rsp]
	inc	eax
	mov	DWORD PTR k$1[rsp], eax
$LN7@to_dos_fil:
	cmp	DWORD PTR k$1[rsp], 3
	jge	SHORT $LN5@to_dos_fil

; 62   : 		{
; 63   : 			 ++i;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 64   : 			 if (filename[i])

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN4@to_dos_fil

; 65   : 				 fname[8+k] = filename[i];

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, DWORD PTR k$1[rsp]
	add	ecx, 8
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR fname$[rsp]
	mov	r8, QWORD PTR filename$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al
$LN4@to_dos_fil:

; 66   : 		}

	jmp	SHORT $LN6@to_dos_fil
$LN5@to_dos_fil:
$LN8@to_dos_fil:

; 67   : 	}
; 68   : 
; 69   : 	for (i = 0; i < 3; i++)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN3@to_dos_fil
$LN2@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN3@to_dos_fil:
	cmp	DWORD PTR i$[rsp], 3
	jae	SHORT $LN1@to_dos_fil

; 70   : 		fname[8+i] = toupper (fname[8+i]);

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 8
	mov	eax, eax
	mov	rcx, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN21@to_dos_fil
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 8
	mov	eax, eax
	mov	rcx, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 122				; 0000007aH
	jg	SHORT $LN21@to_dos_fil
	mov	DWORD PTR tv179[rsp], 1
	jmp	SHORT $LN22@to_dos_fil
$LN21@to_dos_fil:
	mov	DWORD PTR tv179[rsp], 0
$LN22@to_dos_fil:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 8
	mov	eax, eax
	mov	rcx, QWORD PTR fname$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	mov	ecx, DWORD PTR tv179[rsp]
	imul	ecx, 32					; 00000020H
	sub	eax, ecx
	mov	ecx, DWORD PTR i$[rsp]
	add	ecx, 8
	mov	ecx, ecx
	mov	rdx, QWORD PTR fname$[rsp]
	mov	BYTE PTR [rdx+rcx], al
	jmp	SHORT $LN2@to_dos_fil
$LN1@to_dos_fil:
$LN17@to_dos_fil:

; 71   : }

	add	rsp, 72					; 00000048H
	ret	0
?to_dos_file_name32@@YAXPEBDPEADI@Z ENDP		; to_dos_file_name32
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
cluster$ = 8
?cluster_to_sector32@@YA_K_K@Z PROC			; cluster_to_sector32

; 33   : {

	mov	QWORD PTR [rsp+8], rcx

; 34   : 	return cluster_begin_lba + (cluster - 2) * sectors_per_cluster ;

	mov	eax, DWORD PTR ?cluster_begin_lba@@3KA	; cluster_begin_lba
	mov	rcx, QWORD PTR cluster$[rsp]
	sub	rcx, 2
	movzx	edx, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	imul	rcx, rdx
	add	rax, rcx

; 35   : }

	ret	0
?cluster_to_sector32@@YA_K_K@Z ENDP			; cluster_to_sector32
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
sector$1 = 32
i$2 = 36
dirent$ = 40
buf$ = 48
file$ = 56
dos_file_name$ = 120
name$3 = 136
$T4 = 192
dir$ = 200
?fat32_locate_dir@@YA?AU_file_@@PEBD@Z PROC		; fat32_locate_dir

; 171  : FILE fat32_locate_dir (const char* dir) {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 168				; 000000a8H

; 172  :     
; 173  : 	FILE file;
; 174  : 	unsigned char* buf;
; 175  : 	fat32_dir *dirent;
; 176  : 
; 177  : 	char dos_file_name[11];
; 178  : 	to_dos_file_name32 (dir, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	?to_dos_file_name32@@YAXPEBDPEADI@Z	; to_dos_file_name32

; 179  : 	//dos_file_name[11]=0;
; 180  : 
; 181  : 	for (unsigned int sector = 0; sector < 14; sector++) {

	mov	DWORD PTR sector$1[rsp], 0
	jmp	SHORT $LN9@fat32_loca
$LN8@fat32_loca:
	mov	eax, DWORD PTR sector$1[rsp]
	inc	eax
	mov	DWORD PTR sector$1[rsp], eax
$LN9@fat32_loca:
	cmp	DWORD PTR sector$1[rsp], 14
	jae	$LN7@fat32_loca

; 182  : 		buf = (unsigned char*)pmmngr_alloc ();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buf$[rsp], rax

; 183  : 		ata_read_28 (root_sector + sector,1, buf);

	mov	eax, DWORD PTR sector$1[rsp]
	mov	ecx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	ecx, eax
	mov	eax, ecx
	mov	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, eax
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 184  : 		dirent = (fat32_dir*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dirent$[rsp], rax

; 185  : 		for (int i=0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN6@fat32_loca
$LN5@fat32_loca:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN6@fat32_loca:
	cmp	DWORD PTR i$2[rsp], 16
	jge	$LN4@fat32_loca

; 186  : 			
; 187  : 			char name[11];
; 188  : 			memcpy (name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rsp]
	call	memcpy

; 189  : 			//name[11] = 0;
; 190  : 
; 191  : 			if (strcmp (dos_file_name, name) == 0) {

	lea	rdx, QWORD PTR name$3[rsp]
	lea	rcx, QWORD PTR dos_file_name$[rsp]
	call	?strcmp@@YAHPEBD0@Z			; strcmp
	test	eax, eax
	jne	$LN3@fat32_loca

; 192  : 				//kprintf ("File found\n");
; 193  : 				strcpy (file.filename, dir);

	mov	rdx, QWORD PTR dir$[rsp]
	lea	rcx, QWORD PTR file$[rsp]
	call	?strcpy@@YAPEADPEADPEBD@Z		; strcpy

; 194  : 				file.id = 0;

	mov	DWORD PTR file$[rsp+32], 0

; 195  : 				file.start_cluster = dirent->first_cluster;

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	DWORD PTR file$[rsp+48], eax

; 196  : 				file.size = dirent->file_size;

	mov	rax, QWORD PTR dirent$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR file$[rsp+36], eax

; 197  : 				file.eof = 0;

	mov	DWORD PTR file$[rsp+40], 0

; 198  : 				file.status = FILE_STATUS_FOUND;

	mov	DWORD PTR file$[rsp+56], 1

; 199  : 
; 200  : 				if (dirent->attrib == 0x10)

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	eax, 16
	jne	SHORT $LN2@fat32_loca

; 201  : 					file.flags = FILE_FLAG_DIRECTORY;

	mov	DWORD PTR file$[rsp+52], 1

; 202  : 				else

	jmp	SHORT $LN1@fat32_loca
$LN2@fat32_loca:

; 203  : 					file.flags = FILE_FLAG_GENERAL;

	mov	DWORD PTR file$[rsp+52], 2
$LN1@fat32_loca:

; 204  : 				
; 205  : 				pmmngr_free(buf);

	mov	rcx, QWORD PTR buf$[rsp]
	call	?pmmngr_free@@YAXPEAX@Z			; pmmngr_free

; 206  : 				return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T4[rsp]
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	mov	rax, QWORD PTR $T4[rsp]
	jmp	SHORT $LN10@fat32_loca
$LN3@fat32_loca:

; 207  : 			}
; 208  : 			dirent++;

	mov	rax, QWORD PTR dirent$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$[rsp], rax

; 209  : 		}

	jmp	$LN5@fat32_loca
$LN4@fat32_loca:

; 210  : 		pmmngr_free(buf);		

	mov	rcx, QWORD PTR buf$[rsp]
	call	?pmmngr_free@@YAXPEAX@Z			; pmmngr_free

; 211  : 	}

	jmp	$LN8@fat32_loca
$LN7@fat32_loca:

; 212  : 
; 213  : 	file.status = FILE_FLAG_INVALID;

	mov	DWORD PTR file$[rsp+56], 3

; 214  : 	file.id = 0;

	mov	DWORD PTR file$[rsp+32], 0

; 215  : 	file.size = 0;

	mov	DWORD PTR file$[rsp+36], 0

; 216  : 	file.eof = 0;

	mov	DWORD PTR file$[rsp+40], 0

; 217  : 	return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T4[rsp]
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	mov	rax, QWORD PTR $T4[rsp]
$LN10@fat32_loca:

; 218  : }

	add	rsp, 168				; 000000a8H
	pop	rdi
	pop	rsi
	ret	0
?fat32_locate_dir@@YA?AU_file_@@PEBD@Z ENDP		; fat32_locate_dir
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
value$ = 36
lba$ = 40
file$ = 64
buf$ = 72
?fat32_read@@YAXPEAU_file_@@PEAE@Z PROC			; fat32_read

; 130  : void fat32_read (FILE *file, unsigned char* buf) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 131  : 
; 132  : 	auto lba = cluster_to_sector32 (file->start_cluster); 

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+48]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	QWORD PTR lba$[rsp], rax

; 133  : 	/*ata_read_28 (lba, 1, buf);
; 134  : 	ata_read_28 (lba + 1, 1, buf + 512);
; 135  : 	ata_read_28 (lba + 2, 1, buf + 512 + 512);
; 136  : 	ata_read_28 (lba + 3, 1, buf + 512 + 512 + 512);
; 137  : 	ata_read_28 (lba + 4, 1, buf + 512 + 512 + 512 + 512);
; 138  : 	ata_read_28 (lba + 5, 1, buf + 512 + 512 + 512 + 512 + 512);
; 139  : 	ata_read_28 (lba + 6, 1, buf + 512 + 512 + 512 + 512 + 512 + 512);
; 140  : 	ata_read_28 (lba + 7, 1, buf + 512 + 512 + 512 + 512 + 512 + 512 + 512);*/
; 141  : 	for (int i = 0; i < 8; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN5@fat32_read
$LN4@fat32_read:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN5@fat32_read:
	cmp	DWORD PTR i$1[rsp], 8
	jge	SHORT $LN3@fat32_read

; 142  : 		ata_read_28 (lba+i,1,buf);

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR lba$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, eax
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 143  : 		buf += 512;

	mov	rax, QWORD PTR buf$[rsp]
	add	rax, 512				; 00000200H
	mov	QWORD PTR buf$[rsp], rax

; 144  : 	}

	jmp	SHORT $LN4@fat32_read
$LN3@fat32_read:

; 145  : 
; 146  : 	//kprintf("Current cluster -> %x\n",file->start_cluster);
; 147  :     uint32_t value = fat32_read_fat (file->start_cluster);

	mov	rax, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR [rax+48]
	call	?fat32_read_fat@@YAII@Z			; fat32_read_fat
	mov	DWORD PTR value$[rsp], eax

; 148  : 	if (value  >= 0x0FFFFFF8) {

	cmp	DWORD PTR value$[rsp], 268435448	; 0ffffff8H
	jb	SHORT $LN2@fat32_read

; 149  : 	    file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+40], 1
$LN2@fat32_read:

; 150  : 	}
; 151  : 
; 152  : 	if (value  == 0x0FFFFFF7) {

	cmp	DWORD PTR value$[rsp], 268435447	; 0ffffff7H
	jne	SHORT $LN1@fat32_read

; 153  : 	    file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+40], 1
$LN1@fat32_read:

; 154  : 	}
; 155  : 
; 156  : 
; 157  : 	file->start_cluster = value;

	mov	rax, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+48], ecx

; 158  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_read@@YAXPEAU_file_@@PEAE@Z ENDP			; fat32_read
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
i$1 = 32
file$ = 64
buf$ = 72
count$ = 80
?fat32_read_file@@YAXPEAU_file_@@PEAEH@Z PROC		; fat32_read_file

; 161  : void fat32_read_file (FILE *file, unsigned char* buf, int count) {

$LN7:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 162  : 	for (int i=0; i < count; i+= 8) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@fat32_read
$LN3@fat32_read:
	mov	eax, DWORD PTR i$1[rsp]
	add	eax, 8
	mov	DWORD PTR i$1[rsp], eax
$LN4@fat32_read:
	mov	eax, DWORD PTR count$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN2@fat32_read

; 163  : 		fat32_read(file,buf);

	mov	rdx, QWORD PTR buf$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	call	?fat32_read@@YAXPEAU_file_@@PEAE@Z	; fat32_read

; 164  : 		if(file->eof) {

	mov	rax, QWORD PTR file$[rsp]
	cmp	DWORD PTR [rax+40], 0
	je	SHORT $LN1@fat32_read

; 165  : 			break;

	jmp	SHORT $LN2@fat32_read
$LN1@fat32_read:

; 166  : 		}
; 167  : 		buf += 4096;

	mov	rax, QWORD PTR buf$[rsp]
	add	rax, 4096				; 00001000H
	mov	QWORD PTR buf$[rsp], rax

; 168  : 	}

	jmp	SHORT $LN3@fat32_read
$LN2@fat32_read:

; 169  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_read_file@@YAXPEAU_file_@@PEAEH@Z ENDP		; fat32_read_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
root_dir$ = 32
i$1 = 36
p$ = 40
path$ = 48
pathname$2 = 56
cur_dir$ = 72
ret$3 = 136
$T4 = 200
ret$ = 264
$T5 = 328
$T6 = 388
$T7 = 448
$T8 = 512
$T9 = 576
$T10 = 640
$T11 = 736
filename$ = 744
?fat32_open@@YA?AU_file_@@PEBD@Z PROC			; fat32_open

; 337  : FILE fat32_open (const char* filename) {

$LN17:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 712				; 000002c8H

; 338  : 
; 339  : 	FILE cur_dir;
; 340  : 	char* p = 0;

	mov	QWORD PTR p$[rsp], 0

; 341  : 	bool  root_dir = true;

	mov	BYTE PTR root_dir$[rsp], 1

; 342  : 	char* path = (char*) filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR path$[rsp], rax

; 343  : 
; 344  : 	//! any '\'s in path ?
; 345  : 	p = strchr (path, '\\');

	mov	edx, 92					; 0000005cH
	mov	rcx, QWORD PTR path$[rsp]
	call	?strchr@@YAPEADPEADH@Z			; strchr
	mov	QWORD PTR p$[rsp], rax

; 346  : 	if (!p) {

	cmp	QWORD PTR p$[rsp], 0
	jne	$LN14@fat32_open

; 347  : 
; 348  : 		//! nope, must be in root directory, search it
; 349  : 		cur_dir = fat32_locate_dir (path);

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	?fat32_locate_dir@@YA?AU_file_@@PEBD@Z	; fat32_locate_dir
	lea	rcx, QWORD PTR $T6[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	lea	rax, QWORD PTR cur_dir$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 60					; 0000003cH
	rep movsb

; 350  : 
; 351  : 		//! found file ?
; 352  : 		if (cur_dir.flags == FILE_FLAG_GENERAL)

	cmp	DWORD PTR cur_dir$[rsp+52], 2
	jne	SHORT $LN13@fat32_open

; 353  : 			return cur_dir;

	lea	rax, QWORD PTR cur_dir$[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN15@fat32_open
$LN13@fat32_open:

; 354  : 
; 355  : 		//! unable to find
; 356  : 		FILE ret;
; 357  : 		ret.flags = FILE_FLAG_INVALID;

	mov	DWORD PTR ret$3[rsp+52], 3

; 358  : 		return ret;

	lea	rax, QWORD PTR ret$3[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN15@fat32_open
$LN14@fat32_open:

; 359  : 	}
; 360  : 
; 361  : 	//! go to next character after first '\'
; 362  : 	p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN12@fat32_open:

; 363  : 
; 364  : 	while (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	$LN11@fat32_open

; 365  : 
; 366  : 		//! get pathname
; 367  : 		char pathname[16];
; 368  : 		int i=0;

	mov	DWORD PTR i$1[rsp], 0

; 369  : 		for (i=0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN10@fat32_open
$LN9@fat32_open:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN10@fat32_open:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN8@fat32_open

; 370  : 
; 371  : 			//! if another '\' or end of line is reached, we are done
; 372  : 			if (p[i] == '\\' || p[i]=='\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 92					; 0000005cH
	je	SHORT $LN6@fat32_open
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN7@fat32_open
$LN6@fat32_open:

; 373  : 				break;

	jmp	SHORT $LN8@fat32_open
$LN7@fat32_open:

; 374  : 
; 375  : 			//! copy character
; 376  : 			pathname[i]=p[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$2[rsp+rcx], al

; 377  : 		}

	jmp	SHORT $LN9@fat32_open
$LN8@fat32_open:

; 378  : 		pathname[i]=0; //null terminate

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$2[rsp+rax], 0

; 379  : 
; 380  : 		//! open subdirectory or file
; 381  : 		if (root_dir) {

	movzx	eax, BYTE PTR root_dir$[rsp]
	test	eax, eax
	je	SHORT $LN5@fat32_open

; 382  : 			//! search root dir -- open pathname
; 383  : 			cur_dir = fat32_locate_dir (pathname);

	lea	rdx, QWORD PTR pathname$2[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	?fat32_locate_dir@@YA?AU_file_@@PEBD@Z	; fat32_locate_dir
	lea	rcx, QWORD PTR $T5[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	lea	rax, QWORD PTR cur_dir$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 60					; 0000003cH
	rep movsb

; 384  : 			root_dir = false;

	mov	BYTE PTR root_dir$[rsp], 0

; 385  : 		}
; 386  : 		else {

	jmp	SHORT $LN4@fat32_open
$LN5@fat32_open:

; 387  : 			//! search a sub directory instead for pathname
; 388  : 			cur_dir = fat32_locate_subdir (cur_dir, pathname);

	lea	rax, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR cur_dir$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 60					; 0000003cH
	rep movsb
	lea	r8, QWORD PTR pathname$2[rsp]
	lea	rdx, QWORD PTR $T7[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	?fat32_locate_subdir@@YA?AU_file_@@U1@PEBD@Z ; fat32_locate_subdir
	lea	rcx, QWORD PTR $T4[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	lea	rax, QWORD PTR cur_dir$[rsp]
	lea	rcx, QWORD PTR $T4[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 60					; 0000003cH
	rep movsb
$LN4@fat32_open:

; 389  : 		}
; 390  : 
; 391  : 		//! found directory or file?
; 392  : 		if (cur_dir.flags == FILE_FLAG_INVALID)

	cmp	DWORD PTR cur_dir$[rsp+52], 3
	jne	SHORT $LN3@fat32_open

; 393  : 			break;

	jmp	SHORT $LN11@fat32_open
$LN3@fat32_open:

; 394  : 
; 395  : 		//! found file?
; 396  : 		if (cur_dir.flags == FILE_FLAG_GENERAL)

	cmp	DWORD PTR cur_dir$[rsp+52], 2
	jne	SHORT $LN2@fat32_open

; 397  : 			return cur_dir;

	lea	rax, QWORD PTR cur_dir$[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
	jmp	SHORT $LN15@fat32_open
$LN2@fat32_open:

; 398  : 
; 399  : 		//! find next '\'
; 400  : 		p=strchr(p+1, '\\');

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	edx, 92					; 0000005cH
	mov	rcx, rax
	call	?strchr@@YAPEADPEADH@Z			; strchr
	mov	QWORD PTR p$[rsp], rax

; 401  : 		if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN1@fat32_open

; 402  : 			p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN1@fat32_open:

; 403  : 	}

	jmp	$LN12@fat32_open
$LN11@fat32_open:

; 404  : 
; 405  : 	//! unable to find
; 406  : 	FILE ret;
; 407  : 	ret.flags = FILE_FLAG_INVALID;

	mov	DWORD PTR ret$[rsp+52], 3

; 408  : 	return ret;

	lea	rax, QWORD PTR ret$[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
$LN15@fat32_open:

; 409  : }

	add	rsp, 712				; 000002c8H
	pop	rdi
	pop	rsi
	ret	0
?fat32_open@@YA?AU_file_@@PEBD@Z ENDP			; fat32_open
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat32.cpp
_TEXT	SEGMENT
fat32_data$ = 32
buf$ = 40
?initialize_fat32@@YAXXZ PROC				; initialize_fat32

; 85   : void initialize_fat32 () {

$LN3:
	sub	rsp, 56					; 00000038H

; 86   : 
; 87   : 	unsigned char *buf = (unsigned char*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR buf$[rsp], rax

; 88   : 	ata_read_28 (2048,1,buf); //partition_begin_lba = 2048

	mov	r8, QWORD PTR buf$[rsp]
	mov	dx, 1
	mov	ecx, 2048				; 00000800H
	call	?ata_read_28@@YAEIGPEAE@Z		; ata_read_28

; 89   : 
; 90   : 	BPB *fat32_data = (BPB*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR fat32_data$[rsp], rax

; 91   : 
; 92   : 	part_lba = 2048;

	mov	DWORD PTR ?part_lba@@3IA, 2048		; part_lba, 00000800H

; 93   : 
; 94   : #if 0
; 95   : 	printf ("FAT32 BOOT PARAMETER BLOCK\n");
; 96   : 	printf ("Bytes/Sector -> %d\n", fat32_data->bytes_per_sector);
; 97   : 	printf ("Sectors/Cluster -> %d\n", fat32_data->sectors_per_cluster);
; 98   : 	printf ("Reserved Sectors -> %d\n", fat32_data->reserved_sectors);
; 99   : 	printf ("Number Of FATs -> %d\n", fat32_data->num_fats);
; 100  : 	printf ("Root Base Cluster -> %d\n", fat32_data->info.FAT32.root_dir_cluster);
; 101  : 	printf ("Sector/FAT32 -> %d\n", fat32_data->info.FAT32.sect_per_fat32);
; 102  : 	for (int i=0; i <12; i++) {
; 103  : 		putc(fat32_data->info.FAT32.vol_label[i]);
; 104  : 	}
; 105  : 	for (int i=0; i <9; i++) {
; 106  : 		putc(fat32_data->info.FAT32.sys_id[i]);
; 107  : 	}
; 108  : #endif
; 109  : 
; 110  : 	fat_begin_lba = part_lba + fat32_data->reserved_sectors;

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	ecx, DWORD PTR ?part_lba@@3IA		; part_lba
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ?fat_begin_lba@@3KA, eax	; fat_begin_lba

; 111  : 	cluster_begin_lba = part_lba + fat32_data->reserved_sectors + (fat32_data->num_fats * fat32_data->info.FAT32.sect_per_fat32);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	ecx, DWORD PTR ?part_lba@@3IA		; part_lba
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movzx	ecx, BYTE PTR [rcx+16]
	mov	rdx, QWORD PTR fat32_data$[rsp]
	imul	ecx, DWORD PTR [rdx+36]
	add	eax, ecx
	mov	DWORD PTR ?cluster_begin_lba@@3KA, eax	; cluster_begin_lba

; 112  : 	sectors_per_cluster = fat32_data->sectors_per_cluster;

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, BYTE PTR [rax+13]
	mov	BYTE PTR ?sectors_per_cluster@@3EA, al	; sectors_per_cluster

; 113  : 	root_dir_first_cluster = fat32_data->info.FAT32.root_dir_cluster;

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rax+44]
	mov	DWORD PTR ?root_dir_first_cluster@@3KA, eax ; root_dir_first_cluster

; 114  : 	root_sector = cluster_to_sector32 (root_dir_first_cluster);

	mov	eax, DWORD PTR ?root_dir_first_cluster@@3KA ; root_dir_first_cluster
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR ?root_sector@@3KA, eax	; root_sector

; 115  : 	sectors_per_fat32 = fat32_data->info.FAT32.sect_per_fat32;

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR ?sectors_per_fat32@@3IA, eax	; sectors_per_fat32

; 116  : 
; 117  : }

	add	rsp, 56					; 00000038H
	ret	0
?initialize_fat32@@YAXXZ ENDP				; initialize_fat32
_TEXT	ENDS
END
