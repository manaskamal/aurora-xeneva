; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?pci_config_read32@@YAIPEBU_pci_address_@@G@Z	; pci_config_read32
PUBLIC	?pci_config_read16@@YAGPEBU_pci_address_@@G@Z	; pci_config_read16
PUBLIC	?pci_config_read8@@YAEPEBU_pci_address_@@G@Z	; pci_config_read8
PUBLIC	?pci_config_write32@@YAXPEBU_pci_address_@@GI@Z	; pci_config_write32
PUBLIC	?pci_config_write16@@YAXPEBU_pci_address_@@GG@Z	; pci_config_write16
PUBLIC	?pci_config_write8@@YAXPEBU_pci_address_@@GE@Z	; pci_config_write8
PUBLIC	?pci_scan_bus@@YA_NPEAU_pci_scan_state_@@@Z	; pci_scan_bus
PUBLIC	?pci_find_device@@YA_NGGPEAU_pci_address_@@@Z	; pci_find_device
PUBLIC	?pci_setBAR@@YAXPEBU_pci_address_@@HI@Z		; pci_setBAR
PUBLIC	?pci_get_bar_addr@@YAIPEBU_pci_address_@@H@Z	; pci_get_bar_addr
PUBLIC	?pci_set_mem_enable@@YAXPEBU_pci_address_@@_N@Z	; pci_set_mem_enable
EXTRN	?inportb@@YAEG@Z:PROC				; inportb
EXTRN	?inportw@@YAGG@Z:PROC				; inportw
EXTRN	?inportd@@YAIG@Z:PROC				; inportd
EXTRN	?outportb@@YAXGE@Z:PROC				; outportb
EXTRN	?outportw@@YAXGG@Z:PROC				; outportw
EXTRN	?outportd@@YAXGI@Z:PROC				; outportd
pdata	SEGMENT
$pdata$?pci_config_read32@@YAIPEBU_pci_address_@@G@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?pci_config_read32@@YAIPEBU_pci_address_@@G@Z
$pdata$?pci_config_read16@@YAGPEBU_pci_address_@@G@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?pci_config_read16@@YAGPEBU_pci_address_@@G@Z
$pdata$?pci_config_read8@@YAEPEBU_pci_address_@@G@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?pci_config_read8@@YAEPEBU_pci_address_@@G@Z
$pdata$?pci_config_write32@@YAXPEBU_pci_address_@@GI@Z DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$?pci_config_write32@@YAXPEBU_pci_address_@@GI@Z
$pdata$?pci_config_write16@@YAXPEBU_pci_address_@@GG@Z DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$?pci_config_write16@@YAXPEBU_pci_address_@@GG@Z
$pdata$?pci_config_write8@@YAXPEBU_pci_address_@@GE@Z DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?pci_config_write8@@YAXPEBU_pci_address_@@GE@Z
$pdata$?pci_scan_bus@@YA_NPEAU_pci_scan_state_@@@Z DD imagerel $LN9
	DD	imagerel $LN9+302
	DD	imagerel $unwind$?pci_scan_bus@@YA_NPEAU_pci_scan_state_@@@Z
$pdata$?pci_find_device@@YA_NGGPEAU_pci_address_@@@Z DD imagerel $LN6
	DD	imagerel $LN6+118
	DD	imagerel $unwind$?pci_find_device@@YA_NGGPEAU_pci_address_@@@Z
$pdata$?pci_setBAR@@YAXPEBU_pci_address_@@HI@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?pci_setBAR@@YAXPEBU_pci_address_@@HI@Z
$pdata$?pci_get_bar_addr@@YAIPEBU_pci_address_@@H@Z DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$?pci_get_bar_addr@@YAIPEBU_pci_address_@@H@Z
$pdata$?pci_set_mem_enable@@YAXPEBU_pci_address_@@_N@Z DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$?pci_set_mem_enable@@YAXPEBU_pci_address_@@_N@Z
$pdata$?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z DD imagerel ?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z
	DD	imagerel ?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z+76
	DD	imagerel $unwind$?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?pci_config_read32@@YAIPEBU_pci_address_@@G@Z DD 010e01H
	DD	0420eH
$unwind$?pci_config_read16@@YAGPEBU_pci_address_@@G@Z DD 010e01H
	DD	0420eH
$unwind$?pci_config_read8@@YAEPEBU_pci_address_@@G@Z DD 010e01H
	DD	0420eH
$unwind$?pci_config_write32@@YAXPEBU_pci_address_@@GI@Z DD 011301H
	DD	04213H
$unwind$?pci_config_write16@@YAXPEBU_pci_address_@@GG@Z DD 011401H
	DD	04214H
$unwind$?pci_config_write8@@YAXPEBU_pci_address_@@GE@Z DD 011301H
	DD	04213H
$unwind$?pci_scan_bus@@YA_NPEAU_pci_scan_state_@@@Z DD 030b01H
	DD	07007e20bH
	DD	06006H
$unwind$?pci_find_device@@YA_NGGPEAU_pci_address_@@@Z DD 031501H
	DD	070116215H
	DD	06010H
$unwind$?pci_setBAR@@YAXPEBU_pci_address_@@HI@Z DD 011201H
	DD	04212H
$unwind$?pci_get_bar_addr@@YAIPEBU_pci_address_@@H@Z DD 010d01H
	DD	0620dH
$unwind$?pci_set_mem_enable@@YAXPEBU_pci_address_@@_N@Z DD 010d01H
	DD	0620dH
$unwind$?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z DD 010e01H
	DD	0220eH
xdata	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
enable_bit$ = 0
addr$ = 32
offset$ = 40
?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z PROC ; pci_config_pack_address

; 19   : static uint32_t pci_config_pack_address (const pci_address *addr, uint16_t offset) {

	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 20   : 
; 21   : 	const uint32_t enable_bit = 0x80000000UL;

	mov	DWORD PTR enable_bit$[rsp], -2147483648	; 80000000H

; 22   : 
; 23   : 	return (((uint32_t)addr->bus << 16) |
; 24   : 		((uint32_t)addr->device << 11) |
; 25   : 		((uint32_t)addr->function << 8) |
; 26   : 		offset | enable_bit);

	mov	rax, QWORD PTR addr$[rsp]
	movzx	eax, BYTE PTR [rax]
	shl	eax, 16
	mov	rcx, QWORD PTR addr$[rsp]
	movzx	ecx, BYTE PTR [rcx+1]
	shl	ecx, 11
	or	eax, ecx
	mov	rcx, QWORD PTR addr$[rsp]
	movzx	ecx, BYTE PTR [rcx+2]
	shl	ecx, 8
	or	eax, ecx
	movzx	ecx, WORD PTR offset$[rsp]
	or	eax, ecx
	bts	eax, 31

; 27   : }

	add	rsp, 24
	ret	0
?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z ENDP ; pci_config_pack_address
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
command$ = 32
flags$ = 36
addr$ = 64
enable$ = 72
?pci_set_mem_enable@@YAXPEBU_pci_address_@@_N@Z PROC	; pci_set_mem_enable

; 114  : void pci_set_mem_enable (const pci_address *addr, bool enable) {

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 115  : 	uint16_t command = pci_config_read16 (addr, offsetof (pci_config_space, command));

	mov	dx, 4
	mov	rcx, QWORD PTR addr$[rsp]
	call	?pci_config_read16@@YAGPEBU_pci_address_@@G@Z ; pci_config_read16
	mov	WORD PTR command$[rsp], ax

; 116  : 
; 117  : 	const uint16_t flags = 0x0007;

	mov	eax, 7
	mov	WORD PTR flags$[rsp], ax

; 118  : 
; 119  : 	if (enable) {

	movzx	eax, BYTE PTR enable$[rsp]
	test	eax, eax
	je	SHORT $LN2@pci_set_me

; 120  : 		command |= flags;

	movzx	eax, WORD PTR command$[rsp]
	or	eax, 7
	mov	WORD PTR command$[rsp], ax

; 121  : 	}else {

	jmp	SHORT $LN1@pci_set_me
$LN2@pci_set_me:

; 122  : 		command &= ~flags;

	movzx	eax, WORD PTR command$[rsp]
	and	eax, -8
	mov	WORD PTR command$[rsp], ax
$LN1@pci_set_me:

; 123  : 	}
; 124  : 
; 125  : 	pci_config_write16 (addr, offsetof (pci_config_space, command), command);

	movzx	r8d, WORD PTR command$[rsp]
	mov	dx, 4
	mov	rcx, QWORD PTR addr$[rsp]
	call	?pci_config_write16@@YAXPEBU_pci_address_@@GG@Z ; pci_config_write16

; 126  : }

	add	rsp, 56					; 00000038H
	ret	0
?pci_set_mem_enable@@YAXPEBU_pci_address_@@_N@Z ENDP	; pci_set_mem_enable
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
tv75 = 32
bar$ = 36
mask$ = 40
addr$ = 64
index$ = 72
?pci_get_bar_addr@@YAIPEBU_pci_address_@@H@Z PROC	; pci_get_bar_addr

; 106  : uint32_t pci_get_bar_addr (const pci_address *addr, int index) {

$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 107  : 	uint32_t bar = pci_config_read32 (addr, offsetof (pci_config_space, BAR[index]));

	mov	eax, 16
	movsxd	rcx, DWORD PTR index$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	movzx	edx, ax
	mov	rcx, QWORD PTR addr$[rsp]
	call	?pci_config_read32@@YAIPEBU_pci_address_@@G@Z ; pci_config_read32
	mov	DWORD PTR bar$[rsp], eax

; 108  : 	uint32_t mask = (bar & PCI_CONF_BAR_IO) ? 0x3 : 0xf;

	mov	eax, DWORD PTR bar$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN3@pci_get_ba
	mov	DWORD PTR tv75[rsp], 3
	jmp	SHORT $LN4@pci_get_ba
$LN3@pci_get_ba:
	mov	DWORD PTR tv75[rsp], 15
$LN4@pci_get_ba:
	mov	eax, DWORD PTR tv75[rsp]
	mov	DWORD PTR mask$[rsp], eax

; 109  : 
; 110  : 	return bar & ~mask;

	mov	eax, DWORD PTR mask$[rsp]
	not	eax
	mov	ecx, DWORD PTR bar$[rsp]
	and	ecx, eax
	mov	eax, ecx

; 111  : }

	add	rsp, 56					; 00000038H
	ret	0
?pci_get_bar_addr@@YAIPEBU_pci_address_@@H@Z ENDP	; pci_get_bar_addr
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
addr$ = 48
index$ = 56
value$ = 64
?pci_setBAR@@YAXPEBU_pci_address_@@HI@Z PROC		; pci_setBAR

; 101  : void pci_setBAR (const pci_address *addr, int index, uint32_t value) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 102  : 	pci_config_write32 (addr, offsetof (pci_config_space,BAR[index]),value);

	mov	eax, 16
	movsxd	rcx, DWORD PTR index$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	r8d, DWORD PTR value$[rsp]
	movzx	edx, ax
	mov	rcx, QWORD PTR addr$[rsp]
	call	?pci_config_write32@@YAXPEBU_pci_address_@@GI@Z ; pci_config_write32

; 103  : }

	add	rsp, 40					; 00000028H
	ret	0
?pci_setBAR@@YAXPEBU_pci_address_@@HI@Z ENDP		; pci_setBAR
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
bus_scan$ = 32
vendor_id$ = 80
device_id$ = 88
addr_out$ = 96
?pci_find_device@@YA_NGGPEAU_pci_address_@@@Z PROC	; pci_find_device

; 88   : bool pci_find_device (uint16_t vendor_id, uint16_t device_id, pci_address *addr_out) {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	WORD PTR [rsp+8], cx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 89   : 	pci_scan_state bus_scan = {};

	lea	rax, QWORD PTR bus_scan$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 10
	rep stosb
$LN3@pci_find_d:

; 90   : 
; 91   : 	while (pci_scan_bus (&bus_scan)) {

	lea	rcx, QWORD PTR bus_scan$[rsp]
	call	?pci_scan_bus@@YA_NPEAU_pci_scan_state_@@@Z ; pci_scan_bus
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@pci_find_d

; 92   : 		if (bus_scan.vendor_id == vendor_id && bus_scan.device_id == device_id) {

	movzx	eax, WORD PTR bus_scan$[rsp]
	movzx	ecx, WORD PTR vendor_id$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN1@pci_find_d
	movzx	eax, WORD PTR bus_scan$[rsp+2]
	movzx	ecx, WORD PTR device_id$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN1@pci_find_d

; 93   : 			*addr_out = bus_scan.addr;

	lea	rax, QWORD PTR bus_scan$[rsp+7]
	mov	rdi, QWORD PTR addr_out$[rsp]
	mov	rsi, rax
	mov	ecx, 3
	rep movsb

; 94   : 			return true;

	mov	al, 1
	jmp	SHORT $LN4@pci_find_d
$LN1@pci_find_d:

; 95   : 		}
; 96   : 	}

	jmp	SHORT $LN3@pci_find_d
$LN2@pci_find_d:

; 97   : 
; 98   : 	return false;

	xor	al, al
$LN4@pci_find_d:

; 99   : }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
?pci_find_device@@YA_NGGPEAU_pci_address_@@@Z ENDP	; pci_find_device
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
tv77 = 32
tv86 = 33
tv95 = 34
config$ = 48
state$ = 144
?pci_scan_bus@@YA_NPEAU_pci_scan_state_@@@Z PROC	; pci_scan_bus

; 61   : bool pci_scan_bus (pci_scan_state *state) {

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 120				; 00000078H
$LN6@pci_scan_b:

; 62   : 	pci_config_space config;
; 63   : 	
; 64   : 	for (;;) {
; 65   : 		config.words[0] = pci_config_read32(&state->next_addr, 0);

	mov	rax, QWORD PTR state$[rsp]
	add	rax, 4
	xor	edx, edx
	mov	rcx, rax
	call	?pci_config_read32@@YAIPEBU_pci_address_@@G@Z ; pci_config_read32
	mov	ecx, 4
	imul	rcx, 0
	mov	DWORD PTR config$[rsp+rcx], eax

; 66   : 
; 67   : 		state->addr = state->next_addr;

	mov	rax, QWORD PTR state$[rsp]
	mov	rcx, QWORD PTR state$[rsp]
	lea	rdi, QWORD PTR [rax+7]
	lea	rsi, QWORD PTR [rcx+4]
	mov	ecx, 3
	rep movsb

; 68   : 
; 69   : 		if (++state->next_addr.function == 0x8) {

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+6]
	inc	al
	mov	BYTE PTR tv77[rsp], al
	mov	rax, QWORD PTR state$[rsp]
	movzx	ecx, BYTE PTR tv77[rsp]
	mov	BYTE PTR [rax+6], cl
	movzx	eax, BYTE PTR tv77[rsp]
	cmp	eax, 8
	jne	SHORT $LN4@pci_scan_b

; 70   : 			state->next_addr.function = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+6], 0

; 71   : 			if (++state->next_addr.device == 0x20) {

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+5]
	inc	al
	mov	BYTE PTR tv86[rsp], al
	mov	rax, QWORD PTR state$[rsp]
	movzx	ecx, BYTE PTR tv86[rsp]
	mov	BYTE PTR [rax+5], cl
	movzx	eax, BYTE PTR tv86[rsp]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN3@pci_scan_b

; 72   : 				state->next_addr.device = 0;

	mov	rax, QWORD PTR state$[rsp]
	mov	BYTE PTR [rax+5], 0

; 73   : 				if (++state->next_addr.bus == PCI_MAX_BUS) {

	mov	rax, QWORD PTR state$[rsp]
	movzx	eax, BYTE PTR [rax+4]
	inc	al
	mov	BYTE PTR tv95[rsp], al
	mov	rax, QWORD PTR state$[rsp]
	movzx	ecx, BYTE PTR tv95[rsp]
	mov	BYTE PTR [rax+4], cl
	movzx	eax, BYTE PTR tv95[rsp]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN2@pci_scan_b

; 74   : 					return false;

	xor	al, al
	jmp	SHORT $LN7@pci_scan_b
$LN2@pci_scan_b:
$LN3@pci_scan_b:
$LN4@pci_scan_b:

; 75   : 				}
; 76   : 			}
; 77   : 		}
; 78   : 
; 79   : 		if (config.words[0] != 0xFFFFFFFFUL) {

	mov	eax, 4
	imul	rax, 0
	cmp	DWORD PTR config$[rsp+rax], -1		; ffffffffH
	je	SHORT $LN1@pci_scan_b

; 80   : 			state->vendor_id = config.vendor_id;

	mov	rax, QWORD PTR state$[rsp]
	movzx	ecx, WORD PTR config$[rsp]
	mov	WORD PTR [rax], cx

; 81   : 			state->device_id = config.device_id;

	mov	rax, QWORD PTR state$[rsp]
	movzx	ecx, WORD PTR config$[rsp+2]
	mov	WORD PTR [rax+2], cx

; 82   : 			return true;

	mov	al, 1
	jmp	SHORT $LN7@pci_scan_b
$LN1@pci_scan_b:

; 83   : 		}
; 84   : 	}

	jmp	$LN6@pci_scan_b
$LN7@pci_scan_b:

; 85   : }

	add	rsp, 120				; 00000078H
	pop	rdi
	pop	rsi
	ret	0
?pci_scan_bus@@YA_NPEAU_pci_scan_state_@@@Z ENDP	; pci_scan_bus
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
addr$ = 48
offset$ = 56
data$ = 64
?pci_config_write8@@YAXPEBU_pci_address_@@GE@Z PROC	; pci_config_write8

; 55   : void pci_config_write8 (const pci_address *addr, uint16_t offset, uint8_t data) {

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 56   : 	outportd (PCI_REG_CONFIG_ADDRESS, pci_config_pack_address(addr, offset));

	movzx	edx, WORD PTR offset$[rsp]
	mov	rcx, QWORD PTR addr$[rsp]
	call	?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z ; pci_config_pack_address
	mov	edx, eax
	mov	cx, 3320				; 00000cf8H
	call	?outportd@@YAXGI@Z			; outportd

; 57   : 	outportb (PCI_REG_CONFIG_DATA, data);

	movzx	edx, BYTE PTR data$[rsp]
	mov	cx, 3324				; 00000cfcH
	call	?outportb@@YAXGE@Z			; outportb

; 58   : }

	add	rsp, 40					; 00000028H
	ret	0
?pci_config_write8@@YAXPEBU_pci_address_@@GE@Z ENDP	; pci_config_write8
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
addr$ = 48
offset$ = 56
data$ = 64
?pci_config_write16@@YAXPEBU_pci_address_@@GG@Z PROC	; pci_config_write16

; 50   : void pci_config_write16 (const pci_address *addr, uint16_t offset, uint16_t data) {

$LN3:
	mov	WORD PTR [rsp+24], r8w
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 51   : 	outportd (PCI_REG_CONFIG_ADDRESS, pci_config_pack_address (addr, offset));

	movzx	edx, WORD PTR offset$[rsp]
	mov	rcx, QWORD PTR addr$[rsp]
	call	?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z ; pci_config_pack_address
	mov	edx, eax
	mov	cx, 3320				; 00000cf8H
	call	?outportd@@YAXGI@Z			; outportd

; 52   : 	outportw (PCI_REG_CONFIG_DATA, data);

	movzx	edx, WORD PTR data$[rsp]
	mov	cx, 3324				; 00000cfcH
	call	?outportw@@YAXGG@Z			; outportw

; 53   : }

	add	rsp, 40					; 00000028H
	ret	0
?pci_config_write16@@YAXPEBU_pci_address_@@GG@Z ENDP	; pci_config_write16
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
addr$ = 48
offset$ = 56
data$ = 64
?pci_config_write32@@YAXPEBU_pci_address_@@GI@Z PROC	; pci_config_write32

; 45   : void pci_config_write32 (const pci_address *addr, uint16_t offset, uint32_t data) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 46   : 	outportd (PCI_REG_CONFIG_ADDRESS, pci_config_pack_address (addr, offset));

	movzx	edx, WORD PTR offset$[rsp]
	mov	rcx, QWORD PTR addr$[rsp]
	call	?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z ; pci_config_pack_address
	mov	edx, eax
	mov	cx, 3320				; 00000cf8H
	call	?outportd@@YAXGI@Z			; outportd

; 47   : 	outportd (PCI_REG_CONFIG_DATA, data);

	mov	edx, DWORD PTR data$[rsp]
	mov	cx, 3324				; 00000cfcH
	call	?outportd@@YAXGI@Z			; outportd

; 48   : }

	add	rsp, 40					; 00000028H
	ret	0
?pci_config_write32@@YAXPEBU_pci_address_@@GI@Z ENDP	; pci_config_write32
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
addr$ = 48
offset$ = 56
?pci_config_read8@@YAEPEBU_pci_address_@@G@Z PROC	; pci_config_read8

; 40   : uint8_t pci_config_read8 (const pci_address *addr, uint16_t offset) {

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 41   : 	outportd (PCI_REG_CONFIG_ADDRESS, pci_config_pack_address (addr, offset));

	movzx	edx, WORD PTR offset$[rsp]
	mov	rcx, QWORD PTR addr$[rsp]
	call	?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z ; pci_config_pack_address
	mov	edx, eax
	mov	cx, 3320				; 00000cf8H
	call	?outportd@@YAXGI@Z			; outportd

; 42   : 	return inportb (PCI_REG_CONFIG_DATA);

	mov	cx, 3324				; 00000cfcH
	call	?inportb@@YAEG@Z			; inportb

; 43   : }

	add	rsp, 40					; 00000028H
	ret	0
?pci_config_read8@@YAEPEBU_pci_address_@@G@Z ENDP	; pci_config_read8
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
addr$ = 48
offset$ = 56
?pci_config_read16@@YAGPEBU_pci_address_@@G@Z PROC	; pci_config_read16

; 35   : uint16_t pci_config_read16 (const pci_address *addr, uint16_t offset) {

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 36   : 	outportd (PCI_REG_CONFIG_ADDRESS, pci_config_pack_address (addr, offset));

	movzx	edx, WORD PTR offset$[rsp]
	mov	rcx, QWORD PTR addr$[rsp]
	call	?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z ; pci_config_pack_address
	mov	edx, eax
	mov	cx, 3320				; 00000cf8H
	call	?outportd@@YAXGI@Z			; outportd

; 37   : 	return inportw (PCI_REG_CONFIG_DATA);

	mov	cx, 3324				; 00000cfcH
	call	?inportw@@YAGG@Z			; inportw

; 38   : }

	add	rsp, 40					; 00000028H
	ret	0
?pci_config_read16@@YAGPEBU_pci_address_@@G@Z ENDP	; pci_config_read16
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
addr$ = 48
offset$ = 56
?pci_config_read32@@YAIPEBU_pci_address_@@G@Z PROC	; pci_config_read32

; 30   : uint32_t pci_config_read32 (const pci_address *addr, uint16_t offset) {

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 31   : 	outportd (PCI_REG_CONFIG_ADDRESS, pci_config_pack_address (addr, offset));

	movzx	edx, WORD PTR offset$[rsp]
	mov	rcx, QWORD PTR addr$[rsp]
	call	?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z ; pci_config_pack_address
	mov	edx, eax
	mov	cx, 3320				; 00000cf8H
	call	?outportd@@YAXGI@Z			; outportd

; 32   : 	return inportd (PCI_REG_CONFIG_DATA);

	mov	cx, 3324				; 00000cfcH
	call	?inportd@@YAIG@Z			; inportd

; 33   : }

	add	rsp, 40					; 00000028H
	ret	0
?pci_config_read32@@YAIPEBU_pci_address_@@G@Z ENDP	; pci_config_read32
_TEXT	ENDS
END
