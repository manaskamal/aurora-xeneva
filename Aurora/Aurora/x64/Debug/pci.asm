; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?v_i@@3HA					; v_i
_BSS	SEGMENT
?v_i@@3HA DD	01H DUP (?)				; v_i
_BSS	ENDS
CONST	SEGMENT
$SG3758	DB	'MSI-X found for this device', 0aH, 00H
	ORG $+3
$SG3760	DB	'MSI found for this device', 0aH, 00H
	ORG $+5
$SG3765	DB	'MSI-DATA -> %x', 0aH, 00H
$SG3770	DB	'MSG Control -> %x', 0aH, 00H
	ORG $+5
$SG3777	DB	'MSI 64BIT Capable', 0aH, 00H
	ORG $+5
$SG3779	DB	'MSI Mask Capable', 0aH, 00H
	ORG $+6
$SG3780	DB	'MSI interrupt for this device enabled msi reg -> %x', 0aH
	DB	00H
CONST	ENDS
PUBLIC	?read_config_header@@YAXHHHPEATpci_device_info@@@Z ; read_config_header
PUBLIC	?read_config_16@@YAXGHHHHPEAG@Z			; read_config_16
PUBLIC	?write_config_16@@YAXGHHHHG@Z			; write_config_16
PUBLIC	?read_config_32@@YAXGHHHHI@Z			; read_config_32
PUBLIC	?read_config_8@@YAXGHHHHPEAE@Z			; read_config_8
PUBLIC	?write_config_8@@YAXGHHHHE@Z			; write_config_8
PUBLIC	?read_config_32_ext@@YAXGHHHHPEAI@Z		; read_config_32_ext
PUBLIC	?write_config_32@@YAXHHHHI@Z			; write_config_32
PUBLIC	?pci_find_device_class@@YA_NEEPEATpci_device_info@@PEAH11@Z ; pci_find_device_class
PUBLIC	?pci_find_device_id@@YA_NGGPEATpci_device_info@@@Z ; pci_find_device_id
PUBLIC	?pci_alloc_msi@@YA_NHHHP6AX_KPEAX@Z@Z		; pci_alloc_msi
PUBLIC	?pci_enable_bus_master@@YAXHHH@Z		; pci_enable_bus_master
PUBLIC	?pci_enable_interrupt@@YAXHHH@Z			; pci_enable_interrupt
PUBLIC	?pcie_supported@@YA_NXZ				; pcie_supported
PUBLIC	?pci_config_read32@@YAIPEBU_pci_address_@@G@Z	; pci_config_read32
PUBLIC	?pcie_find_device@@YA_KGHHH@Z			; pcie_find_device
PUBLIC	??$mem_after@PEAUacpiMcfgAlloc@@UacpiMcfg@@@@YAPEAUacpiMcfgAlloc@@PEAUacpiMcfg@@@Z ; mem_after<acpiMcfgAlloc * __ptr64,acpiMcfg>
PUBLIC	??$raw_diff@UacpiMcfgAlloc@@UacpiMcfg@@@@YAHPEAUacpiMcfgAlloc@@PEAUacpiMcfg@@@Z ; raw_diff<acpiMcfgAlloc,acpiMcfg>
PUBLIC	??$raw_offset@PECEPEAX@@YAPECEPEAXH@Z		; raw_offset<unsigned char volatile * __ptr64,void * __ptr64>
PUBLIC	??$raw_offset@PECIPEAX@@YAPECIPEAXH@Z		; raw_offset<unsigned int volatile * __ptr64,void * __ptr64>
PUBLIC	??$raw_offset@PECGPEAX@@YAPECGPEAXH@Z		; raw_offset<unsigned short volatile * __ptr64,void * __ptr64>
PUBLIC	?pci_get_msi_addr@@YA_KPEA_K_KIEE@Z		; pci_get_msi_addr
EXTRN	x64_inportb:PROC
EXTRN	x64_inportw:PROC
EXTRN	x64_inportd:PROC
EXTRN	x64_outportw:PROC
EXTRN	x64_outportd:PROC
EXTRN	?setvect@@YAX_KP6AX0PEAX@Z@Z:PROC		; setvect
EXTRN	?inportd@@YAIG@Z:PROC				; inportd
EXTRN	?outportb@@YAXGE@Z:PROC				; outportb
EXTRN	?outportd@@YAXGI@Z:PROC				; outportd
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
EXTRN	?acpi_pcie_supported@@YA_NXZ:PROC		; acpi_pcie_supported
EXTRN	?acpi_get_mcfg@@YAPEAUacpiMcfg@@XZ:PROC		; acpi_get_mcfg
pdata	SEGMENT
$pdata$?read_config_header@@YAXHHHPEATpci_device_info@@@Z DD imagerel $LN7
	DD	imagerel $LN7+171
	DD	imagerel $unwind$?read_config_header@@YAXHHHPEATpci_device_info@@@Z
$pdata$?read_config_16@@YAXGHHHHPEAG@Z DD imagerel $LN6
	DD	imagerel $LN6+233
	DD	imagerel $unwind$?read_config_16@@YAXGHHHHPEAG@Z
$pdata$?write_config_16@@YAXGHHHHG@Z DD imagerel $LN6
	DD	imagerel $LN6+232
	DD	imagerel $unwind$?write_config_16@@YAXGHHHHG@Z
$pdata$?read_config_32@@YAXGHHHHI@Z DD imagerel $LN6
	DD	imagerel $LN6+198
	DD	imagerel $unwind$?read_config_32@@YAXGHHHHI@Z
$pdata$?read_config_8@@YAXGHHHHPEAE@Z DD imagerel $LN6
	DD	imagerel $LN6+238
	DD	imagerel $unwind$?read_config_8@@YAXGHHHHPEAE@Z
$pdata$?write_config_8@@YAXGHHHHE@Z DD imagerel $LN6
	DD	imagerel $LN6+233
	DD	imagerel $unwind$?write_config_8@@YAXGHHHHE@Z
$pdata$?read_config_32_ext@@YAXGHHHHPEAI@Z DD imagerel $LN6
	DD	imagerel $LN6+199
	DD	imagerel $unwind$?read_config_32_ext@@YAXGHHHHPEAI@Z
$pdata$?write_config_32@@YAXHHHHI@Z DD imagerel $LN3
	DD	imagerel $LN3+109
	DD	imagerel $unwind$?write_config_32@@YAXHHHHI@Z
$pdata$?pci_find_device_class@@YA_NEEPEATpci_device_info@@PEAH11@Z DD imagerel $LN18
	DD	imagerel $LN18+956
	DD	imagerel $unwind$?pci_find_device_class@@YA_NEEPEATpci_device_info@@PEAH11@Z
$pdata$?pci_find_device_id@@YA_NGGPEATpci_device_info@@@Z DD imagerel $LN13
	DD	imagerel $LN13+277
	DD	imagerel $unwind$?pci_find_device_id@@YA_NGGPEATpci_device_info@@@Z
$pdata$?pci_alloc_msi@@YA_NHHHP6AX_KPEAX@Z@Z DD imagerel $LN17
	DD	imagerel $LN17+1051
	DD	imagerel $unwind$?pci_alloc_msi@@YA_NHHHP6AX_KPEAX@Z@Z
$pdata$?pci_enable_bus_master@@YAXHHH@Z DD imagerel $LN3
	DD	imagerel $LN3+134
	DD	imagerel $unwind$?pci_enable_bus_master@@YAXHHH@Z
$pdata$?pci_enable_interrupt@@YAXHHH@Z DD imagerel $LN3
	DD	imagerel $LN3+121
	DD	imagerel $unwind$?pci_enable_interrupt@@YAXHHH@Z
$pdata$?pcie_supported@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+29
	DD	imagerel $unwind$?pcie_supported@@YA_NXZ
$pdata$?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z DD imagerel ?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z
	DD	imagerel ?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z+76
	DD	imagerel $unwind$?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z
$pdata$?pci_config_read32@@YAIPEBU_pci_address_@@G@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?pci_config_read32@@YAIPEBU_pci_address_@@G@Z
$pdata$?pcie_find_device@@YA_KGHHH@Z DD imagerel $LN11
	DD	imagerel $LN11+274
	DD	imagerel $unwind$?pcie_find_device@@YA_KGHHH@Z
$pdata$?pci_get_msi_addr@@YA_KPEA_K_KIEE@Z DD imagerel $LN7
	DD	imagerel $LN7+131
	DD	imagerel $unwind$?pci_get_msi_addr@@YA_KPEA_K_KIEE@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?read_config_header@@YAXHHHPEATpci_device_info@@@Z DD 011601H
	DD	06216H
$unwind$?read_config_16@@YAXGHHHHPEAG@Z DD 011701H
	DD	08217H
$unwind$?write_config_16@@YAXGHHHHG@Z DD 011701H
	DD	08217H
$unwind$?read_config_32@@YAXGHHHHI@Z DD 011701H
	DD	08217H
$unwind$?read_config_8@@YAXGHHHHPEAE@Z DD 011701H
	DD	08217H
$unwind$?write_config_8@@YAXGHHHHE@Z DD 011701H
	DD	08217H
$unwind$?read_config_32_ext@@YAXGHHHHPEAI@Z DD 011701H
	DD	08217H
$unwind$?write_config_32@@YAXHHHHI@Z DD 011601H
	DD	06216H
$unwind$?pci_find_device_class@@YA_NEEPEATpci_device_info@@PEAH11@Z DD 041b01H
	DD	02d011bH
	DD	060137014H
$unwind$?pci_find_device_id@@YA_NGGPEATpci_device_info@@@Z DD 041801H
	DD	0290118H
	DD	060107011H
$unwind$?pci_alloc_msi@@YA_NHHHP6AX_KPEAX@Z@Z DD 021901H
	DD	0150119H
$unwind$?pci_enable_bus_master@@YAXHHH@Z DD 011101H
	DD	08211H
$unwind$?pci_enable_interrupt@@YAXHHH@Z DD 011101H
	DD	08211H
$unwind$?pcie_supported@@YA_NXZ DD 010401H
	DD	04204H
$unwind$?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z DD 010e01H
	DD	0220eH
$unwind$?pci_config_read32@@YAIPEBU_pci_address_@@G@Z DD 010e01H
	DD	0420eH
$unwind$?pcie_find_device@@YA_KGHHH@Z DD 011701H
	DD	08217H
$unwind$?pci_get_msi_addr@@YA_KPEA_K_KIEE@Z DD 011801H
	DD	02218H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
tv67 = 0
tv72 = 4
data$ = 32
vector$ = 40
processor$ = 48
edge_trigger$ = 56
deassert$ = 64
?pci_get_msi_addr@@YA_KPEA_K_KIEE@Z PROC		; pci_get_msi_addr

; 284  : uint64_t pci_get_msi_addr (uint64_t* data, size_t vector, uint32_t processor, uint8_t edge_trigger, uint8_t deassert) {

$LN7:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 285  : 
; 286  : 	*data = (vector & 0xFF) | (edge_trigger == 1 ? 0 : (1 << 15)) | (deassert == 1 ? 0 : (1 << 14));

	movzx	eax, BYTE PTR edge_trigger$[rsp]
	cmp	eax, 1
	jne	SHORT $LN3@pci_get_ms
	mov	DWORD PTR tv67[rsp], 0
	jmp	SHORT $LN4@pci_get_ms
$LN3@pci_get_ms:
	mov	DWORD PTR tv67[rsp], 32768		; 00008000H
$LN4@pci_get_ms:
	movzx	eax, BYTE PTR deassert$[rsp]
	cmp	eax, 1
	jne	SHORT $LN5@pci_get_ms
	mov	DWORD PTR tv72[rsp], 0
	jmp	SHORT $LN6@pci_get_ms
$LN5@pci_get_ms:
	mov	DWORD PTR tv72[rsp], 16384		; 00004000H
$LN6@pci_get_ms:
	mov	rax, QWORD PTR vector$[rsp]
	and	rax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR tv67[rsp]
	or	rax, rcx
	movsxd	rcx, DWORD PTR tv72[rsp]
	or	rax, rcx
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rcx], rax

; 287  : 	return (0xFEE00000 | (processor << 12));

	mov	eax, DWORD PTR processor$[rsp]
	shl	eax, 12
	or	eax, -18874368				; fee00000H
	mov	eax, eax

; 288  : }

	add	rsp, 24
	ret	0
?pci_get_msi_addr@@YA_KPEA_K_KIEE@Z ENDP		; pci_get_msi_addr
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\stdint.h
;	COMDAT ??$raw_offset@PECGPEAX@@YAPECGPEAXH@Z
_TEXT	SEGMENT
p1$ = 8
offset$ = 16
??$raw_offset@PECGPEAX@@YAPECGPEAXH@Z PROC		; raw_offset<unsigned short volatile * __ptr64,void * __ptr64>, COMDAT

; 183  : 	{

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 184  : 		return (T) ((size_t)p1 + offset);

	movsxd	rax, DWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR p1$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 185  : 	};

	ret	0
??$raw_offset@PECGPEAX@@YAPECGPEAXH@Z ENDP		; raw_offset<unsigned short volatile * __ptr64,void * __ptr64>
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\stdint.h
;	COMDAT ??$raw_offset@PECIPEAX@@YAPECIPEAXH@Z
_TEXT	SEGMENT
p1$ = 8
offset$ = 16
??$raw_offset@PECIPEAX@@YAPECIPEAXH@Z PROC		; raw_offset<unsigned int volatile * __ptr64,void * __ptr64>, COMDAT

; 183  : 	{

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 184  : 		return (T) ((size_t)p1 + offset);

	movsxd	rax, DWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR p1$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 185  : 	};

	ret	0
??$raw_offset@PECIPEAX@@YAPECIPEAXH@Z ENDP		; raw_offset<unsigned int volatile * __ptr64,void * __ptr64>
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\stdint.h
;	COMDAT ??$raw_offset@PECEPEAX@@YAPECEPEAXH@Z
_TEXT	SEGMENT
p1$ = 8
offset$ = 16
??$raw_offset@PECEPEAX@@YAPECEPEAXH@Z PROC		; raw_offset<unsigned char volatile * __ptr64,void * __ptr64>, COMDAT

; 183  : 	{

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 184  : 		return (T) ((size_t)p1 + offset);

	movsxd	rax, DWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR p1$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 185  : 	};

	ret	0
??$raw_offset@PECEPEAX@@YAPECEPEAXH@Z ENDP		; raw_offset<unsigned char volatile * __ptr64,void * __ptr64>
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\stdint.h
;	COMDAT ??$raw_diff@UacpiMcfgAlloc@@UacpiMcfg@@@@YAHPEAUacpiMcfgAlloc@@PEAUacpiMcfg@@@Z
_TEXT	SEGMENT
p1$ = 8
p2$ = 16
??$raw_diff@UacpiMcfgAlloc@@UacpiMcfg@@@@YAHPEAUacpiMcfgAlloc@@PEAUacpiMcfg@@@Z PROC ; raw_diff<acpiMcfgAlloc,acpiMcfg>, COMDAT

; 179  : 	{

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 180  : 		return (intptr_t)p1 - (intptr_t)p2;

	mov	eax, DWORD PTR p2$[rsp]
	mov	ecx, DWORD PTR p1$[rsp]
	sub	ecx, eax
	mov	eax, ecx

; 181  : 	};

	ret	0
??$raw_diff@UacpiMcfgAlloc@@UacpiMcfg@@@@YAHPEAUacpiMcfgAlloc@@PEAUacpiMcfg@@@Z ENDP ; raw_diff<acpiMcfgAlloc,acpiMcfg>
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\stdint.h
;	COMDAT ??$mem_after@PEAUacpiMcfgAlloc@@UacpiMcfg@@@@YAPEAUacpiMcfgAlloc@@PEAUacpiMcfg@@@Z
_TEXT	SEGMENT
p1$ = 8
??$mem_after@PEAUacpiMcfgAlloc@@UacpiMcfg@@@@YAPEAUacpiMcfgAlloc@@PEAUacpiMcfg@@@Z PROC ; mem_after<acpiMcfgAlloc * __ptr64,acpiMcfg>, COMDAT

; 187  : 	{

	mov	QWORD PTR [rsp+8], rcx

; 188  : 		return (T) (&p1[1]);

	mov	eax, 44					; 0000002cH
	imul	rax, 1
	mov	rcx, QWORD PTR p1$[rsp]
	add	rcx, rax
	mov	rax, rcx

; 189  : 	};

	ret	0
??$mem_after@PEAUacpiMcfgAlloc@@UacpiMcfg@@@@YAPEAUacpiMcfgAlloc@@PEAUacpiMcfg@@@Z ENDP ; mem_after<acpiMcfgAlloc * __ptr64,acpiMcfg>
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
allocs$ = 32
mcfg$ = 40
addr$ = 48
segment$ = 80
bus$ = 88
dev$ = 96
func$ = 104
?pcie_find_device@@YA_KGHHH@Z PROC			; pcie_find_device

; 48   : uint64_t pcie_find_device (uint16_t segment, int bus, int dev, int func) {

$LN11:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 72					; 00000048H

; 49   : 	if (bus > 255)

	cmp	DWORD PTR bus$[rsp], 255		; 000000ffH
	jle	SHORT $LN8@pcie_find_

; 50   : 		return 0;

	xor	eax, eax
	jmp	$LN9@pcie_find_
$LN8@pcie_find_:

; 51   : 	if (dev > 31)

	cmp	DWORD PTR dev$[rsp], 31
	jle	SHORT $LN7@pcie_find_

; 52   : 		return 0;

	xor	eax, eax
	jmp	$LN9@pcie_find_
$LN7@pcie_find_:

; 53   : 	if (func > 7)

	cmp	DWORD PTR func$[rsp], 7
	jle	SHORT $LN6@pcie_find_

; 54   : 		return 0;

	xor	eax, eax
	jmp	$LN9@pcie_find_
$LN6@pcie_find_:

; 55   : 	acpiMcfg *mcfg = acpi_get_mcfg();

	call	?acpi_get_mcfg@@YAPEAUacpiMcfg@@XZ	; acpi_get_mcfg
	mov	QWORD PTR mcfg$[rsp], rax

; 56   : 	acpiMcfgAlloc* allocs = mem_after<acpiMcfgAlloc*>(mcfg);

	mov	rcx, QWORD PTR mcfg$[rsp]
	call	??$mem_after@PEAUacpiMcfgAlloc@@UacpiMcfg@@@@YAPEAUacpiMcfgAlloc@@PEAUacpiMcfg@@@Z ; mem_after<acpiMcfgAlloc * __ptr64,acpiMcfg>
	mov	QWORD PTR allocs$[rsp], rax

; 57   : 	for (; raw_diff(allocs, mcfg) < mcfg->header.length; ++allocs) {

	jmp	SHORT $LN5@pcie_find_
$LN4@pcie_find_:
	mov	rax, QWORD PTR allocs$[rsp]
	add	rax, 16
	mov	QWORD PTR allocs$[rsp], rax
$LN5@pcie_find_:
	mov	rdx, QWORD PTR mcfg$[rsp]
	mov	rcx, QWORD PTR allocs$[rsp]
	call	??$raw_diff@UacpiMcfgAlloc@@UacpiMcfg@@@@YAHPEAUacpiMcfgAlloc@@PEAUacpiMcfg@@@Z ; raw_diff<acpiMcfgAlloc,acpiMcfg>
	mov	rcx, QWORD PTR mcfg$[rsp]
	cmp	eax, DWORD PTR [rcx+4]
	jae	SHORT $LN3@pcie_find_

; 58   : 		if (allocs->startBusNum <= bus && bus <= allocs->endBusNum)

	mov	rax, QWORD PTR allocs$[rsp]
	movzx	eax, BYTE PTR [rax+10]
	cmp	eax, DWORD PTR bus$[rsp]
	jg	SHORT $LN2@pcie_find_
	mov	rax, QWORD PTR allocs$[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	DWORD PTR bus$[rsp], eax
	jg	SHORT $LN2@pcie_find_

; 59   : 			break;

	jmp	SHORT $LN3@pcie_find_
$LN2@pcie_find_:

; 60   : 	}

	jmp	SHORT $LN4@pcie_find_
$LN3@pcie_find_:

; 61   : 	if (raw_diff(allocs, mcfg) >= mcfg->header.length)

	mov	rdx, QWORD PTR mcfg$[rsp]
	mov	rcx, QWORD PTR allocs$[rsp]
	call	??$raw_diff@UacpiMcfgAlloc@@UacpiMcfg@@@@YAHPEAUacpiMcfgAlloc@@PEAUacpiMcfg@@@Z ; raw_diff<acpiMcfgAlloc,acpiMcfg>
	mov	rcx, QWORD PTR mcfg$[rsp]
	cmp	eax, DWORD PTR [rcx+4]
	jb	SHORT $LN1@pcie_find_

; 62   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN9@pcie_find_
$LN1@pcie_find_:

; 63   : 	uint64_t addr = allocs->baseAddress + ((bus - allocs->startBusNum) << 20) | (dev << 15) | (func << 12);

	mov	rax, QWORD PTR allocs$[rsp]
	movzx	eax, BYTE PTR [rax+10]
	mov	ecx, DWORD PTR bus$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	shl	eax, 20
	cdqe
	mov	rcx, QWORD PTR allocs$[rsp]
	mov	rcx, QWORD PTR [rcx]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR dev$[rsp]
	shl	ecx, 15
	movsxd	rcx, ecx
	or	rax, rcx
	mov	ecx, DWORD PTR func$[rsp]
	shl	ecx, 12
	movsxd	rcx, ecx
	or	rax, rcx
	mov	QWORD PTR addr$[rsp], rax

; 64   : 	return addr;

	mov	rax, QWORD PTR addr$[rsp]
$LN9@pcie_find_:

; 65   : }

	add	rsp, 72					; 00000048H
	ret	0
?pcie_find_device@@YA_KGHHH@Z ENDP			; pcie_find_device
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
addr$ = 48
offset$ = 56
?pci_config_read32@@YAIPEBU_pci_address_@@G@Z PROC	; pci_config_read32

; 40   : uint32_t pci_config_read32 (const pci_address *addr, uint16_t offset) {

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 41   : 	outportd (PCI_REG_CONFIG_ADDRESS, pci_config_pack_address (addr, offset));

	movzx	edx, WORD PTR offset$[rsp]
	mov	rcx, QWORD PTR addr$[rsp]
	call	?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z ; pci_config_pack_address
	mov	edx, eax
	mov	cx, 3320				; 00000cf8H
	call	?outportd@@YAXGI@Z			; outportd

; 42   : 	return inportd (PCI_REG_CONFIG_DATA);

	mov	cx, 3324				; 00000cfcH
	call	?inportd@@YAIG@Z			; inportd

; 43   : }

	add	rsp, 40					; 00000028H
	ret	0
?pci_config_read32@@YAIPEBU_pci_address_@@G@Z ENDP	; pci_config_read32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
enable_bit$ = 0
addr$ = 32
offset$ = 40
?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z PROC ; pci_config_pack_address

; 29   : static uint32_t pci_config_pack_address (const pci_address *addr, uint16_t offset) {

	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 30   : 
; 31   : 	const uint32_t enable_bit = 0x80000000UL;

	mov	DWORD PTR enable_bit$[rsp], -2147483648	; 80000000H

; 32   : 
; 33   : 	return (((uint32_t)addr->bus << 16) |
; 34   : 		((uint32_t)addr->device << 11) |
; 35   : 		((uint32_t)addr->function << 8) |
; 36   : 		offset | enable_bit);

	mov	rax, QWORD PTR addr$[rsp]
	movzx	eax, BYTE PTR [rax]
	shl	eax, 16
	mov	rcx, QWORD PTR addr$[rsp]
	movzx	ecx, BYTE PTR [rcx+1]
	shl	ecx, 11
	or	eax, ecx
	mov	rcx, QWORD PTR addr$[rsp]
	movzx	ecx, BYTE PTR [rcx+2]
	shl	ecx, 8
	or	eax, ecx
	movzx	ecx, WORD PTR offset$[rsp]
	or	eax, ecx
	bts	eax, 31

; 37   : }

	add	rsp, 24
	ret	0
?pci_config_pack_address@@YAIPEBU_pci_address_@@G@Z ENDP ; pci_config_pack_address
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
?pcie_supported@@YA_NXZ PROC				; pcie_supported

; 389  : bool pcie_supported () {

$LN5:
	sub	rsp, 40					; 00000028H

; 390  : 	if (!acpi_pcie_supported ())

	call	?acpi_pcie_supported@@YA_NXZ		; acpi_pcie_supported
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@pcie_suppo

; 391  : 		return false;

	xor	al, al
	jmp	SHORT $LN3@pcie_suppo

; 392  : 	else 

	jmp	SHORT $LN1@pcie_suppo
$LN2@pcie_suppo:

; 393  : 		return true;

	mov	al, 1
$LN1@pcie_suppo:
$LN3@pcie_suppo:

; 394  : }

	add	rsp, 40					; 00000028H
	ret	0
?pcie_supported@@YA_NXZ ENDP				; pcie_supported
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
command_reg$ = 48
bus$ = 80
dev$ = 88
func$ = 96
?pci_enable_interrupt@@YAXHHH@Z PROC			; pci_enable_interrupt

; 381  : void pci_enable_interrupt (int bus, int dev, int func) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 382  : 	uint16_t command_reg = 0;

	xor	eax, eax
	mov	WORD PTR command_reg$[rsp], ax

; 383  : 	read_config_16 (0,bus,dev,func,0x4, &command_reg);

	lea	rax, QWORD PTR command_reg$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 4
	mov	r9d, DWORD PTR func$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	xor	ecx, ecx
	call	?read_config_16@@YAXGHHHHPEAG@Z		; read_config_16

; 384  : 	command_reg &= ~(1<<10);

	movzx	eax, WORD PTR command_reg$[rsp]
	btr	eax, 10
	mov	WORD PTR command_reg$[rsp], ax

; 385  :     write_config_16 (0,bus, dev,func,0x4,command_reg);

	movzx	eax, WORD PTR command_reg$[rsp]
	mov	WORD PTR [rsp+40], ax
	mov	DWORD PTR [rsp+32], 4
	mov	r9d, DWORD PTR func$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	xor	ecx, ecx
	call	?write_config_16@@YAXGHHHHG@Z		; write_config_16

; 386  : }

	add	rsp, 72					; 00000048H
	ret	0
?pci_enable_interrupt@@YAXHHH@Z ENDP			; pci_enable_interrupt
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
command_reg$ = 48
bus$ = 80
dev$ = 88
func$ = 96
?pci_enable_bus_master@@YAXHHH@Z PROC			; pci_enable_bus_master

; 372  : void pci_enable_bus_master (int bus, int dev, int func) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 373  : 	//command reg -> 0x4
; 374  : 	uint16_t command_reg = 0;

	xor	eax, eax
	mov	WORD PTR command_reg$[rsp], ax

; 375  : 	read_config_16 (0,bus,dev,func,0x4, &command_reg);

	lea	rax, QWORD PTR command_reg$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 4
	mov	r9d, DWORD PTR func$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	xor	ecx, ecx
	call	?read_config_16@@YAXGHHHHPEAG@Z		; read_config_16

; 376  : 	command_reg |= (1<<2);

	movzx	eax, WORD PTR command_reg$[rsp]
	or	eax, 4
	mov	WORD PTR command_reg$[rsp], ax

; 377  : 	command_reg |= (1<<10);

	movzx	eax, WORD PTR command_reg$[rsp]
	bts	eax, 10
	mov	WORD PTR command_reg$[rsp], ax

; 378  :     write_config_16 (0,bus, dev,func,0x4,command_reg);

	movzx	eax, WORD PTR command_reg$[rsp]
	mov	WORD PTR [rsp+40], ax
	mov	DWORD PTR [rsp+32], 4
	mov	r9d, DWORD PTR func$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	xor	ecx, ecx
	call	?write_config_16@@YAXGHHHHG@Z		; write_config_16

; 379  : }

	add	rsp, 72					; 00000048H
	ret	0
?pci_enable_bus_master@@YAXHHH@Z ENDP			; pci_enable_bus_master
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
cap_reg$1 = 48
msi_reg$2 = 52
bits64_cap$3 = 56
mask_cap$4 = 57
capptr$5 = 60
status$ = 64
data_offset$6 = 68
msgctrl$7 = 72
tv155 = 80
vector$8 = 84
tv159 = 88
msi_data$9 = 96
msi_addr$10 = 104
requested_vecs$11 = 112
msi_cap$ = 120
msi_x_cap$ = 128
cap_header$ = 136
internal_ptr$12 = 144
func$ = 176
dev$ = 184
bus$ = 192
fn$ = 200
?pci_alloc_msi@@YA_NHHHP6AX_KPEAX@Z@Z PROC		; pci_alloc_msi

; 296  : bool pci_alloc_msi (int func, int dev, int bus, void (*fn)(size_t, void* p)) {

$LN17:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 168				; 000000a8H

; 297  : 	
; 298  : 	pci_cap_header *cap_header = NULL;

	mov	QWORD PTR cap_header$[rsp], 0

; 299  : 	pci_msi_cap *msi_cap = NULL;

	mov	QWORD PTR msi_cap$[rsp], 0

; 300  : 	pci_msi_xcap *msi_x_cap = NULL;

	mov	QWORD PTR msi_x_cap$[rsp], 0

; 301  : 
; 302  : 
; 303  : 	uint32_t status = 0;

	mov	DWORD PTR status$[rsp], 0

; 304  : 	read_config_32_ext (0,bus, dev, func, 0x4,&status);

	lea	rax, QWORD PTR status$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 4
	mov	r9d, DWORD PTR func$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	xor	ecx, ecx
	call	?read_config_32_ext@@YAXGHHHHPEAI@Z	; read_config_32_ext

; 305  : 	status >>= 16;

	mov	eax, DWORD PTR status$[rsp]
	shr	eax, 16
	mov	DWORD PTR status$[rsp], eax

; 306  : 	if ((status >> 4) & 1) {

	mov	eax, DWORD PTR status$[rsp]
	shr	eax, 4
	and	eax, 1
	test	eax, eax
	je	$LN10@pci_alloc_

; 307  : 		uint32_t capptr = 0, cap_reg = 0, msi_reg = 0; 

	mov	DWORD PTR capptr$5[rsp], 0
	mov	DWORD PTR cap_reg$1[rsp], 0
	mov	DWORD PTR msi_reg$2[rsp], 0

; 308  : 		read_config_32_ext (0,bus, dev, func, 0x34, &capptr);

	lea	rax, QWORD PTR capptr$5[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 52			; 00000034H
	mov	r9d, DWORD PTR func$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	xor	ecx, ecx
	call	?read_config_32_ext@@YAXGHHHHPEAI@Z	; read_config_32_ext
$LN9@pci_alloc_:

; 309  : 		/*capptr &= 0xFF;
; 310  : 		capptr /= 4;*/
; 311  : 		while (capptr != 0) {

	cmp	DWORD PTR capptr$5[rsp], 0
	je	$LN8@pci_alloc_

; 312  : 			read_config_32_ext (0,bus, dev, func, capptr, &cap_reg);

	lea	rax, QWORD PTR cap_reg$1[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR capptr$5[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR func$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	xor	ecx, ecx
	call	?read_config_32_ext@@YAXGHHHHPEAI@Z	; read_config_32_ext

; 313  : 			if ((cap_reg & 0xff) == PCI_CAPABILITY_MSIX) {

	mov	eax, DWORD PTR cap_reg$1[rsp]
	and	eax, 255				; 000000ffH
	cmp	eax, 17
	jne	SHORT $LN7@pci_alloc_

; 314  : 				printf ("MSI-X found for this device\n");

	lea	rcx, OFFSET FLAT:$SG3758
	call	?printf@@YAXPEBDZZ			; printf

; 315  : 				msi_reg = capptr;

	mov	eax, DWORD PTR capptr$5[rsp]
	mov	DWORD PTR msi_reg$2[rsp], eax

; 316  : 				break;

	jmp	SHORT $LN8@pci_alloc_
$LN7@pci_alloc_:

; 317  : 			}
; 318  : 
; 319  : 			if ((cap_reg & 0xff)  == PCI_CAPABILITY_MSI) {

	mov	eax, DWORD PTR cap_reg$1[rsp]
	and	eax, 255				; 000000ffH
	cmp	eax, 5
	jne	SHORT $LN6@pci_alloc_

; 320  : 				printf ("MSI found for this device\n");

	lea	rcx, OFFSET FLAT:$SG3760
	call	?printf@@YAXPEBDZZ			; printf

; 321  : 				msi_reg = capptr;

	mov	eax, DWORD PTR capptr$5[rsp]
	mov	DWORD PTR msi_reg$2[rsp], eax
$LN6@pci_alloc_:

; 322  : 				//break;
; 323  : 			}
; 324  : 			capptr = ((cap_reg >> 8) & 0xff);   //((cap_reg >> 8) & 0xFF) / 4;

	mov	eax, DWORD PTR cap_reg$1[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	DWORD PTR capptr$5[rsp], eax

; 325  : 		}

	jmp	$LN9@pci_alloc_
$LN8@pci_alloc_:

; 326  : 
; 327  : 		if (msi_reg == 0)

	cmp	DWORD PTR msi_reg$2[rsp], 0
	jne	SHORT $LN5@pci_alloc_

; 328  : 			return false;

	xor	al, al
	jmp	$LN11@pci_alloc_
$LN5@pci_alloc_:

; 329  : 
; 330  : 		uint32_t vector = 60 + v_i;

	mov	eax, DWORD PTR ?v_i@@3HA		; v_i
	add	eax, 60					; 0000003cH
	mov	DWORD PTR vector$8[rsp], eax

; 331  : 		setvect (vector, fn);

	mov	eax, DWORD PTR vector$8[rsp]
	mov	rdx, QWORD PTR fn$[rsp]
	mov	ecx, eax
	call	?setvect@@YAX_KP6AX0PEAX@Z@Z		; setvect

; 332  : 
; 333  : 		uint64_t msi_data = 0;

	mov	QWORD PTR msi_data$9[rsp], 0

; 334  : 		uint64_t msi_addr = pci_get_msi_addr (&msi_data, vector, 0,0,0);

	mov	eax, DWORD PTR vector$8[rsp]
	mov	BYTE PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	mov	edx, eax
	lea	rcx, QWORD PTR msi_data$9[rsp]
	call	?pci_get_msi_addr@@YA_KPEA_K_KIEE@Z	; pci_get_msi_addr
	mov	QWORD PTR msi_addr$10[rsp], rax

; 335  : 		printf ("MSI-DATA -> %x\n", msi_data);

	mov	rdx, QWORD PTR msi_data$9[rsp]
	lea	rcx, OFFSET FLAT:$SG3765
	call	?printf@@YAXPEBDZZ			; printf

; 336  : 		uint64_t internal_ptr = 0;

	mov	QWORD PTR internal_ptr$12[rsp], 0

; 337  : 		read_config_32_ext (0, bus, dev, func, 32,&cap_reg);

	lea	rax, QWORD PTR cap_reg$1[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	mov	r9d, DWORD PTR func$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	xor	ecx, ecx
	call	?read_config_32_ext@@YAXGHHHHPEAI@Z	; read_config_32_ext

; 338  : 		if ((cap_reg & 0xFF) == 0x11) { 

	mov	eax, DWORD PTR cap_reg$1[rsp]
	and	eax, 255				; 000000ffH
	cmp	eax, 17
	jne	SHORT $LN4@pci_alloc_

; 339  : 			//!MSI-X interrupt handling not implemented yet
; 340  : 		} else {

	jmp	$LN3@pci_alloc_
$LN4@pci_alloc_:

; 341  : 			uint64_t msgctrl = cap_reg >> 16;

	mov	eax, DWORD PTR cap_reg$1[rsp]
	shr	eax, 16
	mov	eax, eax
	mov	QWORD PTR msgctrl$7[rsp], rax

; 342  : 			printf ("MSG Control -> %x\n", msgctrl);

	mov	rdx, QWORD PTR msgctrl$7[rsp]
	lea	rcx, OFFSET FLAT:$SG3770
	call	?printf@@YAXPEBDZZ			; printf

; 343  : 			bool mask_cap = ((msgctrl & (1<<8)) != 0);

	mov	rax, QWORD PTR msgctrl$7[rsp]
	and	rax, 256				; 00000100H
	test	rax, rax
	je	SHORT $LN13@pci_alloc_
	mov	DWORD PTR tv155[rsp], 1
	jmp	SHORT $LN14@pci_alloc_
$LN13@pci_alloc_:
	mov	DWORD PTR tv155[rsp], 0
$LN14@pci_alloc_:
	movzx	eax, BYTE PTR tv155[rsp]
	mov	BYTE PTR mask_cap$4[rsp], al

; 344  : 			bool bits64_cap = ((msgctrl & (1<<7)) != 0);

	mov	rax, QWORD PTR msgctrl$7[rsp]
	and	rax, 128				; 00000080H
	test	rax, rax
	je	SHORT $LN15@pci_alloc_
	mov	DWORD PTR tv159[rsp], 1
	jmp	SHORT $LN16@pci_alloc_
$LN15@pci_alloc_:
	mov	DWORD PTR tv159[rsp], 0
$LN16@pci_alloc_:
	movzx	eax, BYTE PTR tv159[rsp]
	mov	BYTE PTR bits64_cap$3[rsp], al

; 345  : 			uint32_t requested_vecs= (msgctrl >> 1) & 0x7;

	mov	rax, QWORD PTR msgctrl$7[rsp]
	shr	rax, 1
	and	rax, 7
	mov	DWORD PTR requested_vecs$11[rsp], eax

; 346  : 
; 347  : 			//! write msg and data
; 348  : 			write_config_32 (bus, dev, func, msi_reg + 1, (uint32_t)msi_addr);

	mov	eax, DWORD PTR msi_reg$2[rsp]
	inc	eax
	mov	ecx, DWORD PTR msi_addr$10[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, eax
	mov	r8d, DWORD PTR func$[rsp]
	mov	edx, DWORD PTR dev$[rsp]
	mov	ecx, DWORD PTR bus$[rsp]
	call	?write_config_32@@YAXHHHHI@Z		; write_config_32

; 349  : 			uint32_t data_offset = 2;

	mov	DWORD PTR data_offset$6[rsp], 2

; 350  : 			if (bits64_cap) {

	movzx	eax, BYTE PTR bits64_cap$3[rsp]
	test	eax, eax
	je	SHORT $LN2@pci_alloc_

; 351  : 				printf ("MSI 64BIT Capable\n");

	lea	rcx, OFFSET FLAT:$SG3777
	call	?printf@@YAXPEBDZZ			; printf

; 352  : 				write_config_32(bus, dev, func, msi_reg + 2, msi_addr >> 32);

	mov	rax, QWORD PTR msi_addr$10[rsp]
	shr	rax, 32					; 00000020H
	mov	ecx, DWORD PTR msi_reg$2[rsp]
	add	ecx, 2
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, DWORD PTR func$[rsp]
	mov	edx, DWORD PTR dev$[rsp]
	mov	ecx, DWORD PTR bus$[rsp]
	call	?write_config_32@@YAXHHHHI@Z		; write_config_32

; 353  : 				++data_offset;

	mov	eax, DWORD PTR data_offset$6[rsp]
	inc	eax
	mov	DWORD PTR data_offset$6[rsp], eax
$LN2@pci_alloc_:

; 354  : 			}
; 355  : 			write_config_32(bus,dev,func,msi_reg + data_offset,msi_data);

	mov	eax, DWORD PTR data_offset$6[rsp]
	mov	ecx, DWORD PTR msi_reg$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR msi_data$9[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, eax
	mov	r8d, DWORD PTR func$[rsp]
	mov	edx, DWORD PTR dev$[rsp]
	mov	ecx, DWORD PTR bus$[rsp]
	call	?write_config_32@@YAXHHHHI@Z		; write_config_32

; 356  : 			if (mask_cap){

	movzx	eax, BYTE PTR mask_cap$4[rsp]
	test	eax, eax
	je	SHORT $LN1@pci_alloc_

; 357  : 				printf ("MSI Mask Capable\n");

	lea	rcx, OFFSET FLAT:$SG3779
	call	?printf@@YAXPEBDZZ			; printf

; 358  : 				write_config_32 (bus, dev, func, msi_reg + 4, 0);

	mov	eax, DWORD PTR msi_reg$2[rsp]
	add	eax, 4
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, eax
	mov	r8d, DWORD PTR func$[rsp]
	mov	edx, DWORD PTR dev$[rsp]
	mov	ecx, DWORD PTR bus$[rsp]
	call	?write_config_32@@YAXHHHHI@Z		; write_config_32
$LN1@pci_alloc_:

; 359  : 			}
; 360  : 			//!Enable MSI
; 361  : 			msgctrl |= 0x1;

	mov	rax, QWORD PTR msgctrl$7[rsp]
	or	rax, 1
	mov	QWORD PTR msgctrl$7[rsp], rax

; 362  : 			cap_reg = (cap_reg & UINT16_MAX) | (msgctrl << 16);

	mov	eax, DWORD PTR cap_reg$1[rsp]
	and	eax, 65535				; 0000ffffH
	mov	eax, eax
	mov	rcx, QWORD PTR msgctrl$7[rsp]
	shl	rcx, 16
	or	rax, rcx
	mov	DWORD PTR cap_reg$1[rsp], eax

; 363  : 			write_config_32 (bus, dev, func, msi_reg, cap_reg);

	mov	eax, DWORD PTR cap_reg$1[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, DWORD PTR msi_reg$2[rsp]
	mov	r8d, DWORD PTR func$[rsp]
	mov	edx, DWORD PTR dev$[rsp]
	mov	ecx, DWORD PTR bus$[rsp]
	call	?write_config_32@@YAXHHHHI@Z		; write_config_32

; 364  : 			printf ("MSI interrupt for this device enabled msi reg -> %x\n", msi_reg);

	mov	edx, DWORD PTR msi_reg$2[rsp]
	lea	rcx, OFFSET FLAT:$SG3780
	call	?printf@@YAXPEBDZZ			; printf

; 365  : 			v_i++;

	mov	eax, DWORD PTR ?v_i@@3HA		; v_i
	inc	eax
	mov	DWORD PTR ?v_i@@3HA, eax		; v_i

; 366  : 			return true;

	mov	al, 1
$LN3@pci_alloc_:
$LN10@pci_alloc_:
$LN11@pci_alloc_:

; 367  : 		}
; 368  : 	}
; 369  : }

	add	rsp, 168				; 000000a8H
	ret	0
?pci_alloc_msi@@YA_NHHHP6AX_KPEAX@Z@Z ENDP		; pci_alloc_msi
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
dev$1 = 48
bus$2 = 52
func$3 = 56
config$ = 64
device_id$ = 352
vendor_id$ = 360
addr_out$ = 368
?pci_find_device_id@@YA_NGGPEATpci_device_info@@@Z PROC	; pci_find_device_id

; 261  : bool pci_find_device_id (uint16_t device_id, uint16_t vendor_id, pci_device_info *addr_out) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	WORD PTR [rsp+8], cx
	push	rsi
	push	rdi
	sub	rsp, 328				; 00000148H

; 262  : 	pci_device_info config;
; 263  : 	for (int bus = 0; bus < 256; bus++) {

	mov	DWORD PTR bus$2[rsp], 0
	jmp	SHORT $LN10@pci_find_d
$LN9@pci_find_d:
	mov	eax, DWORD PTR bus$2[rsp]
	inc	eax
	mov	DWORD PTR bus$2[rsp], eax
$LN10@pci_find_d:
	cmp	DWORD PTR bus$2[rsp], 256		; 00000100H
	jge	$LN8@pci_find_d

; 264  : 		for (int dev = 0; dev < 32; dev++) {

	mov	DWORD PTR dev$1[rsp], 0
	jmp	SHORT $LN7@pci_find_d
$LN6@pci_find_d:
	mov	eax, DWORD PTR dev$1[rsp]
	inc	eax
	mov	DWORD PTR dev$1[rsp], eax
$LN7@pci_find_d:
	cmp	DWORD PTR dev$1[rsp], 32		; 00000020H
	jge	$LN5@pci_find_d

; 265  : 			for (int func = 0; func < 8; func++) {

	mov	DWORD PTR func$3[rsp], 0
	jmp	SHORT $LN4@pci_find_d
$LN3@pci_find_d:
	mov	eax, DWORD PTR func$3[rsp]
	inc	eax
	mov	DWORD PTR func$3[rsp], eax
$LN4@pci_find_d:
	cmp	DWORD PTR func$3[rsp], 8
	jge	$LN2@pci_find_d

; 266  : 
; 267  : 				read_config_32 (0,bus, dev, func, 0, config.header[0]);

	mov	eax, 4
	imul	rax, 0
	mov	eax, DWORD PTR config$[rsp+rax]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, DWORD PTR func$3[rsp]
	mov	r8d, DWORD PTR dev$1[rsp]
	mov	edx, DWORD PTR bus$2[rsp]
	xor	ecx, ecx
	call	?read_config_32@@YAXGHHHHI@Z		; read_config_32

; 268  : 
; 269  : 				read_config_header (bus, dev, func, &config);

	lea	r9, QWORD PTR config$[rsp]
	mov	r8d, DWORD PTR func$3[rsp]
	mov	edx, DWORD PTR dev$1[rsp]
	mov	ecx, DWORD PTR bus$2[rsp]
	call	?read_config_header@@YAXHHHPEATpci_device_info@@@Z ; read_config_header

; 270  : 
; 271  : 				if (config.device.deviceID == device_id && config.device.vendorID == vendor_id) {

	movzx	eax, WORD PTR config$[rsp+2]
	movzx	ecx, WORD PTR device_id$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN1@pci_find_d
	movzx	eax, WORD PTR config$[rsp]
	movzx	ecx, WORD PTR vendor_id$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN1@pci_find_d

; 272  : 					*addr_out = config;

	lea	rax, QWORD PTR config$[rsp]
	mov	rdi, QWORD PTR addr_out$[rsp]
	mov	rsi, rax
	mov	ecx, 256				; 00000100H
	rep movsb

; 273  : 					return true;

	mov	al, 1
	jmp	SHORT $LN11@pci_find_d
$LN1@pci_find_d:

; 274  : 				}
; 275  : 			}

	jmp	$LN3@pci_find_d
$LN2@pci_find_d:

; 276  : 		}

	jmp	$LN6@pci_find_d
$LN5@pci_find_d:

; 277  : 	}

	jmp	$LN9@pci_find_d
$LN8@pci_find_d:

; 278  : 
; 279  : 	return false;

	xor	al, al
$LN11@pci_find_d:

; 280  : }

	add	rsp, 328				; 00000148H
	pop	rdi
	pop	rsi
	ret	0
?pci_find_device_id@@YA_NGGPEATpci_device_info@@@Z ENDP	; pci_find_device_id
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
dev$1 = 48
bus$2 = 52
func$3 = 56
class_$4 = 60
intLine$5 = 64
alloc$ = 72
result$6 = 80
subclass_$7 = 84
mcfg$ = 88
config$ = 96
class_code$ = 384
sub_class$ = 392
addr_out$ = 400
bus_$ = 408
dev_$ = 416
func_$ = 424
?pci_find_device_class@@YA_NEEPEATpci_device_info@@PEAH11@Z PROC ; pci_find_device_class

; 202  : bool pci_find_device_class (uint8_t class_code, uint8_t sub_class, pci_device_info *addr_out, int *bus_, int *dev_, int *func_) {	

$LN18:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	push	rsi
	push	rdi
	sub	rsp, 360				; 00000168H

; 203  : 	pci_device_info config;
; 204  : 	acpiMcfg *mcfg = acpi_get_mcfg();

	call	?acpi_get_mcfg@@YAPEAUacpiMcfg@@XZ	; acpi_get_mcfg
	mov	QWORD PTR mcfg$[rsp], rax

; 205  : 	acpiMcfgAlloc *alloc = mem_after<acpiMcfgAlloc*>(mcfg);

	mov	rcx, QWORD PTR mcfg$[rsp]
	call	??$mem_after@PEAUacpiMcfgAlloc@@UacpiMcfg@@@@YAPEAUacpiMcfgAlloc@@PEAUacpiMcfg@@@Z ; mem_after<acpiMcfgAlloc * __ptr64,acpiMcfg>
	mov	QWORD PTR alloc$[rsp], rax

; 206  : 	//if (!acpi_pcie_supported()){
; 207  : 		for (int bus = 0; bus < 256; bus++) {

	mov	DWORD PTR bus$2[rsp], 0
	jmp	SHORT $LN15@pci_find_d
$LN14@pci_find_d:
	mov	eax, DWORD PTR bus$2[rsp]
	inc	eax
	mov	DWORD PTR bus$2[rsp], eax
$LN15@pci_find_d:
	cmp	DWORD PTR bus$2[rsp], 256		; 00000100H
	jge	$LN13@pci_find_d

; 208  : 			for (int dev = 0; dev < 32; dev++) {

	mov	DWORD PTR dev$1[rsp], 0
	jmp	SHORT $LN12@pci_find_d
$LN11@pci_find_d:
	mov	eax, DWORD PTR dev$1[rsp]
	inc	eax
	mov	DWORD PTR dev$1[rsp], eax
$LN12@pci_find_d:
	cmp	DWORD PTR dev$1[rsp], 32		; 00000020H
	jge	$LN10@pci_find_d

; 209  : 				for (int func = 0; func < 8; func++) {

	mov	DWORD PTR func$3[rsp], 0
	jmp	SHORT $LN9@pci_find_d
$LN8@pci_find_d:
	mov	eax, DWORD PTR func$3[rsp]
	inc	eax
	mov	DWORD PTR func$3[rsp], eax
$LN9@pci_find_d:
	cmp	DWORD PTR func$3[rsp], 8
	jge	$LN7@pci_find_d

; 210  : 					
; 211  : 					if (!acpi_pcie_supported()) {

	call	?acpi_pcie_supported@@YA_NXZ		; acpi_pcie_supported
	movzx	eax, al
	test	eax, eax
	jne	$LN6@pci_find_d

; 212  : 						read_config_32 (0,bus, dev, func, 0, config.header[0]);

	mov	eax, 4
	imul	rax, 0
	mov	eax, DWORD PTR config$[rsp+rax]
	mov	DWORD PTR [rsp+40], eax
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, DWORD PTR func$3[rsp]
	mov	r8d, DWORD PTR dev$1[rsp]
	mov	edx, DWORD PTR bus$2[rsp]
	xor	ecx, ecx
	call	?read_config_32@@YAXGHHHHI@Z		; read_config_32

; 213  : 						read_config_header (bus, dev, func, &config);

	lea	r9, QWORD PTR config$[rsp]
	mov	r8d, DWORD PTR func$3[rsp]
	mov	edx, DWORD PTR dev$1[rsp]
	mov	ecx, DWORD PTR bus$2[rsp]
	call	?read_config_header@@YAXHHHPEATpci_device_info@@@Z ; read_config_header

; 214  : 
; 215  : 						if (config.device.classCode == class_code &&  config.device.subClassCode == sub_class) {

	movzx	eax, BYTE PTR config$[rsp+11]
	movzx	ecx, BYTE PTR class_code$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN5@pci_find_d
	movzx	eax, BYTE PTR config$[rsp+10]
	movzx	ecx, BYTE PTR sub_class$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN5@pci_find_d

; 216  : 							 *addr_out = config;

	lea	rax, QWORD PTR config$[rsp]
	mov	rdi, QWORD PTR addr_out$[rsp]
	mov	rsi, rax
	mov	ecx, 256				; 00000100H
	rep movsb

; 217  : 							 *bus_ = bus;

	mov	rax, QWORD PTR bus_$[rsp]
	mov	ecx, DWORD PTR bus$2[rsp]
	mov	DWORD PTR [rax], ecx

; 218  : 					         *dev_ = dev;

	mov	rax, QWORD PTR dev_$[rsp]
	mov	ecx, DWORD PTR dev$1[rsp]
	mov	DWORD PTR [rax], ecx

; 219  : 					         *func_ = func;

	mov	rax, QWORD PTR func_$[rsp]
	mov	ecx, DWORD PTR func$3[rsp]
	mov	DWORD PTR [rax], ecx

; 220  : 							 return true;

	mov	al, 1
	jmp	$LN16@pci_find_d
$LN5@pci_find_d:

; 221  : 						}
; 222  : 					} else {

	jmp	$LN4@pci_find_d
$LN6@pci_find_d:

; 223  : 						uint32_t class_, subclass_;
; 224  : 						uint32_t result = 0;

	mov	DWORD PTR result$6[rsp], 0

; 225  : 						read_config_32_ext (alloc->pciSegment,bus, dev, func, 0x8, &result);

	lea	rax, QWORD PTR result$6[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 8
	mov	r9d, DWORD PTR func$3[rsp]
	mov	r8d, DWORD PTR dev$1[rsp]
	mov	edx, DWORD PTR bus$2[rsp]
	mov	rax, QWORD PTR alloc$[rsp]
	movzx	ecx, WORD PTR [rax+8]
	call	?read_config_32_ext@@YAXGHHHHPEAI@Z	; read_config_32_ext

; 226  : 						class_ = (result >> 24) & 0xFF;

	mov	eax, DWORD PTR result$6[rsp]
	shr	eax, 24
	and	eax, 255				; 000000ffH
	mov	DWORD PTR class_$4[rsp], eax

; 227  : 						subclass_ = (result >> 16) & 0xFF;

	mov	eax, DWORD PTR result$6[rsp]
	shr	eax, 16
	and	eax, 255				; 000000ffH
	mov	DWORD PTR subclass_$7[rsp], eax

; 228  : 						if (class_ == 0xFF || class_ == 0x00)

	cmp	DWORD PTR class_$4[rsp], 255		; 000000ffH
	je	SHORT $LN2@pci_find_d
	cmp	DWORD PTR class_$4[rsp], 0
	jne	SHORT $LN3@pci_find_d
$LN2@pci_find_d:

; 229  : 							continue;

	jmp	$LN8@pci_find_d
$LN3@pci_find_d:

; 230  : 
; 231  : 						//printf ("Class found -> %x, sub_class -> %x\n", class_, subclass_);
; 232  : 					   //read_config_header (bus, dev, func, &config);
; 233  : 
; 234  : 						if (class_ == class_code && subclass_ == sub_class) {	

	movzx	eax, BYTE PTR class_code$[rsp]
	cmp	DWORD PTR class_$4[rsp], eax
	jne	$LN1@pci_find_d
	movzx	eax, BYTE PTR sub_class$[rsp]
	cmp	DWORD PTR subclass_$7[rsp], eax
	jne	$LN1@pci_find_d

; 235  : 							uint32_t intLine = 0;

	mov	DWORD PTR intLine$5[rsp], 0

; 236  : 							read_config_32_ext(alloc->pciSegment, bus, dev, func, 0x3C, &intLine);

	lea	rax, QWORD PTR intLine$5[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 60			; 0000003cH
	mov	r9d, DWORD PTR func$3[rsp]
	mov	r8d, DWORD PTR dev$1[rsp]
	mov	edx, DWORD PTR bus$2[rsp]
	mov	rax, QWORD PTR alloc$[rsp]
	movzx	ecx, WORD PTR [rax+8]
	call	?read_config_32_ext@@YAXGHHHHPEAI@Z	; read_config_32_ext

; 237  : 						    read_config_32_ext (alloc->pciSegment, bus, dev, func, 0x10, &config.device.nonBridge.baseAddress[0]);

	mov	eax, 4
	imul	rax, 0
	lea	rax, QWORD PTR config$[rsp+rax+16]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 16
	mov	r9d, DWORD PTR func$3[rsp]
	mov	r8d, DWORD PTR dev$1[rsp]
	mov	edx, DWORD PTR bus$2[rsp]
	mov	rax, QWORD PTR alloc$[rsp]
	movzx	ecx, WORD PTR [rax+8]
	call	?read_config_32_ext@@YAXGHHHHPEAI@Z	; read_config_32_ext

; 238  : 				     	    read_config_32_ext (alloc->pciSegment, bus, dev, func, 0x14, &config.device.nonBridge.baseAddress[1]);

	mov	eax, 4
	imul	rax, 1
	lea	rax, QWORD PTR config$[rsp+rax+16]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 20
	mov	r9d, DWORD PTR func$3[rsp]
	mov	r8d, DWORD PTR dev$1[rsp]
	mov	edx, DWORD PTR bus$2[rsp]
	mov	rax, QWORD PTR alloc$[rsp]
	movzx	ecx, WORD PTR [rax+8]
	call	?read_config_32_ext@@YAXGHHHHPEAI@Z	; read_config_32_ext

; 239  : 					        read_config_32_ext (alloc->pciSegment, bus, dev, func, 0x18, &config.device.nonBridge.baseAddress[2]);

	mov	eax, 4
	imul	rax, 2
	lea	rax, QWORD PTR config$[rsp+rax+16]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 24
	mov	r9d, DWORD PTR func$3[rsp]
	mov	r8d, DWORD PTR dev$1[rsp]
	mov	edx, DWORD PTR bus$2[rsp]
	mov	rax, QWORD PTR alloc$[rsp]
	movzx	ecx, WORD PTR [rax+8]
	call	?read_config_32_ext@@YAXGHHHHPEAI@Z	; read_config_32_ext

; 240  : 					        read_config_32_ext (alloc->pciSegment,bus, dev, func, 0x1C, &config.device.nonBridge.baseAddress[3]);

	mov	eax, 4
	imul	rax, 3
	lea	rax, QWORD PTR config$[rsp+rax+16]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 28
	mov	r9d, DWORD PTR func$3[rsp]
	mov	r8d, DWORD PTR dev$1[rsp]
	mov	edx, DWORD PTR bus$2[rsp]
	mov	rax, QWORD PTR alloc$[rsp]
	movzx	ecx, WORD PTR [rax+8]
	call	?read_config_32_ext@@YAXGHHHHPEAI@Z	; read_config_32_ext

; 241  : 					        read_config_32_ext (alloc->pciSegment, bus, dev, func, 0x20, &config.device.nonBridge.baseAddress[4]);

	mov	eax, 4
	imul	rax, 4
	lea	rax, QWORD PTR config$[rsp+rax+16]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 32			; 00000020H
	mov	r9d, DWORD PTR func$3[rsp]
	mov	r8d, DWORD PTR dev$1[rsp]
	mov	edx, DWORD PTR bus$2[rsp]
	mov	rax, QWORD PTR alloc$[rsp]
	movzx	ecx, WORD PTR [rax+8]
	call	?read_config_32_ext@@YAXGHHHHPEAI@Z	; read_config_32_ext

; 242  : 					
; 243  : 						    *addr_out = config;

	lea	rax, QWORD PTR config$[rsp]
	mov	rdi, QWORD PTR addr_out$[rsp]
	mov	rsi, rax
	mov	ecx, 256				; 00000100H
	rep movsb

; 244  : 						    addr_out->device.nonBridge.interruptLine = intLine & 0xff;

	mov	eax, DWORD PTR intLine$5[rsp]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR addr_out$[rsp]
	mov	BYTE PTR [rcx+60], al

; 245  : 						    addr_out->device.nonBridge.interruptPin = (intLine >> 8) & 0xff;

	mov	eax, DWORD PTR intLine$5[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR addr_out$[rsp]
	mov	BYTE PTR [rcx+61], al

; 246  : 						
; 247  : 					         *bus_ = bus;

	mov	rax, QWORD PTR bus_$[rsp]
	mov	ecx, DWORD PTR bus$2[rsp]
	mov	DWORD PTR [rax], ecx

; 248  : 					         *dev_ = dev;

	mov	rax, QWORD PTR dev_$[rsp]
	mov	ecx, DWORD PTR dev$1[rsp]
	mov	DWORD PTR [rax], ecx

; 249  : 					         *func_ = func;

	mov	rax, QWORD PTR func_$[rsp]
	mov	ecx, DWORD PTR func$3[rsp]
	mov	DWORD PTR [rax], ecx

; 250  : 					         return true;

	mov	al, 1
	jmp	SHORT $LN16@pci_find_d
$LN1@pci_find_d:
$LN4@pci_find_d:

; 251  : 						}
; 252  : 					}	
; 253  : 				}

	jmp	$LN8@pci_find_d
$LN7@pci_find_d:

; 254  : 			}

	jmp	$LN11@pci_find_d
$LN10@pci_find_d:

; 255  : 		}

	jmp	$LN14@pci_find_d
$LN13@pci_find_d:

; 256  : 
; 257  : 	return false;

	xor	al, al
$LN16@pci_find_d:

; 258  : }

	add	rsp, 360				; 00000168H
	pop	rdi
	pop	rsi
	ret	0
?pci_find_device_class@@YA_NEEPEATpci_device_info@@PEAH11@Z ENDP ; pci_find_device_class
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
address$ = 32
bus$ = 64
dev$ = 72
func$ = 80
reg$ = 88
data$ = 96
?write_config_32@@YAXHHHHI@Z PROC			; write_config_32

; 140  : void write_config_32 (int bus, int dev, int func, int reg, unsigned data) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 141  : 	//! write
; 142  : 	unsigned address = header_address (bus, dev, func, reg);

	mov	eax, DWORD PTR bus$[rsp]
	and	eax, 255				; 000000ffH
	shl	eax, 16
	mov	ecx, DWORD PTR dev$[rsp]
	and	ecx, 31
	shl	ecx, 11
	or	eax, ecx
	mov	ecx, DWORD PTR func$[rsp]
	and	ecx, 7
	shl	ecx, 8
	or	eax, ecx
	mov	ecx, DWORD PTR reg$[rsp]
	and	ecx, 63					; 0000003fH
	shl	ecx, 2
	or	eax, ecx
	bts	eax, 31
	mov	DWORD PTR address$[rsp], eax

; 143  : 	x64_outportd (PCI_CONFIG_PORT, address);

	mov	edx, DWORD PTR address$[rsp]
	mov	cx, 3320				; 00000cf8H
	call	x64_outportd

; 144  : 	x64_outportd (PCI_DATA_PORT, data);

	mov	edx, DWORD PTR data$[rsp]
	mov	cx, 3324				; 00000cfcH
	call	x64_outportd

; 145  : }

	add	rsp, 56					; 00000038H
	ret	0
?write_config_32@@YAXHHHHI@Z ENDP			; write_config_32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
address$1 = 32
addr$2 = 40
address$3 = 48
segment$ = 80
bus$ = 88
dev$ = 96
function$ = 104
reg$ = 112
data$ = 120
?read_config_32_ext@@YAXGHHHHPEAI@Z PROC		; read_config_32_ext

; 121  : {

$LN6:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 72					; 00000048H

; 122  : 	if (!acpi_pcie_supported()) {

	call	?acpi_pcie_supported@@YA_NXZ		; acpi_pcie_supported
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@read_confi

; 123  : 		//! read configuration dword
; 124  : 		unsigned address = header_address (bus, dev, function, reg);

	mov	eax, DWORD PTR bus$[rsp]
	and	eax, 255				; 000000ffH
	shl	eax, 16
	mov	ecx, DWORD PTR dev$[rsp]
	and	ecx, 31
	shl	ecx, 11
	or	eax, ecx
	mov	ecx, DWORD PTR function$[rsp]
	and	ecx, 7
	shl	ecx, 8
	or	eax, ecx
	mov	ecx, DWORD PTR reg$[rsp]
	and	ecx, 63					; 0000003fH
	shl	ecx, 2
	or	eax, ecx
	bts	eax, 31
	mov	DWORD PTR address$1[rsp], eax

; 125  : 		x64_outportd (PCI_CONFIG_PORT, address);

	mov	edx, DWORD PTR address$1[rsp]
	mov	cx, 3320				; 00000cf8H
	call	x64_outportd

; 126  : 		*data = x64_inportd (PCI_DATA_PORT);

	mov	cx, 3324				; 00000cfcH
	call	x64_inportd
	mov	rcx, QWORD PTR data$[rsp]
	mov	DWORD PTR [rcx], eax

; 127  : 	}else {

	jmp	SHORT $LN2@read_confi
$LN3@read_confi:

; 128  : 		uint64_t addr = pcie_find_device(segment, bus, dev, function);

	mov	r9d, DWORD PTR function$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	movzx	ecx, WORD PTR segment$[rsp]
	call	?pcie_find_device@@YA_KGHHH@Z		; pcie_find_device
	mov	QWORD PTR addr$2[rsp], rax

; 129  : 		if (addr == 0)

	cmp	QWORD PTR addr$2[rsp], 0
	jne	SHORT $LN1@read_confi

; 130  : 			return;

	jmp	SHORT $LN4@read_confi
$LN1@read_confi:

; 131  : 		void *address = (void*)addr;

	mov	rax, QWORD PTR addr$2[rsp]
	mov	QWORD PTR address$3[rsp], rax

; 132  : 		*data = *raw_offset<volatile uint32_t*>(address, reg);

	mov	edx, DWORD PTR reg$[rsp]
	mov	rcx, QWORD PTR address$3[rsp]
	call	??$raw_offset@PECIPEAX@@YAPECIPEAXH@Z	; raw_offset<unsigned int volatile * __ptr64,void * __ptr64>
	mov	rcx, QWORD PTR data$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR [rcx], eax
$LN2@read_confi:
$LN4@read_confi:

; 133  : 		//printf ("Data returned -> %x\n", *data);
; 134  : 	}
; 135  : }

	add	rsp, 72					; 00000048H
	ret	0
?read_config_32_ext@@YAXGHHHHPEAI@Z ENDP		; read_config_32_ext
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
tv74 = 32
address$1 = 36
addr$2 = 40
address$3 = 48
segment$ = 80
bus$ = 88
dev$ = 96
func$ = 104
reg$ = 112
data$ = 120
?write_config_8@@YAXGHHHHE@Z PROC			; write_config_8

; 84   : void write_config_8 (uint16_t segment, int bus, int dev, int func, int reg, unsigned char data) {

$LN6:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 72					; 00000048H

; 85   : 	if (!acpi_pcie_supported()) {

	call	?acpi_pcie_supported@@YA_NXZ		; acpi_pcie_supported
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@write_conf

; 86   : 		unsigned address = header_address (bus, dev, func, (reg / 4));

	mov	eax, DWORD PTR bus$[rsp]
	and	eax, 255				; 000000ffH
	shl	eax, 16
	mov	ecx, DWORD PTR dev$[rsp]
	and	ecx, 31
	shl	ecx, 11
	or	eax, ecx
	mov	ecx, DWORD PTR func$[rsp]
	and	ecx, 7
	shl	ecx, 8
	or	eax, ecx
	mov	DWORD PTR tv74[rsp], eax
	mov	eax, DWORD PTR reg$[rsp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	and	eax, 63					; 0000003fH
	shl	eax, 2
	mov	ecx, DWORD PTR tv74[rsp]
	or	ecx, eax
	mov	eax, ecx
	bts	eax, 31
	mov	DWORD PTR address$1[rsp], eax

; 87   : 		outportd (PCI_CONFIG_PORT, address);

	mov	edx, DWORD PTR address$1[rsp]
	mov	cx, 3320				; 00000cf8H
	call	?outportd@@YAXGI@Z			; outportd

; 88   : 		outportb (PCI_DATA_PORT + (reg % 4), data);

	mov	eax, DWORD PTR reg$[rsp]
	cdq
	and	edx, 3
	add	eax, edx
	and	eax, 3
	sub	eax, edx
	add	eax, 3324				; 00000cfcH
	movzx	edx, BYTE PTR data$[rsp]
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 89   : 	}else {

	jmp	SHORT $LN2@write_conf
$LN3@write_conf:

; 90   : 		uint64_t addr = pcie_find_device(segment, bus, dev, func);

	mov	r9d, DWORD PTR func$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	movzx	ecx, WORD PTR segment$[rsp]
	call	?pcie_find_device@@YA_KGHHH@Z		; pcie_find_device
	mov	QWORD PTR addr$2[rsp], rax

; 91   : 		if (addr == 0)

	cmp	QWORD PTR addr$2[rsp], 0
	jne	SHORT $LN1@write_conf

; 92   : 			return;

	jmp	SHORT $LN4@write_conf
$LN1@write_conf:

; 93   : 		void *address = (void*)addr;

	mov	rax, QWORD PTR addr$2[rsp]
	mov	QWORD PTR address$3[rsp], rax

; 94   : 		*raw_offset<volatile uint8_t*>(address, reg) = data;

	mov	edx, DWORD PTR reg$[rsp]
	mov	rcx, QWORD PTR address$3[rsp]
	call	??$raw_offset@PECEPEAX@@YAPECEPEAXH@Z	; raw_offset<unsigned char volatile * __ptr64,void * __ptr64>
	movzx	ecx, BYTE PTR data$[rsp]
	mov	BYTE PTR [rax], cl
$LN2@write_conf:
$LN4@write_conf:

; 95   : 	}
; 96   : }

	add	rsp, 72					; 00000048H
	ret	0
?write_config_8@@YAXGHHHHE@Z ENDP			; write_config_8
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
tv74 = 32
address$1 = 36
addr$2 = 40
address$3 = 48
segment$ = 80
bus$ = 88
dev$ = 96
function$ = 104
reg$ = 112
data$ = 120
?read_config_8@@YAXGHHHHPEAE@Z PROC			; read_config_8

; 69   : void read_config_8 (uint16_t segment, int bus, int dev, int function, int reg, unsigned char* data) {

$LN6:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 72					; 00000048H

; 70   : 	if (!acpi_pcie_supported()){

	call	?acpi_pcie_supported@@YA_NXZ		; acpi_pcie_supported
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@read_confi

; 71   : 		unsigned address = header_address (bus, dev, function, (reg / 4));

	mov	eax, DWORD PTR bus$[rsp]
	and	eax, 255				; 000000ffH
	shl	eax, 16
	mov	ecx, DWORD PTR dev$[rsp]
	and	ecx, 31
	shl	ecx, 11
	or	eax, ecx
	mov	ecx, DWORD PTR function$[rsp]
	and	ecx, 7
	shl	ecx, 8
	or	eax, ecx
	mov	DWORD PTR tv74[rsp], eax
	mov	eax, DWORD PTR reg$[rsp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	and	eax, 63					; 0000003fH
	shl	eax, 2
	mov	ecx, DWORD PTR tv74[rsp]
	or	ecx, eax
	mov	eax, ecx
	bts	eax, 31
	mov	DWORD PTR address$1[rsp], eax

; 72   : 		x64_outportd (PCI_CONFIG_PORT, address);

	mov	edx, DWORD PTR address$1[rsp]
	mov	cx, 3320				; 00000cf8H
	call	x64_outportd

; 73   : 		*data = x64_inportb ((PCI_DATA_PORT + (reg % 4)));

	mov	eax, DWORD PTR reg$[rsp]
	cdq
	and	edx, 3
	add	eax, edx
	and	eax, 3
	sub	eax, edx
	add	eax, 3324				; 00000cfcH
	movzx	ecx, ax
	call	x64_inportb
	mov	rcx, QWORD PTR data$[rsp]
	mov	BYTE PTR [rcx], al

; 74   : 	}else {

	jmp	SHORT $LN2@read_confi
$LN3@read_confi:

; 75   : 		uint64_t addr = pcie_find_device(segment, bus, dev, function);

	mov	r9d, DWORD PTR function$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	movzx	ecx, WORD PTR segment$[rsp]
	call	?pcie_find_device@@YA_KGHHH@Z		; pcie_find_device
	mov	QWORD PTR addr$2[rsp], rax

; 76   : 		if (addr == 0)

	cmp	QWORD PTR addr$2[rsp], 0
	jne	SHORT $LN1@read_confi

; 77   : 			return;

	jmp	SHORT $LN4@read_confi
$LN1@read_confi:

; 78   : 		void *address = (void*)addr;

	mov	rax, QWORD PTR addr$2[rsp]
	mov	QWORD PTR address$3[rsp], rax

; 79   : 		*data = *raw_offset<volatile uint8_t*>(address, reg);

	mov	edx, DWORD PTR reg$[rsp]
	mov	rcx, QWORD PTR address$3[rsp]
	call	??$raw_offset@PECEPEAX@@YAPECEPEAXH@Z	; raw_offset<unsigned char volatile * __ptr64,void * __ptr64>
	mov	rcx, QWORD PTR data$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al
$LN2@read_confi:
$LN4@read_confi:

; 80   : 	}
; 81   : }

	add	rsp, 72					; 00000048H
	ret	0
?read_config_8@@YAXGHHHHPEAE@Z ENDP			; read_config_8
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
address$1 = 32
addr$2 = 40
address$3 = 48
segment$ = 80
bus$ = 88
dev$ = 96
function$ = 104
reg$ = 112
data$ = 120
?read_config_32@@YAXGHHHHI@Z PROC			; read_config_32

; 102  : {

$LN6:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 72					; 00000048H

; 103  : 	if (!acpi_pcie_supported()) {

	call	?acpi_pcie_supported@@YA_NXZ		; acpi_pcie_supported
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@read_confi

; 104  : 		//! read configuration dword
; 105  : 		unsigned address = header_address (bus, dev, function, reg);

	mov	eax, DWORD PTR bus$[rsp]
	and	eax, 255				; 000000ffH
	shl	eax, 16
	mov	ecx, DWORD PTR dev$[rsp]
	and	ecx, 31
	shl	ecx, 11
	or	eax, ecx
	mov	ecx, DWORD PTR function$[rsp]
	and	ecx, 7
	shl	ecx, 8
	or	eax, ecx
	mov	ecx, DWORD PTR reg$[rsp]
	and	ecx, 63					; 0000003fH
	shl	ecx, 2
	or	eax, ecx
	bts	eax, 31
	mov	DWORD PTR address$1[rsp], eax

; 106  : 		x64_outportd (PCI_CONFIG_PORT, address);

	mov	edx, DWORD PTR address$1[rsp]
	mov	cx, 3320				; 00000cf8H
	call	x64_outportd

; 107  : 		data = x64_inportd (PCI_DATA_PORT);

	mov	cx, 3324				; 00000cfcH
	call	x64_inportd
	mov	DWORD PTR data$[rsp], eax

; 108  : 	}else {

	jmp	SHORT $LN2@read_confi
$LN3@read_confi:

; 109  : 		uint64_t addr = pcie_find_device(segment, bus, dev, function);

	mov	r9d, DWORD PTR function$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	movzx	ecx, WORD PTR segment$[rsp]
	call	?pcie_find_device@@YA_KGHHH@Z		; pcie_find_device
	mov	QWORD PTR addr$2[rsp], rax

; 110  : 		if (addr == 0)

	cmp	QWORD PTR addr$2[rsp], 0
	jne	SHORT $LN1@read_confi

; 111  : 			return;

	jmp	SHORT $LN4@read_confi
$LN1@read_confi:

; 112  : 		void *address = (void*)addr;

	mov	rax, QWORD PTR addr$2[rsp]
	mov	QWORD PTR address$3[rsp], rax

; 113  : 		data = *raw_offset<volatile uint32_t*>(address, reg * 4);

	mov	eax, DWORD PTR reg$[rsp]
	shl	eax, 2
	mov	edx, eax
	mov	rcx, QWORD PTR address$3[rsp]
	call	??$raw_offset@PECIPEAX@@YAPECIPEAXH@Z	; raw_offset<unsigned int volatile * __ptr64,void * __ptr64>
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR data$[rsp], eax
$LN2@read_confi:
$LN4@read_confi:

; 114  : 	}
; 115  : }

	add	rsp, 72					; 00000048H
	ret	0
?read_config_32@@YAXGHHHHI@Z ENDP			; read_config_32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
tv74 = 32
address$1 = 36
addr$2 = 40
address$3 = 48
segment$ = 80
bus$ = 88
dev$ = 96
function$ = 104
reg$ = 112
data$ = 120
?write_config_16@@YAXGHHHHG@Z PROC			; write_config_16

; 170  : {

$LN6:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 72					; 00000048H

; 171  : 	if (!acpi_pcie_supported()) {

	call	?acpi_pcie_supported@@YA_NXZ		; acpi_pcie_supported
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@write_conf

; 172  : 		//! write configuration word
; 173  : 		unsigned address = header_address (bus, dev, function, (reg / 2));

	mov	eax, DWORD PTR bus$[rsp]
	and	eax, 255				; 000000ffH
	shl	eax, 16
	mov	ecx, DWORD PTR dev$[rsp]
	and	ecx, 31
	shl	ecx, 11
	or	eax, ecx
	mov	ecx, DWORD PTR function$[rsp]
	and	ecx, 7
	shl	ecx, 8
	or	eax, ecx
	mov	DWORD PTR tv74[rsp], eax
	mov	eax, DWORD PTR reg$[rsp]
	cdq
	sub	eax, edx
	sar	eax, 1
	and	eax, 63					; 0000003fH
	shl	eax, 2
	mov	ecx, DWORD PTR tv74[rsp]
	or	ecx, eax
	mov	eax, ecx
	bts	eax, 31
	mov	DWORD PTR address$1[rsp], eax

; 174  : 		x64_outportd (PCI_CONFIG_PORT, address);

	mov	edx, DWORD PTR address$1[rsp]
	mov	cx, 3320				; 00000cf8H
	call	x64_outportd

; 175  : 		x64_outportw ((PCI_DATA_PORT + (reg % 2)), data);

	mov	eax, DWORD PTR reg$[rsp]
	cdq
	and	eax, 1
	xor	eax, edx
	sub	eax, edx
	add	eax, 3324				; 00000cfcH
	movzx	edx, WORD PTR data$[rsp]
	movzx	ecx, ax
	call	x64_outportw

; 176  : 	}else {

	jmp	SHORT $LN2@write_conf
$LN3@write_conf:

; 177  : 		uint64_t addr = pcie_find_device(segment, bus, dev, function);

	mov	r9d, DWORD PTR function$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	movzx	ecx, WORD PTR segment$[rsp]
	call	?pcie_find_device@@YA_KGHHH@Z		; pcie_find_device
	mov	QWORD PTR addr$2[rsp], rax

; 178  : 		if (addr == 0)

	cmp	QWORD PTR addr$2[rsp], 0
	jne	SHORT $LN1@write_conf

; 179  : 			return;

	jmp	SHORT $LN4@write_conf
$LN1@write_conf:

; 180  : 		void *address = (void*)addr;

	mov	rax, QWORD PTR addr$2[rsp]
	mov	QWORD PTR address$3[rsp], rax

; 181  : 		*raw_offset<volatile uint16_t*>(address, reg * 4) = data;

	mov	eax, DWORD PTR reg$[rsp]
	shl	eax, 2
	mov	edx, eax
	mov	rcx, QWORD PTR address$3[rsp]
	call	??$raw_offset@PECGPEAX@@YAPECGPEAXH@Z	; raw_offset<unsigned short volatile * __ptr64,void * __ptr64>
	movzx	ecx, WORD PTR data$[rsp]
	mov	WORD PTR [rax], cx
$LN2@write_conf:
$LN4@write_conf:

; 182  : 	}
; 183  : }

	add	rsp, 72					; 00000048H
	ret	0
?write_config_16@@YAXGHHHHG@Z ENDP			; write_config_16
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
tv74 = 32
address$1 = 36
addr$2 = 40
address$3 = 48
segment$ = 80
bus$ = 88
dev$ = 96
function$ = 104
reg$ = 112
data$ = 120
?read_config_16@@YAXGHHHHPEAG@Z PROC			; read_config_16

; 151  : {

$LN6:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 72					; 00000048H

; 152  : 	if (!acpi_pcie_supported()) {

	call	?acpi_pcie_supported@@YA_NXZ		; acpi_pcie_supported
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@read_confi

; 153  : 		//! read configuration word
; 154  : 		unsigned address = header_address (bus, dev, function, (reg / 2));

	mov	eax, DWORD PTR bus$[rsp]
	and	eax, 255				; 000000ffH
	shl	eax, 16
	mov	ecx, DWORD PTR dev$[rsp]
	and	ecx, 31
	shl	ecx, 11
	or	eax, ecx
	mov	ecx, DWORD PTR function$[rsp]
	and	ecx, 7
	shl	ecx, 8
	or	eax, ecx
	mov	DWORD PTR tv74[rsp], eax
	mov	eax, DWORD PTR reg$[rsp]
	cdq
	sub	eax, edx
	sar	eax, 1
	and	eax, 63					; 0000003fH
	shl	eax, 2
	mov	ecx, DWORD PTR tv74[rsp]
	or	ecx, eax
	mov	eax, ecx
	bts	eax, 31
	mov	DWORD PTR address$1[rsp], eax

; 155  : 		x64_outportd (PCI_CONFIG_PORT, address);

	mov	edx, DWORD PTR address$1[rsp]
	mov	cx, 3320				; 00000cf8H
	call	x64_outportd

; 156  : 		*data = x64_inportw (PCI_DATA_PORT + (reg % 2));

	mov	eax, DWORD PTR reg$[rsp]
	cdq
	and	eax, 1
	xor	eax, edx
	sub	eax, edx
	add	eax, 3324				; 00000cfcH
	movzx	ecx, ax
	call	x64_inportw
	mov	rcx, QWORD PTR data$[rsp]
	mov	WORD PTR [rcx], ax

; 157  : 	}else {

	jmp	SHORT $LN2@read_confi
$LN3@read_confi:

; 158  : 		uint64_t addr = pcie_find_device(segment, bus, dev, function);

	mov	r9d, DWORD PTR function$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	movzx	ecx, WORD PTR segment$[rsp]
	call	?pcie_find_device@@YA_KGHHH@Z		; pcie_find_device
	mov	QWORD PTR addr$2[rsp], rax

; 159  : 		if (addr == 0)

	cmp	QWORD PTR addr$2[rsp], 0
	jne	SHORT $LN1@read_confi

; 160  : 			return;

	jmp	SHORT $LN4@read_confi
$LN1@read_confi:

; 161  : 		void *address = (void*)addr;

	mov	rax, QWORD PTR addr$2[rsp]
	mov	QWORD PTR address$3[rsp], rax

; 162  : 		*data = *raw_offset<volatile uint16_t*>(address, reg);

	mov	edx, DWORD PTR reg$[rsp]
	mov	rcx, QWORD PTR address$3[rsp]
	call	??$raw_offset@PECGPEAX@@YAPECGPEAXH@Z	; raw_offset<unsigned short volatile * __ptr64,void * __ptr64>
	mov	rcx, QWORD PTR data$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR [rcx], ax
$LN2@read_confi:
$LN4@read_confi:

; 163  : 	}
; 164  : }

	add	rsp, 72					; 00000048H
	ret	0
?read_config_16@@YAXGHHHHPEAG@Z ENDP			; read_config_16
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\pci.cpp
_TEXT	SEGMENT
reg$1 = 32
address$2 = 36
bus$ = 64
dev$ = 72
function$ = 80
dev_info$ = 88
?read_config_header@@YAXHHHPEATpci_device_info@@@Z PROC	; read_config_header

; 187  : {

$LN7:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 188  : 	if (!acpi_pcie_supported()) {

	call	?acpi_pcie_supported@@YA_NXZ		; acpi_pcie_supported
	movzx	eax, al
	test	eax, eax
	jne	$LN4@read_confi

; 189  : 		unsigned address = 0;

	mov	DWORD PTR address$2[rsp], 0

; 190  : 		int reg;
; 191  : 
; 192  : 		for (reg = 0; reg < (PCI_CONFIGHEADER_SIZE / 4); reg ++)

	mov	DWORD PTR reg$1[rsp], 0
	jmp	SHORT $LN3@read_confi
$LN2@read_confi:
	mov	eax, DWORD PTR reg$1[rsp]
	inc	eax
	mov	DWORD PTR reg$1[rsp], eax
$LN3@read_confi:
	cmp	DWORD PTR reg$1[rsp], 64		; 00000040H
	jge	SHORT $LN1@read_confi

; 193  : 		{
; 194  : 			address = header_address (bus, dev, function, reg);

	mov	eax, DWORD PTR bus$[rsp]
	and	eax, 255				; 000000ffH
	shl	eax, 16
	mov	ecx, DWORD PTR dev$[rsp]
	and	ecx, 31
	shl	ecx, 11
	or	eax, ecx
	mov	ecx, DWORD PTR function$[rsp]
	and	ecx, 7
	shl	ecx, 8
	or	eax, ecx
	mov	ecx, DWORD PTR reg$1[rsp]
	and	ecx, 63					; 0000003fH
	shl	ecx, 2
	or	eax, ecx
	bts	eax, 31
	mov	DWORD PTR address$2[rsp], eax

; 195  : 			x64_outportd (PCI_CONFIG_PORT, address);

	mov	edx, DWORD PTR address$2[rsp]
	mov	cx, 3320				; 00000cf8H
	call	x64_outportd

; 196  : 			dev_info->header[reg] = x64_inportd(PCI_DATA_PORT);

	mov	cx, 3324				; 00000cfcH
	call	x64_inportd
	movsxd	rcx, DWORD PTR reg$1[rsp]
	mov	rdx, QWORD PTR dev_info$[rsp]
	mov	DWORD PTR [rdx+rcx*4], eax

; 197  : 		}

	jmp	SHORT $LN2@read_confi
$LN1@read_confi:
$LN4@read_confi:

; 198  : 	} 
; 199  : }

	add	rsp, 56					; 00000038H
	ret	0
?read_config_header@@YAXHHHPEATpci_device_info@@@Z ENDP	; read_config_header
_TEXT	ENDS
END
