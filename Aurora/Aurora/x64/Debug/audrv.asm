; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?drivers@@3PAPEAU_aurora_driver_@@A		; drivers
PUBLIC	?au_devices@@3PAPEAU_aurora_device_@@A		; au_devices
_BSS	SEGMENT
?drivers@@3PAPEAU_aurora_driver_@@A DQ 0100H DUP (?)	; drivers
?au_devices@@3PAPEAU_aurora_device_@@A DQ 0100H DUP (?)	; au_devices
driver_class_unique_id DD 01H DUP (?)
	ALIGN	8

driver_load_base DQ 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
$SG3886	DB	'AuDriverMain', 00H
	ORG $+3
$SG3889	DB	'AuDriverUnload', 00H
	ORG $+1
$SG3899	DB	'AuDriverMain', 00H
	ORG $+3
$SG3902	DB	'AuDriverUnload', 00H
	ORG $+1
$SG3925	DB	'[aurora]: initializing drivers, please wait... ', 0aH, 00H
	ORG $+7
$SG3930	DB	'/audrv.cnf', 00H
CONST	ENDS
PUBLIC	?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ; AuDrvMngrInitialize
PUBLIC	?AuDriverLoadMem@@YAXPEAE@Z			; AuDriverLoadMem
PUBLIC	AuRegisterDevice
PUBLIC	AuCheckDevice
PUBLIC	?AuRequestDriverId@@YAIXZ			; AuRequestDriverId
PUBLIC	?AuDecreaseDriverId@@YAXXZ			; AuDecreaseDriverId
PUBLIC	?AuGetConfEntry@@YAPEADIIPEAEH@Z		; AuGetConfEntry
PUBLIC	?AuCreateDriverInstance@@YAXPEAD@Z		; AuCreateDriverInstance
PUBLIC	?AuGetDriverName@@YAXIIPEAEH@Z			; AuGetDriverName
PUBLIC	?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z	; AuDriverLoad
EXTRN	strcpy:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	?atoi@@YAHPEBD@Z:PROC				; atoi
EXTRN	printf:PROC
EXTRN	?AuGetProcAddress@@YAPEAXPEAXPEBD@Z:PROC	; AuGetProcAddress
EXTRN	?AuPeLinkLibrary@@YAXPEAX@Z:PROC		; AuPeLinkLibrary
EXTRN	AuPmmngrAlloc:PROC
EXTRN	p2v:PROC
EXTRN	v2p:PROC
EXTRN	AuMapPage:PROC
EXTRN	malloc:PROC
EXTRN	free:PROC
EXTRN	?fat32_open@@YAPEAU_vfs_node_@@PEAU1@PEAD@Z:PROC ; fat32_open
EXTRN	?fat32_read@@YA_KPEAU_vfs_node_@@PEA_K@Z:PROC	; fat32_read
EXTRN	?pci_express_get_device@@YA_KGHHH@Z:PROC	; pci_express_get_device
EXTRN	pci_express_read:PROC
_BSS	SEGMENT
devices_count DD 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD imagerel $LN21
	DD	imagerel $LN21+718
	DD	imagerel $unwind$?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z
$pdata$?AuDriverLoadMem@@YAXPEAE@Z DD imagerel $LN5
	DD	imagerel $LN5+98
	DD	imagerel $unwind$?AuDriverLoadMem@@YAXPEAE@Z
$pdata$AuCheckDevice DD imagerel $LN7
	DD	imagerel $LN7+143
	DD	imagerel $unwind$AuCheckDevice
$pdata$?AuRequestDriverId@@YAIXZ DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$?AuRequestDriverId@@YAIXZ
$pdata$?AuGetConfEntry@@YAPEADIIPEAEH@Z DD imagerel $LN21
	DD	imagerel $LN21+596
	DD	imagerel $unwind$?AuGetConfEntry@@YAPEADIIPEAEH@Z
$pdata$?AuCreateDriverInstance@@YAXPEAD@Z DD imagerel $LN3
	DD	imagerel $LN3+114
	DD	imagerel $unwind$?AuCreateDriverInstance@@YAXPEAD@Z
$pdata$?AuGetDriverName@@YAXIIPEAEH@Z DD imagerel $LN9
	DD	imagerel $LN9+234
	DD	imagerel $unwind$?AuGetDriverName@@YAXIIPEAEH@Z
$pdata$?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z DD imagerel $LN5
	DD	imagerel $LN5+419
	DD	imagerel $unwind$?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD 020c01H
	DD	013010cH
$unwind$?AuDriverLoadMem@@YAXPEAE@Z DD 010901H
	DD	0a209H
$unwind$AuCheckDevice DD 011301H
	DD	02213H
$unwind$?AuRequestDriverId@@YAIXZ DD 010401H
	DD	02204H
$unwind$?AuGetConfEntry@@YAPEADIIPEAEH@Z DD 011601H
	DD	0c216H
$unwind$?AuCreateDriverInstance@@YAXPEAD@Z DD 010901H
	DD	06209H
$unwind$?AuGetDriverName@@YAXIIPEAEH@Z DD 011601H
	DD	0c216H
$unwind$?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z DD 010e01H
	DD	0c20eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\audrv.cpp
_TEXT	SEGMENT
next_base_offset$ = 32
file$ = 40
buffer$ = 48
block$1 = 56
virtual_base$ = 64
entry_addr$ = 72
unload_addr$ = 80
filename$ = 112
driver$ = 120
?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z PROC	; AuDriverLoad

; 195  : void AuDriverLoad (char* filename, aurora_driver_t *driver) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 196  : 	int next_base_offset = 0;

	mov	DWORD PTR next_base_offset$[rsp], 0

; 197  : 	uint64_t* virtual_base = (uint64_t*)driver_load_base;

	mov	rax, QWORD PTR driver_load_base
	mov	QWORD PTR virtual_base$[rsp], rax

; 198  : 
; 199  : 	vfs_node_t *file = fat32_open(NULL, filename);

	mov	rdx, QWORD PTR filename$[rsp]
	xor	ecx, ecx
	call	?fat32_open@@YAPEAU_vfs_node_@@PEAU1@PEAD@Z ; fat32_open
	mov	QWORD PTR file$[rsp], rax

; 200  : 	uint64_t* buffer = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buffer$[rsp], rax

; 201  : 	memset(buffer, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 202  : 	fat32_read(file, buffer);

	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	call	?fat32_read@@YA_KPEAU_vfs_node_@@PEA_K@Z ; fat32_read

; 203  : 	AuMapPage((uint64_t)buffer,driver_load_base,0);

	xor	r8d, r8d
	mov	rdx, QWORD PTR driver_load_base
	mov	rcx, QWORD PTR buffer$[rsp]
	call	AuMapPage

; 204  : 	next_base_offset = 1;

	mov	DWORD PTR next_base_offset$[rsp], 1
$LN2@AuDriverLo:

; 205  : 	
; 206  : 
; 207  : 	while(file->eof != 1) {

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, BYTE PTR [rax+36]
	cmp	eax, 1
	je	SHORT $LN1@AuDriverLo

; 208  : 		uint64_t* block = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR block$1[rsp], rax

; 209  : 		memset(block, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR block$1[rsp]
	call	memset

; 210  : 		fat32_read (file,block);

	mov	rdx, QWORD PTR block$1[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	call	?fat32_read@@YA_KPEAU_vfs_node_@@PEA_K@Z ; fat32_read

; 211  : 		AuMapPage((uint64_t)block,(driver_load_base + next_base_offset * 4096), 0);

	mov	eax, DWORD PTR next_base_offset$[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR driver_load_base
	add	rcx, rax
	mov	rax, rcx
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, QWORD PTR block$1[rsp]
	call	AuMapPage

; 212  : 		next_base_offset++;

	mov	eax, DWORD PTR next_base_offset$[rsp]
	inc	eax
	mov	DWORD PTR next_base_offset$[rsp], eax

; 213  : 	}

	jmp	SHORT $LN2@AuDriverLo
$LN1@AuDriverLo:

; 214  : 
; 215  : 
; 216  : 	void* entry_addr = AuGetProcAddress((void*)driver_load_base,"AuDriverMain");

	lea	rdx, OFFSET FLAT:$SG3886
	mov	rcx, QWORD PTR driver_load_base
	call	?AuGetProcAddress@@YAPEAXPEAXPEBD@Z	; AuGetProcAddress
	mov	QWORD PTR entry_addr$[rsp], rax

; 217  : 	void* unload_addr = AuGetProcAddress((void*)driver_load_base,"AuDriverUnload");

	lea	rdx, OFFSET FLAT:$SG3889
	mov	rcx, QWORD PTR driver_load_base
	call	?AuGetProcAddress@@YAPEAXPEAXPEBD@Z	; AuGetProcAddress
	mov	QWORD PTR unload_addr$[rsp], rax

; 218  : 
; 219  : 	AuPeLinkLibrary(virtual_base);

	mov	rcx, QWORD PTR virtual_base$[rsp]
	call	?AuPeLinkLibrary@@YAXPEAX@Z		; AuPeLinkLibrary

; 220  : 	driver->entry = (au_drv_entry)entry_addr;

	mov	rax, QWORD PTR driver$[rsp]
	mov	rcx, QWORD PTR entry_addr$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 221  : 	driver->unload = (au_drv_unload)unload_addr;

	mov	rax, QWORD PTR driver$[rsp]
	mov	rcx, QWORD PTR unload_addr$[rsp]
	mov	QWORD PTR [rax+64], rcx

; 222  : 	driver->base = AU_DRIVER_BASE_START;

	mov	rax, QWORD PTR driver$[rsp]
	mov	rcx, -70368739983360			; ffffc00000400000H
	mov	QWORD PTR [rax+40], rcx

; 223  : 	driver->end = driver->base + file->size;

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	rcx, QWORD PTR driver$[rsp]
	add	rax, QWORD PTR [rcx+40]
	mov	rcx, QWORD PTR driver$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 224  : 	driver->present = true;

	mov	rax, QWORD PTR driver$[rsp]
	mov	BYTE PTR [rax+34], 1

; 225  : 	driver_load_base = driver_load_base + next_base_offset * 4096;

	mov	eax, DWORD PTR next_base_offset$[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR driver_load_base
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR driver_load_base, rax

; 226  : 	
; 227  : 	free(file);

	mov	rcx, QWORD PTR file$[rsp]
	call	free

; 228  : }

	add	rsp, 104				; 00000068H
	ret	0
?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z ENDP	; AuDriverLoad
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\audrv.cpp
_TEXT	SEGMENT
i$ = 32
p$ = 40
offset$ = 48
drivername$ = 56
vendor_id$ = 112
device_id$ = 120
buffer$ = 128
entryoff$ = 136
?AuGetDriverName@@YAXIIPEAEH@Z PROC			; AuGetDriverName

; 163  : void AuGetDriverName (uint32_t vendor_id, uint32_t device_id,uint8_t* buffer,int entryoff) {

$LN9:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 164  : 
; 165  : 	/* Get the entry offset for required device driver */
; 166  : 	char* offset = AuGetConfEntry(vendor_id, device_id, buffer, entryoff);

	mov	r9d, DWORD PTR entryoff$[rsp]
	mov	r8, QWORD PTR buffer$[rsp]
	mov	edx, DWORD PTR device_id$[rsp]
	mov	ecx, DWORD PTR vendor_id$[rsp]
	call	?AuGetConfEntry@@YAPEADIIPEAEH@Z	; AuGetConfEntry
	mov	QWORD PTR offset$[rsp], rax

; 167  : 
; 168  : 	if (offset == NULL)

	cmp	QWORD PTR offset$[rsp], 0
	jne	SHORT $LN6@AuGetDrive

; 169  : 		return;

	jmp	$LN7@AuGetDrive
$LN6@AuGetDrive:

; 170  : 	char *p = strchr(offset, ']');

	mov	edx, 93					; 0000005dH
	mov	rcx, QWORD PTR offset$[rsp]
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 171  : 	if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN5@AuGetDrive

; 172  : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN5@AuGetDrive:

; 173  : 
; 174  : 	/* get the driver path */
; 175  : 	char drivername[32];
; 176  : 	memset(drivername,0, 32);

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	lea	rcx, QWORD PTR drivername$[rsp]
	call	memset

; 177  : 	int i = 0;

	mov	DWORD PTR i$[rsp], 0

; 178  : 	for (i = 0; i < 32; i++) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@AuGetDrive
$LN3@AuGetDrive:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN4@AuGetDrive:
	cmp	DWORD PTR i$[rsp], 32			; 00000020H
	jge	SHORT $LN2@AuGetDrive

; 179  : 		if(p[i] == '|')

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN1@AuGetDrive

; 180  : 			break;

	jmp	SHORT $LN2@AuGetDrive
$LN1@AuGetDrive:

; 181  : 		drivername[i] = p[i];

	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR drivername$[rsp+rcx], al

; 182  : 	}

	jmp	SHORT $LN3@AuGetDrive
$LN2@AuGetDrive:

; 183  : 
; 184  : 	drivername[i] = 0;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	BYTE PTR drivername$[rsp+rax], 0

; 185  : 
; 186  : 	AuCreateDriverInstance(drivername);

	lea	rcx, QWORD PTR drivername$[rsp]
	call	?AuCreateDriverInstance@@YAXPEAD@Z	; AuCreateDriverInstance
$LN7@AuGetDrive:

; 187  : 	return;
; 188  : }

	add	rsp, 104				; 00000068H
	ret	0
?AuGetDriverName@@YAXIIPEAEH@Z ENDP			; AuGetDriverName
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\audrv.cpp
_TEXT	SEGMENT
driver$ = 32
drivername$ = 64
?AuCreateDriverInstance@@YAXPEAD@Z PROC			; AuCreateDriverInstance

; 146  : void AuCreateDriverInstance (char* drivername) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 147  : 	aurora_driver_t *driver = (aurora_driver_t*)malloc(sizeof(aurora_driver_t));

	mov	ecx, 72					; 00000048H
	call	malloc
	mov	QWORD PTR driver$[rsp], rax

; 148  : 	memset(driver, 0, sizeof(aurora_driver_t));

	mov	r8d, 72					; 00000048H
	xor	edx, edx
	mov	rcx, QWORD PTR driver$[rsp]
	call	memset

; 149  : 	strcpy(driver->name, drivername);

	mov	rax, QWORD PTR driver$[rsp]
	add	rax, 2
	mov	rdx, QWORD PTR drivername$[rsp]
	mov	rcx, rax
	call	strcpy

; 150  : 	driver->id = AuRequestDriverId();

	call	?AuRequestDriverId@@YAIXZ		; AuRequestDriverId
	mov	rcx, QWORD PTR driver$[rsp]
	mov	BYTE PTR [rcx], al

; 151  : 	driver->present = false;

	mov	rax, QWORD PTR driver$[rsp]
	mov	BYTE PTR [rax+34], 0

; 152  : 	drivers[driver->id] = driver;

	mov	rax, QWORD PTR driver$[rsp]
	movzx	eax, BYTE PTR [rax]
	lea	rcx, OFFSET FLAT:?drivers@@3PAPEAU_aurora_driver_@@A ; drivers
	mov	rdx, QWORD PTR driver$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 153  : 
; 154  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuCreateDriverInstance@@YAXPEAD@Z ENDP			; AuCreateDriverInstance
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\audrv.cpp
_TEXT	SEGMENT
num$ = 32
p$ = 40
i$ = 48
i$1 = 52
fbuf$ = 56
devid$ = 64
entret$ = 68
venid$ = 72
entry_num$ = 76
pi$ = 80
vendor_id$ = 112
device_id$ = 120
buffer$ = 128
entryoff$ = 136
?AuGetConfEntry@@YAPEADIIPEAEH@Z PROC			; AuGetConfEntry

; 74   : char* AuGetConfEntry(uint32_t vendor_id, uint32_t device_id,uint8_t* buffer,int entryoff) {

$LN21:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H
$re$22:

; 75   : re:
; 76   : 	int entry_num = entryoff;

	mov	eax, DWORD PTR entryoff$[rsp]
	mov	DWORD PTR entry_num$[rsp], eax

; 77   : 	char* fbuf = (char*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR fbuf$[rsp], rax
$search$23:

; 78   : 	/* Check the entry for the device */
; 79   : search:
; 80   : 	char* p = strchr(fbuf,'(');

	mov	edx, 40					; 00000028H
	mov	rcx, QWORD PTR fbuf$[rsp]
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 81   : 	if (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN18@AuGetConfE

; 82   : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 83   : 		fbuf++;

	mov	rax, QWORD PTR fbuf$[rsp]
	inc	rax
	mov	QWORD PTR fbuf$[rsp], rax
$LN18@AuGetConfE:

; 84   : 	}
; 85   : 	int entret = atoi(p);

	mov	rcx, QWORD PTR p$[rsp]
	call	?atoi@@YAHPEBD@Z			; atoi
	mov	DWORD PTR entret$[rsp], eax

; 86   : 	
; 87   : 	/* Check for last entry '(0)' it indicates that
; 88   : 	 * there is no more entry
; 89   : 	 */
; 90   : 	if (entret == 0) {

	cmp	DWORD PTR entret$[rsp], 0
	jne	SHORT $LN17@AuGetConfE

; 91   : 		return 0;

	xor	eax, eax
	jmp	$LN19@AuGetConfE
$LN17@AuGetConfE:

; 92   : 	}
; 93   : 
; 94   : 	if (entret != entry_num)

	mov	eax, DWORD PTR entry_num$[rsp]
	cmp	DWORD PTR entret$[rsp], eax
	je	SHORT $LN16@AuGetConfE

; 95   : 		goto search;

	jmp	SHORT $search$23
$LN16@AuGetConfE:

; 96   : 
; 97   : 
; 98   : 	/* Search for vendor id of the product */
; 99   : 	fbuf = p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR fbuf$[rsp], rax

; 100  : 	p = strchr(fbuf,'[');

	mov	edx, 91					; 0000005bH
	mov	rcx, QWORD PTR fbuf$[rsp]
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 101  : 	int venid ,devid = 0;

	mov	DWORD PTR devid$[rsp], 0

; 102  : 	int pi = 0;

	mov	DWORD PTR pi$[rsp], 0

; 103  : 	if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN15@AuGetConfE

; 104  : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN15@AuGetConfE:

; 105  : 
; 106  : 	fbuf = p;

	mov	rax, QWORD PTR p$[rsp]
	mov	QWORD PTR fbuf$[rsp], rax

; 107  : 	char num[2];
; 108  : 	memset(num, 0, 2);

	mov	r8d, 2
	xor	edx, edx
	lea	rcx, QWORD PTR num$[rsp]
	call	memset

; 109  : 	int i;
; 110  : 	for (i= 0; i < 2; i++) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN14@AuGetConfE
$LN13@AuGetConfE:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN14@AuGetConfE:
	cmp	DWORD PTR i$[rsp], 2
	jge	SHORT $LN12@AuGetConfE

; 111  : 		if (p[i] == ',' || p[i] == ']')

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN10@AuGetConfE
	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN11@AuGetConfE
$LN10@AuGetConfE:

; 112  : 			break;

	jmp	SHORT $LN12@AuGetConfE
$LN11@AuGetConfE:

; 113  : 		num[i] = p[i];

	movsxd	rax, DWORD PTR i$[rsp]
	movsxd	rcx, DWORD PTR i$[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR num$[rsp+rcx], al

; 114  : 		fbuf++;

	mov	rax, QWORD PTR fbuf$[rsp]
	inc	rax
	mov	QWORD PTR fbuf$[rsp], rax

; 115  : 	}

	jmp	SHORT $LN13@AuGetConfE
$LN12@AuGetConfE:

; 116  : 	num[i]=0;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	BYTE PTR num$[rsp+rax], 0

; 117  : 	venid = atoi(num);

	lea	rcx, QWORD PTR num$[rsp]
	call	?atoi@@YAHPEBD@Z			; atoi
	mov	DWORD PTR venid$[rsp], eax

; 118  : 
; 119  : 	/* Now search for device id / product id */
; 120  : 	p = strchr(fbuf,',');

	mov	edx, 44					; 0000002cH
	mov	rcx, QWORD PTR fbuf$[rsp]
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 121  : 	if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN9@AuGetConfE

; 122  : 		p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN9@AuGetConfE:

; 123  : 	for (int i = 0; i < 2; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN8@AuGetConfE
$LN7@AuGetConfE:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN8@AuGetConfE:
	cmp	DWORD PTR i$1[rsp], 2
	jge	SHORT $LN6@AuGetConfE

; 124  : 		if (p[i] == ',' || p[i] == ']')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN4@AuGetConfE
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN5@AuGetConfE
$LN4@AuGetConfE:

; 125  : 			break;

	jmp	SHORT $LN6@AuGetConfE
$LN5@AuGetConfE:

; 126  : 		num[i] = p[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR num$[rsp+rcx], al

; 127  : 	}

	jmp	SHORT $LN7@AuGetConfE
$LN6@AuGetConfE:

; 128  : 	num[i] = 0;

	movsxd	rax, DWORD PTR i$[rsp]
	mov	BYTE PTR num$[rsp+rax], 0

; 129  : 	devid = atoi(num);

	lea	rcx, QWORD PTR num$[rsp]
	call	?atoi@@YAHPEBD@Z			; atoi
	mov	DWORD PTR devid$[rsp], eax

; 130  : 
; 131  : 
; 132  : 
; 133  : 	if (vendor_id != venid || devid != device_id) {

	mov	eax, DWORD PTR venid$[rsp]
	cmp	DWORD PTR vendor_id$[rsp], eax
	jne	SHORT $LN2@AuGetConfE
	mov	eax, DWORD PTR device_id$[rsp]
	cmp	DWORD PTR devid$[rsp], eax
	je	SHORT $LN3@AuGetConfE
$LN2@AuGetConfE:

; 134  : 		entryoff++;

	mov	eax, DWORD PTR entryoff$[rsp]
	inc	eax
	mov	DWORD PTR entryoff$[rsp], eax

; 135  : 		goto re;

	jmp	$re$22
$LN3@AuGetConfE:

; 136  : 	}
; 137  : 
; 138  : 	/* Finally we found the device driver */
; 139  : 	if (vendor_id == venid && devid == device_id) {

	mov	eax, DWORD PTR venid$[rsp]
	cmp	DWORD PTR vendor_id$[rsp], eax
	jne	SHORT $LN1@AuGetConfE
	mov	eax, DWORD PTR device_id$[rsp]
	cmp	DWORD PTR devid$[rsp], eax
	jne	SHORT $LN1@AuGetConfE

; 140  : 		return fbuf;

	mov	rax, QWORD PTR fbuf$[rsp]
	jmp	SHORT $LN19@AuGetConfE
$LN1@AuGetConfE:

; 141  : 	}
; 142  : 
; 143  : 	return 0;

	xor	eax, eax
$LN19@AuGetConfE:

; 144  : }

	add	rsp, 104				; 00000068H
	ret	0
?AuGetConfEntry@@YAPEADIIPEAEH@Z ENDP			; AuGetConfEntry
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\audrv.cpp
_TEXT	SEGMENT
?AuDecreaseDriverId@@YAXXZ PROC				; AuDecreaseDriverId

; 63   : 	driver_class_unique_id--;

	mov	eax, DWORD PTR driver_class_unique_id
	dec	eax
	mov	DWORD PTR driver_class_unique_id, eax

; 64   : }

	ret	0
?AuDecreaseDriverId@@YAXXZ ENDP				; AuDecreaseDriverId
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\audrv.cpp
_TEXT	SEGMENT
uid$ = 0
?AuRequestDriverId@@YAIXZ PROC				; AuRequestDriverId

; 55   : uint32_t AuRequestDriverId () {

$LN3:
	sub	rsp, 24

; 56   : 	uint32_t uid = driver_class_unique_id;

	mov	eax, DWORD PTR driver_class_unique_id
	mov	DWORD PTR uid$[rsp], eax

; 57   : 	driver_class_unique_id++;

	mov	eax, DWORD PTR driver_class_unique_id
	inc	eax
	mov	DWORD PTR driver_class_unique_id, eax

; 58   : 	return uid;

	mov	eax, DWORD PTR uid$[rsp]

; 59   : }

	add	rsp, 24
	ret	0
?AuRequestDriverId@@YAIXZ ENDP				; AuRequestDriverId
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\audrv.cpp
_TEXT	SEGMENT
i$1 = 0
classC$ = 32
subclassC$ = 40
prog_if$ = 48
AuCheckDevice PROC

; 260  : AU_EXTERN AU_EXPORT bool AuCheckDevice (uint16_t classC, uint16_t subclassC, uint8_t prog_if) {

$LN7:
	mov	BYTE PTR [rsp+24], r8b
	mov	WORD PTR [rsp+16], dx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 24

; 261  : 	for (int i = 0; i < devices_count; i++) 

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@AuCheckDev
$LN3@AuCheckDev:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@AuCheckDev:
	mov	eax, DWORD PTR devices_count
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN2@AuCheckDev

; 262  : 		if (au_devices[i]->class_code == classC &&
; 263  : 			au_devices[i]->sub_class_code == subclassC &&
; 264  : 			au_devices[i]->prog_if == prog_if)

	movsxd	rax, DWORD PTR i$1[rsp]
	lea	rcx, OFFSET FLAT:?au_devices@@3PAPEAU_aurora_device_@@A ; au_devices
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	eax, WORD PTR [rax]
	movzx	ecx, WORD PTR classC$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN1@AuCheckDev
	movsxd	rax, DWORD PTR i$1[rsp]
	lea	rcx, OFFSET FLAT:?au_devices@@3PAPEAU_aurora_device_@@A ; au_devices
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	eax, WORD PTR [rax+2]
	movzx	ecx, WORD PTR subclassC$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN1@AuCheckDev
	movsxd	rax, DWORD PTR i$1[rsp]
	lea	rcx, OFFSET FLAT:?au_devices@@3PAPEAU_aurora_device_@@A ; au_devices
	mov	rax, QWORD PTR [rcx+rax*8]
	movzx	eax, BYTE PTR [rax+4]
	movzx	ecx, BYTE PTR prog_if$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN1@AuCheckDev

; 265  : 			return true;

	mov	al, 1
	jmp	SHORT $LN5@AuCheckDev
$LN1@AuCheckDev:

; 266  : 
; 267  : 	return false;

	jmp	SHORT $LN3@AuCheckDev
$LN2@AuCheckDev:
	xor	al, al
$LN5@AuCheckDev:

; 268  : }

	add	rsp, 24
	ret	0
AuCheckDevice ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\audrv.cpp
_TEXT	SEGMENT
dev$ = 8
AuRegisterDevice PROC

; 249  : AU_EXTERN AU_EXPORT void AuRegisterDevice (aurora_device_t *dev) {

	mov	QWORD PTR [rsp+8], rcx

; 250  : 	au_devices[devices_count] = dev;

	movsxd	rax, DWORD PTR devices_count
	lea	rcx, OFFSET FLAT:?au_devices@@3PAPEAU_aurora_device_@@A ; au_devices
	mov	rdx, QWORD PTR dev$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 251  : 	devices_count++;

	mov	eax, DWORD PTR devices_count
	inc	eax
	mov	DWORD PTR devices_count, eax

; 252  : }

	ret	0
AuRegisterDevice ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\audrv.cpp
_TEXT	SEGMENT
r$ = 32
virtual_base$ = 40
entry_addr$ = 48
entry$ = 56
unload_addr$ = 64
mem$ = 96
?AuDriverLoadMem@@YAXPEAE@Z PROC			; AuDriverLoadMem

; 230  : void AuDriverLoadMem (uint8_t* mem) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 231  : 	uint64_t* virtual_base = (uint64_t*)mem;

	mov	rax, QWORD PTR mem$[rsp]
	mov	QWORD PTR virtual_base$[rsp], rax

; 232  : 
; 233  : 
; 234  : 	void* entry_addr = AuGetProcAddress((void*)mem,"AuDriverMain");

	lea	rdx, OFFSET FLAT:$SG3899
	mov	rcx, QWORD PTR mem$[rsp]
	call	?AuGetProcAddress@@YAPEAXPEAXPEBD@Z	; AuGetProcAddress
	mov	QWORD PTR entry_addr$[rsp], rax

; 235  : 	void* unload_addr = AuGetProcAddress((void*)mem,"AuDriverUnload");

	lea	rdx, OFFSET FLAT:$SG3902
	mov	rcx, QWORD PTR mem$[rsp]
	call	?AuGetProcAddress@@YAPEAXPEAXPEBD@Z	; AuGetProcAddress
	mov	QWORD PTR unload_addr$[rsp], rax

; 236  : 
; 237  : 	AuPeLinkLibrary(virtual_base);

	mov	rcx, QWORD PTR virtual_base$[rsp]
	call	?AuPeLinkLibrary@@YAXPEAX@Z		; AuPeLinkLibrary

; 238  : 	au_drv_entry entry = (au_drv_entry)entry_addr;

	mov	rax, QWORD PTR entry_addr$[rsp]
	mov	QWORD PTR entry$[rsp], rax

; 239  : 	int r = entry();

	call	QWORD PTR entry$[rsp]
	mov	DWORD PTR r$[rsp], eax
$LN2@AuDriverLo:

; 240  : 	for(;;);

	jmp	SHORT $LN2@AuDriverLo

; 241  : }

	add	rsp, 88					; 00000058H
	ret	0
?AuDriverLoadMem@@YAXPEAE@Z ENDP			; AuDriverLoadMem
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\audrv.cpp
_TEXT	SEGMENT
dev$1 = 48
func$2 = 52
bus$3 = 56
i$4 = 60
i$5 = 64
sub_class$ = 68
device$6 = 72
dev_id$ = 80
filesize$ = 84
conf$ = 88
class_code$ = 96
driver$7 = 104
vend_id$ = 112
file$ = 120
device$ = 128
confdata$ = 136
info$ = 160
?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z PROC ; AuDrvMngrInitialize

; 274  : void AuDrvMngrInitialize (KERNEL_BOOT_INFO *info) {

$LN21:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 275  : 	driver_class_unique_id = 0;

	mov	DWORD PTR driver_class_unique_id, 0

; 276  : 	driver_load_base = AU_DRIVER_BASE_START;

	mov	rax, -70368739983360			; ffffc00000400000H
	mov	QWORD PTR driver_load_base, rax

; 277  : 	devices_count = 0;

	mov	DWORD PTR devices_count, 0

; 278  : 
; 279  : 	printf ("[aurora]: initializing drivers, please wait... \n");

	lea	rcx, OFFSET FLAT:$SG3925
	call	printf

; 280  : 	/* Load the conf data */
; 281  : 	uint64_t* conf = (uint64_t*)p2v((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	p2v
	mov	QWORD PTR conf$[rsp], rax

; 282  : 	memset(conf, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR conf$[rsp]
	call	memset

; 283  : 	vfs_node_t* file = fat32_open(NULL, "/audrv.cnf");

	lea	rdx, OFFSET FLAT:$SG3930
	xor	ecx, ecx
	call	?fat32_open@@YAPEAU_vfs_node_@@PEAU1@PEAD@Z ; fat32_open
	mov	QWORD PTR file$[rsp], rax

; 284  : 	int filesize = file->size / 1024;

	xor	edx, edx
	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+32]
	mov	ecx, 1024				; 00000400H
	div	ecx
	mov	DWORD PTR filesize$[rsp], eax

; 285  : 	if(filesize < 4096)

	cmp	DWORD PTR filesize$[rsp], 4096		; 00001000H
	jge	SHORT $LN18@AuDrvMngrI

; 286  : 		fat32_read(file,(uint64_t*)v2p((size_t)conf));

	mov	rcx, QWORD PTR conf$[rsp]
	call	v2p
	mov	rdx, rax
	mov	rcx, QWORD PTR file$[rsp]
	call	?fat32_read@@YA_KPEAU_vfs_node_@@PEA_K@Z ; fat32_read
$LN18@AuDrvMngrI:

; 287  : 
; 288  : 	uint8_t* confdata = (uint8_t*)conf;

	mov	rax, QWORD PTR conf$[rsp]
	mov	QWORD PTR confdata$[rsp], rax

; 289  : 
; 290  : 
; 291  : 	uint32_t vend_id, dev_id, class_code, sub_class = 0;

	mov	DWORD PTR sub_class$[rsp], 0

; 292  : 	uint32_t device = 0;

	mov	DWORD PTR device$[rsp], 0

; 293  : 	for (uint16_t bus = 0; bus < 0x20; bus++) {

	xor	eax, eax
	mov	WORD PTR bus$3[rsp], ax
	jmp	SHORT $LN17@AuDrvMngrI
$LN16@AuDrvMngrI:
	movzx	eax, WORD PTR bus$3[rsp]
	inc	ax
	mov	WORD PTR bus$3[rsp], ax
$LN17@AuDrvMngrI:
	movzx	eax, WORD PTR bus$3[rsp]
	cmp	eax, 32					; 00000020H
	jge	$LN15@AuDrvMngrI

; 294  : 		for (uint16_t dev = 0; dev < 32; dev++) {

	xor	eax, eax
	mov	WORD PTR dev$1[rsp], ax
	jmp	SHORT $LN14@AuDrvMngrI
$LN13@AuDrvMngrI:
	movzx	eax, WORD PTR dev$1[rsp]
	inc	ax
	mov	WORD PTR dev$1[rsp], ax
$LN14@AuDrvMngrI:
	movzx	eax, WORD PTR dev$1[rsp]
	cmp	eax, 32					; 00000020H
	jge	$LN12@AuDrvMngrI

; 295  : 			for (uint16_t func = 0; func < 8; func++) {

	xor	eax, eax
	mov	WORD PTR func$2[rsp], ax
	jmp	SHORT $LN11@AuDrvMngrI
$LN10@AuDrvMngrI:
	movzx	eax, WORD PTR func$2[rsp]
	inc	ax
	mov	WORD PTR func$2[rsp], ax
$LN11@AuDrvMngrI:
	movzx	eax, WORD PTR func$2[rsp]
	cmp	eax, 8
	jge	$LN9@AuDrvMngrI

; 296  : 			
; 297  : 				uint64_t device = pci_express_get_device(0, bus, dev, func);

	movzx	eax, WORD PTR func$2[rsp]
	movzx	ecx, WORD PTR dev$1[rsp]
	movzx	edx, WORD PTR bus$3[rsp]
	mov	r9d, eax
	mov	r8d, ecx
	xor	ecx, ecx
	call	?pci_express_get_device@@YA_KGHHH@Z	; pci_express_get_device
	mov	QWORD PTR device$6[rsp], rax

; 298  : 
; 299  : 				vend_id = pci_express_read(device, PCI_VENDOR_ID, bus, dev, func);

	movzx	eax, WORD PTR func$2[rsp]
	movzx	ecx, WORD PTR dev$1[rsp]
	movzx	edx, WORD PTR bus$3[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, edx
	xor	edx, edx
	mov	rcx, QWORD PTR device$6[rsp]
	call	pci_express_read
	mov	DWORD PTR vend_id$[rsp], eax

; 300  : 				dev_id = pci_express_read(device, PCI_DEVICE_ID, bus, dev, func);

	movzx	eax, WORD PTR func$2[rsp]
	movzx	ecx, WORD PTR dev$1[rsp]
	movzx	edx, WORD PTR bus$3[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, edx
	mov	edx, 2
	mov	rcx, QWORD PTR device$6[rsp]
	call	pci_express_read
	mov	DWORD PTR dev_id$[rsp], eax

; 301  : 				class_code = pci_express_read(device, PCI_CLASS, bus, dev, func);

	movzx	eax, WORD PTR func$2[rsp]
	movzx	ecx, WORD PTR dev$1[rsp]
	movzx	edx, WORD PTR bus$3[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, edx
	mov	edx, 11
	mov	rcx, QWORD PTR device$6[rsp]
	call	pci_express_read
	mov	DWORD PTR class_code$[rsp], eax

; 302  : 				sub_class = pci_express_read(device, PCI_SUBCLASS, bus, dev, func);

	movzx	eax, WORD PTR func$2[rsp]
	movzx	ecx, WORD PTR dev$1[rsp]
	movzx	edx, WORD PTR bus$3[rsp]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, ecx
	mov	r8d, edx
	mov	edx, 10
	mov	rcx, QWORD PTR device$6[rsp]
	call	pci_express_read
	mov	DWORD PTR sub_class$[rsp], eax

; 303  : 				
; 304  : 				if (dev_id == 0xFFFF || vend_id == 0xFFFF) 

	cmp	DWORD PTR dev_id$[rsp], 65535		; 0000ffffH
	je	SHORT $LN7@AuDrvMngrI
	cmp	DWORD PTR vend_id$[rsp], 65535		; 0000ffffH
	jne	SHORT $LN8@AuDrvMngrI
$LN7@AuDrvMngrI:

; 305  : 					continue;	

	jmp	$LN10@AuDrvMngrI
$LN8@AuDrvMngrI:

; 306  : 				AuGetDriverName(class_code,sub_class,  confdata,1);

	mov	r9d, 1
	mov	r8, QWORD PTR confdata$[rsp]
	mov	edx, DWORD PTR sub_class$[rsp]
	mov	ecx, DWORD PTR class_code$[rsp]
	call	?AuGetDriverName@@YAXIIPEAEH@Z		; AuGetDriverName

; 307  : 				for(int i = 0; i < 1000; i++)

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN6@AuDrvMngrI
$LN5@AuDrvMngrI:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
$LN6@AuDrvMngrI:
	cmp	DWORD PTR i$5[rsp], 1000		; 000003e8H
	jge	SHORT $LN4@AuDrvMngrI

; 308  : 					;

	jmp	SHORT $LN5@AuDrvMngrI
$LN4@AuDrvMngrI:

; 309  : 			}

	jmp	$LN10@AuDrvMngrI
$LN9@AuDrvMngrI:

; 310  : 		}

	jmp	$LN13@AuDrvMngrI
$LN12@AuDrvMngrI:

; 311  : 	}

	jmp	$LN16@AuDrvMngrI
$LN15@AuDrvMngrI:

; 312  : 
; 313  : 
; 314  : 	/* Serially call each startup entries of each driver */
; 315  : 	for (int i = 0; i < driver_class_unique_id; i++) {

	mov	DWORD PTR i$4[rsp], 0
	jmp	SHORT $LN3@AuDrvMngrI
$LN2@AuDrvMngrI:
	mov	eax, DWORD PTR i$4[rsp]
	inc	eax
	mov	DWORD PTR i$4[rsp], eax
$LN3@AuDrvMngrI:
	mov	eax, DWORD PTR driver_class_unique_id
	cmp	DWORD PTR i$4[rsp], eax
	jae	SHORT $LN1@AuDrvMngrI

; 316  : 		aurora_driver_t *driver = drivers[i];

	movsxd	rax, DWORD PTR i$4[rsp]
	lea	rcx, OFFSET FLAT:?drivers@@3PAPEAU_aurora_driver_@@A ; drivers
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR driver$7[rsp], rax

; 317  : 		AuDriverLoad(driver->name, driver);

	mov	rax, QWORD PTR driver$7[rsp]
	add	rax, 2
	mov	rdx, QWORD PTR driver$7[rsp]
	mov	rcx, rax
	call	?AuDriverLoad@@YAXPEADPEAU_aurora_driver_@@@Z ; AuDriverLoad

; 318  : 		driver->entry();

	mov	rax, QWORD PTR driver$7[rsp]
	call	QWORD PTR [rax+56]

; 319  : 	}

	jmp	SHORT $LN2@AuDrvMngrI
$LN1@AuDrvMngrI:

; 320  : 
; 321  : 
; 322  : 	free(file);	

	mov	rcx, QWORD PTR file$[rsp]
	call	free

; 323  : }

	add	rsp, 152				; 00000098H
	ret	0
?AuDrvMngrInitialize@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ENDP ; AuDrvMngrInitialize
_TEXT	ENDS
END
