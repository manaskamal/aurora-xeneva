; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?create_mutex@@YAPEAUmutex_t@@XZ		; create_mutex
PUBLIC	?mutex_lock@@YAXPEAUmutex_t@@@Z			; mutex_lock
PUBLIC	?mutex_unlock@@YAXPEAUmutex_t@@@Z		; mutex_unlock
EXTRN	?malloc@@YAPEAX_K@Z:PROC			; malloc
EXTRN	?block_thread@@YAXPEAU_thread_@@@Z:PROC		; block_thread
EXTRN	?get_current_thread@@YAPEAU_thread_@@XZ:PROC	; get_current_thread
EXTRN	?set_multi_task_enable@@YAX_N@Z:PROC		; set_multi_task_enable
EXTRN	force_sched:PROC
pdata	SEGMENT
$pdata$?create_mutex@@YAPEAUmutex_t@@XZ DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$?create_mutex@@YAPEAUmutex_t@@XZ
$pdata$?mutex_lock@@YAXPEAUmutex_t@@@Z DD imagerel $LN6
	DD	imagerel $LN6+165
	DD	imagerel $unwind$?mutex_lock@@YAXPEAUmutex_t@@@Z
$pdata$?mutex_unlock@@YAXPEAUmutex_t@@@Z DD imagerel $LN5
	DD	imagerel $LN5+87
	DD	imagerel $unwind$?mutex_unlock@@YAXPEAUmutex_t@@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?create_mutex@@YAPEAUmutex_t@@XZ DD 010401H
	DD	06204H
$unwind$?mutex_lock@@YAXPEAUmutex_t@@@Z DD 010901H
	DD	04209H
$unwind$?mutex_unlock@@YAXPEAUmutex_t@@@Z DD 010901H
	DD	04209H
xdata	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\atomic\mutex.cpp
_TEXT	SEGMENT
obj$ = 48
?mutex_unlock@@YAXPEAUmutex_t@@@Z PROC			; mutex_unlock

; 57   : void mutex_unlock (mutex_t *obj) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 58   : 
; 59   : 	set_multi_task_enable (false);

	xor	ecx, ecx
	call	?set_multi_task_enable@@YAX_N@Z		; set_multi_task_enable

; 60   : 
; 61   : 	if (obj->blocks <= 0) {

	mov	rax, QWORD PTR obj$[rsp]
	cmp	DWORD PTR [rax+12], 0
	ja	SHORT $LN2@mutex_unlo

; 62   : 		set_multi_task_enable (true);

	mov	cl, 1
	call	?set_multi_task_enable@@YAX_N@Z		; set_multi_task_enable

; 63   : 		return;

	jmp	SHORT $LN3@mutex_unlo
$LN2@mutex_unlo:

; 64   : 	}
; 65   : 
; 66   : 	if (obj->block_thread_num > 0) {

	mov	rax, QWORD PTR obj$[rsp]
	movzx	eax, WORD PTR [rax+8]

; 67   : 		//unblock_thread(1);
; 68   : 	}
; 69   : 	//! decreament the block count
; 70   : 	obj->blocks--;

	mov	rax, QWORD PTR obj$[rsp]
	mov	eax, DWORD PTR [rax+12]
	dec	eax
	mov	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 71   : 	obj->owner_thread = 0;

	mov	rax, QWORD PTR obj$[rsp]
	mov	QWORD PTR [rax], 0

; 72   : 	set_multi_task_enable (true);

	mov	cl, 1
	call	?set_multi_task_enable@@YAX_N@Z		; set_multi_task_enable
$LN3@mutex_unlo:

; 73   : }

	add	rsp, 40					; 00000028H
	ret	0
?mutex_unlock@@YAXPEAUmutex_t@@@Z ENDP			; mutex_unlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\atomic\mutex.cpp
_TEXT	SEGMENT
obj$ = 48
?mutex_lock@@YAXPEAUmutex_t@@@Z PROC			; mutex_lock

; 28   : void mutex_lock (mutex_t * obj) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 29   : 
; 30   : 	//!disable multi tasking
; 31   : 	set_multi_task_enable (false);

	xor	ecx, ecx
	call	?set_multi_task_enable@@YAX_N@Z		; set_multi_task_enable

; 32   : 
; 33   : 	//! check
; 34   : 	if (obj->blocks != 0 && obj->owner_thread == get_current_thread()) {

	mov	rax, QWORD PTR obj$[rsp]
	cmp	DWORD PTR [rax+12], 0
	je	SHORT $LN3@mutex_lock
	call	?get_current_thread@@YAPEAU_thread_@@XZ	; get_current_thread
	mov	rcx, QWORD PTR obj$[rsp]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN3@mutex_lock

; 35   : 		obj->blocks++;

	mov	rax, QWORD PTR obj$[rsp]
	mov	eax, DWORD PTR [rax+12]
	inc	eax
	mov	rcx, QWORD PTR obj$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 36   : 		set_multi_task_enable (true);

	mov	cl, 1
	call	?set_multi_task_enable@@YAX_N@Z		; set_multi_task_enable

; 37   : 		return;

	jmp	SHORT $LN4@mutex_lock
$LN3@mutex_lock:
$LN2@mutex_lock:

; 38   : 	}
; 39   : 
; 40   : 
; 41   : 	while (obj->blocks != 0) {

	mov	rax, QWORD PTR obj$[rsp]
	cmp	DWORD PTR [rax+12], 0
	je	SHORT $LN1@mutex_lock

; 42   : 		block_thread(get_current_thread());

	call	?get_current_thread@@YAPEAU_thread_@@XZ	; get_current_thread
	mov	rcx, rax
	call	?block_thread@@YAXPEAU_thread_@@@Z	; block_thread

; 43   : 		obj->block_thread_num++;

	mov	rax, QWORD PTR obj$[rsp]
	movzx	eax, WORD PTR [rax+8]
	inc	ax
	mov	rcx, QWORD PTR obj$[rsp]
	mov	WORD PTR [rcx+8], ax

; 44   : 		set_multi_task_enable (true);

	mov	cl, 1
	call	?set_multi_task_enable@@YAX_N@Z		; set_multi_task_enable

; 45   : 		force_sched();

	call	force_sched

; 46   : 	}

	jmp	SHORT $LN2@mutex_lock
$LN1@mutex_lock:

; 47   : 
; 48   : 	obj->blocks = 1;

	mov	rax, QWORD PTR obj$[rsp]
	mov	DWORD PTR [rax+12], 1

; 49   : 	obj->owner_thread = get_current_thread();

	call	?get_current_thread@@YAPEAU_thread_@@XZ	; get_current_thread
	mov	rcx, QWORD PTR obj$[rsp]
	mov	QWORD PTR [rcx], rax

; 50   : 	set_multi_task_enable (true);

	mov	cl, 1
	call	?set_multi_task_enable@@YAX_N@Z		; set_multi_task_enable
$LN4@mutex_lock:

; 51   : }

	add	rsp, 40					; 00000028H
	ret	0
?mutex_lock@@YAXPEAUmutex_t@@@Z ENDP			; mutex_lock
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\atomic\mutex.cpp
_TEXT	SEGMENT
obj$ = 32
?create_mutex@@YAPEAUmutex_t@@XZ PROC			; create_mutex

; 18   : mutex_t * create_mutex () {

$LN3:
	sub	rsp, 56					; 00000038H

; 19   : 	mutex_t * obj = (mutex_t*)malloc(sizeof(mutex_t));

	mov	ecx, 16
	call	?malloc@@YAPEAX_K@Z			; malloc
	mov	QWORD PTR obj$[rsp], rax

; 20   : 	obj->blocks = 0;

	mov	rax, QWORD PTR obj$[rsp]
	mov	DWORD PTR [rax+12], 0

; 21   : 	obj->owner_thread= 0;

	mov	rax, QWORD PTR obj$[rsp]
	mov	QWORD PTR [rax], 0

; 22   : 	obj->block_thread_num = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR obj$[rsp]
	mov	WORD PTR [rcx+8], ax

; 23   : 	return obj;

	mov	rax, QWORD PTR obj$[rsp]

; 24   : }

	add	rsp, 56					; 00000038H
	ret	0
?create_mutex@@YAPEAUmutex_t@@XZ ENDP			; create_mutex
_TEXT	ENDS
END
