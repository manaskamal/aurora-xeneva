; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?hbabar@@3PEAXEA				; hbabar
_BSS	SEGMENT
___ahci_64_bit___ DB 01H DUP (?)
	ALIGN	8

?hbabar@@3PEAXEA DQ 01H DUP (?)				; hbabar
_BSS	ENDS
CONST	SEGMENT
$SG3900	DB	'[AHCI]: Taking the control from firmware took %d ms', 0aH
	DB	00H
	ORG $+3
$SG3926	DB	'*******************************', 0aH, 00H
	ORG $+7
$SG3927	DB	'AHCI/SATA not found', 0aH, 00H
	ORG $+3
$SG3928	DB	'Xeneva initialisation failed', 0aH, 00H
	ORG $+2
$SG3929	DB	'Halting System', 0aH, 00H
$SG3930	DB	'*******************************', 0aH, 00H
	ORG $+7
$SG3937	DB	'AHCI/SATA found at dev -> %d, func -> %d, bus -> %d', 0aH
	DB	00H
	ORG $+3
$SG3945	DB	'[AHCI]: Version -- %d.%d', 0aH, 00H
	ORG $+6
$SG3948	DB	'[AHCI]: 64-bit DMA supported', 0aH, 00H
	ORG $+2
$SG3950	DB	'[AHCI]: Num Command Slots -> %d', 0aH, 00H
	ORG $+7
$SG3953	DB	'[AHCI]: Support Staggered spin-up %d', 0aH, 00H
	ORG $+2
$SG3955	DB	'[AHCI]: FIS-Based Switching supported', 0aH, 00H
	ORG $+1
$SG3964	DB	'[AHCI]: SATA Drive found at port %d', 0aH, 00H
	ORG $+3
$SG3967	DB	'[AHCI]: SATAPI Drive found at port %d', 0aH, 00H
	ORG $+1
$SG3970	DB	'[AHCI]: SEMB Drive found at port %d', 0aH, 00H
	ORG $+3
$SG3973	DB	'[AHCI]: PM Drive found at port %d', 0aH, 00H
CONST	ENDS
PUBLIC	?ahci_initialize@@YAXXZ				; ahci_initialize
PUBLIC	?ahci_is_64_bit_supported@@YA_NXZ		; ahci_is_64_bit_supported
PUBLIC	?ahci_check_type@@YAHPEAU_hba_port_@@@Z		; ahci_check_type
PUBLIC	?ahci_control_hand_os@@YAXPEAU_hba_mem_@@@Z	; ahci_control_hand_os
PUBLIC	?ahci_interrupt_handler@@YAX_KPEAX@Z		; ahci_interrupt_handler
EXTRN	?ahci_disk_initialize@@YAXPEAU_hba_port_@@@Z:PROC ; ahci_disk_initialize
EXTRN	x64_cli:PROC
EXTRN	x64_sti:PROC
EXTRN	?timer_sleep@@YAXI@Z:PROC			; timer_sleep
EXTRN	AuInterruptEnd:PROC
EXTRN	AuInterruptSet:PROC
EXTRN	read_config_16:PROC
EXTRN	write_config_16:PROC
EXTRN	pci_find_device_class:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuMapMMIO:PROC
EXTRN	?hda_handler@@YAX_KPEAX@Z:PROC			; hda_handler
EXTRN	?is_hdaudio_initialized@@YA_NXZ:PROC		; is_hdaudio_initialized
EXTRN	printf:PROC
EXTRN	?_debug_print_@@YAXPEADZZ:PROC			; _debug_print_
pdata	SEGMENT
$pdata$?ahci_initialize@@YAXXZ DD imagerel $LN22
	DD	imagerel $LN22+1119
	DD	imagerel $unwind$?ahci_initialize@@YAXXZ
$pdata$?ahci_check_type@@YAHPEAU_hba_port_@@@Z DD imagerel $LN11
	DD	imagerel $LN11+147
	DD	imagerel $unwind$?ahci_check_type@@YAHPEAU_hba_port_@@@Z
$pdata$?ahci_control_hand_os@@YAXPEAU_hba_mem_@@@Z DD imagerel $LN5
	DD	imagerel $LN5+90
	DD	imagerel $unwind$?ahci_control_hand_os@@YAXPEAU_hba_mem_@@@Z
$pdata$?ahci_interrupt_handler@@YAX_KPEAX@Z DD imagerel $LN8
	DD	imagerel $LN8+223
	DD	imagerel $unwind$?ahci_interrupt_handler@@YAX_KPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?ahci_initialize@@YAXXZ DD 020701H
	DD	0130107H
$unwind$?ahci_check_type@@YAHPEAU_hba_port_@@@Z DD 010901H
	DD	02209H
$unwind$?ahci_control_hand_os@@YAXPEAU_hba_mem_@@@Z DD 010901H
	DD	06209H
$unwind$?ahci_interrupt_handler@@YAX_KPEAX@Z DD 010e01H
	DD	0820eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci.cpp
_TEXT	SEGMENT
i$1 = 32
port_is$2 = 36
is$ = 40
hba$ = 48
v$ = 80
p$ = 88
?ahci_interrupt_handler@@YAX_KPEAX@Z PROC		; ahci_interrupt_handler

; 99   : void ahci_interrupt_handler (size_t v, void* p) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 100  : 	x64_cli();

	call	x64_cli

; 101  : 
; 102  : 	HBA_MEM *hba = (HBA_MEM*)hbabar;

	mov	rax, QWORD PTR ?hbabar@@3PEAXEA		; hbabar
	mov	QWORD PTR hba$[rsp], rax

; 103  : 	uint32_t is = hba->is;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR is$[rsp], eax

; 104  : #if 0
; 105  : 	printf ("[AHCI]: Interrupt fired++\n");
; 106  : #endif
; 107  : 	for (int i = 0; i < 32; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN5@ahci_inter
$LN4@ahci_inter:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN5@ahci_inter:
	cmp	DWORD PTR i$1[rsp], 32			; 00000020H
	jge	SHORT $LN3@ahci_inter

; 108  : 		if ((hba->is & hba->pi & (1<<i))) {

	mov	rax, QWORD PTR hba$[rsp]
	mov	rcx, QWORD PTR hba$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	mov	eax, DWORD PTR [rax+8]
	and	eax, ecx
	mov	ecx, DWORD PTR i$1[rsp]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN2@ahci_inter

; 109  : #if 0
; 110  : 			printf ("[AHCI]: Interrupt from %d port\n", i);
; 111  : #endif
; 112  : 			uint32_t port_is = hba->port[i].is;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rcx+rax+272]
	mov	DWORD PTR port_is$2[rsp], eax

; 113  : 
; 114  : #if 0
; 115  : 			if ((hba->port[i].is & (1<<2))) {
; 116  : 				_debug_print_ ("[AHCI]: DMA Setup FIS Interrupt \r\n");
; 117  : 			}else if ((hba->port[i].is & (1<<1))) {
; 118  : 				_debug_print_ ("[AHCI]: PIO Setup FIS Interrupt \r\n");
; 119  : 			}else if (hba->port[i].is & (1<<0)) {
; 120  : 				_debug_print_ ("[AHCI]: D2H Fis received \r\n");
; 121  : 			}else if (hba->port[i].is & (1<<30)) {
; 122  : 				_debug_print_ ("[AHCI]: Task File Error Status \r\n");
; 123  : 			}else if (hba->port[i].is & (1<<29)) {
; 124  : 				_debug_print_ ("[AHCI]: Host Bus Fetal Error Status \r\n");
; 125  : 			}else if (hba->port[i].is & (1<<4)) {
; 126  : 				_debug_print_ ("[AHCI]: Unknown FIS interrupt status \r\n");
; 127  : 			}
; 128  : #endif
; 129  : 
; 130  : 			hba->port[i].is = port_is;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rsp]
	mov	edx, DWORD PTR port_is$2[rsp]
	mov	DWORD PTR [rcx+rax+272], edx

; 131  : 			break;

	jmp	SHORT $LN3@ahci_inter
$LN2@ahci_inter:

; 132  : 		}
; 133  : 	}

	jmp	SHORT $LN4@ahci_inter
$LN3@ahci_inter:

; 134  : 
; 135  : 	if (is_hdaudio_initialized())

	call	?is_hdaudio_initialized@@YA_NXZ		; is_hdaudio_initialized
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@ahci_inter

; 136  : 		hda_handler(v,p);

	mov	rdx, QWORD PTR p$[rsp]
	mov	rcx, QWORD PTR v$[rsp]
	call	?hda_handler@@YAX_KPEAX@Z		; hda_handler
$LN1@ahci_inter:

; 137  : 	
; 138  : 	hba->is = is;

	mov	rax, QWORD PTR hba$[rsp]
	mov	ecx, DWORD PTR is$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 139  : 	AuInterruptEnd(0);

	xor	ecx, ecx
	call	AuInterruptEnd

; 140  : 
; 141  : 	x64_sti();

	call	x64_sti

; 142  : }

	add	rsp, 72					; 00000048H
	ret	0
?ahci_interrupt_handler@@YAX_KPEAX@Z ENDP		; ahci_interrupt_handler
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci.cpp
_TEXT	SEGMENT
i$ = 32
mem$ = 64
?ahci_control_hand_os@@YAXPEAU_hba_mem_@@@Z PROC	; ahci_control_hand_os

; 87   : void ahci_control_hand_os (HBA_MEM *mem) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 88   : 	mem->bohc = mem->bohc | GHC_BOHC_OOS;

	mov	rax, QWORD PTR mem$[rsp]
	mov	eax, DWORD PTR [rax+40]
	or	eax, 2
	mov	rcx, QWORD PTR mem$[rsp]
	mov	DWORD PTR [rcx+40], eax

; 89   : 	int i = 0;

	mov	DWORD PTR i$[rsp], 0
$LN2@ahci_contr:

; 90   : 	while (!(mem->bohc & GHC_BOHC_BOS | GHC_BOHC_OOS | GHC_BOHC_OOS)) {

	mov	rax, QWORD PTR mem$[rsp]
	mov	eax, DWORD PTR [rax+40]
	and	eax, 1
	or	eax, 2
	or	eax, 2
	test	eax, eax
	jne	SHORT $LN1@ahci_contr

; 91   : 		i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 92   : 	}

	jmp	SHORT $LN2@ahci_contr
$LN1@ahci_contr:

; 93   : 	printf ("[AHCI]: Taking the control from firmware took %d ms\n", i);

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG3900
	call	printf

; 94   : }

	add	rsp, 56					; 00000038H
	ret	0
?ahci_control_hand_os@@YAXPEAU_hba_mem_@@@Z ENDP	; ahci_control_hand_os
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci.cpp
_TEXT	SEGMENT
det$ = 0
ipm$ = 1
tv75 = 4
ssts$ = 8
port$ = 32
?ahci_check_type@@YAHPEAU_hba_port_@@@Z PROC		; ahci_check_type

; 62   : int ahci_check_type (HBA_PORT *port) {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 63   : 	uint32_t ssts = port->ssts;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR ssts$[rsp], eax

; 64   : 	uint8_t ipm = (ssts >> 8) & 0x0F;

	mov	eax, DWORD PTR ssts$[rsp]
	shr	eax, 8
	and	eax, 15
	mov	BYTE PTR ipm$[rsp], al

; 65   : 	uint8_t det = ssts & 0x0F;

	mov	eax, DWORD PTR ssts$[rsp]
	and	eax, 15
	mov	BYTE PTR det$[rsp], al

; 66   : 
; 67   : 	if (det != HBA_PORT_DET_PRESENT)

	movzx	eax, BYTE PTR det$[rsp]
	cmp	eax, 3
	je	SHORT $LN8@ahci_check

; 68   : 		return AHCI_DEV_NULL;

	xor	eax, eax
	jmp	SHORT $LN9@ahci_check
$LN8@ahci_check:

; 69   : 	if (ipm != HBA_PORT_IPM_ACTIVE)

	movzx	eax, BYTE PTR ipm$[rsp]
	cmp	eax, 1
	je	SHORT $LN7@ahci_check

; 70   : 		return AHCI_DEV_NULL;

	xor	eax, eax
	jmp	SHORT $LN9@ahci_check
$LN7@ahci_check:

; 71   : 
; 72   : 	switch (port->sig) {

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv75[rsp], eax
	cmp	DWORD PTR tv75[rsp], -1771503359	; 96690101H
	je	SHORT $LN2@ahci_check
	cmp	DWORD PTR tv75[rsp], -1019477759	; c33c0101H
	je	SHORT $LN3@ahci_check
	cmp	DWORD PTR tv75[rsp], -351010559		; eb140101H
	je	SHORT $LN4@ahci_check
	jmp	SHORT $LN1@ahci_check
$LN4@ahci_check:

; 73   : 	case SATA_SIG_ATAPI:
; 74   : 		return AHCI_DEV_SATAPI;

	mov	eax, 4
	jmp	SHORT $LN9@ahci_check
$LN3@ahci_check:

; 75   : 	case SATA_SIG_SEMB:
; 76   : 		return AHCI_DEV_SEMB;

	mov	eax, 2
	jmp	SHORT $LN9@ahci_check
$LN2@ahci_check:

; 77   : 	case SATA_SIG_PM:
; 78   : 		return AHCI_DEV_PM;

	mov	eax, 3
	jmp	SHORT $LN9@ahci_check
$LN1@ahci_check:

; 79   : 	default:
; 80   : 		return AHCI_DEV_SATA;

	mov	eax, 1
$LN9@ahci_check:

; 81   : 	}
; 82   : }

	add	rsp, 24
	ret	0
?ahci_check_type@@YAHPEAU_hba_port_@@@Z ENDP		; ahci_check_type
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci.cpp
_TEXT	SEGMENT
?ahci_is_64_bit_supported@@YA_NXZ PROC			; ahci_is_64_bit_supported

; 245  : 	return ___ahci_64_bit___;

	movzx	eax, BYTE PTR ___ahci_64_bit___

; 246  : }

	ret	0
?ahci_is_64_bit_supported@@YA_NXZ ENDP			; ahci_is_64_bit_supported
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci.cpp
_TEXT	SEGMENT
command_reg$ = 48
i$ = 52
support_spin$ = 56
ahci_not_found$ = 57
hba$ = 64
dt$1 = 72
dev$ = 76
bus$ = 80
func$ = 84
int_line$ = 88
pi$ = 92
info$ = 96
version_minor$ = 104
hba_phys$ = 108
_bit$ = 112
version_major$ = 116
num_command_slots$ = 120
mmio$ = 128
?ahci_initialize@@YAXXZ PROC				; ahci_initialize

; 147  : void ahci_initialize () {

$LN22:
	sub	rsp, 152				; 00000098H

; 148  : 	pci_device_info *info = (pci_device_info*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR info$[rsp], rax

; 149  : 	int bus,dev,func;
; 150  : 	bool ahci_not_found = false;

	mov	BYTE PTR ahci_not_found$[rsp], 0

; 151  : 
; 152  : 	/* First find in standard registry */
; 153  : 	if (!pci_find_device_class(0x01,0x06,info,&bus,&dev,&func)) {

	lea	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR dev$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR bus$[rsp]
	mov	r8, QWORD PTR info$[rsp]
	mov	dl, 6
	mov	cl, 1
	call	pci_find_device_class
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN19@ahci_initi

; 154  : 		ahci_not_found = true;

	mov	BYTE PTR ahci_not_found$[rsp], 1
$LN19@ahci_initi:

; 155  : 	}
; 156  : 	/* not found? now search in RAID registry */
; 157  : 	if (ahci_not_found) {

	movzx	eax, BYTE PTR ahci_not_found$[rsp]
	test	eax, eax
	je	SHORT $LN18@ahci_initi

; 158  : 		if (!pci_find_device_class(0x01,0x04,info,&bus,&dev,&func)) {

	lea	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR dev$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR bus$[rsp]
	mov	r8, QWORD PTR info$[rsp]
	mov	dl, 4
	mov	cl, 1
	call	pci_find_device_class
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN17@ahci_initi

; 159  : 			printf ("*******************************\n");

	lea	rcx, OFFSET FLAT:$SG3926
	call	printf

; 160  : 			printf ("AHCI/SATA not found\n");

	lea	rcx, OFFSET FLAT:$SG3927
	call	printf

; 161  : 			printf ("Xeneva initialisation failed\n");

	lea	rcx, OFFSET FLAT:$SG3928
	call	printf

; 162  : 			printf ("Halting System\n");

	lea	rcx, OFFSET FLAT:$SG3929
	call	printf

; 163  : 			printf ("*******************************\n");

	lea	rcx, OFFSET FLAT:$SG3930
	call	printf
$LN16@ahci_initi:

; 164  : 			for(;;);

	jmp	SHORT $LN16@ahci_initi
$LN17@ahci_initi:
$LN18@ahci_initi:

; 165  : 		}
; 166  : 	}
; 167  : 
; 168  : 	uint16_t command_reg = 0;

	xor	eax, eax
	mov	WORD PTR command_reg$[rsp], ax

; 169  : 	read_config_16 (0,bus,dev,func,0x4, &command_reg);

	lea	rax, QWORD PTR command_reg$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 4
	mov	r9d, DWORD PTR func$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	xor	ecx, ecx
	call	read_config_16

; 170  : 	command_reg |= (1<<2);

	movzx	eax, WORD PTR command_reg$[rsp]
	or	eax, 4
	mov	WORD PTR command_reg$[rsp], ax

; 171  : 	command_reg &= ~(1<<10);

	movzx	eax, WORD PTR command_reg$[rsp]
	btr	eax, 10
	mov	WORD PTR command_reg$[rsp], ax

; 172  : 	command_reg |= (1<<1);

	movzx	eax, WORD PTR command_reg$[rsp]
	or	eax, 2
	mov	WORD PTR command_reg$[rsp], ax

; 173  :     write_config_16 (0,bus, dev,func,0x4,command_reg);

	movzx	eax, WORD PTR command_reg$[rsp]
	mov	WORD PTR [rsp+40], ax
	mov	DWORD PTR [rsp+32], 4
	mov	r9d, DWORD PTR func$[rsp]
	mov	r8d, DWORD PTR dev$[rsp]
	mov	edx, DWORD PTR bus$[rsp]
	xor	ecx, ecx
	call	write_config_16

; 174  : 
; 175  : 	uint8_t int_line = info->device.nonBridge.interruptLine;

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+60]
	mov	BYTE PTR int_line$[rsp], al

; 176  : 	if (info->device.nonBridge.interruptLine < 255) {

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, BYTE PTR [rax+60]
	cmp	eax, 255				; 000000ffH
	jge	SHORT $LN14@ahci_initi

; 177  : 		AuInterruptSet(11, ahci_interrupt_handler, 11);

	mov	r8b, 11
	lea	rdx, OFFSET FLAT:?ahci_interrupt_handler@@YAX_KPEAX@Z ; ahci_interrupt_handler
	mov	ecx, 11
	call	AuInterruptSet
$LN14@ahci_initi:

; 178  : 	}
; 179  : 
; 180  : 	printf ("AHCI/SATA found at dev -> %d, func -> %d, bus -> %d\n", dev, func, bus);

	mov	r9d, DWORD PTR bus$[rsp]
	mov	r8d, DWORD PTR func$[rsp]
	mov	edx, DWORD PTR dev$[rsp]
	lea	rcx, OFFSET FLAT:$SG3937
	call	printf

; 181  : 	uintptr_t hba_phys = (info->device.nonBridge.baseAddress[5] & 0xFFFFFFF0);

	mov	eax, 4
	imul	rax, 5
	mov	rcx, QWORD PTR info$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	and	eax, -16				; fffffff0H
	mov	DWORD PTR hba_phys$[rsp], eax

; 182  : 	void* mmio = AuMapMMIO(hba_phys,512);

	mov	edx, 512				; 00000200H
	mov	ecx, DWORD PTR hba_phys$[rsp]
	call	AuMapMMIO
	mov	QWORD PTR mmio$[rsp], rax

; 183  : 	HBA_MEM *hba = (HBA_MEM*)mmio;//(info->device.nonBridge.baseAddress[5] & 0xFFFFFFF0);

	mov	rax, QWORD PTR mmio$[rsp]
	mov	QWORD PTR hba$[rsp], rax

; 184  : 	hbabar = (void*)mmio; //(info->device.nonBridge.baseAddress[5] & 0xFFFFFFF0);

	mov	rax, QWORD PTR mmio$[rsp]
	mov	QWORD PTR ?hbabar@@3PEAXEA, rax		; hbabar

; 185  : 	hba->ghc = 1;

	mov	rax, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rax+4], 1

; 186  : 
; 187  : 	timer_sleep(500);

	mov	ecx, 500				; 000001f4H
	call	?timer_sleep@@YAXI@Z			; timer_sleep

; 188  : 	hba->ghc = (1<<31);

	mov	rax, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rax+4], -2147483648		; 80000000H

; 189  : 	timer_sleep(100);

	mov	ecx, 100				; 00000064H
	call	?timer_sleep@@YAXI@Z			; timer_sleep

; 190  : 	hba->ghc = (1<<1);

	mov	rax, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rax+4], 2

; 191  : 
; 192  : 	uint32_t version_major = hba->vs >> 16 & 0xff;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax+16]
	shr	eax, 16
	and	eax, 255				; 000000ffH
	mov	DWORD PTR version_major$[rsp], eax

; 193  : 	uint32_t version_minor = hba->vs & 0xff;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR version_minor$[rsp], eax

; 194  : 
; 195  : 	printf ("[AHCI]: Version -- %d.%d\n", version_major, version_minor);

	mov	r8d, DWORD PTR version_minor$[rsp]
	mov	edx, DWORD PTR version_major$[rsp]
	lea	rcx, OFFSET FLAT:$SG3945
	call	printf

; 196  : 	uint32_t _bit = hba->cap >> 31 & 0xff;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 31
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _bit$[rsp], eax

; 197  : 	if (_bit) {

	cmp	DWORD PTR _bit$[rsp], 0
	je	SHORT $LN13@ahci_initi

; 198  : 		printf ("[AHCI]: 64-bit DMA supported\n");

	lea	rcx, OFFSET FLAT:$SG3948
	call	printf

; 199  : 		___ahci_64_bit___ = true;

	mov	BYTE PTR ___ahci_64_bit___, 1
$LN13@ahci_initi:

; 200  : 	}
; 201  : 
; 202  : 	
; 203  : 	hba->is = UINT32_MAX;

	mov	rax, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rax+8], -1			; ffffffffH

; 204  : 	hba->ghc |= 0x2;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax+4]
	or	eax, 2
	mov	rcx, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 205  : 
; 206  : 	uint32_t num_command_slots  = hba->cap >> 8 & 0xff;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	DWORD PTR num_command_slots$[rsp], eax

; 207  : 	_debug_print_ ("[AHCI]: Num Command Slots -> %d\n", num_command_slots);

	mov	edx, DWORD PTR num_command_slots$[rsp]
	lea	rcx, OFFSET FLAT:$SG3950
	call	?_debug_print_@@YAXPEADZZ		; _debug_print_

; 208  : 
; 209  : 	uint8_t support_spin = hba->cap & (1<<27);

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax]
	and	eax, 134217728				; 08000000H
	mov	BYTE PTR support_spin$[rsp], al

; 210  : 	if (support_spin) {

	movzx	eax, BYTE PTR support_spin$[rsp]
	test	eax, eax
	je	SHORT $LN12@ahci_initi

; 211  : 		_debug_print_ ("[AHCI]: Support Staggered spin-up %d\n", support_spin);

	movzx	eax, BYTE PTR support_spin$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3953
	call	?_debug_print_@@YAXPEADZZ		; _debug_print_
$LN12@ahci_initi:

; 212  : 	}
; 213  : 
; 214  : 	if (hba->cap & (1<<16))

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax]
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	SHORT $LN11@ahci_initi

; 215  : 		_debug_print_ ("[AHCI]: FIS-Based Switching supported\n");

	lea	rcx, OFFSET FLAT:$SG3955
	call	?_debug_print_@@YAXPEADZZ		; _debug_print_
$LN11@ahci_initi:

; 216  : 	uint32_t pi = hba->pi;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR pi$[rsp], eax

; 217  : 	int i = 0;

	mov	DWORD PTR i$[rsp], 0
$LN10@ahci_initi:

; 218  : 	while (i < 32) {

	cmp	DWORD PTR i$[rsp], 32			; 00000020H
	jge	$LN9@ahci_initi

; 219  : 		if (pi & 1) {

	mov	eax, DWORD PTR pi$[rsp]
	and	eax, 1
	test	eax, eax
	je	$LN8@ahci_initi

; 220  : 			int dt = ahci_check_type (&hba->port[i]);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rsp]
	lea	rax, QWORD PTR [rcx+rax+256]
	mov	rcx, rax
	call	?ahci_check_type@@YAHPEAU_hba_port_@@@Z	; ahci_check_type
	mov	DWORD PTR dt$1[rsp], eax

; 221  : 			if (dt == AHCI_DEV_SATA) {

	cmp	DWORD PTR dt$1[rsp], 1
	jne	$LN7@ahci_initi

; 222  : 				printf ("[AHCI]: SATA Drive found at port %d\n", i);

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG3964
	call	printf

; 223  : 				hba->port[i].sctl &= ~PX_SCTL_IPM_MASK;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rcx+rax+300]
	and	eax, -4096				; fffff000H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 128				; 00000080H
	mov	rdx, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rdx+rcx+300], eax

; 224  : 				hba->port[i].sctl |= PX_SCTL_IPM_NONE;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rcx+rax+300]
	or	eax, 768				; 00000300H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 128				; 00000080H
	mov	rdx, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rdx+rcx+300], eax

; 225  : 				ahci_disk_initialize(&hba->port[i]);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rsp]
	lea	rax, QWORD PTR [rcx+rax+256]
	mov	rcx, rax
	call	?ahci_disk_initialize@@YAXPEAU_hba_port_@@@Z ; ahci_disk_initialize
	jmp	SHORT $LN6@ahci_initi
$LN7@ahci_initi:

; 226  : 			}
; 227  : 			else if (dt == AHCI_DEV_SATAPI) {

	cmp	DWORD PTR dt$1[rsp], 4
	jne	SHORT $LN5@ahci_initi

; 228  : 				printf ("[AHCI]: SATAPI Drive found at port %d\n", i);

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG3967
	call	printf
	jmp	SHORT $LN4@ahci_initi
$LN5@ahci_initi:

; 229  : 			}else if (dt == AHCI_DEV_SEMB) {

	cmp	DWORD PTR dt$1[rsp], 2
	jne	SHORT $LN3@ahci_initi

; 230  : 				printf ("[AHCI]: SEMB Drive found at port %d\n", i);

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG3970
	call	printf
	jmp	SHORT $LN2@ahci_initi
$LN3@ahci_initi:

; 231  : 			}else if (dt == AHCI_DEV_PM) {

	cmp	DWORD PTR dt$1[rsp], 3
	jne	SHORT $LN1@ahci_initi

; 232  : 				printf ("[AHCI]: PM Drive found at port %d\n", i);

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG3973
	call	printf
$LN1@ahci_initi:
$LN2@ahci_initi:
$LN4@ahci_initi:
$LN6@ahci_initi:
$LN8@ahci_initi:

; 233  : 			}
; 234  : 		}
; 235  : 		pi >>= 1;

	mov	eax, DWORD PTR pi$[rsp]
	shr	eax, 1
	mov	DWORD PTR pi$[rsp], eax

; 236  : 		i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 237  : 	}

	jmp	$LN10@ahci_initi
$LN9@ahci_initi:

; 238  : }

	add	rsp, 152				; 00000098H
	ret	0
?ahci_initialize@@YAXXZ ENDP				; ahci_initialize
_TEXT	ENDS
END
