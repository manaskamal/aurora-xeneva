; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?hbabar@@3PEAXEA				; hbabar
_BSS	SEGMENT
___ahci_64_bit___ DB 01H DUP (?)
	ALIGN	8

?hbabar@@3PEAXEA DQ 01H DUP (?)				; hbabar
_BSS	ENDS
CONST	SEGMENT
$SG3630	DB	'[AHCI]: Taking the control from firmware took %d ms', 0aH
	DB	00H
	ORG $+3
$SG3644	DB	'AHCIInterrupt ', 0dH, 0aH, 00H
	ORG $+7
$SG3652	DB	'AHCI Device -> %x ', 0aH, 00H
	ORG $+4
$SG3656	DB	'*******************************', 0aH, 00H
	ORG $+7
$SG3657	DB	'AHCI/SATA not found', 0aH, 00H
	ORG $+3
$SG3658	DB	'Xeneva initialisation failed', 0aH, 00H
	ORG $+2
$SG3659	DB	'Halting System', 0aH, 00H
$SG3660	DB	'*******************************', 0aH, 00H
	ORG $+7
$SG3665	DB	'AHCI INTERRUPT LINE -> %d ', 0dH, 0aH, 00H
	ORG $+3
$SG3667	DB	'AHCI/SATA found BAR -> %x ', 0aH, 00H
	ORG $+4
$SG3676	DB	'[AHCI]: Version -- %d.%d', 0aH, 00H
	ORG $+6
$SG3679	DB	'[AHCI]: 64-bit DMA supported', 0aH, 00H
	ORG $+2
$SG3681	DB	'[AHCI]: Num Command Slots -> %d', 0aH, 00H
	ORG $+7
$SG3684	DB	'[AHCI]: Support Staggered spin-up %d', 0aH, 00H
	ORG $+2
$SG3686	DB	'[AHCI]: FIS-Based Switching supported', 0aH, 00H
	ORG $+1
$SG3695	DB	'[AHCI]: SATA Drive found at port %d', 0aH, 00H
	ORG $+3
$SG3698	DB	'[AHCI]: SATAPI Drive found at port %d', 0aH, 00H
	ORG $+1
$SG3701	DB	'[AHCI]: SEMB Drive found at port %d', 0aH, 00H
	ORG $+3
$SG3704	DB	'[AHCI]: PM Drive found at port %d', 0aH, 00H
CONST	ENDS
PUBLIC	?ahci_initialize@@YAXXZ				; ahci_initialize
PUBLIC	?ahci_is_64_bit_supported@@YA_NXZ		; ahci_is_64_bit_supported
PUBLIC	?ahci_check_type@@YAHPEAU_hba_port_@@@Z		; ahci_check_type
PUBLIC	?ahci_control_hand_os@@YAXPEAU_hba_mem_@@@Z	; ahci_control_hand_os
PUBLIC	?ahci_interrupt_handler@@YAX_KPEAX@Z		; ahci_interrupt_handler
EXTRN	?ahci_disk_initialize@@YAXPEAU_hba_port_@@@Z:PROC ; ahci_disk_initialize
EXTRN	pci_scan_class:PROC
EXTRN	pci_express_scan_class:PROC
EXTRN	pci_express_read:PROC
EXTRN	pcie_print_capabilities:PROC
EXTRN	AuMapMMIO:PROC
EXTRN	?timer_sleep@@YAXI@Z:PROC			; timer_sleep
EXTRN	AuInterruptEnd:PROC
EXTRN	AuInterruptSet:PROC
EXTRN	printf:PROC
EXTRN	_debug_print_:PROC
pdata	SEGMENT
$pdata$?ahci_initialize@@YAXXZ DD imagerel $LN24
	DD	imagerel $LN24+962
	DD	imagerel $unwind$?ahci_initialize@@YAXXZ
$pdata$?ahci_check_type@@YAHPEAU_hba_port_@@@Z DD imagerel $LN11
	DD	imagerel $LN11+147
	DD	imagerel $unwind$?ahci_check_type@@YAHPEAU_hba_port_@@@Z
$pdata$?ahci_control_hand_os@@YAXPEAU_hba_mem_@@@Z DD imagerel $LN5
	DD	imagerel $LN5+90
	DD	imagerel $unwind$?ahci_control_hand_os@@YAXPEAU_hba_mem_@@@Z
$pdata$?ahci_interrupt_handler@@YAX_KPEAX@Z DD imagerel $LN7
	DD	imagerel $LN7+198
	DD	imagerel $unwind$?ahci_interrupt_handler@@YAX_KPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?ahci_initialize@@YAXXZ DD 010401H
	DD	0c204H
$unwind$?ahci_check_type@@YAHPEAU_hba_port_@@@Z DD 010901H
	DD	02209H
$unwind$?ahci_control_hand_os@@YAXPEAU_hba_mem_@@@Z DD 010901H
	DD	06209H
$unwind$?ahci_interrupt_handler@@YAX_KPEAX@Z DD 010e01H
	DD	0820eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci.cpp
_TEXT	SEGMENT
i$1 = 32
port_is$2 = 36
is$ = 40
hba$ = 48
v$ = 80
p$ = 88
?ahci_interrupt_handler@@YAX_KPEAX@Z PROC		; ahci_interrupt_handler

; 101  : void ahci_interrupt_handler (size_t v, void* p) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 102  : 
; 103  : 	HBA_MEM *hba = (HBA_MEM*)hbabar;

	mov	rax, QWORD PTR ?hbabar@@3PEAXEA		; hbabar
	mov	QWORD PTR hba$[rsp], rax

; 104  : 	uint32_t is = hba->is;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR is$[rsp], eax

; 105  : #if 0
; 106  : 	printf ("[AHCI]: Interrupt fired++\n");
; 107  : #endif
; 108  : 	for (int i = 0; i < 32; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@ahci_inter
$LN3@ahci_inter:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ahci_inter:
	cmp	DWORD PTR i$1[rsp], 32			; 00000020H
	jge	SHORT $LN2@ahci_inter

; 109  : 		if ((hba->is & hba->pi & (1<<i))) {

	mov	rax, QWORD PTR hba$[rsp]
	mov	rcx, QWORD PTR hba$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	mov	eax, DWORD PTR [rax+8]
	and	eax, ecx
	mov	ecx, DWORD PTR i$1[rsp]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	and	eax, ecx
	test	eax, eax
	je	SHORT $LN1@ahci_inter

; 110  : #if 0
; 111  : 			printf ("[AHCI]: Interrupt from %d port\n", i);
; 112  : #endif
; 113  : 			uint32_t port_is = hba->port[i].is;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rcx+rax+272]
	mov	DWORD PTR port_is$2[rsp], eax

; 114  : 
; 115  : #if 0
; 116  : 			if ((hba->port[i].is & (1<<2))) {
; 117  : 				_debug_print_ ("[AHCI]: DMA Setup FIS Interrupt \r\n");
; 118  : 			}else if ((hba->port[i].is & (1<<1))) {
; 119  : 				_debug_print_ ("[AHCI]: PIO Setup FIS Interrupt \r\n");
; 120  : 			}else if (hba->port[i].is & (1<<0)) {
; 121  : 				_debug_print_ ("[AHCI]: D2H Fis received \r\n");
; 122  : 			}else if (hba->port[i].is & (1<<30)) {
; 123  : 				_debug_print_ ("[AHCI]: Task File Error Status \r\n");
; 124  : 			}else if (hba->port[i].is & (1<<29)) {
; 125  : 				_debug_print_ ("[AHCI]: Host Bus Fetal Error Status \r\n");
; 126  : 			}else if (hba->port[i].is & (1<<4)) {
; 127  : 				_debug_print_ ("[AHCI]: Unknown FIS interrupt status \r\n");
; 128  : 			}
; 129  : #endif
; 130  : 
; 131  : 			hba->port[i].is = port_is;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rsp]
	mov	edx, DWORD PTR port_is$2[rsp]
	mov	DWORD PTR [rcx+rax+272], edx

; 132  : 			break;

	jmp	SHORT $LN2@ahci_inter
$LN1@ahci_inter:

; 133  : 		}
; 134  : 	}

	jmp	SHORT $LN3@ahci_inter
$LN2@ahci_inter:

; 135  : 
; 136  : 	/*if (is_hdaudio_initialized())
; 137  : 		hda_handler(v,p);*/
; 138  : 
; 139  : 	_debug_print_ ("AHCI\Interrupt \r\n");

	lea	rcx, OFFSET FLAT:$SG3644
	call	_debug_print_

; 140  : 	
; 141  : 	hba->is = is;

	mov	rax, QWORD PTR hba$[rsp]
	mov	ecx, DWORD PTR is$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 142  : 	AuInterruptEnd(0);

	xor	ecx, ecx
	call	AuInterruptEnd

; 143  : 
; 144  : 
; 145  : }

	add	rsp, 72					; 00000048H
	ret	0
?ahci_interrupt_handler@@YAX_KPEAX@Z ENDP		; ahci_interrupt_handler
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci.cpp
_TEXT	SEGMENT
i$ = 32
mem$ = 64
?ahci_control_hand_os@@YAXPEAU_hba_mem_@@@Z PROC	; ahci_control_hand_os

; 89   : void ahci_control_hand_os (HBA_MEM *mem) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 90   : 	mem->bohc = mem->bohc | GHC_BOHC_OOS;

	mov	rax, QWORD PTR mem$[rsp]
	mov	eax, DWORD PTR [rax+40]
	or	eax, 2
	mov	rcx, QWORD PTR mem$[rsp]
	mov	DWORD PTR [rcx+40], eax

; 91   : 	int i = 0;

	mov	DWORD PTR i$[rsp], 0
$LN2@ahci_contr:

; 92   : 	while (!(mem->bohc & GHC_BOHC_BOS | GHC_BOHC_OOS | GHC_BOHC_OOS)) {

	mov	rax, QWORD PTR mem$[rsp]
	mov	eax, DWORD PTR [rax+40]
	and	eax, 1
	or	eax, 2
	or	eax, 2
	test	eax, eax
	jne	SHORT $LN1@ahci_contr

; 93   : 		i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 94   : 	}

	jmp	SHORT $LN2@ahci_contr
$LN1@ahci_contr:

; 95   : 	printf ("[AHCI]: Taking the control from firmware took %d ms\n", i);

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG3630
	call	printf

; 96   : }

	add	rsp, 56					; 00000038H
	ret	0
?ahci_control_hand_os@@YAXPEAU_hba_mem_@@@Z ENDP	; ahci_control_hand_os
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci.cpp
_TEXT	SEGMENT
det$ = 0
ipm$ = 1
tv75 = 4
ssts$ = 8
port$ = 32
?ahci_check_type@@YAHPEAU_hba_port_@@@Z PROC		; ahci_check_type

; 64   : int ahci_check_type (HBA_PORT *port) {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 65   : 	uint32_t ssts = port->ssts;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR ssts$[rsp], eax

; 66   : 	uint8_t ipm = (ssts >> 8) & 0x0F;

	mov	eax, DWORD PTR ssts$[rsp]
	shr	eax, 8
	and	eax, 15
	mov	BYTE PTR ipm$[rsp], al

; 67   : 	uint8_t det = ssts & 0x0F;

	mov	eax, DWORD PTR ssts$[rsp]
	and	eax, 15
	mov	BYTE PTR det$[rsp], al

; 68   : 
; 69   : 	if (det != HBA_PORT_DET_PRESENT)

	movzx	eax, BYTE PTR det$[rsp]
	cmp	eax, 3
	je	SHORT $LN8@ahci_check

; 70   : 		return AHCI_DEV_NULL;

	xor	eax, eax
	jmp	SHORT $LN9@ahci_check
$LN8@ahci_check:

; 71   : 	if (ipm != HBA_PORT_IPM_ACTIVE)

	movzx	eax, BYTE PTR ipm$[rsp]
	cmp	eax, 1
	je	SHORT $LN7@ahci_check

; 72   : 		return AHCI_DEV_NULL;

	xor	eax, eax
	jmp	SHORT $LN9@ahci_check
$LN7@ahci_check:

; 73   : 
; 74   : 	switch (port->sig) {

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR tv75[rsp], eax
	cmp	DWORD PTR tv75[rsp], -1771503359	; 96690101H
	je	SHORT $LN2@ahci_check
	cmp	DWORD PTR tv75[rsp], -1019477759	; c33c0101H
	je	SHORT $LN3@ahci_check
	cmp	DWORD PTR tv75[rsp], -351010559		; eb140101H
	je	SHORT $LN4@ahci_check
	jmp	SHORT $LN1@ahci_check
$LN4@ahci_check:

; 75   : 	case SATA_SIG_ATAPI:
; 76   : 		return AHCI_DEV_SATAPI;

	mov	eax, 4
	jmp	SHORT $LN9@ahci_check
$LN3@ahci_check:

; 77   : 	case SATA_SIG_SEMB:
; 78   : 		return AHCI_DEV_SEMB;

	mov	eax, 2
	jmp	SHORT $LN9@ahci_check
$LN2@ahci_check:

; 79   : 	case SATA_SIG_PM:
; 80   : 		return AHCI_DEV_PM;

	mov	eax, 3
	jmp	SHORT $LN9@ahci_check
$LN1@ahci_check:

; 81   : 	default:
; 82   : 		return AHCI_DEV_SATA;

	mov	eax, 1
$LN9@ahci_check:

; 83   : 	}
; 84   : }

	add	rsp, 24
	ret	0
?ahci_check_type@@YAHPEAU_hba_port_@@@Z ENDP		; ahci_check_type
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci.cpp
_TEXT	SEGMENT
?ahci_is_64_bit_supported@@YA_NXZ PROC			; ahci_is_64_bit_supported

; 268  : 	return ___ahci_64_bit___;

	movzx	eax, BYTE PTR ___ahci_64_bit___

; 269  : }

	ret	0
?ahci_is_64_bit_supported@@YA_NXZ ENDP			; ahci_is_64_bit_supported
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci.cpp
_TEXT	SEGMENT
i$ = 32
support_spin$ = 36
ahci_not_found$ = 37
hba$ = 40
device$ = 48
int_line$ = 52
dt$1 = 56
pi$ = 60
base_address$ = 64
_bit$ = 68
num_command_slots$ = 72
version_major$ = 76
hba_phys$ = 80
version_minor$ = 84
mmio$ = 88
?ahci_initialize@@YAXXZ PROC				; ahci_initialize

; 150  : void ahci_initialize () {

$LN24:
	sub	rsp, 104				; 00000068H

; 151  : 	int bus,dev,func;
; 152  : 	bool ahci_not_found = false;

	mov	BYTE PTR ahci_not_found$[rsp], 0

; 153  : 
; 154  : 	/* First find in standard registry */
; 155  : 	uint32_t device = pci_express_scan_class(0x01,0x06);

	mov	dl, 6
	mov	cl, 1
	call	pci_express_scan_class
	mov	DWORD PTR device$[rsp], eax

; 156  : 	printf ("AHCI Device -> %x \n", device);

	mov	edx, DWORD PTR device$[rsp]
	lea	rcx, OFFSET FLAT:$SG3652
	call	printf

; 157  : 	if (device == 0xFFFFFFFF)

	cmp	DWORD PTR device$[rsp], -1		; ffffffffH
	jne	SHORT $LN21@ahci_initi

; 158  : 		ahci_not_found = true;

	mov	BYTE PTR ahci_not_found$[rsp], 1
$LN21@ahci_initi:

; 159  : 	
; 160  : 	/* not found? now search in RAID registry */
; 161  : 	if (ahci_not_found) {

	movzx	eax, BYTE PTR ahci_not_found$[rsp]
	test	eax, eax
	je	SHORT $LN20@ahci_initi

; 162  : 		device = pci_scan_class(0x01,0x04);

	mov	dl, 4
	mov	cl, 1
	call	pci_scan_class
	mov	DWORD PTR device$[rsp], eax

; 163  : 		if (device == 0xFFFFFFFF){

	cmp	DWORD PTR device$[rsp], -1		; ffffffffH
	jne	SHORT $LN19@ahci_initi

; 164  : 			printf ("*******************************\n");

	lea	rcx, OFFSET FLAT:$SG3656
	call	printf

; 165  : 			printf ("AHCI/SATA not found\n");

	lea	rcx, OFFSET FLAT:$SG3657
	call	printf

; 166  : 			printf ("Xeneva initialisation failed\n");

	lea	rcx, OFFSET FLAT:$SG3658
	call	printf

; 167  : 			printf ("Halting System\n");

	lea	rcx, OFFSET FLAT:$SG3659
	call	printf

; 168  : 			printf ("*******************************\n");

	lea	rcx, OFFSET FLAT:$SG3660
	call	printf
$LN18@ahci_initi:

; 169  : 			for(;;);

	jmp	SHORT $LN18@ahci_initi
$LN19@ahci_initi:
$LN20@ahci_initi:

; 170  : 		}
; 171  : 	}
; 172  : 	
; 173  : 	
; 174  : 	uint32_t int_line = pci_express_read(device, PCI_INTERRUPT_LINE);

	mov	edx, 60					; 0000003cH
	mov	ecx, DWORD PTR device$[rsp]
	call	pci_express_read
	mov	DWORD PTR int_line$[rsp], eax

; 175  : 	printf ("AHCI INTERRUPT LINE -> %d \r\n", int_line);

	mov	edx, DWORD PTR int_line$[rsp]
	lea	rcx, OFFSET FLAT:$SG3665
	call	printf

; 176  : 	uint32_t base_address = pci_express_read(device,PCI_BAR5);

	mov	edx, 36					; 00000024H
	mov	ecx, DWORD PTR device$[rsp]
	call	pci_express_read
	mov	DWORD PTR base_address$[rsp], eax

; 177  : 	printf ("AHCI/SATA found BAR -> %x \n", base_address);

	mov	edx, DWORD PTR base_address$[rsp]
	lea	rcx, OFFSET FLAT:$SG3667
	call	printf

; 178  : 
; 179  : 	
; 180  : 
; 181  : 	//pci_enable_bus_master(device);
; 182  : 	//pci_enable_interrupts(device);
; 183  : 
; 184  : 	
; 185  : 
; 186  : 	//uint8_t int_line = info->device.nonBridge.interruptLine;
; 187  : 	
; 188  : 
; 189  : 	/*shirq_t* shdev = (shirq_t*)malloc(sizeof(shirq_t));
; 190  : 	shdev->irq = info->device.nonBridge.interruptLine;
; 191  : 	shdev->IrqHandler = ahci_interrupt_handler;
; 192  : 	shdev->device_id = info->device.deviceID;
; 193  : 	shdev->vendor_id = info->device.vendorID;
; 194  : 	AuSharedDeviceRegister(shdev);*/
; 195  : 	
; 196  : 	if (int_line < 255) {

	cmp	DWORD PTR int_line$[rsp], 255		; 000000ffH
	jae	SHORT $LN16@ahci_initi

; 197  : 		AuInterruptSet(int_line, ahci_interrupt_handler,int_line, false);

	mov	eax, DWORD PTR int_line$[rsp]
	xor	r9d, r9d
	movzx	r8d, BYTE PTR int_line$[rsp]
	lea	rdx, OFFSET FLAT:?ahci_interrupt_handler@@YAX_KPEAX@Z ; ahci_interrupt_handler
	mov	ecx, eax
	call	AuInterruptSet
$LN16@ahci_initi:

; 198  : 	}
; 199  : 
; 200  : 
; 201  : 	uintptr_t hba_phys = base_address & 0xFFFFFFF0;

	mov	eax, DWORD PTR base_address$[rsp]
	and	eax, -16				; fffffff0H
	mov	DWORD PTR hba_phys$[rsp], eax

; 202  : 	void* mmio = AuMapMMIO(hba_phys,512);

	mov	eax, DWORD PTR hba_phys$[rsp]
	mov	edx, 512				; 00000200H
	mov	ecx, eax
	call	AuMapMMIO
	mov	QWORD PTR mmio$[rsp], rax

; 203  : 	HBA_MEM *hba = (HBA_MEM*)mmio;//(info->device.nonBridge.baseAddress[5] & 0xFFFFFFF0);

	mov	rax, QWORD PTR mmio$[rsp]
	mov	QWORD PTR hba$[rsp], rax

; 204  : 	hbabar = (void*)mmio; //(info->device.nonBridge.baseAddress[5] & 0xFFFFFFF0);

	mov	rax, QWORD PTR mmio$[rsp]
	mov	QWORD PTR ?hbabar@@3PEAXEA, rax		; hbabar

; 205  : 	hba->ghc = 1;

	mov	rax, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rax+4], 1

; 206  : 
; 207  : 	timer_sleep(500);

	mov	ecx, 500				; 000001f4H
	call	?timer_sleep@@YAXI@Z			; timer_sleep

; 208  : 	hba->ghc = (1<<31);

	mov	rax, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rax+4], -2147483648		; 80000000H

; 209  : 	timer_sleep(100);

	mov	ecx, 100				; 00000064H
	call	?timer_sleep@@YAXI@Z			; timer_sleep

; 210  : 	hba->ghc = (1<<1);

	mov	rax, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rax+4], 2

; 211  : 
; 212  : 	uint32_t version_major = hba->vs >> 16 & 0xff;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax+16]
	shr	eax, 16
	and	eax, 255				; 000000ffH
	mov	DWORD PTR version_major$[rsp], eax

; 213  : 	uint32_t version_minor = hba->vs & 0xff;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax+16]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR version_minor$[rsp], eax

; 214  : 
; 215  : 	printf ("[AHCI]: Version -- %d.%d\n", version_major, version_minor);

	mov	r8d, DWORD PTR version_minor$[rsp]
	mov	edx, DWORD PTR version_major$[rsp]
	lea	rcx, OFFSET FLAT:$SG3676
	call	printf

; 216  : 	uint32_t _bit = hba->cap >> 31 & 0xff;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 31
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _bit$[rsp], eax

; 217  : 	if (_bit) {

	cmp	DWORD PTR _bit$[rsp], 0
	je	SHORT $LN15@ahci_initi

; 218  : 		printf ("[AHCI]: 64-bit DMA supported\n");

	lea	rcx, OFFSET FLAT:$SG3679
	call	printf

; 219  : 		___ahci_64_bit___ = true;

	mov	BYTE PTR ___ahci_64_bit___, 1
$LN15@ahci_initi:

; 220  : 	}
; 221  : 
; 222  : 	
; 223  : 	hba->is = UINT32_MAX;

	mov	rax, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rax+8], -1			; ffffffffH

; 224  : 	hba->ghc |= 0x2;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax+4]
	or	eax, 2
	mov	rcx, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 225  : 
; 226  : 	uint32_t num_command_slots  = hba->cap >> 8 & 0xff;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	DWORD PTR num_command_slots$[rsp], eax

; 227  : 	_debug_print_ ("[AHCI]: Num Command Slots -> %d\n", num_command_slots);

	mov	edx, DWORD PTR num_command_slots$[rsp]
	lea	rcx, OFFSET FLAT:$SG3681
	call	_debug_print_

; 228  : 
; 229  : 	uint8_t support_spin = hba->cap & (1<<27);

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax]
	and	eax, 134217728				; 08000000H
	mov	BYTE PTR support_spin$[rsp], al

; 230  : 	if (support_spin) {

	movzx	eax, BYTE PTR support_spin$[rsp]
	test	eax, eax
	je	SHORT $LN14@ahci_initi

; 231  : 		_debug_print_ ("[AHCI]: Support Staggered spin-up %d\n", support_spin);

	movzx	eax, BYTE PTR support_spin$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3684
	call	_debug_print_
$LN14@ahci_initi:

; 232  : 	}
; 233  : 
; 234  : 	if (hba->cap & (1<<16))

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax]
	and	eax, 65536				; 00010000H
	test	eax, eax
	je	SHORT $LN13@ahci_initi

; 235  : 		_debug_print_ ("[AHCI]: FIS-Based Switching supported\n");

	lea	rcx, OFFSET FLAT:$SG3686
	call	_debug_print_
$LN13@ahci_initi:

; 236  : 	uint32_t pi = hba->pi;

	mov	rax, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR pi$[rsp], eax

; 237  : 	int i = 0;

	mov	DWORD PTR i$[rsp], 0
$LN12@ahci_initi:

; 238  : 	while (i < 32) {

	cmp	DWORD PTR i$[rsp], 32			; 00000020H
	jge	$LN11@ahci_initi

; 239  : 		if (pi & 1) {

	mov	eax, DWORD PTR pi$[rsp]
	and	eax, 1
	test	eax, eax
	je	$LN10@ahci_initi

; 240  : 			int dt = ahci_check_type (&hba->port[i]);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rsp]
	lea	rax, QWORD PTR [rcx+rax+256]
	mov	rcx, rax
	call	?ahci_check_type@@YAHPEAU_hba_port_@@@Z	; ahci_check_type
	mov	DWORD PTR dt$1[rsp], eax

; 241  : 			if (dt == AHCI_DEV_SATA) {

	cmp	DWORD PTR dt$1[rsp], 1
	jne	$LN9@ahci_initi

; 242  : 				printf ("[AHCI]: SATA Drive found at port %d\n", i);

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG3695
	call	printf

; 243  : 				hba->port[i].sctl &= ~PX_SCTL_IPM_MASK;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rcx+rax+300]
	and	eax, -4096				; fffff000H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 128				; 00000080H
	mov	rdx, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rdx+rcx+300], eax

; 244  : 				hba->port[i].sctl |= PX_SCTL_IPM_NONE;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rsp]
	mov	eax, DWORD PTR [rcx+rax+300]
	or	eax, 768				; 00000300H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 128				; 00000080H
	mov	rdx, QWORD PTR hba$[rsp]
	mov	DWORD PTR [rdx+rcx+300], eax

; 245  : 				ahci_disk_initialize(&hba->port[i]);

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 128				; 00000080H
	mov	rcx, QWORD PTR hba$[rsp]
	lea	rax, QWORD PTR [rcx+rax+256]
	mov	rcx, rax
	call	?ahci_disk_initialize@@YAXPEAU_hba_port_@@@Z ; ahci_disk_initialize
	jmp	SHORT $LN8@ahci_initi
$LN9@ahci_initi:

; 246  : 			}
; 247  : 			else if (dt == AHCI_DEV_SATAPI) {

	cmp	DWORD PTR dt$1[rsp], 4
	jne	SHORT $LN7@ahci_initi

; 248  : 				printf ("[AHCI]: SATAPI Drive found at port %d\n", i);

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG3698
	call	printf
	jmp	SHORT $LN6@ahci_initi
$LN7@ahci_initi:

; 249  : 			}else if (dt == AHCI_DEV_SEMB) {

	cmp	DWORD PTR dt$1[rsp], 2
	jne	SHORT $LN5@ahci_initi

; 250  : 				printf ("[AHCI]: SEMB Drive found at port %d\n", i);

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG3701
	call	printf
	jmp	SHORT $LN4@ahci_initi
$LN5@ahci_initi:

; 251  : 			}else if (dt == AHCI_DEV_PM) {

	cmp	DWORD PTR dt$1[rsp], 3
	jne	SHORT $LN3@ahci_initi

; 252  : 				printf ("[AHCI]: PM Drive found at port %d\n", i);

	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG3704
	call	printf
$LN3@ahci_initi:
$LN4@ahci_initi:
$LN6@ahci_initi:
$LN8@ahci_initi:
$LN10@ahci_initi:

; 253  : 			}
; 254  : 		}
; 255  : 		pi >>= 1;

	mov	eax, DWORD PTR pi$[rsp]
	shr	eax, 1
	mov	DWORD PTR pi$[rsp], eax

; 256  : 		i++;

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax

; 257  : 	}

	jmp	$LN12@ahci_initi
$LN11@ahci_initi:

; 258  : 
; 259  : 	pcie_print_capabilities(device);

	mov	ecx, DWORD PTR device$[rsp]
	call	pcie_print_capabilities
$LN2@ahci_initi:

; 260  : 	for(;;);

	jmp	SHORT $LN2@ahci_initi

; 261  : }

	add	rsp, 104				; 00000068H
	ret	0
?ahci_initialize@@YAXXZ ENDP				; ahci_initialize
_TEXT	ENDS
END
