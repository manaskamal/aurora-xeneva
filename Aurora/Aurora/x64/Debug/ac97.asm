; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_ac97@@3U_ac97_@@A				; _ac97
_BSS	SEGMENT
?_ac97@@3U_ac97_@@A DB 028H DUP (?)			; _ac97
_BSS	ENDS
CONST	SEGMENT
$SG3278	DB	'AC97 interrupt fired++', 0aH, 00H
$SG3298	DB	'No AC97 device found', 0aH, 00H
	ORG $+2
$SG3299	DB	'AC97 Device found with device id -> %x, vendor id -> %x', 0aH
	DB	00H
	ORG $+7
$SG3302	DB	'AC97 interrupt line -> %d', 0aH, 00H
	ORG $+5
$SG3303	DB	'AC97 NAMBAR -> %x, NABMBAR -> %x', 0aH, 00H
	ORG $+6
$SG3304	DB	'AC97 NAMBAR -> %x, NABMBAR -> %x', 0aH, 00H
	ORG $+6
$SG3306	DB	'AC97 channels: %d', 0aH, 00H
	ORG $+5
$SG3308	DB	'20 bit sound supported', 0aH, 00H
$SG3311	DB	'Bit could not be cleared', 0aH, 00H
	ORG $+6
$SG3312	DB	'AC97 Sample Rate -> %d Hz', 0aH, 00H
	ORG $+5
$SG3314	DB	'AC97 initialized', 0aH, 00H
	ORG $+6
$SG3319	DB	'VAL = %x', 0aH, 00H
CONST	ENDS
PUBLIC	?ac97_initialize@@YAXXZ				; ac97_initialize
PUBLIC	?ac97_start@@YAXPEAE@Z				; ac97_start
PUBLIC	?wait@@YAXH@Z					; wait
PUBLIC	?ac97_handler@@YAX_KPEAX@Z			; ac97_handler
PUBLIC	?ac97_set_volume@@YAXHH@Z			; ac97_set_volume
PUBLIC	?ac97_set_sample_rate@@YAXH@Z			; ac97_set_sample_rate
EXTRN	x64_sti:PROC
EXTRN	x64_inportb:PROC
EXTRN	x64_inportw:PROC
EXTRN	x64_inportd:PROC
EXTRN	x64_outportb:PROC
EXTRN	x64_outportw:PROC
EXTRN	x64_outportd:PROC
EXTRN	?apic_local_eoi@@YAXXZ:PROC			; apic_local_eoi
EXTRN	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z:PROC	; interrupt_set
EXTRN	?pci_find_device_class@@YA_NEEPEATpci_device_info@@PEAH11@Z:PROC ; pci_find_device_class
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
EXTRN	?malloc@@YAPEAXI@Z:PROC				; malloc
pdata	SEGMENT
$pdata$?ac97_initialize@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+613
	DD	imagerel $unwind$?ac97_initialize@@YAXXZ
$pdata$?ac97_start@@YAXPEAE@Z DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$?ac97_start@@YAXPEAE@Z
$pdata$?ac97_handler@@YAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?ac97_handler@@YAX_KPEAX@Z
$pdata$?ac97_set_volume@@YAXHH@Z DD imagerel $LN3
	DD	imagerel $LN3+123
	DD	imagerel $unwind$?ac97_set_volume@@YAXHH@Z
$pdata$?ac97_set_sample_rate@@YAXH@Z DD imagerel $LN3
	DD	imagerel $LN3+115
	DD	imagerel $unwind$?ac97_set_sample_rate@@YAXH@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?ac97_initialize@@YAXXZ DD 010401H
	DD	0a204H
$unwind$?ac97_start@@YAXPEAE@Z DD 010901H
	DD	06209H
$unwind$?ac97_handler@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?ac97_set_volume@@YAXHH@Z DD 010c01H
	DD	0620cH
$unwind$?ac97_set_sample_rate@@YAXH@Z DD 010801H
	DD	04208H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ac97\ac97.cpp
_TEXT	SEGMENT
hertz$ = 48
?ac97_set_sample_rate@@YAXH@Z PROC			; ac97_set_sample_rate

; 41   : void ac97_set_sample_rate(int hertz) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 42   : 	x64_outportw (_ac97.nambar + 0x2A, x64_inportw(_ac97.nambar + 0x2A));

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A
	add	eax, 42					; 0000002aH
	movzx	ecx, ax
	call	x64_inportw
	movzx	ecx, WORD PTR ?_ac97@@3U_ac97_@@A
	add	ecx, 42					; 0000002aH
	movzx	edx, ax
	call	x64_outportw

; 43   : 	/*for(int i = 0; i < 100; i++)
; 44   : 		;*/
; 45   : 	wait(100);

	mov	ecx, 100				; 00000064H
	call	?wait@@YAXH@Z				; wait

; 46   : 	x64_outportw (_ac97.nambar + 0x2C, hertz);

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A
	add	eax, 44					; 0000002cH
	movzx	edx, WORD PTR hertz$[rsp]
	movzx	ecx, ax
	call	x64_outportw

; 47   : 	x64_outportw (_ac97.nambar + 0x32, hertz);

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A
	add	eax, 50					; 00000032H
	movzx	edx, WORD PTR hertz$[rsp]
	movzx	ecx, ax
	call	x64_outportw

; 48   : 	/*for (int i = 0; i < 100; i++)
; 49   : 		;*/
; 50   : 	wait(100);

	mov	ecx, 100				; 00000064H
	call	?wait@@YAXH@Z				; wait

; 51   : }

	add	rsp, 40					; 00000028H
	ret	0
?ac97_set_sample_rate@@YAXH@Z ENDP			; ac97_set_sample_rate
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ac97\ac97.cpp
_TEXT	SEGMENT
vol$ = 32
right$ = 36
left$ = 40
left_percent$ = 64
right_percent$ = 72
?ac97_set_volume@@YAXHH@Z PROC				; ac97_set_volume

; 32   : void ac97_set_volume (int left_percent, int right_percent) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 33   : 	int left = left_percent * 10 / 32;

	mov	eax, DWORD PTR left_percent$[rsp]
	imul	eax, 10
	cdq
	and	edx, 31
	add	eax, edx
	sar	eax, 5
	mov	DWORD PTR left$[rsp], eax

; 34   : 	int right = right_percent * 10 / 32;

	mov	eax, DWORD PTR right_percent$[rsp]
	imul	eax, 10
	cdq
	and	edx, 31
	add	eax, edx
	sar	eax, 5
	mov	DWORD PTR right$[rsp], eax

; 35   : 
; 36   : 	uint16_t vol = left | (right << 8);

	mov	eax, DWORD PTR right$[rsp]
	shl	eax, 8
	mov	ecx, DWORD PTR left$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	WORD PTR vol$[rsp], ax

; 37   : 	x64_outportw (_ac97.nambar + NAM_MASTER_VOL, vol);

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A
	add	eax, 2
	movzx	edx, WORD PTR vol$[rsp]
	movzx	ecx, ax
	call	x64_outportw

; 38   : 	x64_outportw (_ac97.nambar + NAM_PCM_VOL, vol);

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A
	add	eax, 24
	movzx	edx, WORD PTR vol$[rsp]
	movzx	ecx, ax
	call	x64_outportw

; 39   : }

	add	rsp, 56					; 00000038H
	ret	0
?ac97_set_volume@@YAXHH@Z ENDP				; ac97_set_volume
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ac97\ac97.cpp
_TEXT	SEGMENT
i$ = 48
p$ = 56
?ac97_handler@@YAX_KPEAX@Z PROC				; ac97_handler

; 27   : void ac97_handler (size_t i, void* p) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 28   : 	printf ("AC97 interrupt fired++\n");

	lea	rcx, OFFSET FLAT:$SG3278
	call	?printf@@YAXPEBDZZ			; printf

; 29   : 	apic_local_eoi();

	call	?apic_local_eoi@@YAXXZ			; apic_local_eoi

; 30   : }

	add	rsp, 40					; 00000028H
	ret	0
?ac97_handler@@YAX_KPEAX@Z ENDP				; ac97_handler
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ac97\ac97.cpp
_TEXT	SEGMENT
ms$ = 8
?wait@@YAXH@Z PROC					; wait

; 20   : void wait (int ms) {

	mov	DWORD PTR [rsp+8], ecx
$LN2@wait:

; 21   : 	while(ms > 0) {

	cmp	DWORD PTR ms$[rsp], 0
	jle	SHORT $LN1@wait

; 22   : 		ms--;

	mov	eax, DWORD PTR ms$[rsp]
	dec	eax
	mov	DWORD PTR ms$[rsp], eax

; 23   : 	}

	jmp	SHORT $LN2@wait
$LN1@wait:

; 24   : }

	fatret	0
?wait@@YAXH@Z ENDP					; wait
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ac97\ac97.cpp
_TEXT	SEGMENT
val$ = 32
buffer$ = 64
?ac97_start@@YAXPEAE@Z PROC				; ac97_start

; 142  : void ac97_start (unsigned char* buffer) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 143  : 	//memcpy (_ac97.buffer, buffer, 4096);
; 144  : 
; 145  : 	//ac97_set_sample_rate (44100);
; 146  : 
; 147  : 	uint8_t val = x64_inportb (_ac97.nabmbar + NABM_OFFSET_BUFFER_CNT);

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A+2
	add	eax, 11
	movzx	ecx, ax
	call	x64_inportb
	mov	BYTE PTR val$[rsp], al

; 148  : 	val = (val & ~0x1F) | 0x1D;

	movzx	eax, BYTE PTR val$[rsp]
	and	eax, -32				; ffffffffffffffe0H
	or	eax, 29
	mov	BYTE PTR val$[rsp], al

; 149  : 	printf ("VAL = %x\n", val);

	movzx	eax, BYTE PTR val$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3319
	call	?printf@@YAXPEBDZZ			; printf

; 150  : 	x64_outportb (_ac97.nabmbar  + 0x0B, 0x1);

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A+2
	add	eax, 11
	mov	dl, 1
	movzx	ecx, ax
	call	x64_outportb

; 151  : 	/*for(int i = 0; i < 100000000; i++)
; 152  : 		;*/
; 153  : 	x64_sti();

	call	x64_sti

; 154  : }

	add	rsp, 56					; 00000038H
	ret	0
?ac97_start@@YAXPEAE@Z ENDP				; ac97_start
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ac97\ac97.cpp
_TEXT	SEGMENT
val$ = 48
tick$ = 49
cap$ = 52
func$ = 56
dev$ = 60
bus$ = 64
addr$ = 72
?ac97_initialize@@YAXXZ PROC				; ac97_initialize

; 54   : void ac97_initialize () {

$LN6:
	sub	rsp, 88					; 00000058H

; 55   : 	
; 56   : 	pci_device_info *addr = (pci_device_info*)malloc(sizeof(pci_config_space));

	mov	ecx, 64					; 00000040H
	call	?malloc@@YAPEAXI@Z			; malloc
	mov	QWORD PTR addr$[rsp], rax

; 57   : 	int bus, dev, func = 0;

	mov	DWORD PTR func$[rsp], 0

; 58   : 	if (!pci_find_device_class (0x04,0x01,addr, &bus, &dev, &func)) {

	lea	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR dev$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR bus$[rsp]
	mov	r8, QWORD PTR addr$[rsp]
	mov	dl, 1
	mov	cl, 4
	call	?pci_find_device_class@@YA_NEEPEATpci_device_info@@PEAH11@Z ; pci_find_device_class
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@ac97_initi

; 59   : 		printf ("No AC97 device found\n");

	lea	rcx, OFFSET FLAT:$SG3298
	call	?printf@@YAXPEBDZZ			; printf

; 60   : 		return;

	jmp	$LN4@ac97_initi
$LN3@ac97_initi:

; 61   : 	}
; 62   : 
; 63   : 	printf ("AC97 Device found with device id -> %x, vendor id -> %x\n", addr->device.deviceID, addr->device.vendorID);

	mov	rax, QWORD PTR addr$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR addr$[rsp]
	movzx	ecx, WORD PTR [rcx+2]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG3299
	call	?printf@@YAXPEBDZZ			; printf

; 64   : 
; 65   : 	_ac97.nambar = (uint16_t)addr->device.nonBridge.baseAddress[0];

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR addr$[rsp]
	movzx	eax, WORD PTR [rcx+rax+16]
	mov	WORD PTR ?_ac97@@3U_ac97_@@A, ax

; 66   : 	_ac97.nabmbar = (uint16_t)addr->device.nonBridge.baseAddress[1];

	mov	eax, 4
	imul	rax, 1
	mov	rcx, QWORD PTR addr$[rsp]
	movzx	eax, WORD PTR [rcx+rax+16]
	mov	WORD PTR ?_ac97@@3U_ac97_@@A+2, ax

; 67   : 	printf ("AC97 interrupt line -> %d\n", addr->device.nonBridge.interruptLine);

	mov	rax, QWORD PTR addr$[rsp]
	movzx	eax, BYTE PTR [rax+60]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3302
	call	?printf@@YAXPEBDZZ			; printf

; 68   : 
; 69   : 	interrupt_set(addr->device.nonBridge.interruptLine, ac97_handler, addr->device.nonBridge.interruptLine);

	mov	rax, QWORD PTR addr$[rsp]
	movzx	eax, BYTE PTR [rax+60]
	mov	rcx, QWORD PTR addr$[rsp]
	movzx	r8d, BYTE PTR [rcx+60]
	lea	rdx, OFFSET FLAT:?ac97_handler@@YAX_KPEAX@Z ; ac97_handler
	mov	ecx, eax
	call	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z	; interrupt_set

; 70   : 
; 71   : 	printf ("AC97 NAMBAR -> %x, NABMBAR -> %x\n", _ac97.nambar, _ac97.nabmbar + 0x2C);

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A+2
	add	eax, 44					; 0000002cH
	movzx	ecx, WORD PTR ?_ac97@@3U_ac97_@@A
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG3303
	call	?printf@@YAXPEBDZZ			; printf

; 72   : 	printf ("AC97 NAMBAR -> %x, NABMBAR -> %x\n", addr->device.nonBridge.baseAddress[0],addr->device.nonBridge.baseAddress[1]);

	mov	eax, 4
	imul	rax, 1
	mov	ecx, 4
	imul	rcx, 0
	mov	rdx, QWORD PTR addr$[rsp]
	mov	r8d, DWORD PTR [rdx+rax+16]
	mov	rax, QWORD PTR addr$[rsp]
	mov	edx, DWORD PTR [rax+rcx+16]
	lea	rcx, OFFSET FLAT:$SG3304
	call	?printf@@YAXPEBDZZ			; printf

; 73   : 
; 74   : 
; 75   : 	//! Reset
; 76   : 	x64_outportd (_ac97.nabmbar + 0x2C, 0x3);

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A+2
	add	eax, 44					; 0000002cH
	mov	edx, 3
	movzx	ecx, ax
	call	x64_outportd

; 77   : 	x64_outportw (_ac97.nambar + PORT_NAM_RESET, 0 /* 42*/);

	xor	edx, edx
	movzx	ecx, WORD PTR ?_ac97@@3U_ac97_@@A
	call	x64_outportw

; 78   : 
; 79   : 	uint32_t cap = x64_inportd (_ac97.nabmbar + 0x30);

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A+2
	add	eax, 48					; 00000030H
	movzx	ecx, ax
	call	x64_inportd
	mov	DWORD PTR cap$[rsp], eax

; 80   : 	printf ("AC97 channels: %d\n", 2 + 2 * ((cap >> 20) & 3));

	mov	eax, DWORD PTR cap$[rsp]
	shr	eax, 20
	and	eax, 3
	lea	eax, DWORD PTR [rax+rax+2]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3306
	call	?printf@@YAXPEBDZZ			; printf

; 81   : 	if (((cap >> 22) & 3) == 1)

	mov	eax, DWORD PTR cap$[rsp]
	shr	eax, 22
	and	eax, 3
	cmp	eax, 1
	jne	SHORT $LN2@ac97_initi

; 82   : 		printf ("20 bit sound supported\n");

	lea	rcx, OFFSET FLAT:$SG3308
	call	?printf@@YAXPEBDZZ			; printf
$LN2@ac97_initi:

; 83   : 
; 84   : 	
; 85   : 	//!reset output channel
; 86   : 	uint8_t val = x64_inportb(_ac97.nabmbar + NABM_PCM_OUTPUT_BASE + NABM_OFFSET_BUFFER_CNT);

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A+2
	add	eax, 27
	movzx	ecx, ax
	call	x64_inportb
	mov	BYTE PTR val$[rsp], al

; 87   : 	x64_outportb(_ac97.nabmbar + NABM_OFFSET_BUFFER_CNT, (1<<0) | (1<<1));

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A+2
	add	eax, 11
	mov	dl, 3
	movzx	ecx, ax
	call	x64_outportb

; 88   : 	x64_outportb(_ac97.nabmbar + NABM_OFFSET_BUFFER_CNT, (1<<4));

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A+2
	add	eax, 11
	mov	dl, 16
	movzx	ecx, ax
	call	x64_outportb

; 89   : 	//for (int i = 0; i < 2500; i++)
; 90   : 	//	;
; 91   : 	wait(2500);

	mov	ecx, 2500				; 000009c4H
	call	?wait@@YAXH@Z				; wait

; 92   : 	if (x64_inportb(_ac97.nabmbar + NABM_OFFSET_BUFFER_CNT) & 2) {

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A+2
	add	eax, 11
	movzx	ecx, ax
	call	x64_inportb
	movzx	eax, al
	and	eax, 2
	test	eax, eax
	je	SHORT $LN1@ac97_initi

; 93   : 		printf ("Bit could not be cleared\n");

	lea	rcx, OFFSET FLAT:$SG3311
	call	?printf@@YAXPEBDZZ			; printf
$LN1@ac97_initi:

; 94   : 	}
; 95   : 
; 96   : 	ac97_set_volume(100, 100);

	mov	edx, 100				; 00000064H
	mov	ecx, 100				; 00000064H
	call	?ac97_set_volume@@YAXHH@Z		; ac97_set_volume

; 97   : 
; 98   : 
; 99   : 	printf ("AC97 Sample Rate -> %d Hz\n",  x64_inportw (_ac97.nambar +0x2A));

	movzx	eax, WORD PTR ?_ac97@@3U_ac97_@@A
	add	eax, 42					; 0000002aH
	movzx	ecx, ax
	call	x64_inportw
	movzx	eax, ax
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3312
	call	?printf@@YAXPEBDZZ			; printf

; 100  : 
; 101  : 	bool tick = false;

	mov	BYTE PTR tick$[rsp], 0

; 102  : 	
; 103  : 	//size_t *buffer_1 = (size_t*)malloc(40960 * 2);
; 104  : 	//size_t *buffer_2 = (size_t*)malloc(40960 * 2);
; 105  : 	//size_t *buffer_3 = (size_t*)malloc(40960 * 2);
; 106  : 
; 107  : 	//printf ("Buffers allocated\n");
; 108  : 
; 109  : 	//ac97_buffer_desc_t *desc = (ac97_buffer_desc_t*)pmmngr_alloc();
; 110  : 	//for (int i = 0; i <32; i++) {
; 111  : 	//	desc[i].buf = (uint32_t)buff;
; 112  : 	//	desc[i].len = 0xFFFE;
; 113  : 	//	desc[i].ioc = 1;
; 114  : 	//	desc[i].bup = 0;
; 115  : 	//}
; 116  : 
; 117  : 	//desc[31].bup = 1;
; 118  : 
; 119  : 	//for (int i = 0; i < 65535; i++) {
; 120  : 	//	data_1++ = buffer;
; 121  : 	//}
; 122  : 
; 123  : 	//uint16_t* data_2 = (uint16_t*)get_physical_address(buffer_2);
; 124  : 	//for (int i = 0; i < 65535; i++) {
; 125  : 	//	*data_2++ = 0;
; 126  : 	//}
; 127  : 
; 128  : 	//uint16_t* data_3 = (uint16_t*)get_physical_address(buffer_3);
; 129  : 	//for (int i = 0; i < 65535; i++) {
; 130  : 	//	*data_3++ = 0;
; 131  : 	//}
; 132  : 
; 133  : 
; 134  : 	//// ("BDL Allocated address -> %x -> %x\n", bdl, (uint32_t)get_physical_address((uint64_t)bdl));
; 135  : 	//x64_outportd (_ac97.nabmbar + 0x10, (uint32_t)desc);
; 136  : 	//x64_outportb (_ac97.nabmbar + 0x15, 32);
; 137  : 
; 138  : 	printf("AC97 initialized\n");

	lea	rcx, OFFSET FLAT:$SG3314
	call	?printf@@YAXPEBDZZ			; printf
$LN4@ac97_initi:

; 139  : }

	add	rsp, 88					; 00000058H
	ret	0
?ac97_initialize@@YAXXZ ENDP				; ac97_initialize
_TEXT	ENDS
END
