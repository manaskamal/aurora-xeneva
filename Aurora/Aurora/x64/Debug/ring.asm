; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?initialize_ring@@YAXPEAU_ring_@@@Z		; initialize_ring
PUBLIC	?ring_insert@@YA_NPEAU_ring_@@PEAX_N@Z		; ring_insert
PUBLIC	?ring_is_empty@@YA_NPEBU_ring_@@@Z		; ring_is_empty
PUBLIC	?ring_delete_first@@YA_NPEAU_ring_@@PEAX@Z	; ring_delete_first
PUBLIC	?ring_move@@YAXPEAU_ring_@@0PEAX@Z		; ring_move
EXTRN	?malloc@@YAPEAX_K@Z:PROC			; malloc
EXTRN	?mfree@@YAXPEAX@Z:PROC				; mfree
pdata	SEGMENT
$pdata$?ring_insert@@YA_NPEAU_ring_@@PEAX_N@Z DD imagerel $LN10
	DD	imagerel $LN10+194
	DD	imagerel $unwind$?ring_insert@@YA_NPEAU_ring_@@PEAX_N@Z
$pdata$?ring_is_empty@@YA_NPEBU_ring_@@@Z DD imagerel $LN6
	DD	imagerel $LN6+57
	DD	imagerel $unwind$?ring_is_empty@@YA_NPEBU_ring_@@@Z
$pdata$?ring_delete_first@@YA_NPEAU_ring_@@PEAX@Z DD imagerel $LN9
	DD	imagerel $LN9+163
	DD	imagerel $unwind$?ring_delete_first@@YA_NPEAU_ring_@@PEAX@Z
$pdata$?ring_move@@YAXPEAU_ring_@@0PEAX@Z DD imagerel $LN11
	DD	imagerel $LN11+221
	DD	imagerel $unwind$?ring_move@@YAXPEAU_ring_@@0PEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?ring_insert@@YA_NPEAU_ring_@@PEAX_N@Z DD 011301H
	DD	08213H
$unwind$?ring_is_empty@@YA_NPEBU_ring_@@@Z DD 010901H
	DD	02209H
$unwind$?ring_delete_first@@YA_NPEAU_ring_@@PEAX@Z DD 010e01H
	DD	0820eH
$unwind$?ring_move@@YAXPEAU_ring_@@0PEAX@Z DD 011301H
	DD	08213H
xdata	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\utils\ring.cpp
_TEXT	SEGMENT
ring$ = 8
prev$ = 16
?take_out@@YAXPEAU_ring_@@PEAU_element_@@@Z PROC	; take_out

; 34   : static void take_out (ring_t* ring, element_t* prev) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 35   : 	if (!ring) 

	cmp	QWORD PTR ring$[rsp], 0
	jne	SHORT $LN5@take_out

; 36   : 		return;

	jmp	$LN6@take_out
$LN5@take_out:

; 37   : 
; 38   : 	if (prev->next == prev) {

	mov	rax, QWORD PTR prev$[rsp]
	mov	rcx, QWORD PTR prev$[rsp]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN4@take_out

; 39   : 		ring->begin = 0;

	mov	rax, QWORD PTR ring$[rsp]
	mov	QWORD PTR [rax], 0

; 40   : 		ring->current = 0;

	mov	rax, QWORD PTR ring$[rsp]
	mov	QWORD PTR [rax+8], 0

; 41   : 	} else {

	jmp	SHORT $LN3@take_out
$LN4@take_out:

; 42   : 		if (prev->next == ring->begin) ring->begin = prev->next->next;

	mov	rax, QWORD PTR prev$[rsp]
	mov	rcx, QWORD PTR ring$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN2@take_out
	mov	rax, QWORD PTR prev$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR ring$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rax
$LN2@take_out:

; 43   : 		if (prev->next == ring->current) ring->current = prev->next->next;

	mov	rax, QWORD PTR prev$[rsp]
	mov	rcx, QWORD PTR ring$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rax+8], rcx
	jne	SHORT $LN1@take_out
	mov	rax, QWORD PTR prev$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR ring$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+8], rax
$LN1@take_out:

; 44   : 		prev->next = prev->next->next;

	mov	rax, QWORD PTR prev$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR prev$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+8], rax
$LN3@take_out:
$LN6@take_out:

; 45   : 	}
; 46   : }

	fatret	0
?take_out@@YAXPEAU_ring_@@PEAU_element_@@@Z ENDP	; take_out
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\utils\ring.cpp
_TEXT	SEGMENT
ring$ = 8
prev$ = 16
elem$ = 24
?put_in@@YAXPEAU_ring_@@PEAU_element_@@1@Z PROC		; put_in

; 22   : static void put_in (ring_t* ring, element_t *prev, element_t *elem) {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 23   : 	if (ring->begin == 0) {

	mov	rax, QWORD PTR ring$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN2@put_in

; 24   : 		elem->next = elem;

	mov	rax, QWORD PTR elem$[rsp]
	mov	rcx, QWORD PTR elem$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 25   : 		ring->begin = elem;

	mov	rax, QWORD PTR ring$[rsp]
	mov	rcx, QWORD PTR elem$[rsp]
	mov	QWORD PTR [rax], rcx

; 26   : 		ring->current = elem;

	mov	rax, QWORD PTR ring$[rsp]
	mov	rcx, QWORD PTR elem$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 27   : 	} else {

	jmp	SHORT $LN1@put_in
$LN2@put_in:

; 28   : 		elem->next = prev->next;

	mov	rax, QWORD PTR elem$[rsp]
	mov	rcx, QWORD PTR prev$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rax+8], rcx

; 29   : 		prev->next = elem;

	mov	rax, QWORD PTR prev$[rsp]
	mov	rcx, QWORD PTR elem$[rsp]
	mov	QWORD PTR [rax+8], rcx
$LN1@put_in:

; 30   : 	}
; 31   : }

	fatret	0
?put_in@@YAXPEAU_ring_@@PEAU_element_@@1@Z ENDP		; put_in
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\utils\ring.cpp
_TEXT	SEGMENT
current$ = 32
prev$ = 40
begin$ = 48
dest$ = 80
source$ = 88
data$ = 96
?ring_move@@YAXPEAU_ring_@@0PEAX@Z PROC			; ring_move

; 105  : void ring_move (ring_t* dest, ring_t * source, void* data) {

$LN11:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 106  : 
; 107  : 	if (!dest && !source)

	cmp	QWORD PTR dest$[rsp], 0
	jne	SHORT $LN8@ring_move
	cmp	QWORD PTR source$[rsp], 0
	jne	SHORT $LN8@ring_move

; 108  : 		return;

	jmp	$LN9@ring_move
$LN8@ring_move:

; 109  : 
; 110  : 	if (source == 0 || dest == 0 || source->begin == 0) return;

	cmp	QWORD PTR source$[rsp], 0
	je	SHORT $LN6@ring_move
	cmp	QWORD PTR dest$[rsp], 0
	je	SHORT $LN6@ring_move
	mov	rax, QWORD PTR source$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN7@ring_move
$LN6@ring_move:
	jmp	$LN9@ring_move
$LN7@ring_move:

; 111  : 	
; 112  : 	element_t * prev = source->begin;

	mov	rax, QWORD PTR source$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR prev$[rsp], rax

; 113  : 	element_t * begin = prev;

	mov	rax, QWORD PTR prev$[rsp]
	mov	QWORD PTR begin$[rsp], rax

; 114  : 	element_t * current = prev->next;

	mov	rax, QWORD PTR prev$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR current$[rsp], rax
$LN5@ring_move:

; 115  : 
; 116  : 	do {
; 117  : 		if (current->data == data) {

	mov	rax, QWORD PTR current$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN2@ring_move

; 118  : 			take_out(source, prev);

	mov	rdx, QWORD PTR prev$[rsp]
	mov	rcx, QWORD PTR source$[rsp]
	call	?take_out@@YAXPEAU_ring_@@PEAU_element_@@@Z ; take_out

; 119  : 			break;

	jmp	SHORT $LN3@ring_move
$LN2@ring_move:

; 120  : 		}
; 121  : 		prev = current;

	mov	rax, QWORD PTR current$[rsp]
	mov	QWORD PTR prev$[rsp], rax

; 122  : 		current = current->next;

	mov	rax, QWORD PTR current$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR current$[rsp], rax

; 123  : 	} while (prev != begin);

	mov	rax, QWORD PTR begin$[rsp]
	cmp	QWORD PTR prev$[rsp], rax
	jne	SHORT $LN5@ring_move
$LN3@ring_move:

; 124  : 
; 125  : 	if (current->data == data) 

	mov	rax, QWORD PTR current$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN1@ring_move

; 126  : 		put_in (dest, dest->current, current);

	mov	r8, QWORD PTR current$[rsp]
	mov	rax, QWORD PTR dest$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR dest$[rsp]
	call	?put_in@@YAXPEAU_ring_@@PEAU_element_@@1@Z ; put_in
$LN1@ring_move:
$LN9@ring_move:

; 127  : 
; 128  : }

	add	rsp, 72					; 00000048H
	ret	0
?ring_move@@YAXPEAU_ring_@@0PEAX@Z ENDP			; ring_move
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\utils\ring.cpp
_TEXT	SEGMENT
current$ = 32
temp$1 = 40
begin$ = 48
ring$ = 80
data$ = 88
?ring_delete_first@@YA_NPEAU_ring_@@PEAX@Z PROC		; ring_delete_first

; 80   : bool ring_delete_first (ring_t* ring, void* data) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 81   : 	
; 82   : 	if (!ring) 

	cmp	QWORD PTR ring$[rsp], 0
	jne	SHORT $LN6@ring_delet

; 83   : 		return false;

	xor	al, al
	jmp	$LN7@ring_delet
$LN6@ring_delet:

; 84   : 
; 85   : 	if (ring->begin == 0) return false;

	mov	rax, QWORD PTR ring$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN5@ring_delet
	xor	al, al
	jmp	SHORT $LN7@ring_delet
$LN5@ring_delet:

; 86   : 
; 87   : 	element_t * current = ring->current;

	mov	rax, QWORD PTR ring$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR current$[rsp], rax

; 88   : 	element_t * begin = current;

	mov	rax, QWORD PTR current$[rsp]
	mov	QWORD PTR begin$[rsp], rax
$LN4@ring_delet:

; 89   : 
; 90   : 	do {
; 91   : 		if (current->next->data == data) {

	mov	rax, QWORD PTR current$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR data$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN1@ring_delet

; 92   : 			element_t * temp = current->next;

	mov	rax, QWORD PTR current$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR temp$1[rsp], rax

; 93   : 			take_out (ring, current);

	mov	rdx, QWORD PTR current$[rsp]
	mov	rcx, QWORD PTR ring$[rsp]
	call	?take_out@@YAXPEAU_ring_@@PEAU_element_@@@Z ; take_out

; 94   : 			mfree(temp);

	mov	rcx, QWORD PTR temp$1[rsp]
	call	?mfree@@YAXPEAX@Z			; mfree

; 95   : 			return (true);

	mov	al, 1
	jmp	SHORT $LN7@ring_delet
$LN1@ring_delet:

; 96   : 		}
; 97   : 		current = current->next;

	mov	rax, QWORD PTR current$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR current$[rsp], rax

; 98   : 	}
; 99   : 	while (current != begin);

	mov	rax, QWORD PTR begin$[rsp]
	cmp	QWORD PTR current$[rsp], rax
	jne	SHORT $LN4@ring_delet

; 100  : 
; 101  : 	return (false);

	xor	al, al
$LN7@ring_delet:

; 102  : }

	add	rsp, 72					; 00000048H
	ret	0
?ring_delete_first@@YA_NPEAU_ring_@@PEAX@Z ENDP		; ring_delete_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\utils\ring.cpp
_TEXT	SEGMENT
tv67 = 0
ring$ = 32
?ring_is_empty@@YA_NPEBU_ring_@@@Z PROC			; ring_is_empty

; 73   : bool ring_is_empty (const ring_t* ring) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 74   : 	if (!ring)

	cmp	QWORD PTR ring$[rsp], 0
	jne	SHORT $LN1@ring_is_em

; 75   : 		return false;

	xor	al, al
	jmp	SHORT $LN2@ring_is_em
$LN1@ring_is_em:

; 76   : 	return (ring->begin == 0);

	mov	rax, QWORD PTR ring$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN4@ring_is_em
	mov	DWORD PTR tv67[rsp], 1
	jmp	SHORT $LN5@ring_is_em
$LN4@ring_is_em:
	mov	DWORD PTR tv67[rsp], 0
$LN5@ring_is_em:
	movzx	eax, BYTE PTR tv67[rsp]
$LN2@ring_is_em:

; 77   : }

	add	rsp, 24
	ret	0
?ring_is_empty@@YA_NPEBU_ring_@@@Z ENDP			; ring_is_empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\utils\ring.cpp
_TEXT	SEGMENT
current$1 = 32
item$ = 40
begin$2 = 48
ring$ = 80
data$ = 88
single$ = 96
?ring_insert@@YA_NPEAU_ring_@@PEAX_N@Z PROC		; ring_insert

; 48   : bool ring_insert (ring_t* ring, void* data, bool single) {

$LN10:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 49   : 
; 50   : 	if (!ring)

	cmp	QWORD PTR ring$[rsp], 0
	jne	SHORT $LN7@ring_inser

; 51   : 		return false;

	xor	al, al
	jmp	$LN8@ring_inser
$LN7@ring_inser:

; 52   : 
; 53   : 	if (single && ring->begin != 0) {

	movzx	eax, BYTE PTR single$[rsp]
	test	eax, eax
	je	SHORT $LN6@ring_inser
	mov	rax, QWORD PTR ring$[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN6@ring_inser

; 54   : 		element_t * current = ring->current;

	mov	rax, QWORD PTR ring$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR current$1[rsp], rax

; 55   : 		element_t * begin = current;

	mov	rax, QWORD PTR current$1[rsp]
	mov	QWORD PTR begin$2[rsp], rax
$LN5@ring_inser:

; 56   : 		do {
; 57   : 			if (current->data == data) {

	mov	rax, QWORD PTR current$1[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	cmp	QWORD PTR [rax], rcx
	jne	SHORT $LN2@ring_inser

; 58   : 				return false;

	xor	al, al
	jmp	SHORT $LN8@ring_inser
$LN2@ring_inser:

; 59   : 			}
; 60   : 			current = current->next;

	mov	rax, QWORD PTR current$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR current$1[rsp], rax

; 61   : 		}
; 62   : 		while (current != begin);

	mov	rax, QWORD PTR begin$2[rsp]
	cmp	QWORD PTR current$1[rsp], rax
	jne	SHORT $LN5@ring_inser
$LN6@ring_inser:

; 63   : 	}
; 64   : 	element_t* item = (element_t*)malloc(sizeof(element_t*));

	mov	ecx, 8
	call	?malloc@@YAPEAX_K@Z			; malloc
	mov	QWORD PTR item$[rsp], rax

; 65   : 	if (item) {

	cmp	QWORD PTR item$[rsp], 0
	je	SHORT $LN1@ring_inser

; 66   : 		item->data = data;

	mov	rax, QWORD PTR item$[rsp]
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rax], rcx

; 67   : 		put_in (ring,ring->current, item);

	mov	r8, QWORD PTR item$[rsp]
	mov	rax, QWORD PTR ring$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR ring$[rsp]
	call	?put_in@@YAXPEAU_ring_@@PEAU_element_@@1@Z ; put_in

; 68   : 		return (true);

	mov	al, 1
	jmp	SHORT $LN8@ring_inser
$LN1@ring_inser:

; 69   : 	}
; 70   : 	return false;

	xor	al, al
$LN8@ring_inser:

; 71   : }

	add	rsp, 72					; 00000048H
	ret	0
?ring_insert@@YA_NPEAU_ring_@@PEAX_N@Z ENDP		; ring_insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\utils\ring.cpp
_TEXT	SEGMENT
ring$ = 8
?initialize_ring@@YAXPEAU_ring_@@@Z PROC		; initialize_ring

; 17   : void initialize_ring (ring_t * ring) {

	mov	QWORD PTR [rsp+8], rcx

; 18   : 	ring->current = 0;

	mov	rax, QWORD PTR ring$[rsp]
	mov	QWORD PTR [rax+8], 0

; 19   : 	ring->begin = 0;

	mov	rax, QWORD PTR ring$[rsp]
	mov	QWORD PTR [rax], 0

; 20   : }

	ret	0
?initialize_ring@@YAXPEAU_ring_@@@Z ENDP		; initialize_ring
_TEXT	ENDS
END
