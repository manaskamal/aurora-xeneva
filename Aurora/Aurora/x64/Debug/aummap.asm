; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?au_mmap@@YAPEAXPEAX_K0@Z			; au_mmap
EXTRN	x64_cli:PROC
EXTRN	AuGetFreePage:PROC
EXTRN	malloc:PROC
EXTRN	?get_current_thread@@YAPEAU_thread_@@XZ:PROC	; get_current_thread
EXTRN	?AuInsertVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z:PROC ; AuInsertVMArea
EXTRN	?get_current_process@@YAPEAU_process_@@XZ:PROC	; get_current_process
pdata	SEGMENT
$pdata$?au_mmap@@YAPEAXPEAX_K0@Z DD imagerel $LN7
	DD	imagerel $LN7+338
	DD	imagerel $unwind$?au_mmap@@YAPEAXPEAX_K0@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?au_mmap@@YAPEAXPEAX_K0@Z DD 011301H
	DD	0a213H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\mmngr\aummap.cpp
_TEXT	SEGMENT
vma$ = 32
vaddr_start$ = 40
map_param$ = 48
size$ = 56
file$ = 64
proc$ = 72
address$ = 96
length$ = 104
params$ = 112
?au_mmap@@YAPEAXPEAX_K0@Z PROC				; au_mmap

; 46   : void* au_mmap (void* address, size_t length, void* params) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 47   : 	/* this is a system call, so make sure it is atomic */
; 48   : 	x64_cli();

	call	x64_cli

; 49   : 	mmap_params_t *map_param = (mmap_params_t*)params;

	mov	rax, QWORD PTR params$[rsp]
	mov	QWORD PTR map_param$[rsp], rax

; 50   : 	
; 51   : 	process_t *proc = get_current_process();

	call	?get_current_process@@YAPEAU_process_@@XZ ; get_current_process
	mov	QWORD PTR proc$[rsp], rax

; 52   : 	uint64_t vaddr_start = 0;

	mov	QWORD PTR vaddr_start$[rsp], 0

; 53   : 
; 54   : 	/* Get the starting address */
; 55   : 	if (address == NULL) {

	cmp	QWORD PTR address$[rsp], 0
	jne	SHORT $LN4@au_mmap

; 56   : 		address = AuGetFreePage(0,true);

	mov	dl, 1
	xor	ecx, ecx
	call	AuGetFreePage
	mov	QWORD PTR address$[rsp], rax

; 57   : 		vaddr_start = (uint64_t)address;

	mov	rax, QWORD PTR address$[rsp]
	mov	QWORD PTR vaddr_start$[rsp], rax

; 58   : 	}else 

	jmp	SHORT $LN3@au_mmap
$LN4@au_mmap:

; 59   : 		vaddr_start = (uint64_t)address;

	mov	rax, QWORD PTR address$[rsp]
	mov	QWORD PTR vaddr_start$[rsp], rax
$LN3@au_mmap:

; 60   : 
; 61   : 	vfs_node_t *file = NULL;

	mov	QWORD PTR file$[rsp], 0

; 62   : 	if (map_param->filedesc) {

	mov	rax, QWORD PTR map_param$[rsp]
	cmp	DWORD PTR [rax+8], 0
	je	SHORT $LN2@au_mmap

; 63   : 		file = get_current_thread()->fd[map_param->filedesc];

	call	?get_current_thread@@YAPEAU_thread_@@XZ	; get_current_thread
	mov	rcx, QWORD PTR map_param$[rsp]
	movsxd	rcx, DWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax+rcx*8+776]
	mov	QWORD PTR file$[rsp], rax
$LN2@au_mmap:

; 64   : 	}
; 65   : 
; 66   : 	uint64_t size = length / 4096;

	xor	edx, edx
	mov	rax, QWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR size$[rsp], rax

; 67   : 	if (size == 0)

	cmp	QWORD PTR size$[rsp], 0
	jne	SHORT $LN1@au_mmap

; 68   : 		size = 1;

	mov	QWORD PTR size$[rsp], 1
$LN1@au_mmap:

; 69   : 	au_vm_area_t *vma = (au_vm_area_t*)malloc(sizeof(au_vm_area_t));

	mov	ecx, 72					; 00000048H
	call	malloc
	mov	QWORD PTR vma$[rsp], rax

; 70   : 	vma->start = vaddr_start;

	mov	rax, QWORD PTR vma$[rsp]
	mov	rcx, QWORD PTR vaddr_start$[rsp]
	mov	QWORD PTR [rax], rcx

; 71   : 	vma->end = (vaddr_start + length * 4096);

	mov	rax, QWORD PTR length$[rsp]
	imul	rax, 4096				; 00001000H
	mov	rcx, QWORD PTR vaddr_start$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR vma$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 72   : 	vma->file = file;

	mov	rax, QWORD PTR vma$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 73   : 	vma->offset = map_param->offset;

	mov	rax, QWORD PTR vma$[rsp]
	mov	rcx, QWORD PTR map_param$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rax+32], rcx

; 74   : 	vma->prot_flags = map_param->protect;

	mov	rax, QWORD PTR vma$[rsp]
	mov	rcx, QWORD PTR map_param$[rsp]
	movzx	ecx, WORD PTR [rcx]
	mov	WORD PTR [rax+16], cx

; 75   : 	vma->type = VM_TYPE_RESOURCE;

	mov	rax, QWORD PTR vma$[rsp]
	mov	BYTE PTR [rax+48], 5

; 76   : 	vma->length = size;

	mov	rax, QWORD PTR vma$[rsp]
	mov	rcx, QWORD PTR size$[rsp]
	mov	QWORD PTR [rax+40], rcx

; 77   : 	AuInsertVMArea(proc, vma);

	mov	rdx, QWORD PTR vma$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	call	?AuInsertVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z ; AuInsertVMArea

; 78   : 	return address;

	mov	rax, QWORD PTR address$[rsp]

; 79   : }

	add	rsp, 88					; 00000058H
	ret	0
?au_mmap@@YAPEAXPEAX_K0@Z ENDP				; au_mmap
_TEXT	ENDS
END
