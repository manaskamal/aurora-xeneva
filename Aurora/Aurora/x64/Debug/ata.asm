; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ata_pm@@3EA					; ata_pm
PUBLIC	?ide_buf@@3PAEA					; ide_buf
PUBLIC	?ata_drive@@3EA					; ata_drive
PUBLIC	?ata_slave_drive@@3EA				; ata_slave_drive
PUBLIC	?ata_device_name@@3PADA				; ata_device_name
PUBLIC	?ide_irq_invoked@@3IA				; ide_irq_invoked
_BSS	SEGMENT
?ata_pm@@3EA DB	01H DUP (?)				; ata_pm
	ALIGN	4

?ide_buf@@3PAEA DB 0200H DUP (?)			; ide_buf
?ata_drive@@3EA DB 01H DUP (?)				; ata_drive
	ALIGN	4

?ata_slave_drive@@3EA DB 01H DUP (?)			; ata_slave_drive
	ALIGN	4

?ata_device_name@@3PADA DB 028H DUP (?)			; ata_device_name
?ide_irq_invoked@@3IA DD 01H DUP (?)			; ide_irq_invoked
_BSS	ENDS
CONST	SEGMENT
$SG2991	DB	'master ', 00H
$SG2992	DB	'slave', 00H
	ORG $+2
$SG2993	DB	'primary', 00H
$SG2994	DB	'secondary', 00H
	ORG $+6
$SG2995	DB	'ATA: %s s has error. disabled, ', 0aH, 00H
	ORG $+7
$SG3025	DB	'[ATA]: error!, device failure!', 0aH, 00H
CONST	ENDS
PUBLIC	?ata_initialize@@YAXXZ				; ata_initialize
PUBLIC	?ata_read_28@@YAEIGPEAE@Z			; ata_read_28
PUBLIC	?ata_write_one@@YAEPEAEI@Z			; ata_write_one
PUBLIC	?ata_slave_read_28@@YAEIGPEAE@Z			; ata_slave_read_28
PUBLIC	?ata_slave_write_one@@YAEPEAEI@Z		; ata_slave_write_one
PUBLIC	?ide_select_drive@@YAXEE@Z			; ide_select_drive
PUBLIC	?ide_primary_irq@@YAX_KPEAX@Z			; ide_primary_irq
PUBLIC	?ide_secondary_irq@@YAX_KPEAX@Z			; ide_secondary_irq
PUBLIC	?ide_wait_irq@@YAXXZ				; ide_wait_irq
PUBLIC	?ide_identify@@YA_NEE@Z				; ide_identify
PUBLIC	?ide_400ns_delay@@YAXG@Z			; ide_400ns_delay
PUBLIC	?ide_poll@@YAXG@Z				; ide_poll
PUBLIC	?ata_read_48@@YAX_KGPEAE@Z			; ata_read_48
PUBLIC	?ata_probe@@YAXXZ				; ata_probe
EXTRN	x64_outportw:PROC
EXTRN	?inportb@@YAEG@Z:PROC				; inportb
EXTRN	?inportw@@YAGG@Z:PROC				; inportw
EXTRN	?outportb@@YAXGE@Z:PROC				; outportb
EXTRN	?interrupt_end@@YAXXZ:PROC			; interrupt_end
EXTRN	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z:PROC	; interrupt_set
EXTRN	?memset@@YAXPEAXEI@Z:PROC			; memset
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
pdata	SEGMENT
$pdata$?ata_initialize@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?ata_initialize@@YAXXZ
$pdata$?ata_read_28@@YAEIGPEAE@Z DD imagerel $LN15
	DD	imagerel $LN15+443
	DD	imagerel $unwind$?ata_read_28@@YAEIGPEAE@Z
$pdata$?ata_write_one@@YAEPEAEI@Z DD imagerel $LN15
	DD	imagerel $LN15+457
	DD	imagerel $unwind$?ata_write_one@@YAEPEAEI@Z
$pdata$?ata_slave_read_28@@YAEIGPEAE@Z DD imagerel $LN15
	DD	imagerel $LN15+443
	DD	imagerel $unwind$?ata_slave_read_28@@YAEIGPEAE@Z
$pdata$?ata_slave_write_one@@YAEPEAEI@Z DD imagerel $LN15
	DD	imagerel $LN15+457
	DD	imagerel $unwind$?ata_slave_write_one@@YAEPEAEI@Z
$pdata$?ide_select_drive@@YAXEE@Z DD imagerel $LN9
	DD	imagerel $LN9+94
	DD	imagerel $unwind$?ide_select_drive@@YAXEE@Z
$pdata$?ata_wait_busy@@YAXG@Z DD imagerel ?ata_wait_busy@@YAXG@Z
	DD	imagerel ?ata_wait_busy@@YAXG@Z+44
	DD	imagerel $unwind$?ata_wait_busy@@YAXG@Z
$pdata$?ata_wait_drq@@YAXG@Z DD imagerel ?ata_wait_drq@@YAXG@Z
	DD	imagerel ?ata_wait_drq@@YAXG@Z+42
	DD	imagerel $unwind$?ata_wait_drq@@YAXG@Z
$pdata$?reset_ata_controller@@YAXG@Z DD imagerel ?reset_ata_controller@@YAXG@Z
	DD	imagerel ?reset_ata_controller@@YAXG@Z+131
	DD	imagerel $unwind$?reset_ata_controller@@YAXG@Z
$pdata$?ide_primary_irq@@YAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?ide_primary_irq@@YAX_KPEAX@Z
$pdata$?ide_secondary_irq@@YAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$?ide_secondary_irq@@YAX_KPEAX@Z
$pdata$?ide_identify@@YA_NEE@Z DD imagerel $LN19
	DD	imagerel $LN19+433
	DD	imagerel $unwind$?ide_identify@@YA_NEE@Z
$pdata$?ide_400ns_delay@@YAXG@Z DD imagerel $LN6
	DD	imagerel $LN6+63
	DD	imagerel $unwind$?ide_400ns_delay@@YAXG@Z
$pdata$?ide_poll@@YAXG@Z DD imagerel $LN9
	DD	imagerel $LN9+153
	DD	imagerel $unwind$?ide_poll@@YAXG@Z
$pdata$?ata_read_48@@YAX_KGPEAE@Z DD imagerel $LN15
	DD	imagerel $LN15+548
	DD	imagerel $unwind$?ata_read_48@@YAX_KGPEAE@Z
$pdata$?ata_probe@@YAXXZ DD imagerel $LN11
	DD	imagerel $LN11+322
	DD	imagerel $unwind$?ata_probe@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?ata_initialize@@YAXXZ DD 010401H
	DD	04204H
$unwind$?ata_read_28@@YAEIGPEAE@Z DD 011201H
	DD	08212H
$unwind$?ata_write_one@@YAEPEAEI@Z DD 010d01H
	DD	0820dH
$unwind$?ata_slave_read_28@@YAEIGPEAE@Z DD 011201H
	DD	08212H
$unwind$?ata_slave_write_one@@YAEPEAEI@Z DD 010d01H
	DD	0820dH
$unwind$?ide_select_drive@@YAXEE@Z DD 010c01H
	DD	0420cH
$unwind$?ata_wait_busy@@YAXG@Z DD 010901H
	DD	04209H
$unwind$?ata_wait_drq@@YAXG@Z DD 010901H
	DD	04209H
$unwind$?reset_ata_controller@@YAXG@Z DD 010901H
	DD	06209H
$unwind$?ide_primary_irq@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?ide_secondary_irq@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?ide_identify@@YA_NEE@Z DD 010c01H
	DD	0820cH
$unwind$?ide_400ns_delay@@YAXG@Z DD 010901H
	DD	06209H
$unwind$?ide_poll@@YAXG@Z DD 010901H
	DD	06209H
$unwind$?ata_read_48@@YAX_KGPEAE@Z DD 011301H
	DD	06213H
$unwind$?ata_probe@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
?ata_probe@@YAXXZ PROC					; ata_probe

; 460  : {

$LN11:
	sub	rsp, 56					; 00000038H

; 461  : 	if (ide_identify (ATA_PRIMARY, ATA_MASTER))

	xor	edx, edx
	xor	ecx, ecx
	call	?ide_identify@@YA_NEE@Z			; ide_identify
	movzx	eax, al
	test	eax, eax
	je	$LN8@ata_probe

; 462  : 	{
; 463  : 		ata_pm = 1;

	mov	BYTE PTR ?ata_pm@@3EA, 1		; ata_pm

; 464  : 		memset (ata_device_name, 0, 40);

	mov	r8d, 40					; 00000028H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?ata_device_name@@3PADA ; ata_device_name
	call	?memset@@YAXPEAXEI@Z			; memset

; 465  : 		for (int i= 0; i < 40; i += 2)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN7@ata_probe
$LN6@ata_probe:
	mov	eax, DWORD PTR i$1[rsp]
	add	eax, 2
	mov	DWORD PTR i$1[rsp], eax
$LN7@ata_probe:
	cmp	DWORD PTR i$1[rsp], 40			; 00000028H
	jge	SHORT $LN5@ata_probe

; 466  : 		{
; 467  : 			ata_device_name[i] = ide_buf[ATA_IDENT_MODEL + i + 1];

	mov	eax, DWORD PTR i$1[rsp]
	add	eax, 55					; 00000037H
	cdqe
	lea	rcx, OFFSET FLAT:?ide_buf@@3PAEA	; ide_buf
	movsxd	rdx, DWORD PTR i$1[rsp]
	lea	r8, OFFSET FLAT:?ata_device_name@@3PADA	; ata_device_name
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al

; 468  : 			ata_device_name[i + 1] = ide_buf[ATA_IDENT_MODEL + i];

	mov	eax, DWORD PTR i$1[rsp]
	add	eax, 54					; 00000036H
	cdqe
	lea	rcx, OFFSET FLAT:?ide_buf@@3PAEA	; ide_buf
	mov	edx, DWORD PTR i$1[rsp]
	inc	edx
	movsxd	rdx, edx
	lea	r8, OFFSET FLAT:?ata_device_name@@3PADA	; ata_device_name
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al

; 469  : 		}

	jmp	SHORT $LN6@ata_probe
$LN5@ata_probe:

; 470  : 
; 471  : 		//printf("[ATA]: Primary-Master Device: %s\n", ata_device_name);
; 472  : 		ata_drive = (ATA_PRIMARY << 1) | ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive
$LN8@ata_probe:

; 473  : 	}
; 474  : 
; 475  : 	if (ide_identify (ATA_PRIMARY, ATA_SLAVE)) {

	mov	dl, 1
	xor	ecx, ecx
	call	?ide_identify@@YA_NEE@Z			; ide_identify
	movzx	eax, al
	test	eax, eax
	je	$LN4@ata_probe

; 476  : 		//ata_pm = 1;
; 477  : 		memset (ata_device_name, 0, 40);

	mov	r8d, 40					; 00000028H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?ata_device_name@@3PADA ; ata_device_name
	call	?memset@@YAXPEAXEI@Z			; memset

; 478  : 		for (int i= 0; i < 40; i += 2)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@ata_probe
$LN2@ata_probe:
	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 2
	mov	DWORD PTR i$2[rsp], eax
$LN3@ata_probe:
	cmp	DWORD PTR i$2[rsp], 40			; 00000028H
	jge	SHORT $LN1@ata_probe

; 479  : 		{
; 480  : 			ata_device_name[i] = ide_buf[ATA_IDENT_MODEL + i + 1];

	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 55					; 00000037H
	cdqe
	lea	rcx, OFFSET FLAT:?ide_buf@@3PAEA	; ide_buf
	movsxd	rdx, DWORD PTR i$2[rsp]
	lea	r8, OFFSET FLAT:?ata_device_name@@3PADA	; ata_device_name
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al

; 481  : 			ata_device_name[i + 1] = ide_buf[ATA_IDENT_MODEL + i];

	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 54					; 00000036H
	cdqe
	lea	rcx, OFFSET FLAT:?ide_buf@@3PAEA	; ide_buf
	mov	edx, DWORD PTR i$2[rsp]
	inc	edx
	movsxd	rdx, edx
	lea	r8, OFFSET FLAT:?ata_device_name@@3PADA	; ata_device_name
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al

; 482  : 		}

	jmp	SHORT $LN2@ata_probe
$LN1@ata_probe:

; 483  : 
; 484  : 		ata_slave_drive = (ATA_PRIMARY << 1) | ATA_SLAVE;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 1	; ata_slave_drive
$LN4@ata_probe:

; 485  : 		//printf("[ATA]: Primary-Slave Device: %s\n", ata_device_name);
; 486  : 	}
; 487  : }

	add	rsp, 56					; 00000038H
	ret	0
?ata_probe@@YAXXZ ENDP					; ata_probe
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
i$ = 32
cmd$ = 33
io$ = 36
tv65 = 40
tv74 = 44
lba$ = 64
sector_count$ = 72
target$ = 80
?ata_read_48@@YAX_KGPEAE@Z PROC				; ata_read_48

; 290  : {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 291  : 
; 292  : 	uint16_t io = 0;

	xor	eax, eax
	mov	WORD PTR io$[rsp], ax

; 293  : 	switch (ata_drive)

	movzx	eax, BYTE PTR ?ata_drive@@3EA		; ata_drive
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 0
	je	SHORT $LN8@ata_read_4
	cmp	BYTE PTR tv65[rsp], 1
	je	SHORT $LN7@ata_read_4
	cmp	BYTE PTR tv65[rsp], 2
	je	SHORT $LN6@ata_read_4
	cmp	BYTE PTR tv65[rsp], 3
	je	SHORT $LN5@ata_read_4
	jmp	SHORT $LN4@ata_read_4
$LN8@ata_read_4:

; 294  : 	{
; 295  : 	case (ATA_PRIMARY << 1 |  ATA_MASTER):
; 296  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 297  : 		ata_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive

; 298  : 		break;

	jmp	SHORT $LN9@ata_read_4
$LN7@ata_read_4:

; 299  : 	case (ATA_PRIMARY << 1 | ATA_SLAVE):
; 300  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 301  : 		ata_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_drive@@3EA, 1		; ata_drive

; 302  : 		break;

	jmp	SHORT $LN9@ata_read_4
$LN6@ata_read_4:

; 303  : 	case (ATA_SECONDARY << 1 | ATA_MASTER):
; 304  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 305  : 		ata_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive

; 306  : 		break;

	jmp	SHORT $LN9@ata_read_4
$LN5@ata_read_4:

; 307  : 	case (ATA_SECONDARY << 1 | ATA_SLAVE):
; 308  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 309  : 		ata_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_drive@@3EA, 1		; ata_drive

; 310  : 		break;

	jmp	SHORT $LN9@ata_read_4
$LN4@ata_read_4:

; 311  : 	default:
; 312  : 		return;

	jmp	$LN11@ata_read_4
$LN9@ata_read_4:

; 313  : 	}
; 314  : 
; 315  : 	uint8_t cmd = (ata_drive == ATA_MASTER ? 0x40 : 0x50);

	movzx	eax, BYTE PTR ?ata_drive@@3EA		; ata_drive
	test	eax, eax
	jne	SHORT $LN13@ata_read_4
	mov	DWORD PTR tv74[rsp], 64			; 00000040H
	jmp	SHORT $LN14@ata_read_4
$LN13@ata_read_4:
	mov	DWORD PTR tv74[rsp], 80			; 00000050H
$LN14@ata_read_4:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR cmd$[rsp], al

; 316  : 
; 317  : 	outportb (io + ATA_REG_HDDEVSEL, cmd);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 6
	movzx	edx, BYTE PTR cmd$[rsp]
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 318  : 	outportb (io + ATA_REG_SECCOUNT0, (sector_count >> 8) & 0xFF);

	movzx	eax, WORD PTR sector_count$[rsp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 2
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 319  : 	outportb (io + ATA_REG_LBA0, (lba >> 24) & 0xFF);

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 3
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 320  : 	outportb (io + ATA_REG_LBA1, (lba >> 32) & 0xFF);

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 32					; 00000020H
	and	rax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 4
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 321  : 	outportb (io + ATA_REG_LBA2, (lba >> 40) & 0xFF);

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 40					; 00000028H
	and	rax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 5
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 322  : 	outportb (io + ATA_REG_SECCOUNT0, sector_count & 0xFF);

	movzx	eax, WORD PTR sector_count$[rsp]
	and	eax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 2
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 323  : 	outportb (io + ATA_REG_LBA0, lba & 0xFF);

	mov	rax, QWORD PTR lba$[rsp]
	and	rax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 3
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 324  : 	outportb (io + ATA_REG_LBA1, (lba >> 8) & 0xFF);

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 8
	and	rax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 4
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 325  : 	outportb (io + ATA_REG_LBA2, (lba >> 16) & 0xFF);

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 5
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 326  : 	outportb (io + ATA_REG_STATUS, ATA_CMD_READ_PIO_EXT);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	mov	dl, 36					; 00000024H
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 327  : 	
; 328  : 
; 329  : 	ide_poll(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_poll@@YAXG@Z			; ide_poll

; 330  : 	uint8_t i;
; 331  : 	for (i = 0; i < 256; i++)

	mov	BYTE PTR i$[rsp], 0
	jmp	SHORT $LN3@ata_read_4
$LN2@ata_read_4:
	movzx	eax, BYTE PTR i$[rsp]
	inc	al
	mov	BYTE PTR i$[rsp], al
$LN3@ata_read_4:
	movzx	eax, BYTE PTR i$[rsp]
	cmp	eax, 256				; 00000100H
	jge	SHORT $LN1@ata_read_4

; 332  : 	{
; 333  : 
; 334  : 		 *(uint16_t*)(target + i * 2) = inportw (io + ATA_REG_DATA);

	movzx	ecx, WORD PTR io$[rsp]
	call	?inportw@@YAGG@Z			; inportw
	movzx	ecx, BYTE PTR i$[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR target$[rsp]
	mov	WORD PTR [rdx+rcx], ax

; 335  : 		
; 336  : 	}

	jmp	SHORT $LN2@ata_read_4
$LN1@ata_read_4:

; 337  :     
; 338  : 	ide_400ns_delay(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_400ns_delay@@YAXG@Z		; ide_400ns_delay
$LN11@ata_read_4:

; 339  : 	//kprintf("\nData 48 bit read");
; 340  : }

	add	rsp, 56					; 00000038H
	ret	0
?ata_read_48@@YAX_KGPEAE@Z ENDP				; ata_read_48
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
status$ = 32
i$1 = 36
io$ = 64
?ide_poll@@YAXG@Z PROC					; ide_poll

; 143  : {

$LN9:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 144  : 	for (int i = 0; i < 4; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@ide_poll
$LN5@ide_poll:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@ide_poll:
	cmp	DWORD PTR i$1[rsp], 4
	jge	SHORT $LN4@ide_poll

; 145  : 	{
; 146  : 		inportb (io + ATA_REG_STATUS);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	?inportb@@YAEG@Z			; inportb

; 147  : 	}

	jmp	SHORT $LN5@ide_poll
$LN4@ide_poll:
$retry$10:

; 148  : retry:
; 149  : 	uint8_t status = inportb (io + ATA_REG_STATUS);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	?inportb@@YAEG@Z			; inportb
	mov	BYTE PTR status$[rsp], al

; 150  : 
; 151  : 	if (status & ATA_SR_BSY)

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN3@ide_poll

; 152  : 	{
; 153  : 		//kprintf ("\n ATA status busy");
; 154  : 		goto retry;

	jmp	SHORT $retry$10
$LN3@ide_poll:
$retry2$11:

; 155  : 	}
; 156  : 
; 157  : retry2:
; 158  : 	status = inportb (io + ATA_REG_STATUS);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	?inportb@@YAEG@Z			; inportb
	mov	BYTE PTR status$[rsp], al

; 159  : 	if (status & ATA_SR_ERR)

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@ide_poll

; 160  : 	{
; 161  : 		printf("[ATA]: error!, device failure!\n");

	lea	rcx, OFFSET FLAT:$SG3025
	call	?printf@@YAXPEBDZZ			; printf
$LN2@ide_poll:

; 162  : 	}
; 163  : 
; 164  : 	if (! (status & ATA_SR_DRQ))

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN1@ide_poll

; 165  : 	{
; 166  : 		//printf ("[ATA]: Status, drq");
; 167  : 		goto retry2;

	jmp	SHORT $retry2$11
$LN1@ide_poll:

; 168  : 	}
; 169  : 
; 170  : 	return;
; 171  : }

	add	rsp, 56					; 00000038H
	ret	0
?ide_poll@@YAXG@Z ENDP					; ide_poll
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
data$1 = 32
i$2 = 36
io$ = 64
?ide_400ns_delay@@YAXG@Z PROC				; ide_400ns_delay

; 134  : {

$LN6:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 135  : 	
; 136  : 	for (int i = 0; i < 4; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@ide_400ns_
$LN2@ide_400ns_:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@ide_400ns_:
	cmp	DWORD PTR i$2[rsp], 4
	jge	SHORT $LN1@ide_400ns_

; 137  : 	{
; 138  : 		uint8_t data = inportb(io + ATA_REG_ALTSTATUS);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 12
	movzx	ecx, ax
	call	?inportb@@YAEG@Z			; inportb
	mov	BYTE PTR data$1[rsp], al

; 139  : 	}

	jmp	SHORT $LN2@ide_400ns_
$LN1@ide_400ns_:

; 140  : }

	add	rsp, 56					; 00000038H
	ret	0
?ide_400ns_delay@@YAXG@Z ENDP				; ide_400ns_delay
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
status$ = 32
io$ = 36
i$1 = 40
tv68 = 44
tv152 = 48
tv156 = 56
bus$ = 80
drive$ = 88
?ide_identify@@YA_NEE@Z PROC				; ide_identify

; 87   : {

$LN19:
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 72					; 00000048H

; 88   : 	ide_select_drive (bus, drive);

	movzx	edx, BYTE PTR drive$[rsp]
	movzx	ecx, BYTE PTR bus$[rsp]
	call	?ide_select_drive@@YAXEE@Z		; ide_select_drive

; 89   : 
; 90   : 	uint16_t  io = bus == ATA_PRIMARY ? ATA_PRIMARY_IO : ATA_SECONDARY_IO;

	movzx	eax, BYTE PTR bus$[rsp]
	test	eax, eax
	jne	SHORT $LN13@ide_identi
	mov	DWORD PTR tv68[rsp], 496		; 000001f0H
	jmp	SHORT $LN14@ide_identi
$LN13@ide_identi:
	mov	DWORD PTR tv68[rsp], 368		; 00000170H
$LN14@ide_identi:
	movzx	eax, WORD PTR tv68[rsp]
	mov	WORD PTR io$[rsp], ax

; 91   : 
; 92   : 	outportb(io + ATA_REG_SECCOUNT0, 0);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 2
	xor	edx, edx
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 93   : 	outportb(io + ATA_REG_LBA0, 0);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 3
	xor	edx, edx
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 94   : 	outportb(io + ATA_REG_LBA1, 0);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 4
	xor	edx, edx
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 95   : 	outportb(io + ATA_REG_LBA2, 0);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 5
	xor	edx, edx
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 96   : 
; 97   : 	// now send identify
; 98   : 	outportb(io + ATA_REG_COMMAND, ATA_CMD_IDENTIFY);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	mov	dl, 236					; 000000ecH
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 99   : 
; 100  : 	//! read status port
; 101  : 	uint8_t status = inportb (io + ATA_REG_STATUS );

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	?inportb@@YAEG@Z			; inportb
	mov	BYTE PTR status$[rsp], al

; 102  : 	if (status)

	movzx	eax, BYTE PTR status$[rsp]
	test	eax, eax
	je	$LN10@ide_identi
$LN9@ide_identi:

; 103  : 	{
; 104  : 		while ((inportb(io + ATA_REG_STATUS) & ATA_SR_BSY) != 0);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	?inportb@@YAEG@Z			; inportb
	movzx	eax, al
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN8@ide_identi
	jmp	SHORT $LN9@ide_identi
$LN8@ide_identi:
$pm_stat_read$20:

; 105  : pm_stat_read:
; 106  : 		status = inportb (io + ATA_REG_STATUS);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	?inportb@@YAEG@Z			; inportb
	mov	BYTE PTR status$[rsp], al

; 107  : 		if (status & ATA_SR_ERR)

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@ide_identi

; 108  : 		{
; 109  : 			printf("ATA: %s s has error. disabled, \n", bus == ATA_PRIMARY ? "primary" : "secondary", 
; 110  : 				drive == ATA_PRIMARY ? "master " : "slave");

	movzx	eax, BYTE PTR drive$[rsp]
	test	eax, eax
	jne	SHORT $LN15@ide_identi
	lea	rax, OFFSET FLAT:$SG2991
	mov	QWORD PTR tv152[rsp], rax
	jmp	SHORT $LN16@ide_identi
$LN15@ide_identi:
	lea	rax, OFFSET FLAT:$SG2992
	mov	QWORD PTR tv152[rsp], rax
$LN16@ide_identi:
	movzx	eax, BYTE PTR bus$[rsp]
	test	eax, eax
	jne	SHORT $LN17@ide_identi
	lea	rax, OFFSET FLAT:$SG2993
	mov	QWORD PTR tv156[rsp], rax
	jmp	SHORT $LN18@ide_identi
$LN17@ide_identi:
	lea	rax, OFFSET FLAT:$SG2994
	mov	QWORD PTR tv156[rsp], rax
$LN18@ide_identi:
	mov	r8, QWORD PTR tv152[rsp]
	mov	rdx, QWORD PTR tv156[rsp]
	lea	rcx, OFFSET FLAT:$SG2995
	call	?printf@@YAXPEBDZZ			; printf
$LN7@ide_identi:
$LN6@ide_identi:

; 111  : 			//return false;
; 112  : 		}
; 113  : 
; 114  : 		while (! (status & ATA_SR_DRQ))

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN5@ide_identi

; 115  : 		{
; 116  : 			goto pm_stat_read;

	jmp	$pm_stat_read$20

; 117  : 		}

	jmp	SHORT $LN6@ide_identi
$LN5@ide_identi:

; 118  : 
; 119  : 		for (int i = 0; i < 256;i++ )

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@ide_identi
$LN3@ide_identi:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ide_identi:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN2@ide_identi

; 120  : 		{
; 121  : 			*(uint16_t *) (ide_buf + i*2) = inportw(io + ATA_REG_DATA);

	movzx	ecx, WORD PTR io$[rsp]
	call	?inportw@@YAGG@Z			; inportw
	mov	ecx, DWORD PTR i$1[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	lea	rdx, OFFSET FLAT:?ide_buf@@3PAEA	; ide_buf
	mov	WORD PTR [rdx+rcx], ax

; 122  : 			//("\n%x %x", *(uint16_t*) (ide_buf + i * 2) >> 8, *(uint16_t *)(ide_buf + i * 2) & 0xFF);
; 123  : 		}

	jmp	SHORT $LN3@ide_identi
$LN2@ide_identi:

; 124  : 		return true;

	mov	al, 1
	jmp	SHORT $LN11@ide_identi
$LN10@ide_identi:

; 125  : 	}
; 126  : 	else
; 127  : 	{
; 128  : 		//printf("ATA: Status 0\n");
; 129  : 	}
; 130  : 	return false;

	xor	al, al
$LN11@ide_identi:

; 131  : }

	add	rsp, 72					; 00000048H
	ret	0
?ide_identify@@YA_NEE@Z ENDP				; ide_identify
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
?ide_wait_irq@@YAXXZ PROC				; ide_wait_irq

; 80   : void ide_wait_irq () {

	npad	2
$LN2@ide_wait_i:

; 81   : 	while (!ide_irq_invoked)

	cmp	DWORD PTR ?ide_irq_invoked@@3IA, 0	; ide_irq_invoked
	jne	SHORT $LN1@ide_wait_i

; 82   : 		;

	jmp	SHORT $LN2@ide_wait_i
$LN1@ide_wait_i:

; 83   : 	ide_irq_invoked = 0;

	mov	DWORD PTR ?ide_irq_invoked@@3IA, 0	; ide_irq_invoked

; 84   : }

	ret	0
?ide_wait_irq@@YAXXZ ENDP				; ide_wait_irq
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
vector$ = 48
param$ = 56
?ide_secondary_irq@@YAX_KPEAX@Z PROC			; ide_secondary_irq

; 75   : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 76   : 	reset_ata_controller (ATA_SECONDARY_IO);

	mov	cx, 368					; 00000170H
	call	?reset_ata_controller@@YAXG@Z		; reset_ata_controller

; 77   : 	interrupt_end();

	call	?interrupt_end@@YAXXZ			; interrupt_end

; 78   : }

	add	rsp, 40					; 00000028H
	ret	0
?ide_secondary_irq@@YAX_KPEAX@Z ENDP			; ide_secondary_irq
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
vector$ = 48
param$ = 56
?ide_primary_irq@@YAX_KPEAX@Z PROC			; ide_primary_irq

; 69   : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 70   : 	ide_irq_invoked = 1;

	mov	DWORD PTR ?ide_irq_invoked@@3IA, 1	; ide_irq_invoked

; 71   : 	interrupt_end();

	call	?interrupt_end@@YAXXZ			; interrupt_end

; 72   : }

	add	rsp, 40					; 00000028H
	ret	0
?ide_primary_irq@@YAX_KPEAX@Z ENDP			; ide_primary_irq
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
i$1 = 32
j$2 = 36
io$ = 64
?reset_ata_controller@@YAXG@Z PROC			; reset_ata_controller

; 49   : {

	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 50   : 
; 51   : 	outportb (io + ATA_REG_CONTROL, 0x04);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 12
	mov	dl, 4
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 52   : 	for (int i=0; i<20; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@reset_ata_
$LN5@reset_ata_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@reset_ata_:
	cmp	DWORD PTR i$1[rsp], 20
	jge	SHORT $LN4@reset_ata_

; 53   : 		;

	jmp	SHORT $LN5@reset_ata_
$LN4@reset_ata_:

; 54   : 
; 55   : 	ata_wait_busy(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 56   : 
; 57   : 	outportb (io + ATA_REG_CONTROL, 0);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 12
	xor	edx, edx
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 58   : 
; 59   : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 60   : 
; 61   : 	for (int j = 0; j < 30000000; j++)

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN3@reset_ata_
$LN2@reset_ata_:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN3@reset_ata_:
	cmp	DWORD PTR j$2[rsp], 30000000		; 01c9c380H
	jge	SHORT $LN1@reset_ata_

; 62   : 		;

	jmp	SHORT $LN2@reset_ata_
$LN1@reset_ata_:

; 63   : 
; 64   : }

	add	rsp, 56					; 00000038H
	ret	0
?reset_ata_controller@@YAXG@Z ENDP			; reset_ata_controller
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
io$ = 48
?ata_wait_drq@@YAXG@Z PROC				; ata_wait_drq

; 43   : {

	mov	WORD PTR [rsp+8], cx
	sub	rsp, 40					; 00000028H
$LN2@ata_wait_d:

; 44   : 	while (!(inportb (io + ATA_REG_STATUS) & STATUS_RDY))

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	?inportb@@YAEG@Z			; inportb
	movzx	eax, al
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN1@ata_wait_d

; 45   : 		;

	jmp	SHORT $LN2@ata_wait_d
$LN1@ata_wait_d:

; 46   : }

	add	rsp, 40					; 00000028H
	ret	0
?ata_wait_drq@@YAXG@Z ENDP				; ata_wait_drq
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
io$ = 48
?ata_wait_busy@@YAXG@Z PROC				; ata_wait_busy

; 37   : {

	mov	WORD PTR [rsp+8], cx
	sub	rsp, 40					; 00000028H
$LN2@ata_wait_b:

; 38   : 	while (inportb(io + ATA_REG_STATUS) & STATUS_BSY)

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	?inportb@@YAEG@Z			; inportb
	movzx	eax, al
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN1@ata_wait_b

; 39   : 		;

	jmp	SHORT $LN2@ata_wait_b
$LN1@ata_wait_b:

; 40   : }

	add	rsp, 40					; 00000028H
	ret	0
?ata_wait_busy@@YAXG@Z ENDP				; ata_wait_busy
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
bus$ = 48
i$ = 56
?ide_select_drive@@YAXEE@Z PROC				; ide_select_drive

; 22   : {

$LN9:
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 40					; 00000028H

; 23   : 	if (bus == ATA_PRIMARY )

	movzx	eax, BYTE PTR bus$[rsp]
	test	eax, eax
	jne	SHORT $LN6@ide_select

; 24   : 		if (i == ATA_MASTER)

	movzx	eax, BYTE PTR i$[rsp]
	test	eax, eax
	jne	SHORT $LN5@ide_select

; 25   : 			outportb(ATA_PRIMARY_IO + ATA_REG_HDDEVSEL, 0xA0);

	mov	dl, 160					; 000000a0H
	mov	cx, 502					; 000001f6H
	call	?outportb@@YAXGE@Z			; outportb

; 26   : 		else

	jmp	SHORT $LN4@ide_select
$LN5@ide_select:

; 27   : 			outportb(ATA_PRIMARY_IO + ATA_REG_HDDEVSEL, 0xB0);

	mov	dl, 176					; 000000b0H
	mov	cx, 502					; 000001f6H
	call	?outportb@@YAXGE@Z			; outportb
$LN4@ide_select:

; 28   : 	else

	jmp	SHORT $LN3@ide_select
$LN6@ide_select:

; 29   : 		if (i == ATA_MASTER)

	movzx	eax, BYTE PTR i$[rsp]
	test	eax, eax
	jne	SHORT $LN2@ide_select

; 30   : 			outportb(ATA_SECONDARY_IO + ATA_REG_HDDEVSEL, 0xA0);

	mov	dl, 160					; 000000a0H
	mov	cx, 374					; 00000176H
	call	?outportb@@YAXGE@Z			; outportb

; 31   : 		else

	jmp	SHORT $LN1@ide_select
$LN2@ide_select:

; 32   : 			outportb(ATA_SECONDARY_IO + ATA_REG_HDDEVSEL, 0xB0);

	mov	dl, 176					; 000000b0H
	mov	cx, 374					; 00000176H
	call	?outportb@@YAXGE@Z			; outportb
$LN1@ide_select:
$LN3@ide_select:

; 33   : }

	add	rsp, 40					; 00000028H
	ret	0
?ide_select_drive@@YAXEE@Z ENDP				; ide_select_drive
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
cmd$ = 32
io$ = 36
tv65 = 40
i$1 = 44
tv74 = 48
buf$ = 80
lba$ = 88
?ata_slave_write_one@@YAEPEAEI@Z PROC			; ata_slave_write_one

; 402  : {

$LN15:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 403  : 	uint16_t io = 0;

	xor	eax, eax
	mov	WORD PTR io$[rsp], ax

; 404  : 	switch (ata_slave_drive)

	movzx	eax, BYTE PTR ?ata_slave_drive@@3EA	; ata_slave_drive
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 0
	je	SHORT $LN8@ata_slave_
	cmp	BYTE PTR tv65[rsp], 1
	je	SHORT $LN7@ata_slave_
	cmp	BYTE PTR tv65[rsp], 2
	je	SHORT $LN6@ata_slave_
	cmp	BYTE PTR tv65[rsp], 3
	je	SHORT $LN5@ata_slave_
	jmp	SHORT $LN4@ata_slave_
$LN8@ata_slave_:

; 405  : 	{
; 406  : 	case (ATA_PRIMARY << 1 | ATA_MASTER):
; 407  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 408  : 		ata_slave_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 0	; ata_slave_drive

; 409  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN7@ata_slave_:

; 410  : 	case (ATA_PRIMARY << 1 | ATA_SLAVE):
; 411  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 412  : 		ata_slave_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 1	; ata_slave_drive

; 413  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN6@ata_slave_:

; 414  : 	case (ATA_SECONDARY << 1 | ATA_MASTER):
; 415  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 416  : 		ata_slave_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 0	; ata_slave_drive

; 417  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN5@ata_slave_:

; 418  : 	case (ATA_SECONDARY << 1 | ATA_SLAVE):
; 419  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 420  : 		ata_slave_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 1	; ata_slave_drive

; 421  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN4@ata_slave_:

; 422  : 	default:
; 423  : 		return 0;

	xor	al, al
	jmp	$LN11@ata_slave_
$LN9@ata_slave_:

; 424  : 	}
; 425  : 
; 426  : 	uint8_t  cmd = (ata_slave_drive == ATA_MASTER ? 0xE0 : 0xF0);

	movzx	eax, BYTE PTR ?ata_slave_drive@@3EA	; ata_slave_drive
	test	eax, eax
	jne	SHORT $LN13@ata_slave_
	mov	DWORD PTR tv74[rsp], 224		; 000000e0H
	jmp	SHORT $LN14@ata_slave_
$LN13@ata_slave_:
	mov	DWORD PTR tv74[rsp], 240		; 000000f0H
$LN14@ata_slave_:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR cmd$[rsp], al

; 427  : 
; 428  : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 429  : 	outportb(io + ATA_REG_HDDEVSEL, (cmd | (uint8_t) ((lba >> 24 & 0xFF))));

	movzx	eax, BYTE PTR cmd$[rsp]
	mov	ecx, DWORD PTR lba$[rsp]
	shr	ecx, 24
	and	ecx, 255				; 000000ffH
	movzx	ecx, cl
	or	eax, ecx
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 6
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 430  : 	outportb(io + 1, 0x00);

	movzx	eax, WORD PTR io$[rsp]
	inc	eax
	xor	edx, edx
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 431  : 
; 432  : 	//! single sector write
; 433  :     outportb(io + ATA_REG_SECCOUNT0, 1);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 2
	mov	dl, 1
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 434  : 
; 435  : 	//! select LBA
; 436  : 	outportb(io + ATA_REG_LBA0, (uint8_t)((lba)));

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 3
	movzx	edx, BYTE PTR lba$[rsp]
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 437  : 	outportb(io + ATA_REG_LBA1, (uint8_t)((lba) >> 8));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 8
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 4
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 438  : 	outportb(io + ATA_REG_LBA2, (uint8_t)((lba) >> 16));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 16
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 5
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 439  : 
; 440  : 	//! select write command
; 441  : 	outportb (io + ATA_REG_COMMAND, ATA_CMD_WRITE_PIO);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	mov	dl, 48					; 00000030H
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 442  : 
; 443  : 	//! wait until ready
; 444  : 	ide_poll(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_poll@@YAXG@Z			; ide_poll

; 445  : 
; 446  : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 447  : 	ata_wait_drq (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_drq@@YAXG@Z			; ata_wait_drq

; 448  : 	for (int i=0; i < 256; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@ata_slave_
$LN2@ata_slave_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@ata_slave_:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN1@ata_slave_

; 449  : 	{
; 450  : 	
; 451  : 		x64_outportw(io + ATA_REG_DATA, *(uint16_t *)(buf + i * 2));

	mov	eax, DWORD PTR i$1[rsp]
	shl	eax, 1
	cdqe
	mov	rcx, QWORD PTR buf$[rsp]
	movzx	edx, WORD PTR [rcx+rax]
	movzx	ecx, WORD PTR io$[rsp]
	call	x64_outportw

; 452  : 	}

	jmp	SHORT $LN2@ata_slave_
$LN1@ata_slave_:

; 453  : 
; 454  : 	ide_400ns_delay (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_400ns_delay@@YAXG@Z		; ide_400ns_delay

; 455  : 	return 1;

	mov	al, 1
$LN11@ata_slave_:

; 456  : }

	add	rsp, 72					; 00000048H
	ret	0
?ata_slave_write_one@@YAEPEAEI@Z ENDP			; ata_slave_write_one
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
cmd$ = 32
io$ = 36
tv65 = 40
i$1 = 44
tv74 = 48
lba$ = 80
sec_count$ = 88
buf$ = 96
?ata_slave_read_28@@YAEIGPEAE@Z PROC			; ata_slave_read_28

; 343  : {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 344  : 	//! we only support 28 bit LBA so far
; 345  : 	uint16_t io = 0;

	xor	eax, eax
	mov	WORD PTR io$[rsp], ax

; 346  : 	switch (ata_slave_drive)

	movzx	eax, BYTE PTR ?ata_slave_drive@@3EA	; ata_slave_drive
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 0
	je	SHORT $LN8@ata_slave_
	cmp	BYTE PTR tv65[rsp], 1
	je	SHORT $LN7@ata_slave_
	cmp	BYTE PTR tv65[rsp], 2
	je	SHORT $LN6@ata_slave_
	cmp	BYTE PTR tv65[rsp], 3
	je	SHORT $LN5@ata_slave_
	jmp	SHORT $LN4@ata_slave_
$LN8@ata_slave_:

; 347  : 	{
; 348  : 	case (ATA_PRIMARY << 1 |  ATA_MASTER):
; 349  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 350  : 		ata_slave_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 0	; ata_slave_drive

; 351  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN7@ata_slave_:

; 352  : 	case (ATA_PRIMARY << 1 | ATA_SLAVE):
; 353  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 354  : 		ata_slave_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 1	; ata_slave_drive

; 355  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN6@ata_slave_:

; 356  : 	case (ATA_SECONDARY << 1 | ATA_MASTER):
; 357  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 358  : 		ata_slave_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 0	; ata_slave_drive

; 359  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN5@ata_slave_:

; 360  : 	case (ATA_SECONDARY << 1 | ATA_SLAVE):
; 361  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 362  : 		ata_slave_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 1	; ata_slave_drive

; 363  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN4@ata_slave_:

; 364  : 	default:
; 365  : 		return 0;

	xor	al, al
	jmp	$LN11@ata_slave_
$LN9@ata_slave_:

; 366  : 	}
; 367  : 
; 368  : 	uint8_t cmd = (ata_slave_drive == ATA_MASTER ? 0xE0 : 0xF0);

	movzx	eax, BYTE PTR ?ata_slave_drive@@3EA	; ata_slave_drive
	test	eax, eax
	jne	SHORT $LN13@ata_slave_
	mov	DWORD PTR tv74[rsp], 224		; 000000e0H
	jmp	SHORT $LN14@ata_slave_
$LN13@ata_slave_:
	mov	DWORD PTR tv74[rsp], 240		; 000000f0H
$LN14@ata_slave_:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR cmd$[rsp], al

; 369  : 
; 370  : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 371  : 	
; 372  : 	outportb (io + ATA_REG_HDDEVSEL, (cmd | (uint8_t) ((lba >> 24 & 0x0F))));

	movzx	eax, BYTE PTR cmd$[rsp]
	mov	ecx, DWORD PTR lba$[rsp]
	shr	ecx, 24
	and	ecx, 15
	movzx	ecx, cl
	or	eax, ecx
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 6
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 373  : 	outportb (io + 1, 0x00);

	movzx	eax, WORD PTR io$[rsp]
	inc	eax
	xor	edx, edx
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 374  : 
; 375  : 	//! single sector read
; 376  : 	outportb (io + ATA_REG_SECCOUNT0, sec_count);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 2
	movzx	edx, BYTE PTR sec_count$[rsp]
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 377  : 
; 378  : 	//! select LBA
; 379  : 	outportb (io + ATA_REG_LBA0, (uint8_t)((lba)));

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 3
	movzx	edx, BYTE PTR lba$[rsp]
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 380  : 	outportb (io + ATA_REG_LBA1, (uint8_t)((lba) >> 8));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 8
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 4
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 381  : 	outportb (io + ATA_REG_LBA2, (uint8_t)((lba) >> 16));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 16
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 5
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 382  : 
; 383  : 	//! select read command
; 384  : 	outportb (io + ATA_REG_COMMAND, ATA_CMD_READ_PIO);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	mov	dl, 32					; 00000020H
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 385  : 
; 386  : 	//! wait untill ready
; 387  : 	ide_poll (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_poll@@YAXG@Z			; ide_poll

; 388  : 	
; 389  : 	for (int i = 0; i < 256; i++ )

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@ata_slave_
$LN2@ata_slave_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@ata_slave_:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN1@ata_slave_

; 390  : 	{
; 391  : 			
; 392  : 	   *(uint16_t*)(buf + i * 2) = inportw (io + ATA_REG_DATA);

	movzx	ecx, WORD PTR io$[rsp]
	call	?inportw@@YAGG@Z			; inportw
	mov	ecx, DWORD PTR i$1[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR buf$[rsp]
	mov	WORD PTR [rdx+rcx], ax

; 393  :     }

	jmp	SHORT $LN2@ata_slave_
$LN1@ata_slave_:

; 394  : 	
; 395  : 	
; 396  : 	ide_400ns_delay(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_400ns_delay@@YAXG@Z		; ide_400ns_delay

; 397  : 	//ide_wait_irq ();
; 398  : 	return 0;

	xor	al, al
$LN11@ata_slave_:

; 399  : }

	add	rsp, 72					; 00000048H
	ret	0
?ata_slave_read_28@@YAEIGPEAE@Z ENDP			; ata_slave_read_28
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
cmd$ = 32
io$ = 36
tv65 = 40
i$1 = 44
tv74 = 48
buf$ = 80
lba$ = 88
?ata_write_one@@YAEPEAEI@Z PROC				; ata_write_one

; 174  : {

$LN15:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 175  : 	uint16_t io = 0;

	xor	eax, eax
	mov	WORD PTR io$[rsp], ax

; 176  : 	switch (ata_drive)

	movzx	eax, BYTE PTR ?ata_drive@@3EA		; ata_drive
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 0
	je	SHORT $LN8@ata_write_
	cmp	BYTE PTR tv65[rsp], 1
	je	SHORT $LN7@ata_write_
	cmp	BYTE PTR tv65[rsp], 2
	je	SHORT $LN6@ata_write_
	cmp	BYTE PTR tv65[rsp], 3
	je	SHORT $LN5@ata_write_
	jmp	SHORT $LN4@ata_write_
$LN8@ata_write_:

; 177  : 	{
; 178  : 	case (ATA_PRIMARY << 1 | ATA_MASTER):
; 179  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 180  : 		ata_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive

; 181  : 		break;

	jmp	SHORT $LN9@ata_write_
$LN7@ata_write_:

; 182  : 	case (ATA_PRIMARY << 1 | ATA_SLAVE):
; 183  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 184  : 		ata_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_drive@@3EA, 1		; ata_drive

; 185  : 		break;

	jmp	SHORT $LN9@ata_write_
$LN6@ata_write_:

; 186  : 	case (ATA_SECONDARY << 1 | ATA_MASTER):
; 187  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 188  : 		ata_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive

; 189  : 		break;

	jmp	SHORT $LN9@ata_write_
$LN5@ata_write_:

; 190  : 	case (ATA_SECONDARY << 1 | ATA_SLAVE):
; 191  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 192  : 		ata_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_drive@@3EA, 1		; ata_drive

; 193  : 		break;

	jmp	SHORT $LN9@ata_write_
$LN4@ata_write_:

; 194  : 	default:
; 195  : 		return 0;

	xor	al, al
	jmp	$LN11@ata_write_
$LN9@ata_write_:

; 196  : 	}
; 197  : 
; 198  : 	uint8_t  cmd = (ata_drive == ATA_MASTER ? 0xE0 : 0xF0);

	movzx	eax, BYTE PTR ?ata_drive@@3EA		; ata_drive
	test	eax, eax
	jne	SHORT $LN13@ata_write_
	mov	DWORD PTR tv74[rsp], 224		; 000000e0H
	jmp	SHORT $LN14@ata_write_
$LN13@ata_write_:
	mov	DWORD PTR tv74[rsp], 240		; 000000f0H
$LN14@ata_write_:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR cmd$[rsp], al

; 199  : 
; 200  : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 201  : 	outportb(io + ATA_REG_HDDEVSEL, (cmd | (uint8_t) ((lba >> 24 & 0xFF))));

	movzx	eax, BYTE PTR cmd$[rsp]
	mov	ecx, DWORD PTR lba$[rsp]
	shr	ecx, 24
	and	ecx, 255				; 000000ffH
	movzx	ecx, cl
	or	eax, ecx
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 6
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 202  : 	outportb(io + 1, 0x00);

	movzx	eax, WORD PTR io$[rsp]
	inc	eax
	xor	edx, edx
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 203  : 
; 204  : 	//! single sector write
; 205  :     outportb(io + ATA_REG_SECCOUNT0, 1);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 2
	mov	dl, 1
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 206  : 
; 207  : 	//! select LBA
; 208  : 	outportb(io + ATA_REG_LBA0, (uint8_t)((lba)));

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 3
	movzx	edx, BYTE PTR lba$[rsp]
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 209  : 	outportb(io + ATA_REG_LBA1, (uint8_t)((lba) >> 8));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 8
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 4
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 210  : 	outportb(io + ATA_REG_LBA2, (uint8_t)((lba) >> 16));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 16
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 5
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 211  : 
; 212  : 	//! select write command
; 213  : 	outportb (io + ATA_REG_COMMAND, ATA_CMD_WRITE_PIO);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	mov	dl, 48					; 00000030H
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 214  : 
; 215  : 	//! wait until ready
; 216  : 	ide_poll(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_poll@@YAXG@Z			; ide_poll

; 217  : 
; 218  : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 219  : 	ata_wait_drq (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_drq@@YAXG@Z			; ata_wait_drq

; 220  : 	for (int i=0; i < 256; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@ata_write_
$LN2@ata_write_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@ata_write_:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN1@ata_write_

; 221  : 	{
; 222  : 	
; 223  : 		x64_outportw(io + ATA_REG_DATA, *(uint16_t *)(buf + i * 2));

	mov	eax, DWORD PTR i$1[rsp]
	shl	eax, 1
	cdqe
	mov	rcx, QWORD PTR buf$[rsp]
	movzx	edx, WORD PTR [rcx+rax]
	movzx	ecx, WORD PTR io$[rsp]
	call	x64_outportw

; 224  : 	}

	jmp	SHORT $LN2@ata_write_
$LN1@ata_write_:

; 225  : 
; 226  : 	ide_400ns_delay (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_400ns_delay@@YAXG@Z		; ide_400ns_delay

; 227  : 	return 1;

	mov	al, 1
$LN11@ata_write_:

; 228  : }

	add	rsp, 72					; 00000048H
	ret	0
?ata_write_one@@YAEPEAEI@Z ENDP				; ata_write_one
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
cmd$ = 32
io$ = 36
tv65 = 40
i$1 = 44
tv74 = 48
lba$ = 80
sec_count$ = 88
buf$ = 96
?ata_read_28@@YAEIGPEAE@Z PROC				; ata_read_28

; 231  : {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 232  : 	//! we only support 28 bit LBA so far
; 233  : 	uint16_t io = 0;

	xor	eax, eax
	mov	WORD PTR io$[rsp], ax

; 234  : 	switch (ata_drive)

	movzx	eax, BYTE PTR ?ata_drive@@3EA		; ata_drive
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 0
	je	SHORT $LN8@ata_read_2
	cmp	BYTE PTR tv65[rsp], 1
	je	SHORT $LN7@ata_read_2
	cmp	BYTE PTR tv65[rsp], 2
	je	SHORT $LN6@ata_read_2
	cmp	BYTE PTR tv65[rsp], 3
	je	SHORT $LN5@ata_read_2
	jmp	SHORT $LN4@ata_read_2
$LN8@ata_read_2:

; 235  : 	{
; 236  : 	case (ATA_PRIMARY << 1 |  ATA_MASTER):
; 237  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 238  : 		ata_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive

; 239  : 		break;

	jmp	SHORT $LN9@ata_read_2
$LN7@ata_read_2:

; 240  : 	case (ATA_PRIMARY << 1 | ATA_SLAVE):
; 241  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 242  : 		ata_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_drive@@3EA, 1		; ata_drive

; 243  : 		break;

	jmp	SHORT $LN9@ata_read_2
$LN6@ata_read_2:

; 244  : 	case (ATA_SECONDARY << 1 | ATA_MASTER):
; 245  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 246  : 		ata_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive

; 247  : 		break;

	jmp	SHORT $LN9@ata_read_2
$LN5@ata_read_2:

; 248  : 	case (ATA_SECONDARY << 1 | ATA_SLAVE):
; 249  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 250  : 		ata_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_drive@@3EA, 1		; ata_drive

; 251  : 		break;

	jmp	SHORT $LN9@ata_read_2
$LN4@ata_read_2:

; 252  : 	default:
; 253  : 		return 0;

	xor	al, al
	jmp	$LN11@ata_read_2
$LN9@ata_read_2:

; 254  : 	}
; 255  : 
; 256  : 	uint8_t cmd = (ata_drive == ATA_MASTER ? 0xE0 : 0xF0);

	movzx	eax, BYTE PTR ?ata_drive@@3EA		; ata_drive
	test	eax, eax
	jne	SHORT $LN13@ata_read_2
	mov	DWORD PTR tv74[rsp], 224		; 000000e0H
	jmp	SHORT $LN14@ata_read_2
$LN13@ata_read_2:
	mov	DWORD PTR tv74[rsp], 240		; 000000f0H
$LN14@ata_read_2:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR cmd$[rsp], al

; 257  : 
; 258  : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 259  : 	
; 260  : 	outportb (io + ATA_REG_HDDEVSEL, (cmd | (uint8_t) ((lba >> 24 & 0x0F))));

	movzx	eax, BYTE PTR cmd$[rsp]
	mov	ecx, DWORD PTR lba$[rsp]
	shr	ecx, 24
	and	ecx, 15
	movzx	ecx, cl
	or	eax, ecx
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 6
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 261  : 	outportb (io + 1, 0x00);

	movzx	eax, WORD PTR io$[rsp]
	inc	eax
	xor	edx, edx
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 262  : 
; 263  : 	//! single sector read
; 264  : 	outportb (io + ATA_REG_SECCOUNT0, sec_count);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 2
	movzx	edx, BYTE PTR sec_count$[rsp]
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 265  : 
; 266  : 	//! select LBA
; 267  : 	outportb (io + ATA_REG_LBA0, (uint8_t)((lba)));

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 3
	movzx	edx, BYTE PTR lba$[rsp]
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 268  : 	outportb (io + ATA_REG_LBA1, (uint8_t)((lba) >> 8));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 8
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 4
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 269  : 	outportb (io + ATA_REG_LBA2, (uint8_t)((lba) >> 16));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 16
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 5
	movzx	edx, al
	call	?outportb@@YAXGE@Z			; outportb

; 270  : 
; 271  : 	//! select read command
; 272  : 	outportb (io + ATA_REG_COMMAND, ATA_CMD_READ_PIO);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	mov	dl, 32					; 00000020H
	movzx	ecx, ax
	call	?outportb@@YAXGE@Z			; outportb

; 273  : 
; 274  : 	//! wait untill ready
; 275  : 	ide_poll (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_poll@@YAXG@Z			; ide_poll

; 276  : 	
; 277  : 	for (int i = 0; i < 256; i++ )

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@ata_read_2
$LN2@ata_read_2:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@ata_read_2:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN1@ata_read_2

; 278  : 	{
; 279  : 			
; 280  : 	   *(uint16_t*)(buf + i * 2) = inportw (io + ATA_REG_DATA);

	movzx	ecx, WORD PTR io$[rsp]
	call	?inportw@@YAGG@Z			; inportw
	mov	ecx, DWORD PTR i$1[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR buf$[rsp]
	mov	WORD PTR [rdx+rcx], ax

; 281  :     }

	jmp	SHORT $LN2@ata_read_2
$LN1@ata_read_2:

; 282  : 	
; 283  : 	
; 284  : 	ide_400ns_delay(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_400ns_delay@@YAXG@Z		; ide_400ns_delay

; 285  : 	//ide_wait_irq ();
; 286  : 	return 0;

	xor	al, al
$LN11@ata_read_2:

; 287  : }

	add	rsp, 72					; 00000048H
	ret	0
?ata_read_28@@YAEIGPEAE@Z ENDP				; ata_read_28
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
?ata_initialize@@YAXXZ PROC				; ata_initialize

; 489  : void ata_initialize (){

$LN3:
	sub	rsp, 40					; 00000028H

; 490  : 
; 491  : 	interrupt_set(35, ide_primary_irq, 14);

	mov	r8b, 14
	lea	rdx, OFFSET FLAT:?ide_primary_irq@@YAX_KPEAX@Z ; ide_primary_irq
	mov	ecx, 35					; 00000023H
	call	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z	; interrupt_set

; 492  : 
; 493  : 	interrupt_set(36, ide_secondary_irq,15);

	mov	r8b, 15
	lea	rdx, OFFSET FLAT:?ide_secondary_irq@@YAX_KPEAX@Z ; ide_secondary_irq
	mov	ecx, 36					; 00000024H
	call	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z	; interrupt_set

; 494  : 
; 495  : 	ata_probe ();

	call	?ata_probe@@YAXXZ			; ata_probe

; 496  : }

	add	rsp, 40					; 00000028H
	ret	0
?ata_initialize@@YAXXZ ENDP				; ata_initialize
_TEXT	ENDS
END
