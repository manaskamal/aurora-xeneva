; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ata_pm@@3EA					; ata_pm
PUBLIC	?ide_buf@@3PAEA					; ide_buf
PUBLIC	?ata_drive@@3EA					; ata_drive
PUBLIC	?ata_slave_drive@@3EA				; ata_slave_drive
PUBLIC	?ata_device_name@@3PADA				; ata_device_name
PUBLIC	?ide_irq_invoked@@3IA				; ide_irq_invoked
_BSS	SEGMENT
?ata_pm@@3EA DB	01H DUP (?)				; ata_pm
	ALIGN	4

?ide_buf@@3PAEA DB 0200H DUP (?)			; ide_buf
?ata_drive@@3EA DB 01H DUP (?)				; ata_drive
	ALIGN	4

?ata_slave_drive@@3EA DB 01H DUP (?)			; ata_slave_drive
	ALIGN	4

?ata_device_name@@3PADA DB 028H DUP (?)			; ata_device_name
?ide_irq_invoked@@3IA DD 01H DUP (?)			; ide_irq_invoked
_BSS	ENDS
CONST	SEGMENT
$SG3341	DB	'master ', 00H
$SG3342	DB	'slave', 00H
	ORG $+2
$SG3343	DB	'primary', 00H
$SG3344	DB	'secondary', 00H
	ORG $+6
$SG3345	DB	'ATA: %s s has error. disabled, ', 0aH, 00H
	ORG $+7
$SG3375	DB	'[ATA]: error!, device failure!', 0aH, 00H
$SG3416	DB	'[ATA]: Read28 -- no selected io & drive', 0aH, 00H
	ORG $+7
$SG3504	DB	'[ATA]: Primary-Master Device: %s', 0aH, 00H
	ORG $+6
$SG3506	DB	'[ATA]: Primary-Master Device Size -> %d GB', 0aH, 00H
	ORG $+4
$SG3512	DB	'[ATA]: Primary-Slave Device: %s', 0aH, 00H
	ORG $+7
$SG3520	DB	'******************************************', 0aH, 00H
	ORG $+4
$SG3521	DB	'System error!!!!', 0aH, 00H
	ORG $+6
$SG3522	DB	'Xeneva initialization failed', 0aH, 00H
	ORG $+2
$SG3523	DB	'Storage IDE mode error, halting system', 0aH, 00H
$SG3524	DB	'******************************************', 0aH, 00H
CONST	ENDS
PUBLIC	?ata_initialize@@YAXXZ				; ata_initialize
PUBLIC	?ata_read_28@@YAEIGPEAE@Z			; ata_read_28
PUBLIC	?ata_write_one@@YAEPEAEI@Z			; ata_write_one
PUBLIC	?ata_slave_read_28@@YAEIGPEAE@Z			; ata_slave_read_28
PUBLIC	?ata_slave_write_one@@YAEPEAEI@Z		; ata_slave_write_one
PUBLIC	?ide_select_drive@@YAXEE@Z			; ide_select_drive
PUBLIC	?ide_primary_irq@@YAX_KPEAX@Z			; ide_primary_irq
PUBLIC	?ide_secondary_irq@@YAX_KPEAX@Z			; ide_secondary_irq
PUBLIC	?ide_wait_irq@@YAXXZ				; ide_wait_irq
PUBLIC	?ide_identify@@YA_NEE@Z				; ide_identify
PUBLIC	?ide_400ns_delay@@YAXG@Z			; ide_400ns_delay
PUBLIC	?ide_poll@@YAXG@Z				; ide_poll
PUBLIC	?ata_read_48@@YAX_KGPEAE@Z			; ata_read_48
PUBLIC	?ata_probe@@YAXXZ				; ata_probe
EXTRN	x64_cli:PROC
EXTRN	x64_sti:PROC
EXTRN	x64_outportw:PROC
EXTRN	inportb:PROC
EXTRN	inportw:PROC
EXTRN	outportb:PROC
EXTRN	AuInterruptEnd:PROC
EXTRN	AuInterruptSet:PROC
EXTRN	memset:PROC
EXTRN	printf:PROC
EXTRN	pci_find_device_class:PROC
EXTRN	pci_enable_bus_master:PROC
EXTRN	?debug_print@@YAXPEBDZZ:PROC			; debug_print
pdata	SEGMENT
$pdata$?ata_initialize@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+196
	DD	imagerel $unwind$?ata_initialize@@YAXXZ
$pdata$?ata_read_28@@YAEIGPEAE@Z DD imagerel $LN15
	DD	imagerel $LN15+455
	DD	imagerel $unwind$?ata_read_28@@YAEIGPEAE@Z
$pdata$?ata_write_one@@YAEPEAEI@Z DD imagerel $LN15
	DD	imagerel $LN15+457
	DD	imagerel $unwind$?ata_write_one@@YAEPEAEI@Z
$pdata$?ata_slave_read_28@@YAEIGPEAE@Z DD imagerel $LN15
	DD	imagerel $LN15+443
	DD	imagerel $unwind$?ata_slave_read_28@@YAEIGPEAE@Z
$pdata$?ata_slave_write_one@@YAEPEAEI@Z DD imagerel $LN15
	DD	imagerel $LN15+457
	DD	imagerel $unwind$?ata_slave_write_one@@YAEPEAEI@Z
$pdata$?ide_select_drive@@YAXEE@Z DD imagerel $LN9
	DD	imagerel $LN9+94
	DD	imagerel $unwind$?ide_select_drive@@YAXEE@Z
$pdata$?ata_wait_busy@@YAXG@Z DD imagerel ?ata_wait_busy@@YAXG@Z
	DD	imagerel ?ata_wait_busy@@YAXG@Z+44
	DD	imagerel $unwind$?ata_wait_busy@@YAXG@Z
$pdata$?ata_wait_drq@@YAXG@Z DD imagerel ?ata_wait_drq@@YAXG@Z
	DD	imagerel ?ata_wait_drq@@YAXG@Z+42
	DD	imagerel $unwind$?ata_wait_drq@@YAXG@Z
$pdata$?reset_ata_controller@@YAXG@Z DD imagerel ?reset_ata_controller@@YAXG@Z
	DD	imagerel ?reset_ata_controller@@YAXG@Z+131
	DD	imagerel $unwind$?reset_ata_controller@@YAXG@Z
$pdata$?ide_primary_irq@@YAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$?ide_primary_irq@@YAX_KPEAX@Z
$pdata$?ide_secondary_irq@@YAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?ide_secondary_irq@@YAX_KPEAX@Z
$pdata$?ide_identify@@YA_NEE@Z DD imagerel $LN19
	DD	imagerel $LN19+433
	DD	imagerel $unwind$?ide_identify@@YA_NEE@Z
$pdata$?ide_400ns_delay@@YAXG@Z DD imagerel $LN6
	DD	imagerel $LN6+63
	DD	imagerel $unwind$?ide_400ns_delay@@YAXG@Z
$pdata$?ide_poll@@YAXG@Z DD imagerel $LN9
	DD	imagerel $LN9+153
	DD	imagerel $unwind$?ide_poll@@YAXG@Z
$pdata$?ata_read_48@@YAX_KGPEAE@Z DD imagerel $LN15
	DD	imagerel $LN15+548
	DD	imagerel $unwind$?ata_read_48@@YAX_KGPEAE@Z
$pdata$?ata_probe@@YAXXZ DD imagerel $LN11
	DD	imagerel $LN11+407
	DD	imagerel $unwind$?ata_probe@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?ata_initialize@@YAXXZ DD 020701H
	DD	0290107H
$unwind$?ata_read_28@@YAEIGPEAE@Z DD 011201H
	DD	08212H
$unwind$?ata_write_one@@YAEPEAEI@Z DD 010d01H
	DD	0820dH
$unwind$?ata_slave_read_28@@YAEIGPEAE@Z DD 011201H
	DD	08212H
$unwind$?ata_slave_write_one@@YAEPEAEI@Z DD 010d01H
	DD	0820dH
$unwind$?ide_select_drive@@YAXEE@Z DD 010c01H
	DD	0420cH
$unwind$?ata_wait_busy@@YAXG@Z DD 010901H
	DD	04209H
$unwind$?ata_wait_drq@@YAXG@Z DD 010901H
	DD	04209H
$unwind$?reset_ata_controller@@YAXG@Z DD 010901H
	DD	06209H
$unwind$?ide_primary_irq@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?ide_secondary_irq@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?ide_identify@@YA_NEE@Z DD 010c01H
	DD	0820cH
$unwind$?ide_400ns_delay@@YAXG@Z DD 010901H
	DD	06209H
$unwind$?ide_poll@@YAXG@Z DD 010901H
	DD	06209H
$unwind$?ata_read_48@@YAX_KGPEAE@Z DD 011301H
	DD	06213H
$unwind$?ata_probe@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
?ata_probe@@YAXXZ PROC					; ata_probe

; 466  : {

$LN11:
	sub	rsp, 56					; 00000038H

; 467  : 	if (ide_identify (ATA_PRIMARY, ATA_MASTER))

	xor	edx, edx
	xor	ecx, ecx
	call	?ide_identify@@YA_NEE@Z			; ide_identify
	movzx	eax, al
	test	eax, eax
	je	$LN8@ata_probe

; 468  : 	{
; 469  : 		ata_pm = 1;

	mov	BYTE PTR ?ata_pm@@3EA, 1		; ata_pm

; 470  : 		memset (ata_device_name, 0, 40);

	mov	r8d, 40					; 00000028H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?ata_device_name@@3PADA ; ata_device_name
	call	memset

; 471  : 		for (int i= 0; i < 40; i += 2)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN7@ata_probe
$LN6@ata_probe:
	mov	eax, DWORD PTR i$1[rsp]
	add	eax, 2
	mov	DWORD PTR i$1[rsp], eax
$LN7@ata_probe:
	cmp	DWORD PTR i$1[rsp], 40			; 00000028H
	jge	SHORT $LN5@ata_probe

; 472  : 		{
; 473  : 			ata_device_name[i] = ide_buf[ATA_IDENT_MODEL + i + 1];

	mov	eax, DWORD PTR i$1[rsp]
	add	eax, 55					; 00000037H
	cdqe
	lea	rcx, OFFSET FLAT:?ide_buf@@3PAEA	; ide_buf
	movsxd	rdx, DWORD PTR i$1[rsp]
	lea	r8, OFFSET FLAT:?ata_device_name@@3PADA	; ata_device_name
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al

; 474  : 			ata_device_name[i + 1] = ide_buf[ATA_IDENT_MODEL + i];

	mov	eax, DWORD PTR i$1[rsp]
	add	eax, 54					; 00000036H
	cdqe
	lea	rcx, OFFSET FLAT:?ide_buf@@3PAEA	; ide_buf
	mov	edx, DWORD PTR i$1[rsp]
	inc	edx
	movsxd	rdx, edx
	lea	r8, OFFSET FLAT:?ata_device_name@@3PADA	; ata_device_name
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al

; 475  : 		}

	jmp	SHORT $LN6@ata_probe
$LN5@ata_probe:

; 476  : 
; 477  : 		printf("[ATA]: Primary-Master Device: %s\n", ata_device_name);

	lea	rdx, OFFSET FLAT:?ata_device_name@@3PADA ; ata_device_name
	lea	rcx, OFFSET FLAT:$SG3504
	call	printf

; 478  : 		printf("[ATA]: Primary-Master Device Size -> %d GB\n", *((unsigned int*)(ide_buf + 200)) / 1024 / 1024 / 1024);

	xor	edx, edx
	mov	eax, DWORD PTR ?ide_buf@@3PAEA+200
	mov	ecx, 1024				; 00000400H
	div	ecx
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	ecx
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	ecx
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3506
	call	printf

; 479  : 		ata_drive = (ATA_PRIMARY << 1) | ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive
$LN8@ata_probe:

; 480  : 	}
; 481  : 
; 482  : 	if (ide_identify (ATA_PRIMARY, ATA_SLAVE)) {

	mov	dl, 1
	xor	ecx, ecx
	call	?ide_identify@@YA_NEE@Z			; ide_identify
	movzx	eax, al
	test	eax, eax
	je	$LN4@ata_probe

; 483  : 		//ata_pm = 1;
; 484  : 		memset (ata_device_name, 0, 40);

	mov	r8d, 40					; 00000028H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?ata_device_name@@3PADA ; ata_device_name
	call	memset

; 485  : 		for (int i= 0; i < 40; i += 2)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@ata_probe
$LN2@ata_probe:
	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 2
	mov	DWORD PTR i$2[rsp], eax
$LN3@ata_probe:
	cmp	DWORD PTR i$2[rsp], 40			; 00000028H
	jge	SHORT $LN1@ata_probe

; 486  : 		{
; 487  : 			ata_device_name[i] = ide_buf[ATA_IDENT_MODEL + i + 1];

	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 55					; 00000037H
	cdqe
	lea	rcx, OFFSET FLAT:?ide_buf@@3PAEA	; ide_buf
	movsxd	rdx, DWORD PTR i$2[rsp]
	lea	r8, OFFSET FLAT:?ata_device_name@@3PADA	; ata_device_name
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al

; 488  : 			ata_device_name[i + 1] = ide_buf[ATA_IDENT_MODEL + i];

	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 54					; 00000036H
	cdqe
	lea	rcx, OFFSET FLAT:?ide_buf@@3PAEA	; ide_buf
	mov	edx, DWORD PTR i$2[rsp]
	inc	edx
	movsxd	rdx, edx
	lea	r8, OFFSET FLAT:?ata_device_name@@3PADA	; ata_device_name
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al

; 489  : 		}

	jmp	SHORT $LN2@ata_probe
$LN1@ata_probe:

; 490  : 
; 491  : 		ata_slave_drive = (ATA_PRIMARY << 1) | ATA_SLAVE;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 1	; ata_slave_drive

; 492  : 		printf("[ATA]: Primary-Slave Device: %s\n", ata_device_name);

	lea	rdx, OFFSET FLAT:?ata_device_name@@3PADA ; ata_device_name
	lea	rcx, OFFSET FLAT:$SG3512
	call	printf
$LN4@ata_probe:

; 493  : 	}
; 494  : }

	add	rsp, 56					; 00000038H
	ret	0
?ata_probe@@YAXXZ ENDP					; ata_probe
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
i$ = 32
cmd$ = 33
io$ = 36
tv65 = 40
tv74 = 44
lba$ = 64
sector_count$ = 72
target$ = 80
?ata_read_48@@YAX_KGPEAE@Z PROC				; ata_read_48

; 296  : {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 297  : 
; 298  : 	uint16_t io = 0;

	xor	eax, eax
	mov	WORD PTR io$[rsp], ax

; 299  : 	switch (ata_drive)

	movzx	eax, BYTE PTR ?ata_drive@@3EA		; ata_drive
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 0
	je	SHORT $LN8@ata_read_4
	cmp	BYTE PTR tv65[rsp], 1
	je	SHORT $LN7@ata_read_4
	cmp	BYTE PTR tv65[rsp], 2
	je	SHORT $LN6@ata_read_4
	cmp	BYTE PTR tv65[rsp], 3
	je	SHORT $LN5@ata_read_4
	jmp	SHORT $LN4@ata_read_4
$LN8@ata_read_4:

; 300  : 	{
; 301  : 	case (ATA_PRIMARY << 1 |  ATA_MASTER):
; 302  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 303  : 		ata_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive

; 304  : 		break;

	jmp	SHORT $LN9@ata_read_4
$LN7@ata_read_4:

; 305  : 	case (ATA_PRIMARY << 1 | ATA_SLAVE):
; 306  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 307  : 		ata_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_drive@@3EA, 1		; ata_drive

; 308  : 		break;

	jmp	SHORT $LN9@ata_read_4
$LN6@ata_read_4:

; 309  : 	case (ATA_SECONDARY << 1 | ATA_MASTER):
; 310  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 311  : 		ata_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive

; 312  : 		break;

	jmp	SHORT $LN9@ata_read_4
$LN5@ata_read_4:

; 313  : 	case (ATA_SECONDARY << 1 | ATA_SLAVE):
; 314  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 315  : 		ata_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_drive@@3EA, 1		; ata_drive

; 316  : 		break;

	jmp	SHORT $LN9@ata_read_4
$LN4@ata_read_4:

; 317  : 	default:
; 318  : 		return;

	jmp	$LN11@ata_read_4
$LN9@ata_read_4:

; 319  : 	}
; 320  : 
; 321  : 	uint8_t cmd = (ata_drive == ATA_MASTER ? 0x40 : 0x50);

	movzx	eax, BYTE PTR ?ata_drive@@3EA		; ata_drive
	test	eax, eax
	jne	SHORT $LN13@ata_read_4
	mov	DWORD PTR tv74[rsp], 64			; 00000040H
	jmp	SHORT $LN14@ata_read_4
$LN13@ata_read_4:
	mov	DWORD PTR tv74[rsp], 80			; 00000050H
$LN14@ata_read_4:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR cmd$[rsp], al

; 322  : 
; 323  : 	outportb (io + ATA_REG_HDDEVSEL, cmd);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 6
	movzx	edx, BYTE PTR cmd$[rsp]
	movzx	ecx, ax
	call	outportb

; 324  : 	outportb (io + ATA_REG_SECCOUNT0, (sector_count >> 8) & 0xFF);

	movzx	eax, WORD PTR sector_count$[rsp]
	sar	eax, 8
	and	eax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 2
	movzx	edx, al
	call	outportb

; 325  : 	outportb (io + ATA_REG_LBA0, (lba >> 24) & 0xFF);

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 3
	movzx	edx, al
	call	outportb

; 326  : 	outportb (io + ATA_REG_LBA1, (lba >> 32) & 0xFF);

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 32					; 00000020H
	and	rax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 4
	movzx	edx, al
	call	outportb

; 327  : 	outportb (io + ATA_REG_LBA2, (lba >> 40) & 0xFF);

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 40					; 00000028H
	and	rax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 5
	movzx	edx, al
	call	outportb

; 328  : 	outportb (io + ATA_REG_SECCOUNT0, sector_count & 0xFF);

	movzx	eax, WORD PTR sector_count$[rsp]
	and	eax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 2
	movzx	edx, al
	call	outportb

; 329  : 	outportb (io + ATA_REG_LBA0, lba & 0xFF);

	mov	rax, QWORD PTR lba$[rsp]
	and	rax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 3
	movzx	edx, al
	call	outportb

; 330  : 	outportb (io + ATA_REG_LBA1, (lba >> 8) & 0xFF);

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 8
	and	rax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 4
	movzx	edx, al
	call	outportb

; 331  : 	outportb (io + ATA_REG_LBA2, (lba >> 16) & 0xFF);

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 5
	movzx	edx, al
	call	outportb

; 332  : 	outportb (io + ATA_REG_STATUS, ATA_CMD_READ_PIO_EXT);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	mov	dl, 36					; 00000024H
	movzx	ecx, ax
	call	outportb

; 333  : 	
; 334  : 
; 335  : 	ide_poll(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_poll@@YAXG@Z			; ide_poll

; 336  : 	uint8_t i;
; 337  : 	for (i = 0; i < 256; i++)

	mov	BYTE PTR i$[rsp], 0
	jmp	SHORT $LN3@ata_read_4
$LN2@ata_read_4:
	movzx	eax, BYTE PTR i$[rsp]
	inc	al
	mov	BYTE PTR i$[rsp], al
$LN3@ata_read_4:
	movzx	eax, BYTE PTR i$[rsp]
	cmp	eax, 256				; 00000100H
	jge	SHORT $LN1@ata_read_4

; 338  : 	{
; 339  : 
; 340  : 		 *(uint16_t*)(target + i * 2) = inportw (io + ATA_REG_DATA);

	movzx	ecx, WORD PTR io$[rsp]
	call	inportw
	movzx	ecx, BYTE PTR i$[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR target$[rsp]
	mov	WORD PTR [rdx+rcx], ax

; 341  : 		
; 342  : 	}

	jmp	SHORT $LN2@ata_read_4
$LN1@ata_read_4:

; 343  :     
; 344  : 	ide_400ns_delay(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_400ns_delay@@YAXG@Z		; ide_400ns_delay
$LN11@ata_read_4:

; 345  : 	//kprintf("\nData 48 bit read");
; 346  : }

	add	rsp, 56					; 00000038H
	ret	0
?ata_read_48@@YAX_KGPEAE@Z ENDP				; ata_read_48
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
status$ = 32
i$1 = 36
io$ = 64
?ide_poll@@YAXG@Z PROC					; ide_poll

; 145  : {

$LN9:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 146  : 	for (int i = 0; i < 4; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@ide_poll
$LN5@ide_poll:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@ide_poll:
	cmp	DWORD PTR i$1[rsp], 4
	jge	SHORT $LN4@ide_poll

; 147  : 	{
; 148  : 		inportb (io + ATA_REG_STATUS);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	inportb

; 149  : 	}

	jmp	SHORT $LN5@ide_poll
$LN4@ide_poll:
$retry$10:

; 150  : retry:
; 151  : 	uint8_t status = inportb (io + ATA_REG_STATUS);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	inportb
	mov	BYTE PTR status$[rsp], al

; 152  : 
; 153  : 	if (status & ATA_SR_BSY)

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN3@ide_poll

; 154  : 	{
; 155  : 		//kprintf ("\n ATA status busy");
; 156  : 		goto retry;

	jmp	SHORT $retry$10
$LN3@ide_poll:
$retry2$11:

; 157  : 	}
; 158  : 
; 159  : retry2:
; 160  : 	status = inportb (io + ATA_REG_STATUS);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	inportb
	mov	BYTE PTR status$[rsp], al

; 161  : 	if (status & ATA_SR_ERR)

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@ide_poll

; 162  : 	{
; 163  : 		printf("[ATA]: error!, device failure!\n");

	lea	rcx, OFFSET FLAT:$SG3375
	call	printf
$LN2@ide_poll:

; 164  : 	}
; 165  : 
; 166  : 	if (! (status & ATA_SR_DRQ))

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN1@ide_poll

; 167  : 	{
; 168  : 		//printf ("[ATA]: Status, drq");
; 169  : 		goto retry2;

	jmp	SHORT $retry2$11
$LN1@ide_poll:

; 170  : 	}
; 171  : 
; 172  : 	return;
; 173  : }

	add	rsp, 56					; 00000038H
	ret	0
?ide_poll@@YAXG@Z ENDP					; ide_poll
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
data$1 = 32
i$2 = 36
io$ = 64
?ide_400ns_delay@@YAXG@Z PROC				; ide_400ns_delay

; 136  : {

$LN6:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 137  : 	
; 138  : 	for (int i = 0; i < 40; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@ide_400ns_
$LN2@ide_400ns_:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@ide_400ns_:
	cmp	DWORD PTR i$2[rsp], 40			; 00000028H
	jge	SHORT $LN1@ide_400ns_

; 139  : 	{
; 140  : 		uint8_t data = inportb(io + ATA_REG_ALTSTATUS);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 12
	movzx	ecx, ax
	call	inportb
	mov	BYTE PTR data$1[rsp], al

; 141  : 	}

	jmp	SHORT $LN2@ide_400ns_
$LN1@ide_400ns_:

; 142  : }

	add	rsp, 56					; 00000038H
	ret	0
?ide_400ns_delay@@YAXG@Z ENDP				; ide_400ns_delay
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
status$ = 32
io$ = 36
i$1 = 40
tv68 = 44
tv152 = 48
tv156 = 56
bus$ = 80
drive$ = 88
?ide_identify@@YA_NEE@Z PROC				; ide_identify

; 89   : {

$LN19:
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 72					; 00000048H

; 90   : 	ide_select_drive (bus, drive);

	movzx	edx, BYTE PTR drive$[rsp]
	movzx	ecx, BYTE PTR bus$[rsp]
	call	?ide_select_drive@@YAXEE@Z		; ide_select_drive

; 91   : 
; 92   : 	uint16_t  io = bus == ATA_PRIMARY ? ATA_PRIMARY_IO : ATA_SECONDARY_IO;

	movzx	eax, BYTE PTR bus$[rsp]
	test	eax, eax
	jne	SHORT $LN13@ide_identi
	mov	DWORD PTR tv68[rsp], 496		; 000001f0H
	jmp	SHORT $LN14@ide_identi
$LN13@ide_identi:
	mov	DWORD PTR tv68[rsp], 368		; 00000170H
$LN14@ide_identi:
	movzx	eax, WORD PTR tv68[rsp]
	mov	WORD PTR io$[rsp], ax

; 93   : 
; 94   : 	outportb(io + ATA_REG_SECCOUNT0, 0);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 2
	xor	edx, edx
	movzx	ecx, ax
	call	outportb

; 95   : 	outportb(io + ATA_REG_LBA0, 0);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 3
	xor	edx, edx
	movzx	ecx, ax
	call	outportb

; 96   : 	outportb(io + ATA_REG_LBA1, 0);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 4
	xor	edx, edx
	movzx	ecx, ax
	call	outportb

; 97   : 	outportb(io + ATA_REG_LBA2, 0);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 5
	xor	edx, edx
	movzx	ecx, ax
	call	outportb

; 98   : 
; 99   : 	// now send identify
; 100  : 	outportb(io + ATA_REG_COMMAND, ATA_CMD_IDENTIFY);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	mov	dl, 236					; 000000ecH
	movzx	ecx, ax
	call	outportb

; 101  : 
; 102  : 	//! read status port
; 103  : 	uint8_t status = inportb (io + ATA_REG_STATUS );

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	inportb
	mov	BYTE PTR status$[rsp], al

; 104  : 	if (status)

	movzx	eax, BYTE PTR status$[rsp]
	test	eax, eax
	je	$LN10@ide_identi
$LN9@ide_identi:

; 105  : 	{
; 106  : 		while ((inportb(io + ATA_REG_STATUS) & ATA_SR_BSY) != 0);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	inportb
	movzx	eax, al
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN8@ide_identi
	jmp	SHORT $LN9@ide_identi
$LN8@ide_identi:
$pm_stat_read$20:

; 107  : pm_stat_read:
; 108  : 		status = inportb (io + ATA_REG_STATUS);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	inportb
	mov	BYTE PTR status$[rsp], al

; 109  : 		if (status & ATA_SR_ERR)

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@ide_identi

; 110  : 		{
; 111  : 			printf("ATA: %s s has error. disabled, \n", bus == ATA_PRIMARY ? "primary" : "secondary", 
; 112  : 				drive == ATA_PRIMARY ? "master " : "slave");

	movzx	eax, BYTE PTR drive$[rsp]
	test	eax, eax
	jne	SHORT $LN15@ide_identi
	lea	rax, OFFSET FLAT:$SG3341
	mov	QWORD PTR tv152[rsp], rax
	jmp	SHORT $LN16@ide_identi
$LN15@ide_identi:
	lea	rax, OFFSET FLAT:$SG3342
	mov	QWORD PTR tv152[rsp], rax
$LN16@ide_identi:
	movzx	eax, BYTE PTR bus$[rsp]
	test	eax, eax
	jne	SHORT $LN17@ide_identi
	lea	rax, OFFSET FLAT:$SG3343
	mov	QWORD PTR tv156[rsp], rax
	jmp	SHORT $LN18@ide_identi
$LN17@ide_identi:
	lea	rax, OFFSET FLAT:$SG3344
	mov	QWORD PTR tv156[rsp], rax
$LN18@ide_identi:
	mov	r8, QWORD PTR tv152[rsp]
	mov	rdx, QWORD PTR tv156[rsp]
	lea	rcx, OFFSET FLAT:$SG3345
	call	printf
$LN7@ide_identi:
$LN6@ide_identi:

; 113  : 			//return false;
; 114  : 		}
; 115  : 
; 116  : 		while (! (status & ATA_SR_DRQ))

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN5@ide_identi

; 117  : 		{
; 118  : 			goto pm_stat_read;

	jmp	$pm_stat_read$20

; 119  : 		}

	jmp	SHORT $LN6@ide_identi
$LN5@ide_identi:

; 120  : 
; 121  : 		for (int i = 0; i < 256;i++ )

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@ide_identi
$LN3@ide_identi:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ide_identi:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN2@ide_identi

; 122  : 		{
; 123  : 			*(uint16_t *) (ide_buf + i*2) = inportw(io + ATA_REG_DATA);

	movzx	ecx, WORD PTR io$[rsp]
	call	inportw
	mov	ecx, DWORD PTR i$1[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	lea	rdx, OFFSET FLAT:?ide_buf@@3PAEA	; ide_buf
	mov	WORD PTR [rdx+rcx], ax

; 124  : 			//("\n%x %x", *(uint16_t*) (ide_buf + i * 2) >> 8, *(uint16_t *)(ide_buf + i * 2) & 0xFF);
; 125  : 		}

	jmp	SHORT $LN3@ide_identi
$LN2@ide_identi:

; 126  : 		return true;

	mov	al, 1
	jmp	SHORT $LN11@ide_identi
$LN10@ide_identi:

; 127  : 	}
; 128  : 	else
; 129  : 	{
; 130  : 		//printf("ATA: Status 0\n");
; 131  : 	}
; 132  : 	return false;

	xor	al, al
$LN11@ide_identi:

; 133  : }

	add	rsp, 72					; 00000048H
	ret	0
?ide_identify@@YA_NEE@Z ENDP				; ide_identify
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
?ide_wait_irq@@YAXXZ PROC				; ide_wait_irq

; 82   : void ide_wait_irq () {

	npad	2
$LN2@ide_wait_i:

; 83   : 	while (!ide_irq_invoked)

	cmp	DWORD PTR ?ide_irq_invoked@@3IA, 0	; ide_irq_invoked
	jne	SHORT $LN1@ide_wait_i

; 84   : 		;

	jmp	SHORT $LN2@ide_wait_i
$LN1@ide_wait_i:

; 85   : 	ide_irq_invoked = 0;

	mov	DWORD PTR ?ide_irq_invoked@@3IA, 0	; ide_irq_invoked

; 86   : }

	ret	0
?ide_wait_irq@@YAXXZ ENDP				; ide_wait_irq
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
vector$ = 48
param$ = 56
?ide_secondary_irq@@YAX_KPEAX@Z PROC			; ide_secondary_irq

; 77   : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 78   : 	reset_ata_controller (ATA_SECONDARY_IO);

	mov	cx, 368					; 00000170H
	call	?reset_ata_controller@@YAXG@Z		; reset_ata_controller

; 79   : 	AuInterruptEnd(15);

	mov	ecx, 15
	call	AuInterruptEnd

; 80   : }

	add	rsp, 40					; 00000028H
	ret	0
?ide_secondary_irq@@YAX_KPEAX@Z ENDP			; ide_secondary_irq
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
vector$ = 48
param$ = 56
?ide_primary_irq@@YAX_KPEAX@Z PROC			; ide_primary_irq

; 71   : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 72   : 	ide_irq_invoked = 1;

	mov	DWORD PTR ?ide_irq_invoked@@3IA, 1	; ide_irq_invoked

; 73   : 	AuInterruptEnd(14);

	mov	ecx, 14
	call	AuInterruptEnd

; 74   : }

	add	rsp, 40					; 00000028H
	ret	0
?ide_primary_irq@@YAX_KPEAX@Z ENDP			; ide_primary_irq
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
i$1 = 32
j$2 = 36
io$ = 64
?reset_ata_controller@@YAXG@Z PROC			; reset_ata_controller

; 51   : {

	mov	WORD PTR [rsp+8], cx
	sub	rsp, 56					; 00000038H

; 52   : 
; 53   : 	outportb (io + ATA_REG_CONTROL, 0x04);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 12
	mov	dl, 4
	movzx	ecx, ax
	call	outportb

; 54   : 	for (int i=0; i<20; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@reset_ata_
$LN5@reset_ata_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@reset_ata_:
	cmp	DWORD PTR i$1[rsp], 20
	jge	SHORT $LN4@reset_ata_

; 55   : 		;

	jmp	SHORT $LN5@reset_ata_
$LN4@reset_ata_:

; 56   : 
; 57   : 	ata_wait_busy(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 58   : 
; 59   : 	outportb (io + ATA_REG_CONTROL, 0);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 12
	xor	edx, edx
	movzx	ecx, ax
	call	outportb

; 60   : 
; 61   : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 62   : 
; 63   : 	for (int j = 0; j < 30000000; j++)

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN3@reset_ata_
$LN2@reset_ata_:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN3@reset_ata_:
	cmp	DWORD PTR j$2[rsp], 30000000		; 01c9c380H
	jge	SHORT $LN1@reset_ata_

; 64   : 		;

	jmp	SHORT $LN2@reset_ata_
$LN1@reset_ata_:

; 65   : 
; 66   : }

	add	rsp, 56					; 00000038H
	ret	0
?reset_ata_controller@@YAXG@Z ENDP			; reset_ata_controller
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
io$ = 48
?ata_wait_drq@@YAXG@Z PROC				; ata_wait_drq

; 45   : {

	mov	WORD PTR [rsp+8], cx
	sub	rsp, 40					; 00000028H
$LN2@ata_wait_d:

; 46   : 	while (!(inportb (io + ATA_REG_STATUS) & STATUS_RDY))

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	inportb
	movzx	eax, al
	and	eax, 64					; 00000040H
	test	eax, eax
	jne	SHORT $LN1@ata_wait_d

; 47   : 		;

	jmp	SHORT $LN2@ata_wait_d
$LN1@ata_wait_d:

; 48   : }

	add	rsp, 40					; 00000028H
	ret	0
?ata_wait_drq@@YAXG@Z ENDP				; ata_wait_drq
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
io$ = 48
?ata_wait_busy@@YAXG@Z PROC				; ata_wait_busy

; 39   : {

	mov	WORD PTR [rsp+8], cx
	sub	rsp, 40					; 00000028H
$LN2@ata_wait_b:

; 40   : 	while (inportb(io + ATA_REG_STATUS) & STATUS_BSY)

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	movzx	ecx, ax
	call	inportb
	movzx	eax, al
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $LN1@ata_wait_b

; 41   : 		;

	jmp	SHORT $LN2@ata_wait_b
$LN1@ata_wait_b:

; 42   : }

	add	rsp, 40					; 00000028H
	ret	0
?ata_wait_busy@@YAXG@Z ENDP				; ata_wait_busy
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
bus$ = 48
i$ = 56
?ide_select_drive@@YAXEE@Z PROC				; ide_select_drive

; 24   : {

$LN9:
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 40					; 00000028H

; 25   : 	if (bus == ATA_PRIMARY )

	movzx	eax, BYTE PTR bus$[rsp]
	test	eax, eax
	jne	SHORT $LN6@ide_select

; 26   : 		if (i == ATA_MASTER)

	movzx	eax, BYTE PTR i$[rsp]
	test	eax, eax
	jne	SHORT $LN5@ide_select

; 27   : 			outportb(ATA_PRIMARY_IO + ATA_REG_HDDEVSEL, 0xA0);

	mov	dl, 160					; 000000a0H
	mov	cx, 502					; 000001f6H
	call	outportb

; 28   : 		else

	jmp	SHORT $LN4@ide_select
$LN5@ide_select:

; 29   : 			outportb(ATA_PRIMARY_IO + ATA_REG_HDDEVSEL, 0xB0);

	mov	dl, 176					; 000000b0H
	mov	cx, 502					; 000001f6H
	call	outportb
$LN4@ide_select:

; 30   : 	else

	jmp	SHORT $LN3@ide_select
$LN6@ide_select:

; 31   : 		if (i == ATA_MASTER)

	movzx	eax, BYTE PTR i$[rsp]
	test	eax, eax
	jne	SHORT $LN2@ide_select

; 32   : 			outportb(ATA_SECONDARY_IO + ATA_REG_HDDEVSEL, 0xA0);

	mov	dl, 160					; 000000a0H
	mov	cx, 374					; 00000176H
	call	outportb

; 33   : 		else

	jmp	SHORT $LN1@ide_select
$LN2@ide_select:

; 34   : 			outportb(ATA_SECONDARY_IO + ATA_REG_HDDEVSEL, 0xB0);

	mov	dl, 176					; 000000b0H
	mov	cx, 374					; 00000176H
	call	outportb
$LN1@ide_select:
$LN3@ide_select:

; 35   : }

	add	rsp, 40					; 00000028H
	ret	0
?ide_select_drive@@YAXEE@Z ENDP				; ide_select_drive
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
cmd$ = 32
io$ = 36
tv65 = 40
i$1 = 44
tv74 = 48
buf$ = 80
lba$ = 88
?ata_slave_write_one@@YAEPEAEI@Z PROC			; ata_slave_write_one

; 408  : {

$LN15:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 409  : 	uint16_t io = 0;

	xor	eax, eax
	mov	WORD PTR io$[rsp], ax

; 410  : 	switch (ata_slave_drive)

	movzx	eax, BYTE PTR ?ata_slave_drive@@3EA	; ata_slave_drive
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 0
	je	SHORT $LN8@ata_slave_
	cmp	BYTE PTR tv65[rsp], 1
	je	SHORT $LN7@ata_slave_
	cmp	BYTE PTR tv65[rsp], 2
	je	SHORT $LN6@ata_slave_
	cmp	BYTE PTR tv65[rsp], 3
	je	SHORT $LN5@ata_slave_
	jmp	SHORT $LN4@ata_slave_
$LN8@ata_slave_:

; 411  : 	{
; 412  : 	case (ATA_PRIMARY << 1 | ATA_MASTER):
; 413  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 414  : 		ata_slave_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 0	; ata_slave_drive

; 415  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN7@ata_slave_:

; 416  : 	case (ATA_PRIMARY << 1 | ATA_SLAVE):
; 417  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 418  : 		ata_slave_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 1	; ata_slave_drive

; 419  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN6@ata_slave_:

; 420  : 	case (ATA_SECONDARY << 1 | ATA_MASTER):
; 421  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 422  : 		ata_slave_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 0	; ata_slave_drive

; 423  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN5@ata_slave_:

; 424  : 	case (ATA_SECONDARY << 1 | ATA_SLAVE):
; 425  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 426  : 		ata_slave_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 1	; ata_slave_drive

; 427  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN4@ata_slave_:

; 428  : 	default:
; 429  : 		return 0;

	xor	al, al
	jmp	$LN11@ata_slave_
$LN9@ata_slave_:

; 430  : 	}
; 431  : 
; 432  : 	uint8_t  cmd = (ata_slave_drive == ATA_MASTER ? 0xE0 : 0xF0);

	movzx	eax, BYTE PTR ?ata_slave_drive@@3EA	; ata_slave_drive
	test	eax, eax
	jne	SHORT $LN13@ata_slave_
	mov	DWORD PTR tv74[rsp], 224		; 000000e0H
	jmp	SHORT $LN14@ata_slave_
$LN13@ata_slave_:
	mov	DWORD PTR tv74[rsp], 240		; 000000f0H
$LN14@ata_slave_:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR cmd$[rsp], al

; 433  : 
; 434  : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 435  : 	outportb(io + ATA_REG_HDDEVSEL, (cmd | (uint8_t) ((lba >> 24 & 0xFF))));

	movzx	eax, BYTE PTR cmd$[rsp]
	mov	ecx, DWORD PTR lba$[rsp]
	shr	ecx, 24
	and	ecx, 255				; 000000ffH
	movzx	ecx, cl
	or	eax, ecx
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 6
	movzx	edx, al
	call	outportb

; 436  : 	outportb(io + 1, 0x00);

	movzx	eax, WORD PTR io$[rsp]
	inc	eax
	xor	edx, edx
	movzx	ecx, ax
	call	outportb

; 437  : 
; 438  : 	//! single sector write
; 439  :     outportb(io + ATA_REG_SECCOUNT0, 1);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 2
	mov	dl, 1
	movzx	ecx, ax
	call	outportb

; 440  : 
; 441  : 	//! select LBA
; 442  : 	outportb(io + ATA_REG_LBA0, (uint8_t)((lba)));

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 3
	movzx	edx, BYTE PTR lba$[rsp]
	movzx	ecx, ax
	call	outportb

; 443  : 	outportb(io + ATA_REG_LBA1, (uint8_t)((lba) >> 8));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 8
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 4
	movzx	edx, al
	call	outportb

; 444  : 	outportb(io + ATA_REG_LBA2, (uint8_t)((lba) >> 16));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 16
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 5
	movzx	edx, al
	call	outportb

; 445  : 
; 446  : 	//! select write command
; 447  : 	outportb (io + ATA_REG_COMMAND, ATA_CMD_WRITE_PIO);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	mov	dl, 48					; 00000030H
	movzx	ecx, ax
	call	outportb

; 448  : 
; 449  : 	//! wait until ready
; 450  : 	ide_poll(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_poll@@YAXG@Z			; ide_poll

; 451  : 
; 452  : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 453  : 	ata_wait_drq (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_drq@@YAXG@Z			; ata_wait_drq

; 454  : 	for (int i=0; i < 256; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@ata_slave_
$LN2@ata_slave_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@ata_slave_:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN1@ata_slave_

; 455  : 	{
; 456  : 	
; 457  : 		x64_outportw(io + ATA_REG_DATA, *(uint16_t *)(buf + i * 2));

	mov	eax, DWORD PTR i$1[rsp]
	shl	eax, 1
	cdqe
	mov	rcx, QWORD PTR buf$[rsp]
	movzx	edx, WORD PTR [rcx+rax]
	movzx	ecx, WORD PTR io$[rsp]
	call	x64_outportw

; 458  : 	}

	jmp	SHORT $LN2@ata_slave_
$LN1@ata_slave_:

; 459  : 
; 460  : 	ide_400ns_delay (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_400ns_delay@@YAXG@Z		; ide_400ns_delay

; 461  : 	return 1;

	mov	al, 1
$LN11@ata_slave_:

; 462  : }

	add	rsp, 72					; 00000048H
	ret	0
?ata_slave_write_one@@YAEPEAEI@Z ENDP			; ata_slave_write_one
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
cmd$ = 32
io$ = 36
tv65 = 40
i$1 = 44
tv74 = 48
lba$ = 80
sec_count$ = 88
buf$ = 96
?ata_slave_read_28@@YAEIGPEAE@Z PROC			; ata_slave_read_28

; 349  : {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 350  : 	//! we only support 28 bit LBA so far
; 351  : 	uint16_t io = 0;

	xor	eax, eax
	mov	WORD PTR io$[rsp], ax

; 352  : 	switch (ata_slave_drive)

	movzx	eax, BYTE PTR ?ata_slave_drive@@3EA	; ata_slave_drive
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 0
	je	SHORT $LN8@ata_slave_
	cmp	BYTE PTR tv65[rsp], 1
	je	SHORT $LN7@ata_slave_
	cmp	BYTE PTR tv65[rsp], 2
	je	SHORT $LN6@ata_slave_
	cmp	BYTE PTR tv65[rsp], 3
	je	SHORT $LN5@ata_slave_
	jmp	SHORT $LN4@ata_slave_
$LN8@ata_slave_:

; 353  : 	{
; 354  : 	case (ATA_PRIMARY << 1 |  ATA_MASTER):
; 355  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 356  : 		ata_slave_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 0	; ata_slave_drive

; 357  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN7@ata_slave_:

; 358  : 	case (ATA_PRIMARY << 1 | ATA_SLAVE):
; 359  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 360  : 		ata_slave_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 1	; ata_slave_drive

; 361  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN6@ata_slave_:

; 362  : 	case (ATA_SECONDARY << 1 | ATA_MASTER):
; 363  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 364  : 		ata_slave_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 0	; ata_slave_drive

; 365  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN5@ata_slave_:

; 366  : 	case (ATA_SECONDARY << 1 | ATA_SLAVE):
; 367  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 368  : 		ata_slave_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_slave_drive@@3EA, 1	; ata_slave_drive

; 369  : 		break;

	jmp	SHORT $LN9@ata_slave_
$LN4@ata_slave_:

; 370  : 	default:
; 371  : 		return 0;

	xor	al, al
	jmp	$LN11@ata_slave_
$LN9@ata_slave_:

; 372  : 	}
; 373  : 
; 374  : 	uint8_t cmd = (ata_slave_drive == ATA_MASTER ? 0xE0 : 0xF0);

	movzx	eax, BYTE PTR ?ata_slave_drive@@3EA	; ata_slave_drive
	test	eax, eax
	jne	SHORT $LN13@ata_slave_
	mov	DWORD PTR tv74[rsp], 224		; 000000e0H
	jmp	SHORT $LN14@ata_slave_
$LN13@ata_slave_:
	mov	DWORD PTR tv74[rsp], 240		; 000000f0H
$LN14@ata_slave_:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR cmd$[rsp], al

; 375  : 
; 376  : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 377  : 	
; 378  : 	outportb (io + ATA_REG_HDDEVSEL, (cmd | (uint8_t) ((lba >> 24 & 0x0F))));

	movzx	eax, BYTE PTR cmd$[rsp]
	mov	ecx, DWORD PTR lba$[rsp]
	shr	ecx, 24
	and	ecx, 15
	movzx	ecx, cl
	or	eax, ecx
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 6
	movzx	edx, al
	call	outportb

; 379  : 	outportb (io + 1, 0x00);

	movzx	eax, WORD PTR io$[rsp]
	inc	eax
	xor	edx, edx
	movzx	ecx, ax
	call	outportb

; 380  : 
; 381  : 	//! single sector read
; 382  : 	outportb (io + ATA_REG_SECCOUNT0, sec_count);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 2
	movzx	edx, BYTE PTR sec_count$[rsp]
	movzx	ecx, ax
	call	outportb

; 383  : 
; 384  : 	//! select LBA
; 385  : 	outportb (io + ATA_REG_LBA0, (uint8_t)((lba)));

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 3
	movzx	edx, BYTE PTR lba$[rsp]
	movzx	ecx, ax
	call	outportb

; 386  : 	outportb (io + ATA_REG_LBA1, (uint8_t)((lba) >> 8));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 8
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 4
	movzx	edx, al
	call	outportb

; 387  : 	outportb (io + ATA_REG_LBA2, (uint8_t)((lba) >> 16));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 16
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 5
	movzx	edx, al
	call	outportb

; 388  : 
; 389  : 	//! select read command
; 390  : 	outportb (io + ATA_REG_COMMAND, ATA_CMD_READ_PIO);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	mov	dl, 32					; 00000020H
	movzx	ecx, ax
	call	outportb

; 391  : 
; 392  : 	//! wait untill ready
; 393  : 	ide_poll (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_poll@@YAXG@Z			; ide_poll

; 394  : 	
; 395  : 	for (int i = 0; i < 256; i++ )

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@ata_slave_
$LN2@ata_slave_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@ata_slave_:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN1@ata_slave_

; 396  : 	{
; 397  : 			
; 398  : 	   *(uint16_t*)(buf + i * 2) = inportw (io + ATA_REG_DATA);

	movzx	ecx, WORD PTR io$[rsp]
	call	inportw
	mov	ecx, DWORD PTR i$1[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR buf$[rsp]
	mov	WORD PTR [rdx+rcx], ax

; 399  :     }

	jmp	SHORT $LN2@ata_slave_
$LN1@ata_slave_:

; 400  : 	
; 401  : 	
; 402  : 	ide_400ns_delay(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_400ns_delay@@YAXG@Z		; ide_400ns_delay

; 403  : 	//ide_wait_irq ();
; 404  : 	return 0;

	xor	al, al
$LN11@ata_slave_:

; 405  : }

	add	rsp, 72					; 00000048H
	ret	0
?ata_slave_read_28@@YAEIGPEAE@Z ENDP			; ata_slave_read_28
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
cmd$ = 32
io$ = 36
tv65 = 40
i$1 = 44
tv74 = 48
buf$ = 80
lba$ = 88
?ata_write_one@@YAEPEAEI@Z PROC				; ata_write_one

; 176  : {

$LN15:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 177  : 	uint16_t io = 0;

	xor	eax, eax
	mov	WORD PTR io$[rsp], ax

; 178  : 	switch (ata_drive)

	movzx	eax, BYTE PTR ?ata_drive@@3EA		; ata_drive
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 0
	je	SHORT $LN8@ata_write_
	cmp	BYTE PTR tv65[rsp], 1
	je	SHORT $LN7@ata_write_
	cmp	BYTE PTR tv65[rsp], 2
	je	SHORT $LN6@ata_write_
	cmp	BYTE PTR tv65[rsp], 3
	je	SHORT $LN5@ata_write_
	jmp	SHORT $LN4@ata_write_
$LN8@ata_write_:

; 179  : 	{
; 180  : 	case (ATA_PRIMARY << 1 | ATA_MASTER):
; 181  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 182  : 		ata_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive

; 183  : 		break;

	jmp	SHORT $LN9@ata_write_
$LN7@ata_write_:

; 184  : 	case (ATA_PRIMARY << 1 | ATA_SLAVE):
; 185  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 186  : 		ata_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_drive@@3EA, 1		; ata_drive

; 187  : 		break;

	jmp	SHORT $LN9@ata_write_
$LN6@ata_write_:

; 188  : 	case (ATA_SECONDARY << 1 | ATA_MASTER):
; 189  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 190  : 		ata_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive

; 191  : 		break;

	jmp	SHORT $LN9@ata_write_
$LN5@ata_write_:

; 192  : 	case (ATA_SECONDARY << 1 | ATA_SLAVE):
; 193  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 194  : 		ata_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_drive@@3EA, 1		; ata_drive

; 195  : 		break;

	jmp	SHORT $LN9@ata_write_
$LN4@ata_write_:

; 196  : 	default:
; 197  : 		return 0;

	xor	al, al
	jmp	$LN11@ata_write_
$LN9@ata_write_:

; 198  : 	}
; 199  : 
; 200  : 	uint8_t  cmd = (ata_drive == ATA_MASTER ? 0xE0 : 0xF0);

	movzx	eax, BYTE PTR ?ata_drive@@3EA		; ata_drive
	test	eax, eax
	jne	SHORT $LN13@ata_write_
	mov	DWORD PTR tv74[rsp], 224		; 000000e0H
	jmp	SHORT $LN14@ata_write_
$LN13@ata_write_:
	mov	DWORD PTR tv74[rsp], 240		; 000000f0H
$LN14@ata_write_:
	movzx	eax, BYTE PTR tv74[rsp]
	mov	BYTE PTR cmd$[rsp], al

; 201  : 
; 202  : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 203  : 	outportb(io + ATA_REG_HDDEVSEL, (cmd | (uint8_t) ((lba >> 24 & 0xFF))));

	movzx	eax, BYTE PTR cmd$[rsp]
	mov	ecx, DWORD PTR lba$[rsp]
	shr	ecx, 24
	and	ecx, 255				; 000000ffH
	movzx	ecx, cl
	or	eax, ecx
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 6
	movzx	edx, al
	call	outportb

; 204  : 	outportb(io + 1, 0x00);

	movzx	eax, WORD PTR io$[rsp]
	inc	eax
	xor	edx, edx
	movzx	ecx, ax
	call	outportb

; 205  : 
; 206  : 	//! single sector write
; 207  :     outportb(io + ATA_REG_SECCOUNT0, 1);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 2
	mov	dl, 1
	movzx	ecx, ax
	call	outportb

; 208  : 
; 209  : 	//! select LBA
; 210  : 	outportb(io + ATA_REG_LBA0, (uint8_t)((lba)));

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 3
	movzx	edx, BYTE PTR lba$[rsp]
	movzx	ecx, ax
	call	outportb

; 211  : 	outportb(io + ATA_REG_LBA1, (uint8_t)((lba) >> 8));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 8
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 4
	movzx	edx, al
	call	outportb

; 212  : 	outportb(io + ATA_REG_LBA2, (uint8_t)((lba) >> 16));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 16
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 5
	movzx	edx, al
	call	outportb

; 213  : 
; 214  : 	//! select write command
; 215  : 	outportb (io + ATA_REG_COMMAND, ATA_CMD_WRITE_PIO);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	mov	dl, 48					; 00000030H
	movzx	ecx, ax
	call	outportb

; 216  : 
; 217  : 	//! wait until ready
; 218  : 	ide_poll(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_poll@@YAXG@Z			; ide_poll

; 219  : 
; 220  : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 221  : 	ata_wait_drq (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_drq@@YAXG@Z			; ata_wait_drq

; 222  : 	for (int i=0; i < 256; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@ata_write_
$LN2@ata_write_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@ata_write_:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN1@ata_write_

; 223  : 	{
; 224  : 	
; 225  : 		x64_outportw(io + ATA_REG_DATA, *(uint16_t *)(buf + i * 2));

	mov	eax, DWORD PTR i$1[rsp]
	shl	eax, 1
	cdqe
	mov	rcx, QWORD PTR buf$[rsp]
	movzx	edx, WORD PTR [rcx+rax]
	movzx	ecx, WORD PTR io$[rsp]
	call	x64_outportw

; 226  : 	}

	jmp	SHORT $LN2@ata_write_
$LN1@ata_write_:

; 227  : 
; 228  : 	ide_400ns_delay (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_400ns_delay@@YAXG@Z		; ide_400ns_delay

; 229  : 	return 1;

	mov	al, 1
$LN11@ata_write_:

; 230  : }

	add	rsp, 72					; 00000048H
	ret	0
?ata_write_one@@YAEPEAEI@Z ENDP				; ata_write_one
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
cmd$ = 32
io$ = 36
tv65 = 40
i$1 = 44
tv75 = 48
lba$ = 80
sec_count$ = 88
buf$ = 96
?ata_read_28@@YAEIGPEAE@Z PROC				; ata_read_28

; 233  : {

$LN15:
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 234  : 	//! we only support 28 bit LBA so far
; 235  : 	uint16_t io = 0;

	xor	eax, eax
	mov	WORD PTR io$[rsp], ax

; 236  : 	switch (ata_drive)

	movzx	eax, BYTE PTR ?ata_drive@@3EA		; ata_drive
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 0
	je	SHORT $LN8@ata_read_2
	cmp	BYTE PTR tv65[rsp], 1
	je	SHORT $LN7@ata_read_2
	cmp	BYTE PTR tv65[rsp], 2
	je	SHORT $LN6@ata_read_2
	cmp	BYTE PTR tv65[rsp], 3
	je	SHORT $LN5@ata_read_2
	jmp	SHORT $LN4@ata_read_2
$LN8@ata_read_2:

; 237  : 	{
; 238  : 	case (ATA_PRIMARY << 1 |  ATA_MASTER):
; 239  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 240  : 		ata_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive

; 241  : 		break;

	jmp	SHORT $LN9@ata_read_2
$LN7@ata_read_2:

; 242  : 	case (ATA_PRIMARY << 1 | ATA_SLAVE):
; 243  : 		io = ATA_PRIMARY_IO;

	mov	eax, 496				; 000001f0H
	mov	WORD PTR io$[rsp], ax

; 244  : 		ata_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_drive@@3EA, 1		; ata_drive

; 245  : 		break;

	jmp	SHORT $LN9@ata_read_2
$LN6@ata_read_2:

; 246  : 	case (ATA_SECONDARY << 1 | ATA_MASTER):
; 247  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 248  : 		ata_drive = ATA_MASTER;

	mov	BYTE PTR ?ata_drive@@3EA, 0		; ata_drive

; 249  : 		break;

	jmp	SHORT $LN9@ata_read_2
$LN5@ata_read_2:

; 250  : 	case (ATA_SECONDARY << 1 | ATA_SLAVE):
; 251  : 		io = ATA_SECONDARY_IO;

	mov	eax, 368				; 00000170H
	mov	WORD PTR io$[rsp], ax

; 252  : 		ata_drive = ATA_SLAVE;

	mov	BYTE PTR ?ata_drive@@3EA, 1		; ata_drive

; 253  : 		break;

	jmp	SHORT $LN9@ata_read_2
$LN4@ata_read_2:

; 254  : 	default:{
; 255  : 		printf ("[ATA]: Read28 -- no selected io & drive\n");

	lea	rcx, OFFSET FLAT:$SG3416
	call	printf

; 256  : 		return 0;

	xor	al, al
	jmp	$LN11@ata_read_2
$LN9@ata_read_2:

; 257  : 	}
; 258  : 	}
; 259  : 
; 260  : 	/*printf ("[ATA]: Read28 -- io device selected -> %x\n", io);
; 261  : 	printf ("[ATA]: Read28 -- ata drive selected -> %x\n", ata_drive);*/
; 262  : 	uint8_t cmd = (ata_drive == ATA_MASTER ? 0xE0 : 0xF0);

	movzx	eax, BYTE PTR ?ata_drive@@3EA		; ata_drive
	test	eax, eax
	jne	SHORT $LN13@ata_read_2
	mov	DWORD PTR tv75[rsp], 224		; 000000e0H
	jmp	SHORT $LN14@ata_read_2
$LN13@ata_read_2:
	mov	DWORD PTR tv75[rsp], 240		; 000000f0H
$LN14@ata_read_2:
	movzx	eax, BYTE PTR tv75[rsp]
	mov	BYTE PTR cmd$[rsp], al

; 263  : 
; 264  : 	ata_wait_busy (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ata_wait_busy@@YAXG@Z			; ata_wait_busy

; 265  : 	
; 266  : 	outportb (io + ATA_REG_HDDEVSEL, (cmd | (uint8_t) ((lba >> 24 & 0x0F))));

	movzx	eax, BYTE PTR cmd$[rsp]
	mov	ecx, DWORD PTR lba$[rsp]
	shr	ecx, 24
	and	ecx, 15
	movzx	ecx, cl
	or	eax, ecx
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 6
	movzx	edx, al
	call	outportb

; 267  : 	outportb (io + 1, 0x00);

	movzx	eax, WORD PTR io$[rsp]
	inc	eax
	xor	edx, edx
	movzx	ecx, ax
	call	outportb

; 268  : 
; 269  : 	//! single sector read
; 270  : 	outportb (io + ATA_REG_SECCOUNT0, sec_count);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 2
	movzx	edx, BYTE PTR sec_count$[rsp]
	movzx	ecx, ax
	call	outportb

; 271  : 
; 272  : 	//! select LBA
; 273  : 	outportb (io + ATA_REG_LBA0, (uint8_t)((lba)));

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 3
	movzx	edx, BYTE PTR lba$[rsp]
	movzx	ecx, ax
	call	outportb

; 274  : 	outportb (io + ATA_REG_LBA1, (uint8_t)((lba) >> 8));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 8
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 4
	movzx	edx, al
	call	outportb

; 275  : 	outportb (io + ATA_REG_LBA2, (uint8_t)((lba) >> 16));

	mov	eax, DWORD PTR lba$[rsp]
	shr	eax, 16
	movzx	ecx, WORD PTR io$[rsp]
	add	ecx, 5
	movzx	edx, al
	call	outportb

; 276  : 
; 277  : 	//! select read command
; 278  : 	outportb (io + ATA_REG_COMMAND, ATA_CMD_READ_PIO);

	movzx	eax, WORD PTR io$[rsp]
	add	eax, 7
	mov	dl, 32					; 00000020H
	movzx	ecx, ax
	call	outportb

; 279  : 
; 280  : 	//! wait untill ready
; 281  : 	ide_poll (io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_poll@@YAXG@Z			; ide_poll

; 282  : 	
; 283  : 	for (int i = 0; i < 256; i++ )

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@ata_read_2
$LN2@ata_read_2:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@ata_read_2:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN1@ata_read_2

; 284  : 	{
; 285  : 			
; 286  : 	   *(uint16_t*)(buf + i * 2) = inportw (io + ATA_REG_DATA);

	movzx	ecx, WORD PTR io$[rsp]
	call	inportw
	mov	ecx, DWORD PTR i$1[rsp]
	shl	ecx, 1
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR buf$[rsp]
	mov	WORD PTR [rdx+rcx], ax

; 287  :     }

	jmp	SHORT $LN2@ata_read_2
$LN1@ata_read_2:

; 288  : 	
; 289  : 	
; 290  : 	ide_400ns_delay(io);

	movzx	ecx, WORD PTR io$[rsp]
	call	?ide_400ns_delay@@YAXG@Z		; ide_400ns_delay

; 291  : 	//ide_wait_irq ();
; 292  : 	return 0;

	xor	al, al
$LN11@ata_read_2:

; 293  : }

	add	rsp, 72					; 00000048H
	ret	0
?ata_read_28@@YAEIGPEAE@Z ENDP				; ata_read_28
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ata.cpp
_TEXT	SEGMENT
dev$ = 48
bus$ = 52
func$ = 56
info$ = 64
?ata_initialize@@YAXXZ PROC				; ata_initialize

; 496  : void ata_initialize (){

$LN6:
	sub	rsp, 328				; 00000148H

; 497  : 
; 498  : 	x64_cli();

	call	x64_cli

; 499  : 	pci_device_info info;
; 500  : 	int bus; int dev; int func;
; 501  : 	if (!pci_find_device_class (0x01,0x01,&info,&bus,&dev,&func)) {

	lea	rax, QWORD PTR func$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR dev$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR bus$[rsp]
	lea	r8, QWORD PTR info$[rsp]
	mov	dl, 1
	mov	cl, 1
	call	pci_find_device_class
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@ata_initia

; 502  : 		debug_print ("******************************************\n");

	lea	rcx, OFFSET FLAT:$SG3520
	call	?debug_print@@YAXPEBDZZ			; debug_print

; 503  : 		debug_print ("System error!!!!\n");

	lea	rcx, OFFSET FLAT:$SG3521
	call	?debug_print@@YAXPEBDZZ			; debug_print

; 504  : 		debug_print ("Xeneva initialization failed\n");

	lea	rcx, OFFSET FLAT:$SG3522
	call	?debug_print@@YAXPEBDZZ			; debug_print

; 505  : 		debug_print ("Storage IDE mode error, halting system\n");

	lea	rcx, OFFSET FLAT:$SG3523
	call	?debug_print@@YAXPEBDZZ			; debug_print

; 506  : 		debug_print ("******************************************\n");

	lea	rcx, OFFSET FLAT:$SG3524
	call	?debug_print@@YAXPEBDZZ			; debug_print
$LN2@ata_initia:

; 507  : 		for(;;);

	jmp	SHORT $LN2@ata_initia
$LN3@ata_initia:

; 508  : 	}
; 509  : 	pci_enable_bus_master (bus,dev,func);

	mov	r8d, DWORD PTR func$[rsp]
	mov	edx, DWORD PTR dev$[rsp]
	mov	ecx, DWORD PTR bus$[rsp]
	call	pci_enable_bus_master

; 510  : 	
; 511  : 	AuInterruptSet(35, ide_primary_irq, 14);

	mov	r8b, 14
	lea	rdx, OFFSET FLAT:?ide_primary_irq@@YAX_KPEAX@Z ; ide_primary_irq
	mov	ecx, 35					; 00000023H
	call	AuInterruptSet

; 512  : 
; 513  : 	AuInterruptSet(36, ide_secondary_irq,15);

	mov	r8b, 15
	lea	rdx, OFFSET FLAT:?ide_secondary_irq@@YAX_KPEAX@Z ; ide_secondary_irq
	mov	ecx, 36					; 00000024H
	call	AuInterruptSet

; 514  : 
; 515  : 	ata_probe ();

	call	?ata_probe@@YAXXZ			; ata_probe

; 516  : 
; 517  : 	x64_sti();

	call	x64_sti

; 518  : }

	add	rsp, 328				; 00000148H
	ret	0
?ata_initialize@@YAXXZ ENDP				; ata_initialize
_TEXT	ENDS
END
