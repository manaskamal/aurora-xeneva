; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?AuInsertVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z ; AuInsertVMArea
PUBLIC	?AuRemoveVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z ; AuRemoveVMArea
PUBLIC	?AuFindVMA@@YAPEAU_vma_area_@@_K@Z		; AuFindVMA
PUBLIC	?AuCleanVMA@@YAXPEAU_process_@@@Z		; AuCleanVMA
PUBLIC	?AuFindVMAUniqueId@@YAPEAU_vma_area_@@I@Z	; AuFindVMAUniqueId
EXTRN	free:PROC
EXTRN	?get_current_process@@YAPEAU_process_@@XZ:PROC	; get_current_process
pdata	SEGMENT
$pdata$?AuRemoveVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z DD imagerel $LN8
	DD	imagerel $LN8+184
	DD	imagerel $unwind$?AuRemoveVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z
$pdata$?AuFindVMA@@YAPEAU_vma_area_@@_K@Z DD imagerel $LN7
	DD	imagerel $LN7+107
	DD	imagerel $unwind$?AuFindVMA@@YAPEAU_vma_area_@@_K@Z
$pdata$?AuCleanVMA@@YAXPEAU_process_@@@Z DD imagerel $LN6
	DD	imagerel $LN6+67
	DD	imagerel $unwind$?AuCleanVMA@@YAXPEAU_process_@@@Z
$pdata$?AuFindVMAUniqueId@@YAPEAU_vma_area_@@I@Z DD imagerel $LN7
	DD	imagerel $LN7+89
	DD	imagerel $unwind$?AuFindVMAUniqueId@@YAPEAU_vma_area_@@I@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuRemoveVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z DD 010e01H
	DD	0420eH
$unwind$?AuFindVMA@@YAPEAU_vma_area_@@_K@Z DD 010901H
	DD	06209H
$unwind$?AuCleanVMA@@YAXPEAU_process_@@@Z DD 010901H
	DD	06209H
$unwind$?AuFindVMAUniqueId@@YAPEAU_vma_area_@@I@Z DD 010801H
	DD	06208H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\mmngr\vma.cpp
_TEXT	SEGMENT
vma$1 = 32
proc$ = 40
uid$ = 64
?AuFindVMAUniqueId@@YAPEAU_vma_area_@@I@Z PROC		; AuFindVMAUniqueId

; 97   : au_vm_area_t *AuFindVMAUniqueId (uint32_t uid) {

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 98   : 	process_t *proc = get_current_process();

	call	?get_current_process@@YAPEAU_process_@@XZ ; get_current_process
	mov	QWORD PTR proc$[rsp], rax

; 99   : 	for (au_vm_area_t *vma = proc->vma_area; vma != NULL; vma = vma->next) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+2128]
	mov	QWORD PTR vma$1[rsp], rax
	jmp	SHORT $LN4@AuFindVMAU
$LN3@AuFindVMAU:
	mov	rax, QWORD PTR vma$1[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR vma$1[rsp], rax
$LN4@AuFindVMAU:
	cmp	QWORD PTR vma$1[rsp], 0
	je	SHORT $LN2@AuFindVMAU

; 100  : 		if (vma->unique_id == uid){

	mov	rax, QWORD PTR vma$1[rsp]
	mov	ecx, DWORD PTR uid$[rsp]
	cmp	DWORD PTR [rax+52], ecx
	jne	SHORT $LN1@AuFindVMAU

; 101  : 			return vma;

	mov	rax, QWORD PTR vma$1[rsp]
	jmp	SHORT $LN5@AuFindVMAU
$LN1@AuFindVMAU:

; 102  : 		}
; 103  : 	}

	jmp	SHORT $LN3@AuFindVMAU
$LN2@AuFindVMAU:

; 104  : 	return NULL;

	xor	eax, eax
$LN5@AuFindVMAU:

; 105  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuFindVMAUniqueId@@YAPEAU_vma_area_@@I@Z ENDP		; AuFindVMAUniqueId
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\mmngr\vma.cpp
_TEXT	SEGMENT
vma$1 = 32
proc$ = 64
?AuCleanVMA@@YAXPEAU_process_@@@Z PROC			; AuCleanVMA

; 111  : void AuCleanVMA(process_t *proc) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 112  : 	for (au_vm_area_t *vma = proc->vma_area; vma != NULL; vma = vma->next)

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+2128]
	mov	QWORD PTR vma$1[rsp], rax
	jmp	SHORT $LN3@AuCleanVMA
$LN2@AuCleanVMA:
	mov	rax, QWORD PTR vma$1[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR vma$1[rsp], rax
$LN3@AuCleanVMA:
	cmp	QWORD PTR vma$1[rsp], 0
	je	SHORT $LN1@AuCleanVMA

; 113  : 		free(vma);

	mov	rcx, QWORD PTR vma$1[rsp]
	call	free
	jmp	SHORT $LN2@AuCleanVMA
$LN1@AuCleanVMA:

; 114  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuCleanVMA@@YAXPEAU_process_@@@Z ENDP			; AuCleanVMA
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\mmngr\vma.cpp
_TEXT	SEGMENT
vma$1 = 32
proc$ = 40
address$ = 64
?AuFindVMA@@YAPEAU_vma_area_@@_K@Z PROC			; AuFindVMA

; 81   : au_vm_area_t *AuFindVMA (uint64_t address) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 82   : 	process_t *proc = get_current_process();

	call	?get_current_process@@YAPEAU_process_@@XZ ; get_current_process
	mov	QWORD PTR proc$[rsp], rax

; 83   : 	for (au_vm_area_t *vma = proc->vma_area; vma != NULL; vma = vma->next) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+2128]
	mov	QWORD PTR vma$1[rsp], rax
	jmp	SHORT $LN4@AuFindVMA
$LN3@AuFindVMA:
	mov	rax, QWORD PTR vma$1[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR vma$1[rsp], rax
$LN4@AuFindVMA:
	cmp	QWORD PTR vma$1[rsp], 0
	je	SHORT $LN2@AuFindVMA

; 84   : 		if (address >= vma->start && address <= vma->end){

	mov	rax, QWORD PTR vma$1[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR address$[rsp], rax
	jb	SHORT $LN1@AuFindVMA
	mov	rax, QWORD PTR vma$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR address$[rsp], rax
	ja	SHORT $LN1@AuFindVMA

; 85   : 			return vma;

	mov	rax, QWORD PTR vma$1[rsp]
	jmp	SHORT $LN5@AuFindVMA
$LN1@AuFindVMA:

; 86   : 		}
; 87   : 	}

	jmp	SHORT $LN3@AuFindVMA
$LN2@AuFindVMA:

; 88   : 	return NULL;

	xor	eax, eax
$LN5@AuFindVMA:

; 89   : }

	add	rsp, 56					; 00000038H
	ret	0
?AuFindVMA@@YAPEAU_vma_area_@@_K@Z ENDP			; AuFindVMA
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\mmngr\vma.cpp
_TEXT	SEGMENT
proc$ = 48
vma$ = 56
?AuRemoveVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z PROC ; AuRemoveVMArea

; 58   : void AuRemoveVMArea (process_t *proc, au_vm_area_t *vma) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 59   : 	if (proc->vma_area == NULL)

	mov	rax, QWORD PTR proc$[rsp]
	cmp	QWORD PTR [rax+2128], 0
	jne	SHORT $LN5@AuRemoveVM

; 60   : 		return;

	jmp	$LN6@AuRemoveVM
$LN5@AuRemoveVM:

; 61   : 
; 62   : 	if (vma == proc->vma_area) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+2128]
	cmp	QWORD PTR vma$[rsp], rax
	jne	SHORT $LN4@AuRemoveVM

; 63   : 		proc->vma_area = proc->vma_area->next;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+2128]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rcx+2128], rax

; 64   : 	} else {

	jmp	SHORT $LN3@AuRemoveVM
$LN4@AuRemoveVM:

; 65   : 		vma->prev->next = vma->next;

	mov	rax, QWORD PTR vma$[rsp]
	mov	rax, QWORD PTR [rax+72]
	mov	rcx, QWORD PTR vma$[rsp]
	mov	rcx, QWORD PTR [rcx+64]
	mov	QWORD PTR [rax+64], rcx
$LN3@AuRemoveVM:

; 66   : 	}
; 67   : 
; 68   : 	if (vma == proc->last_vma) {

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+2136]
	cmp	QWORD PTR vma$[rsp], rax
	jne	SHORT $LN2@AuRemoveVM

; 69   : 		proc->last_vma = vma->prev;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR vma$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	mov	QWORD PTR [rax+2136], rcx

; 70   : 	} else {

	jmp	SHORT $LN1@AuRemoveVM
$LN2@AuRemoveVM:

; 71   : 		vma->next->prev = vma->prev;

	mov	rax, QWORD PTR vma$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	rcx, QWORD PTR vma$[rsp]
	mov	rcx, QWORD PTR [rcx+72]
	mov	QWORD PTR [rax+72], rcx
$LN1@AuRemoveVM:

; 72   : 	}
; 73   : 
; 74   : 	free(vma);

	mov	rcx, QWORD PTR vma$[rsp]
	call	free
$LN6@AuRemoveVM:

; 75   : }

	add	rsp, 40					; 00000028H
	ret	0
?AuRemoveVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z ENDP ; AuRemoveVMArea
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\mmngr\vma.cpp
_TEXT	SEGMENT
proc$ = 8
vma$ = 16
?AuInsertVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z PROC ; AuInsertVMArea

; 39   : void AuInsertVMArea(process_t *proc, au_vm_area_t *vma) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 40   : 	vma->next = NULL;

	mov	rax, QWORD PTR vma$[rsp]
	mov	QWORD PTR [rax+64], 0

; 41   : 	vma->prev = NULL;

	mov	rax, QWORD PTR vma$[rsp]
	mov	QWORD PTR [rax+72], 0

; 42   : 
; 43   : 	if (proc->vma_area == NULL){

	mov	rax, QWORD PTR proc$[rsp]
	cmp	QWORD PTR [rax+2128], 0
	jne	SHORT $LN2@AuInsertVM

; 44   : 		proc->vma_area = vma;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR vma$[rsp]
	mov	QWORD PTR [rax+2128], rcx

; 45   : 		proc->last_vma = proc->vma_area;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+2128]
	mov	QWORD PTR [rax+2136], rcx

; 46   : 	}else {

	jmp	SHORT $LN1@AuInsertVM
$LN2@AuInsertVM:

; 47   : 		proc->last_vma->next = vma;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rax, QWORD PTR [rax+2136]
	mov	rcx, QWORD PTR vma$[rsp]
	mov	QWORD PTR [rax+64], rcx

; 48   : 		vma->prev = proc->last_vma;

	mov	rax, QWORD PTR vma$[rsp]
	mov	rcx, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR [rcx+2136]
	mov	QWORD PTR [rax+72], rcx

; 49   : 		proc->last_vma = vma;

	mov	rax, QWORD PTR proc$[rsp]
	mov	rcx, QWORD PTR vma$[rsp]
	mov	QWORD PTR [rax+2136], rcx
$LN1@AuInsertVM:

; 50   : 	}
; 51   : }

	fatret	0
?AuInsertVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z ENDP ; AuInsertVMArea
_TEXT	ENDS
END
