; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?mouse_x@@3HA					; mouse_x
PUBLIC	?mouse_y@@3HA					; mouse_y
PUBLIC	?mouse_x_difference@@3HA			; mouse_x_difference
PUBLIC	?mouse_y_difference@@3HA			; mouse_y_difference
PUBLIC	?prev_button@@3PAEA				; prev_button
PUBLIC	?curr_button@@3PAEA				; curr_button
PUBLIC	?mouse_button_state@@3IA			; mouse_button_state
PUBLIC	?mouse_button@@3HC				; mouse_button
PUBLIC	?old_message@@3U_dwm_message_@@A		; old_message
_BSS	SEGMENT
mouse_cycle DB	01H DUP (?)
	ALIGN	4

?mouse_x@@3HA DD 01H DUP (?)				; mouse_x
?mouse_y@@3HA DD 01H DUP (?)				; mouse_y
?mouse_x_difference@@3HA DD 01H DUP (?)			; mouse_x_difference
?mouse_y_difference@@3HA DD 01H DUP (?)			; mouse_y_difference
?prev_button@@3PAEA DB 03H DUP (?)			; prev_button
	ALIGN	4

?curr_button@@3PAEA DB 03H DUP (?)			; curr_button
	ALIGN	4

?mouse_button_state@@3IA DD 01H DUP (?)			; mouse_button_state
?mouse_button@@3HC DD 01H DUP (?)			; mouse_button
?old_message@@3U_dwm_message_@@A DB 01cH DUP (?)	; old_message
_BSS	ENDS
CONST	SEGMENT
$SG3652	DB	'Mouse Vertical scroll up ', 0aH, 00H
	ORG $+5
$SG3655	DB	'Mouse Vertical scroll down ', 0aH, 00H
	ORG $+3
$SG3658	DB	'Mouse Horizontal Scroll up ', 0aH, 00H
	ORG $+3
$SG3661	DB	'Mouse Horizontal Scroll down ', 0aH, 00H
	ORG $+1
$SG3681	DB	'mouse', 00H
	ORG $+2
$SG3682	DB	'/dev/mouse', 00H
	ORG $+5
$SG3686	DB	'mouse interrupt setupped', 0aH, 00H
CONST	ENDS
PUBLIC	?AuInitializeMouse@@YAXXZ			; AuInitializeMouse
PUBLIC	?mouse_wait@@YAXE@Z				; mouse_wait
PUBLIC	?mouse_write@@YAXE@Z				; mouse_write
PUBLIC	?mouse_read@@YAEXZ				; mouse_read
PUBLIC	?left_button_up@@YAHXZ				; left_button_up
PUBLIC	?mouse_handler@@YAX_KPEAX@Z			; mouse_handler
PUBLIC	?mouse_ioquery@@YAHPEAU_vfs_node_@@HPEAX@Z	; mouse_ioquery
PUBLIC	?mouse_register_device@@YAXXZ			; mouse_register_device
EXTRN	x64_cli:PROC
EXTRN	x64_sti:PROC
EXTRN	x64_inportb:PROC
EXTRN	inportb:PROC
EXTRN	outportb:PROC
EXTRN	AuInterruptEnd:PROC
EXTRN	AuInterruptSet:PROC
EXTRN	AuIrqMask:PROC
EXTRN	strcpy:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	printf:PROC
EXTRN	vfs_mount:PROC
EXTRN	malloc:PROC
EXTRN	AuGetScreenWidth:PROC
EXTRN	AuGetScreenHeight:PROC
EXTRN	?dwm_put_message@@YAXPEAU_dwm_message_@@@Z:PROC	; dwm_put_message
_BSS	SEGMENT
mouse_byte DB	04H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$?AuInitializeMouse@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+198
	DD	imagerel $unwind$?AuInitializeMouse@@YAXXZ
$pdata$?mouse_wait@@YAXE@Z DD imagerel $LN11
	DD	imagerel $LN11+131
	DD	imagerel $unwind$?mouse_wait@@YAXE@Z
$pdata$?mouse_write@@YAXE@Z DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$?mouse_write@@YAXE@Z
$pdata$?mouse_read@@YAEXZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$?mouse_read@@YAEXZ
$pdata$?left_button_up@@YAHXZ DD imagerel $LN5
	DD	imagerel $LN5+76
	DD	imagerel $unwind$?left_button_up@@YAHXZ
$pdata$?mouse_handler@@YAX_KPEAX@Z DD imagerel $LN35
	DD	imagerel $LN35+1194
	DD	imagerel $unwind$?mouse_handler@@YAX_KPEAX@Z
$pdata$?mouse_ioquery@@YAHPEAU_vfs_node_@@HPEAX@Z DD imagerel $LN9
	DD	imagerel $LN9+97
	DD	imagerel $unwind$?mouse_ioquery@@YAHPEAU_vfs_node_@@HPEAX@Z
$pdata$?mouse_register_device@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+195
	DD	imagerel $unwind$?mouse_register_device@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?AuInitializeMouse@@YAXXZ DD 010401H
	DD	06204H
$unwind$?mouse_wait@@YAXE@Z DD 010801H
	DD	06208H
$unwind$?mouse_write@@YAXE@Z DD 010801H
	DD	04208H
$unwind$?mouse_read@@YAEXZ DD 010401H
	DD	04204H
$unwind$?left_button_up@@YAHXZ DD 010401H
	DD	02204H
$unwind$?mouse_handler@@YAX_KPEAX@Z DD 010e01H
	DD	0c20eH
$unwind$?mouse_ioquery@@YAHPEAU_vfs_node_@@HPEAX@Z DD 011201H
	DD	06212H
$unwind$?mouse_register_device@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\mouse.cpp
_TEXT	SEGMENT
node$ = 32
?mouse_register_device@@YAXXZ PROC			; mouse_register_device

; 220  : void mouse_register_device () {

$LN3:
	sub	rsp, 56					; 00000038H

; 221  : 	vfs_node_t *node = (vfs_node_t*)malloc(sizeof(vfs_node_t));

	mov	ecx, 104				; 00000068H
	call	malloc
	mov	QWORD PTR node$[rsp], rax

; 222  : 	strcpy (node->filename, "mouse");

	mov	rax, QWORD PTR node$[rsp]
	lea	rdx, OFFSET FLAT:$SG3681
	mov	rcx, rax
	call	strcpy

; 223  : 	node->size = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	DWORD PTR [rax+32], 0

; 224  : 	node->eof = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	BYTE PTR [rax+36], 0

; 225  : 	node->pos = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	DWORD PTR [rax+40], 0

; 226  : 	node->current = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	DWORD PTR [rax+44], 0

; 227  : 	node->flags = FS_FLAG_GENERAL;

	mov	rax, QWORD PTR node$[rsp]
	mov	BYTE PTR [rax+48], 2

; 228  : 	node->status = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	BYTE PTR [rax+49], 0

; 229  : 	node->open = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+64], 0

; 230  : 	node->read = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+72], 0

; 231  : 	node->write = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+80], 0

; 232  : 	node->read_blk = 0;

	mov	rax, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax+88], 0

; 233  : 	node->ioquery = mouse_ioquery;

	mov	rax, QWORD PTR node$[rsp]
	lea	rcx, OFFSET FLAT:?mouse_ioquery@@YAHPEAU_vfs_node_@@HPEAX@Z ; mouse_ioquery
	mov	QWORD PTR [rax+96], rcx

; 234  : 	vfs_mount ("/dev/mouse", node, 0);

	xor	r8d, r8d
	mov	rdx, QWORD PTR node$[rsp]
	lea	rcx, OFFSET FLAT:$SG3682
	call	vfs_mount

; 235  : }

	add	rsp, 56					; 00000038H
	ret	0
?mouse_register_device@@YAXXZ ENDP			; mouse_register_device
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\mouse.cpp
_TEXT	SEGMENT
tv64 = 32
node$ = 64
code$ = 72
arg$ = 80
?mouse_ioquery@@YAHPEAU_vfs_node_@@HPEAX@Z PROC		; mouse_ioquery

; 198  : int mouse_ioquery (vfs_node_t *node, int code, void* arg) {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 199  : 	switch (code) {

	mov	eax, DWORD PTR code$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 300		; 0000012cH
	je	SHORT $LN4@mouse_ioqu
	cmp	DWORD PTR tv64[rsp], 301		; 0000012dH
	je	SHORT $LN3@mouse_ioqu
	cmp	DWORD PTR tv64[rsp], 302		; 0000012eH
	je	SHORT $LN2@mouse_ioqu
	jmp	SHORT $LN1@mouse_ioqu
$LN4@mouse_ioqu:

; 200  : 		case MOUSE_IOCODE_DISABLE:
; 201  : 			AuIrqMask(12,true);

	mov	dl, 1
	mov	cl, 12
	call	AuIrqMask

; 202  : 			break;

	jmp	SHORT $LN5@mouse_ioqu
$LN3@mouse_ioqu:

; 203  : 		case MOUSE_IOCODE_ENABLE:
; 204  : 			AuIrqMask(12, false);

	xor	edx, edx
	mov	cl, 12
	call	AuIrqMask

; 205  : 			break;

	jmp	SHORT $LN5@mouse_ioqu
$LN2@mouse_ioqu:

; 206  : 		case 302:
; 207  : 			return 10;

	mov	eax, 10
	jmp	SHORT $LN7@mouse_ioqu
$LN1@mouse_ioqu:
$LN5@mouse_ioqu:

; 208  : 			break;
; 209  : 		default:
; 210  : 			break;
; 211  : 	}
; 212  : 
; 213  : 	return 1;

	mov	eax, 1
$LN7@mouse_ioqu:

; 214  : }

	add	rsp, 56					; 00000038H
	ret	0
?mouse_ioquery@@YAHPEAU_vfs_node_@@HPEAX@Z ENDP		; mouse_ioquery
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\mouse.cpp
_TEXT	SEGMENT
mouse_in$1 = 32
status$ = 33
tv75 = 36
x$2 = 40
y$3 = 44
tv154 = 48
tv159 = 52
msg$4 = 56
p$ = 112
param$ = 120
?mouse_handler@@YAX_KPEAX@Z PROC			; mouse_handler

; 87   : void mouse_handler (size_t p, void* param) {

$LN35:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 88   : 	uint8_t status = inportb (MOUSE_STATUS);

	mov	cx, 100					; 00000064H
	call	inportb
	mov	BYTE PTR status$[rsp], al
$LN32@mouse_hand:

; 89   : 	while ((status & MOUSE_BBIT) && (status & MOUSE_F_BIT)) {

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 1
	test	eax, eax
	je	$LN31@mouse_hand
	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	$LN31@mouse_hand

; 90   : 		int8_t mouse_in = inportb (MOUSE_PORT);

	mov	cx, 96					; 00000060H
	call	inportb
	mov	BYTE PTR mouse_in$1[rsp], al

; 91   : 		switch (mouse_cycle) {

	movzx	eax, BYTE PTR mouse_cycle
	mov	BYTE PTR tv75[rsp], al
	cmp	BYTE PTR tv75[rsp], 0
	je	SHORT $LN28@mouse_hand
	cmp	BYTE PTR tv75[rsp], 1
	je	SHORT $LN26@mouse_hand
	cmp	BYTE PTR tv75[rsp], 2
	je	SHORT $LN25@mouse_hand
	cmp	BYTE PTR tv75[rsp], 3
	je	$LN23@mouse_hand
	cmp	BYTE PTR tv75[rsp], 4
	je	$LN21@mouse_hand
	jmp	$LN29@mouse_hand
$LN28@mouse_hand:

; 92   : 		case 0:
; 93   : 			mouse_byte[0] = mouse_in;

	mov	eax, 1
	imul	rax, 0
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	edx, BYTE PTR mouse_in$1[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 94   : 			if (!(mouse_in & MOUSE_V_BIT)) break;

	movsx	eax, BYTE PTR mouse_in$1[rsp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $LN27@mouse_hand
	jmp	$LN29@mouse_hand
$LN27@mouse_hand:

; 95   : 			++mouse_cycle;

	movzx	eax, BYTE PTR mouse_cycle
	inc	al
	mov	BYTE PTR mouse_cycle, al

; 96   : 			break;

	jmp	SHORT $LN29@mouse_hand
$LN26@mouse_hand:

; 97   : 		case 1:
; 98   : 			mouse_byte[1] = mouse_in;

	mov	eax, 1
	imul	rax, 1
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	edx, BYTE PTR mouse_in$1[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 99   : 			++mouse_cycle;

	movzx	eax, BYTE PTR mouse_cycle
	inc	al
	mov	BYTE PTR mouse_cycle, al

; 100  : 			break;

	jmp	SHORT $LN29@mouse_hand
$LN25@mouse_hand:

; 101  : 		case 2:
; 102  : 			mouse_byte[2] = mouse_in;

	mov	eax, 1
	imul	rax, 2
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	edx, BYTE PTR mouse_in$1[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 103  : 			goto finish_packet;

	jmp	SHORT $LN24@mouse_hand
	jmp	SHORT $finish_packet$36
$LN23@mouse_hand:

; 104  : 		case 3:
; 105  : 			mouse_byte[3] = mouse_in;

	mov	eax, 1
	imul	rax, 3
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	edx, BYTE PTR mouse_in$1[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 106  : 			goto finish_packet;

	jmp	SHORT $LN22@mouse_hand
	jmp	SHORT $finish_packet$36
$LN21@mouse_hand:

; 107  : 		case 4:
; 108  : 			mouse_byte[4] = mouse_in;

	mov	eax, 1
	imul	rax, 4
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	edx, BYTE PTR mouse_in$1[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 109  : 			goto finish_packet;

	jmp	SHORT $LN20@mouse_hand
	jmp	SHORT $finish_packet$36
$LN29@mouse_hand:

; 110  : 		}
; 111  : 
; 112  : 		goto read_next;

	jmp	$LN19@mouse_hand
	jmp	$read_next$37
$LN20@mouse_hand:
$LN22@mouse_hand:
$LN24@mouse_hand:
$finish_packet$36:

; 113  : 
; 114  : finish_packet:
; 115  : 		mouse_cycle = 0;

	mov	BYTE PTR mouse_cycle, 0

; 116  : 
; 117  : 		int x = mouse_byte[1];

	mov	eax, 1
	imul	rax, 1
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR x$2[rsp], eax

; 118  : 		int y = mouse_byte[2];

	mov	eax, 1
	imul	rax, 2
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR y$3[rsp], eax

; 119  : 		if (x && mouse_byte[0] & ( 1 <<  4)) {

	cmp	DWORD PTR x$2[rsp], 0
	je	SHORT $LN18@mouse_hand
	mov	eax, 1
	imul	rax, 0
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 16
	test	eax, eax
	je	SHORT $LN18@mouse_hand

; 120  : 			x = x - 0x100;

	mov	eax, DWORD PTR x$2[rsp]
	sub	eax, 256				; 00000100H
	mov	DWORD PTR x$2[rsp], eax
$LN18@mouse_hand:

; 121  : 		}
; 122  : 
; 123  : 		if (y && mouse_byte[0] & (1 << 5)) {

	cmp	DWORD PTR y$3[rsp], 0
	je	SHORT $LN17@mouse_hand
	mov	eax, 1
	imul	rax, 0
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN17@mouse_hand

; 124  : 			y = y - 0x100;

	mov	eax, DWORD PTR y$3[rsp]
	sub	eax, 256				; 00000100H
	mov	DWORD PTR y$3[rsp], eax
$LN17@mouse_hand:

; 125  : 		}
; 126  : 
; 127  : 		mouse_x_difference = x;

	mov	eax, DWORD PTR x$2[rsp]
	mov	DWORD PTR ?mouse_x_difference@@3HA, eax	; mouse_x_difference

; 128  : 		mouse_y_difference = y;

	mov	eax, DWORD PTR y$3[rsp]
	mov	DWORD PTR ?mouse_y_difference@@3HA, eax	; mouse_y_difference

; 129  : 		mouse_x += mouse_x_difference;

	mov	eax, DWORD PTR ?mouse_x_difference@@3HA	; mouse_x_difference
	mov	ecx, DWORD PTR ?mouse_x@@3HA		; mouse_x
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ?mouse_x@@3HA, eax		; mouse_x

; 130  : 		mouse_y -= mouse_y_difference;

	mov	eax, DWORD PTR ?mouse_y_difference@@3HA	; mouse_y_difference
	mov	ecx, DWORD PTR ?mouse_y@@3HA		; mouse_y
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ?mouse_y@@3HA, eax		; mouse_y

; 131  : 
; 132  : 		if (mouse_x < 0)

	cmp	DWORD PTR ?mouse_x@@3HA, 0		; mouse_x
	jge	SHORT $LN16@mouse_hand

; 133  : 			mouse_x = 0;

	mov	DWORD PTR ?mouse_x@@3HA, 0		; mouse_x
$LN16@mouse_hand:

; 134  : 
; 135  : 		if (mouse_y < 0)

	cmp	DWORD PTR ?mouse_y@@3HA, 0		; mouse_y
	jge	SHORT $LN15@mouse_hand

; 136  : 			mouse_y = 0;

	mov	DWORD PTR ?mouse_y@@3HA, 0		; mouse_y
$LN15@mouse_hand:

; 137  : 
; 138  : 		if (mouse_x + 24 > AuGetScreenWidth())

	mov	eax, DWORD PTR ?mouse_x@@3HA		; mouse_x
	add	eax, 24
	mov	DWORD PTR tv154[rsp], eax
	call	AuGetScreenWidth
	mov	ecx, DWORD PTR tv154[rsp]
	cmp	ecx, eax
	jbe	SHORT $LN14@mouse_hand

; 139  : 			mouse_x = AuGetScreenWidth() - 24;

	call	AuGetScreenWidth
	sub	eax, 24
	mov	DWORD PTR ?mouse_x@@3HA, eax		; mouse_x
$LN14@mouse_hand:

; 140  : 
; 141  : 		if (mouse_y + 24 > AuGetScreenHeight())

	mov	eax, DWORD PTR ?mouse_y@@3HA		; mouse_y
	add	eax, 24
	mov	DWORD PTR tv159[rsp], eax
	call	AuGetScreenHeight
	mov	ecx, DWORD PTR tv159[rsp]
	cmp	ecx, eax
	jbe	SHORT $LN13@mouse_hand

; 142  : 			mouse_y = AuGetScreenHeight() - 24;

	call	AuGetScreenHeight
	sub	eax, 24
	mov	DWORD PTR ?mouse_y@@3HA, eax		; mouse_y
$LN13@mouse_hand:

; 143  : 
; 144  : 		mouse_button_state = 0;

	mov	DWORD PTR ?mouse_button_state@@3IA, 0	; mouse_button_state

; 145  : 
; 146  : 		if (mouse_byte[0] & 0x01) {    //0x01 for PS/2

	mov	eax, 1
	imul	rax, 0
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN12@mouse_hand

; 147  : 			curr_button[0] = 1;

	mov	eax, 1
	imul	rax, 0
	lea	rcx, OFFSET FLAT:?curr_button@@3PAEA	; curr_button
	mov	BYTE PTR [rcx+rax], 1

; 148  : 			mouse_button_state = 1;

	mov	DWORD PTR ?mouse_button_state@@3IA, 1	; mouse_button_state

; 149  : 		}else

	jmp	SHORT $LN11@mouse_hand
$LN12@mouse_hand:

; 150  : 			curr_button[0] = 0;

	mov	eax, 1
	imul	rax, 0
	lea	rcx, OFFSET FLAT:?curr_button@@3PAEA	; curr_button
	mov	BYTE PTR [rcx+rax], 0
$LN11@mouse_hand:

; 151  : 
; 152  : 		if (mouse_byte[0] & 0x02) {

	mov	eax, 1
	imul	rax, 0
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN10@mouse_hand

; 153  : 			curr_button[2] = 1;

	mov	eax, 1
	imul	rax, 2
	lea	rcx, OFFSET FLAT:?curr_button@@3PAEA	; curr_button
	mov	BYTE PTR [rcx+rax], 1

; 154  : 		}else 

	jmp	SHORT $LN9@mouse_hand
$LN10@mouse_hand:

; 155  : 			curr_button[2] = 0;

	mov	eax, 1
	imul	rax, 2
	lea	rcx, OFFSET FLAT:?curr_button@@3PAEA	; curr_button
	mov	BYTE PTR [rcx+rax], 0
$LN9@mouse_hand:

; 156  : 
; 157  : 		if (mouse_byte[0] & 0x04)

	mov	eax, 1
	imul	rax, 0
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN8@mouse_hand

; 158  : 			mouse_button |= MOUSE_MIDDLE_CLICK;

	mov	eax, DWORD PTR ?mouse_button@@3HC	; mouse_button
	or	eax, 4
	mov	DWORD PTR ?mouse_button@@3HC, eax	; mouse_button
$LN8@mouse_hand:

; 159  : 
; 160  : 
; 161  : 		if (mouse_byte[4] & 0x1)

	mov	eax, 1
	imul	rax, 4
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN7@mouse_hand

; 162  : 			printf ("Mouse Vertical scroll up \n");

	lea	rcx, OFFSET FLAT:$SG3652
	call	printf
	jmp	SHORT $LN6@mouse_hand
$LN7@mouse_hand:

; 163  : 		else if (mouse_byte[4] & 0xF)

	mov	eax, 1
	imul	rax, 4
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 15
	test	eax, eax
	je	SHORT $LN5@mouse_hand

; 164  : 			printf ("Mouse Vertical scroll down \n");

	lea	rcx, OFFSET FLAT:$SG3655
	call	printf
	jmp	SHORT $LN4@mouse_hand
$LN5@mouse_hand:

; 165  : 		else if (mouse_byte[4] & 0x2)

	mov	eax, 1
	imul	rax, 4
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN3@mouse_hand

; 166  : 			printf ("Mouse Horizontal Scroll up \n");

	lea	rcx, OFFSET FLAT:$SG3658
	call	printf
	jmp	SHORT $LN2@mouse_hand
$LN3@mouse_hand:

; 167  : 		else if (mouse_byte[4] & 0xE)

	mov	eax, 1
	imul	rax, 4
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 14
	test	eax, eax
	je	SHORT $LN1@mouse_hand

; 168  : 			printf ("Mouse Horizontal Scroll down \n");

	lea	rcx, OFFSET FLAT:$SG3661
	call	printf
$LN1@mouse_hand:
$LN2@mouse_hand:
$LN4@mouse_hand:
$LN6@mouse_hand:

; 169  : 		//!Pass here the message stream to all waiting processes
; 170  : 	
; 171  : 		x64_cli();

	call	x64_cli

; 172  : 		dwm_message_t msg; // = (dwm_message_t*)pmmngr_alloc();
; 173  : 		msg.type = 1;

	mov	eax, 1
	mov	WORD PTR msg$4[rsp], ax

; 174  : 		msg.dword = mouse_x;

	mov	eax, DWORD PTR ?mouse_x@@3HA		; mouse_x
	mov	DWORD PTR msg$4[rsp+4], eax

; 175  : 		msg.dword2 = mouse_y;

	mov	eax, DWORD PTR ?mouse_y@@3HA		; mouse_y
	mov	DWORD PTR msg$4[rsp+8], eax

; 176  : 		msg.dword4 = mouse_button_state;

	mov	eax, DWORD PTR ?mouse_button_state@@3IA	; mouse_button_state
	mov	DWORD PTR msg$4[rsp+16], eax

; 177  : 		msg.dword5 = mouse_byte[1];

	mov	eax, 1
	imul	rax, 1
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR msg$4[rsp+20], eax

; 178  : 		msg.dword6 = -mouse_byte[2];

	mov	eax, 1
	imul	rax, 2
	lea	rcx, OFFSET FLAT:mouse_byte
	movzx	eax, BYTE PTR [rcx+rax]
	neg	eax
	mov	DWORD PTR msg$4[rsp+24], eax

; 179  : 		dwm_put_message (&msg);

	lea	rcx, QWORD PTR msg$4[rsp]
	call	?dwm_put_message@@YAXPEAU_dwm_message_@@@Z ; dwm_put_message

; 180  : 		x64_sti();

	call	x64_sti

; 181  : 		//pmmngr_free (msg);
; 182  : 		//mutex_unlock (mouse);
; 183  :     /*	if (left_button_up()) {
; 184  : 			mouse_button_state |= 5;
; 185  : 		}*/
; 186  : 
; 187  : 		memcpy (prev_button, curr_button, 3);

	mov	r8d, 3
	lea	rdx, OFFSET FLAT:?curr_button@@3PAEA	; curr_button
	lea	rcx, OFFSET FLAT:?prev_button@@3PAEA	; prev_button
	call	memcpy

; 188  : 		memset (curr_button, 0x00, 3);

	mov	r8d, 3
	xor	edx, edx
	lea	rcx, OFFSET FLAT:?curr_button@@3PAEA	; curr_button
	call	memset
$LN19@mouse_hand:
$read_next$37:

; 189  : read_next:
; 190  : 		break;

	jmp	SHORT $LN31@mouse_hand

; 191  : 	}

	jmp	$LN32@mouse_hand
$LN31@mouse_hand:

; 192  : 
; 193  : 	AuInterruptEnd(12);

	mov	ecx, 12
	call	AuInterruptEnd

; 194  : }

	add	rsp, 104				; 00000068H
	ret	0
?mouse_handler@@YAX_KPEAX@Z ENDP			; mouse_handler
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\mouse.cpp
_TEXT	SEGMENT
tv72 = 0
?left_button_up@@YAHXZ PROC				; left_button_up

; 75   : int left_button_up() {

$LN5:
	sub	rsp, 24

; 76   : 	return prev_button[0] && !curr_button[0];

	mov	eax, 1
	imul	rax, 0
	lea	rcx, OFFSET FLAT:?prev_button@@3PAEA	; prev_button
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN3@left_butto
	mov	eax, 1
	imul	rax, 0
	lea	rcx, OFFSET FLAT:?curr_button@@3PAEA	; curr_button
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN3@left_butto
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@left_butto
$LN3@left_butto:
	mov	DWORD PTR tv72[rsp], 0
$LN4@left_butto:
	mov	eax, DWORD PTR tv72[rsp]

; 77   : }

	add	rsp, 24
	ret	0
?left_button_up@@YAHXZ ENDP				; left_button_up
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\mouse.cpp
_TEXT	SEGMENT
?mouse_read@@YAEXZ PROC					; mouse_read

; 69   : uint8_t mouse_read () {

$LN3:
	sub	rsp, 40					; 00000028H

; 70   : 	mouse_wait (0);

	xor	ecx, ecx
	call	?mouse_wait@@YAXE@Z			; mouse_wait

; 71   : 	return inportb (0x60);

	mov	cx, 96					; 00000060H
	call	inportb

; 72   : }

	add	rsp, 40					; 00000028H
	ret	0
?mouse_read@@YAEXZ ENDP					; mouse_read
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\mouse.cpp
_TEXT	SEGMENT
write$ = 48
?mouse_write@@YAXE@Z PROC				; mouse_write

; 59   : void mouse_write (uint8_t write) {

$LN3:
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 40					; 00000028H

; 60   : 	mouse_wait (1);

	mov	cl, 1
	call	?mouse_wait@@YAXE@Z			; mouse_wait

; 61   : 	outportb (0x64, 0xD4);

	mov	dl, 212					; 000000d4H
	mov	cx, 100					; 00000064H
	call	outportb

; 62   : 	mouse_wait (1);

	mov	cl, 1
	call	?mouse_wait@@YAXE@Z			; mouse_wait

; 63   : 	outportb (0x60, write);

	movzx	edx, BYTE PTR write$[rsp]
	mov	cx, 96					; 00000060H
	call	outportb

; 64   : }

	add	rsp, 40					; 00000028H
	ret	0
?mouse_write@@YAXE@Z ENDP				; mouse_write
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\mouse.cpp
_TEXT	SEGMENT
_timer_out_$ = 32
tv68 = 36
tv76 = 40
a_type$ = 64
?mouse_wait@@YAXE@Z PROC				; mouse_wait

; 37   : void  mouse_wait (uint8_t a_type){

$LN11:
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 56					; 00000038H

; 38   : 	uint32_t _timer_out_ = 100000;

	mov	DWORD PTR _timer_out_$[rsp], 100000	; 000186a0H

; 39   : 	if (a_type == 0) {

	movzx	eax, BYTE PTR a_type$[rsp]
	test	eax, eax
	jne	SHORT $LN8@mouse_wait
$LN7@mouse_wait:

; 40   : 		while (_timer_out_--){

	mov	eax, DWORD PTR _timer_out_$[rsp]
	mov	DWORD PTR tv68[rsp], eax
	mov	eax, DWORD PTR _timer_out_$[rsp]
	dec	eax
	mov	DWORD PTR _timer_out_$[rsp], eax
	cmp	DWORD PTR tv68[rsp], 0
	je	SHORT $LN6@mouse_wait

; 41   : 			if ((x64_inportb(0x64) & 1) == 1){

	mov	cx, 100					; 00000064H
	call	x64_inportb
	movzx	eax, al
	and	eax, 1
	cmp	eax, 1
	jne	SHORT $LN5@mouse_wait

; 42   : 				return;

	jmp	SHORT $LN9@mouse_wait
$LN5@mouse_wait:

; 43   : 			}
; 44   : 		}

	jmp	SHORT $LN7@mouse_wait
$LN6@mouse_wait:

; 45   : 		return;

	jmp	SHORT $LN9@mouse_wait

; 46   : 	}else {

	jmp	SHORT $LN4@mouse_wait
$LN8@mouse_wait:
$LN3@mouse_wait:

; 47   : 		while (_timer_out_--){

	mov	eax, DWORD PTR _timer_out_$[rsp]
	mov	DWORD PTR tv76[rsp], eax
	mov	eax, DWORD PTR _timer_out_$[rsp]
	dec	eax
	mov	DWORD PTR _timer_out_$[rsp], eax
	cmp	DWORD PTR tv76[rsp], 0
	je	SHORT $LN2@mouse_wait

; 48   : 			if ((x64_inportb(0x64) & 2) == 0){

	mov	cx, 100					; 00000064H
	call	x64_inportb
	movzx	eax, al
	and	eax, 2
	test	eax, eax
	jne	SHORT $LN1@mouse_wait

; 49   : 				return;

	jmp	SHORT $LN9@mouse_wait
$LN1@mouse_wait:

; 50   : 			}
; 51   : 		}

	jmp	SHORT $LN3@mouse_wait
$LN2@mouse_wait:
$LN4@mouse_wait:
$LN9@mouse_wait:

; 52   : 		return;
; 53   : 	}
; 54   : }

	add	rsp, 56					; 00000038H
	ret	0
?mouse_wait@@YAXE@Z ENDP				; mouse_wait
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\mouse.cpp
_TEXT	SEGMENT
status$ = 32
?AuInitializeMouse@@YAXXZ PROC				; AuInitializeMouse

; 241  : void AuInitializeMouse () {

$LN3:
	sub	rsp, 56					; 00000038H

; 242  : 	mouse_cycle = 0;

	mov	BYTE PTR mouse_cycle, 0

; 243  : 	mouse_x = 0;

	mov	DWORD PTR ?mouse_x@@3HA, 0		; mouse_x

; 244  : 	mouse_y = 0;

	mov	DWORD PTR ?mouse_y@@3HA, 0		; mouse_y

; 245  : 
; 246  : 	uint8_t status;
; 247  : 
; 248  : 	mouse_wait (1);

	mov	cl, 1
	call	?mouse_wait@@YAXE@Z			; mouse_wait

; 249  :     outportb (0x64, 0xA8);

	mov	dl, 168					; 000000a8H
	mov	cx, 100					; 00000064H
	call	outportb

; 250  : 
; 251  : 	mouse_wait(1);

	mov	cl, 1
	call	?mouse_wait@@YAXE@Z			; mouse_wait

; 252  : 	outportb (0x64, 0x20);

	mov	dl, 32					; 00000020H
	mov	cx, 100					; 00000064H
	call	outportb

; 253  : 
; 254  : 	mouse_wait (0);

	xor	ecx, ecx
	call	?mouse_wait@@YAXE@Z			; mouse_wait

; 255  : 	status = (inportb (0x60) | 2);

	mov	cx, 96					; 00000060H
	call	inportb
	movzx	eax, al
	or	eax, 2
	mov	BYTE PTR status$[rsp], al

; 256  : 
; 257  : 	mouse_wait (1);

	mov	cl, 1
	call	?mouse_wait@@YAXE@Z			; mouse_wait

; 258  : 	outportb (0x64, 0x60);

	mov	dl, 96					; 00000060H
	mov	cx, 100					; 00000064H
	call	outportb

; 259  : 
; 260  : 	mouse_wait (1);

	mov	cl, 1
	call	?mouse_wait@@YAXE@Z			; mouse_wait

; 261  : 	outportb (0x60, status);

	movzx	edx, BYTE PTR status$[rsp]
	mov	cx, 96					; 00000060H
	call	outportb

; 262  : 
; 263  : 	mouse_write (0xF6);

	mov	cl, 246					; 000000f6H
	call	?mouse_write@@YAXE@Z			; mouse_write

; 264  : 	mouse_read ();

	call	?mouse_read@@YAEXZ			; mouse_read

; 265  : 
; 266  : 	mouse_write (0xF4);

	mov	cl, 244					; 000000f4H
	call	?mouse_write@@YAXE@Z			; mouse_write

; 267  : 	mouse_read ();

	call	?mouse_read@@YAEXZ			; mouse_read

; 268  : 
; 269  : 	AuInterruptSet (34, mouse_handler, 12);  //34

	mov	r8b, 12
	lea	rdx, OFFSET FLAT:?mouse_handler@@YAX_KPEAX@Z ; mouse_handler
	mov	ecx, 34					; 00000022H
	call	AuInterruptSet

; 270  : 	printf ("mouse interrupt setupped\n");

	lea	rcx, OFFSET FLAT:$SG3686
	call	printf

; 271  : 	mouse_register_device ();

	call	?mouse_register_device@@YAXXZ		; mouse_register_device

; 272  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuInitializeMouse@@YAXXZ ENDP				; AuInitializeMouse
_TEXT	ENDS
END
