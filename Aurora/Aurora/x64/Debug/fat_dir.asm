; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3677	DB	'Listing Files', 0aH, 00H
	ORG $+1
$SG3683	DB	'%s         %d KB ', 0aH, 00H
	ORG $+5
$SG3695	DB	'Creating directory ', 0dH, 0aH, 00H
	ORG $+2
$SG3727	DB	'FAT32: Directory created at entry-> %d ', 0dH, 0aH, 00H
	ORG $+6
$SG3741	DB	'Creating directory ', 0dH, 0aH, 00H
	ORG $+2
$SG3759	DB	'FAT32: Directory opened at entry-> %d ', 0dH, 0aH, 00H
CONST	ENDS
PUBLIC	?fat32_find_free_dir_entry@@YAXI@Z		; fat32_find_free_dir_entry
PUBLIC	?fat32_make_dir@@YAPEAU_vfs_node_@@IPEAD@Z	; fat32_make_dir
PUBLIC	?fat32_open_dir@@YAPEAU_vfs_node_@@IPEAD@Z	; fat32_open_dir
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	?fat32_to_dos_file_name@@YAXPEBDPEADI@Z:PROC	; fat32_to_dos_file_name
EXTRN	?_debug_print_@@YAXPEADZZ:PROC			; _debug_print_
EXTRN	?fat32_find_free_cluster@@YAIXZ:PROC		; fat32_find_free_cluster
EXTRN	?fat32_alloc_cluster@@YAXHI@Z:PROC		; fat32_alloc_cluster
EXTRN	?fat32_get_root_cluster@@YAIXZ:PROC		; fat32_get_root_cluster
EXTRN	?fat32_get_sector_per_cluster@@YA_KXZ:PROC	; fat32_get_sector_per_cluster
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	malloc:PROC
EXTRN	free:PROC
EXTRN	?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z:PROC ; ahci_disk_write
EXTRN	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z:PROC ; ahci_disk_read
EXTRN	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ:PROC	; ahci_disk_get_port
EXTRN	printf:PROC
EXTRN	?fat32_read_fat@@YAII@Z:PROC			; fat32_read_fat
EXTRN	?fat32_clear_cluster@@YAXI@Z:PROC		; fat32_clear_cluster
EXTRN	?cluster_to_sector32@@YA_K_K@Z:PROC		; cluster_to_sector32
EXTRN	?fat32_format_date@@YAGXZ:PROC			; fat32_format_date
EXTRN	?fat32_format_time@@YAGXZ:PROC			; fat32_format_time
pdata	SEGMENT
$pdata$?fat32_find_free_dir_entry@@YAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+226
	DD	imagerel $unwind$?fat32_find_free_dir_entry@@YAXI@Z
$pdata$?fat32_make_dir@@YAPEAU_vfs_node_@@IPEAD@Z DD imagerel $LN16
	DD	imagerel $LN16+1444
	DD	imagerel $unwind$?fat32_make_dir@@YAPEAU_vfs_node_@@IPEAD@Z
$pdata$?fat32_open_dir@@YAPEAU_vfs_node_@@IPEAD@Z DD imagerel $LN13
	DD	imagerel $LN13+578
	DD	imagerel $unwind$?fat32_open_dir@@YAPEAU_vfs_node_@@IPEAD@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?fat32_find_free_dir_entry@@YAXI@Z DD 010801H
	DD	0a208H
$unwind$?fat32_make_dir@@YAPEAU_vfs_node_@@IPEAD@Z DD 021001H
	DD	0170110H
$unwind$?fat32_open_dir@@YAPEAU_vfs_node_@@IPEAD@Z DD 021001H
	DD	0110110H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat_dir.cpp
_TEXT	SEGMENT
is_parent_root$ = 32
file$ = 40
i$1 = 48
j$2 = 52
buff$ = 56
dirent$3 = 64
fname$ = 72
tv95 = 88
tv83 = 96
cmpname$4 = 104
buffer$5 = 120
parent_clust$ = 144
filename$ = 152
?fat32_open_dir@@YAPEAU_vfs_node_@@IPEAD@Z PROC		; fat32_open_dir

; 202  : vfs_node_t *fat32_open_dir (uint32_t parent_clust, char* filename) {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 136				; 00000088H

; 203  : 	vfs_node_t *file = (vfs_node_t*)malloc(sizeof(vfs_node_t));

	mov	ecx, 104				; 00000068H
	call	malloc
	mov	QWORD PTR file$[rsp], rax

; 204  : 	memset(file, 0, sizeof(vfs_node_t));

	mov	r8d, 104				; 00000068H
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rsp]
	call	memset

; 205  : 
; 206  : 
; 207  : 	uint64_t* buff = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buff$[rsp], rax

; 208  : 	memset(buff, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 209  : 
; 210  : 	bool is_parent_root = false;

	mov	BYTE PTR is_parent_root$[rsp], 0

; 211  : 
; 212  : 	_debug_print_ ("Creating directory \r\n");

	lea	rcx, OFFSET FLAT:$SG3741
	call	?_debug_print_@@YAXPEADZZ		; _debug_print_

; 213  : 
; 214  : 	char fname[11];
; 215  : 	memset(fname,0,11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR fname$[rsp]
	call	memset

; 216  : 	fat32_to_dos_file_name (filename, fname, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?fat32_to_dos_file_name@@YAXPEBDPEADI@Z	; fat32_to_dos_file_name

; 217  : 
; 218  : 	if (parent_clust == fat32_get_root_cluster ())

	call	?fat32_get_root_cluster@@YAIXZ		; fat32_get_root_cluster
	cmp	DWORD PTR parent_clust$[rsp], eax
	jne	SHORT $LN10@fat32_open

; 219  : 		is_parent_root = true;

	mov	BYTE PTR is_parent_root$[rsp], 1
$LN10@fat32_open:
$search$14:

; 220  : 
; 221  : search:
; 222  : 	for (int j = 0; j < fat32_get_sector_per_cluster(); j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN9@fat32_open
$LN8@fat32_open:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN9@fat32_open:
	movsxd	rax, DWORD PTR j$2[rsp]
	mov	QWORD PTR tv83[rsp], rax
	call	?fat32_get_sector_per_cluster@@YA_KXZ	; fat32_get_sector_per_cluster
	mov	rcx, QWORD PTR tv83[rsp]
	cmp	rcx, rax
	jae	$LN7@fat32_open

; 223  : 		memset(buff,0,4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 224  : 		ahci_disk_read (ahci_disk_get_port(), cluster_to_sector32(parent_clust) + j, 1,buff);

	mov	eax, DWORD PTR parent_clust$[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	movsxd	rcx, DWORD PTR j$2[rsp]
	add	rax, rcx
	mov	QWORD PTR tv95[rsp], rax
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buff$[rsp]
	mov	r8d, 1
	mov	rcx, QWORD PTR tv95[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 225  : 
; 226  : 		unsigned char* buffer = (unsigned char*)buff;

	mov	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR buffer$5[rsp], rax

; 227  : 		fat32_dir *dirent = (fat32_dir*)buff;

	mov	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR dirent$3[rsp], rax

; 228  : 		for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@fat32_open
$LN5@fat32_open:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@fat32_open:
	cmp	DWORD PTR i$1[rsp], 16
	jge	$LN4@fat32_open

; 229  : 
; 230  : 			char cmpname[11];
; 231  : 			memcpy (cmpname,dirent->filename, 11);

	mov	rax, QWORD PTR dirent$3[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR cmpname$4[rsp]
	call	memcpy

; 232  : 
; 233  : 			if (strcmp(cmpname,fname) == 0) {

	lea	rdx, QWORD PTR fname$[rsp]
	lea	rcx, QWORD PTR cmpname$4[rsp]
	call	strcmp
	test	eax, eax
	jne	SHORT $LN3@fat32_open

; 234  : 				strcpy (file->filename,fname);

	mov	rax, QWORD PTR file$[rsp]
	lea	rdx, QWORD PTR fname$[rsp]
	mov	rcx, rax
	call	strcpy

; 235  : 				file->size = dirent->file_size;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR dirent$3[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+32], ecx

; 236  : 				file->eof = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 0

; 237  : 				file->pos = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+40], 0

; 238  : 				file->current = dirent->first_cluster;

	mov	rax, QWORD PTR dirent$3[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	rcx, QWORD PTR file$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 239  : 				file->flags = FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+48], 1

; 240  : 				file->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+49], 4

; 241  : 				AuPmmngrFree(buff);

	mov	rcx, QWORD PTR buff$[rsp]
	call	AuPmmngrFree

; 242  : 				_debug_print_ ("FAT32: Directory opened at entry-> %d \r\n",i);

	mov	edx, DWORD PTR i$1[rsp]
	lea	rcx, OFFSET FLAT:$SG3759
	call	?_debug_print_@@YAXPEADZZ		; _debug_print_

; 243  : 			    return file;

	mov	rax, QWORD PTR file$[rsp]
	jmp	SHORT $LN11@fat32_open
$LN3@fat32_open:

; 244  : 			}
; 245  : 			dirent++;

	mov	rax, QWORD PTR dirent$3[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$3[rsp], rax

; 246  : 		}

	jmp	$LN5@fat32_open
$LN4@fat32_open:

; 247  : 	}

	jmp	$LN8@fat32_open
$LN7@fat32_open:

; 248  : 	parent_clust = fat32_read_fat(parent_clust);

	mov	ecx, DWORD PTR parent_clust$[rsp]
	call	?fat32_read_fat@@YAII@Z			; fat32_read_fat
	mov	DWORD PTR parent_clust$[rsp], eax

; 249  : 	if (parent_clust != FAT_EOC_MARK)

	cmp	DWORD PTR parent_clust$[rsp], -8	; fffffff8H
	je	SHORT $LN2@fat32_open

; 250  : 		goto search;

	jmp	$search$14

; 251  : 	else {

	jmp	SHORT $LN1@fat32_open
$LN2@fat32_open:

; 252  : 		free(file);

	mov	rcx, QWORD PTR file$[rsp]
	call	free

; 253  : 		return NULL;

	xor	eax, eax
$LN1@fat32_open:
$LN11@fat32_open:

; 254  : 	}
; 255  : }

	add	rsp, 136				; 00000088H
	ret	0
?fat32_open_dir@@YAPEAU_vfs_node_@@IPEAD@Z ENDP		; fat32_open_dir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat_dir.cpp
_TEXT	SEGMENT
dirent$1 = 32
is_parent_root$ = 40
dot_dot$2 = 48
dot_entry$3 = 56
cluster$4 = 64
j$5 = 68
file$ = 72
i$6 = 80
buff$ = 88
entrybuf$7 = 96
fname$ = 104
tv234 = 120
tv246 = 128
entry$8 = 136
tv83 = 144
buffer$9 = 152
tv231 = 160
tv95 = 168
parent_clust$ = 192
filename$ = 200
?fat32_make_dir@@YAPEAU_vfs_node_@@IPEAD@Z PROC		; fat32_make_dir

; 85   : vfs_node_t *fat32_make_dir (uint32_t parent_clust, char* filename) {

$LN16:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 184				; 000000b8H

; 86   : 	vfs_node_t *file = (vfs_node_t*)malloc(sizeof(vfs_node_t));

	mov	ecx, 104				; 00000068H
	call	malloc
	mov	QWORD PTR file$[rsp], rax

; 87   : 	memset(file, 0, sizeof(vfs_node_t));

	mov	r8d, 104				; 00000068H
	xor	edx, edx
	mov	rcx, QWORD PTR file$[rsp]
	call	memset

; 88   : 
; 89   : 
; 90   : 	uint64_t* buff = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buff$[rsp], rax

; 91   : 	memset(buff, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 92   : 
; 93   : 	bool is_parent_root = false;

	mov	BYTE PTR is_parent_root$[rsp], 0

; 94   : 
; 95   : 	_debug_print_ ("Creating directory \r\n");

	lea	rcx, OFFSET FLAT:$SG3695
	call	?_debug_print_@@YAXPEADZZ		; _debug_print_

; 96   : 
; 97   : 	char fname[11];
; 98   : 	memset(fname,0,11);

	mov	r8d, 11
	xor	edx, edx
	lea	rcx, QWORD PTR fname$[rsp]
	call	memset

; 99   : 	fat32_to_dos_file_name (filename, fname, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?fat32_to_dos_file_name@@YAXPEBDPEADI@Z	; fat32_to_dos_file_name

; 100  : 
; 101  : 	if (parent_clust == fat32_get_root_cluster ())

	call	?fat32_get_root_cluster@@YAIXZ		; fat32_get_root_cluster
	cmp	DWORD PTR parent_clust$[rsp], eax
	jne	SHORT $LN13@fat32_make

; 102  : 		is_parent_root = true;

	mov	BYTE PTR is_parent_root$[rsp], 1
$LN13@fat32_make:
$search$17:

; 103  : 
; 104  : search:
; 105  : 	for (int j = 0; j < fat32_get_sector_per_cluster(); j++) {

	mov	DWORD PTR j$5[rsp], 0
	jmp	SHORT $LN12@fat32_make
$LN11@fat32_make:
	mov	eax, DWORD PTR j$5[rsp]
	inc	eax
	mov	DWORD PTR j$5[rsp], eax
$LN12@fat32_make:
	movsxd	rax, DWORD PTR j$5[rsp]
	mov	QWORD PTR tv83[rsp], rax
	call	?fat32_get_sector_per_cluster@@YA_KXZ	; fat32_get_sector_per_cluster
	mov	rcx, QWORD PTR tv83[rsp]
	cmp	rcx, rax
	jae	$LN10@fat32_make

; 106  : 		memset(buff,0,4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buff$[rsp]
	call	memset

; 107  : 		ahci_disk_read (ahci_disk_get_port(), cluster_to_sector32(parent_clust) + j, 1,buff);

	mov	eax, DWORD PTR parent_clust$[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	movsxd	rcx, DWORD PTR j$5[rsp]
	add	rax, rcx
	mov	QWORD PTR tv95[rsp], rax
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buff$[rsp]
	mov	r8d, 1
	mov	rcx, QWORD PTR tv95[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 108  : 
; 109  : 		unsigned char* buffer = (unsigned char*)buff;

	mov	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR buffer$9[rsp], rax

; 110  : 		fat32_dir *dirent = (fat32_dir*)buff;

	mov	rax, QWORD PTR buff$[rsp]
	mov	QWORD PTR dirent$1[rsp], rax

; 111  : 		for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$6[rsp], 0
	jmp	SHORT $LN9@fat32_make
$LN8@fat32_make:
	mov	eax, DWORD PTR i$6[rsp]
	inc	eax
	mov	DWORD PTR i$6[rsp], eax
$LN9@fat32_make:
	cmp	DWORD PTR i$6[rsp], 16
	jge	$LN7@fat32_make

; 112  : 			if (dirent->filename[0] == 0x00 || dirent->filename[0] == 0xE5) {

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN5@fat32_make
	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 229				; 000000e5H
	jne	$LN6@fat32_make
$LN5@fat32_make:

; 113  : 				memcpy (dirent->filename, fname,11);

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	r8d, 11
	lea	rdx, QWORD PTR fname$[rsp]
	mov	rcx, rax
	call	memcpy

; 114  : 
; 115  : 				uint32_t cluster = fat32_find_free_cluster();

	call	?fat32_find_free_cluster@@YAIXZ		; fat32_find_free_cluster
	mov	DWORD PTR cluster$4[rsp], eax

; 116  : 				fat32_alloc_cluster (cluster,FAT_EOC_MARK);

	mov	edx, -8					; fffffff8H
	mov	ecx, DWORD PTR cluster$4[rsp]
	call	?fat32_alloc_cluster@@YAXHI@Z		; fat32_alloc_cluster

; 117  : 				fat32_clear_cluster(cluster);

	mov	ecx, DWORD PTR cluster$4[rsp]
	call	?fat32_clear_cluster@@YAXI@Z		; fat32_clear_cluster

; 118  : 
; 119  : 				dirent->attrib = ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	BYTE PTR [rax+11], 16

; 120  : 				dirent->first_cluster = cluster & 0x0000FFFF;

	mov	eax, DWORD PTR cluster$4[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+26], ax

; 121  : 				dirent->first_cluster_hi_bytes = (cluster & 0x0FFF0000)>>16;

	mov	eax, DWORD PTR cluster$4[rsp]
	and	eax, 268369920				; 0fff0000H
	shr	eax, 16
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+20], ax

; 122  : 				dirent->date_created = fat32_format_date();

	call	?fat32_format_date@@YAGXZ		; fat32_format_date
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+16], ax

; 123  : 				dirent->time_created = fat32_format_time();

	call	?fat32_format_time@@YAGXZ		; fat32_format_time
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+14], ax

; 124  : 				dirent->last_wrt_date = dirent->date_created;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+24], cx

; 125  : 				dirent->last_wrt_time = dirent->time_created;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+14]
	mov	WORD PTR [rax+22], cx

; 126  : 				dirent->date_last_accessed = 0;

	xor	eax, eax
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	WORD PTR [rcx+18], ax

; 127  : 				dirent->file_size = 0;

	mov	rax, QWORD PTR dirent$1[rsp]
	mov	DWORD PTR [rax+28], 0

; 128  : 
; 129  : 				uint64_t* entrybuf = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR entrybuf$7[rsp], rax

; 130  : 				memset(entrybuf, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR entrybuf$7[rsp]
	call	memset

; 131  : 				uint8_t* entry = (uint8_t*)entrybuf;

	mov	rax, QWORD PTR entrybuf$7[rsp]
	mov	QWORD PTR entry$8[rsp], rax

; 132  : 
; 133  : 				fat32_dir *dot_entry = (fat32_dir*)entrybuf;

	mov	rax, QWORD PTR entrybuf$7[rsp]
	mov	QWORD PTR dot_entry$3[rsp], rax

; 134  : 				memset(dot_entry, 0, sizeof(fat32_dir));

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR dot_entry$3[rsp]
	call	memset

; 135  : 				dot_entry->filename[0] = '.';

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR dot_entry$3[rsp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH

; 136  : 				memset(dot_entry->filename+1,0x20,10);

	mov	rax, QWORD PTR dot_entry$3[rsp]
	inc	rax
	mov	r8d, 10
	mov	dl, 32					; 00000020H
	mov	rcx, rax
	call	memset

; 137  : 				dot_entry->attrib = ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dot_entry$3[rsp]
	mov	BYTE PTR [rax+11], 16

; 138  : 				dot_entry->date_created = dirent->date_created;

	mov	rax, QWORD PTR dot_entry$3[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+16], cx

; 139  : 				dot_entry->time_created = dirent->time_created;

	mov	rax, QWORD PTR dot_entry$3[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+14]
	mov	WORD PTR [rax+14], cx

; 140  : 				dot_entry->date_last_accessed = dirent->date_last_accessed;

	mov	rax, QWORD PTR dot_entry$3[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+18]
	mov	WORD PTR [rax+18], cx

; 141  : 			    dot_entry->file_size = 0;

	mov	rax, QWORD PTR dot_entry$3[rsp]
	mov	DWORD PTR [rax+28], 0

; 142  : 			    dot_entry->first_cluster = dirent->first_cluster;

	mov	rax, QWORD PTR dot_entry$3[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+26]
	mov	WORD PTR [rax+26], cx

; 143  : 			    dot_entry->first_cluster_hi_bytes = dirent->first_cluster_hi_bytes;

	mov	rax, QWORD PTR dot_entry$3[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+20]
	mov	WORD PTR [rax+20], cx

; 144  : 			    dot_entry->last_wrt_date = dirent->last_wrt_date;

	mov	rax, QWORD PTR dot_entry$3[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+24]
	mov	WORD PTR [rax+24], cx

; 145  : 			    dot_entry->last_wrt_time = dirent->last_wrt_time;

	mov	rax, QWORD PTR dot_entry$3[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+22]
	mov	WORD PTR [rax+22], cx

; 146  : 		
; 147  : 			    fat32_dir *dot_dot = (fat32_dir*)(entrybuf + sizeof(fat32_dir));

	mov	rax, QWORD PTR entrybuf$7[rsp]
	add	rax, 256				; 00000100H
	mov	QWORD PTR dot_dot$2[rsp], rax

; 148  : 			    memset(dot_dot, 0, sizeof(fat32_dir));

	mov	r8d, 32					; 00000020H
	xor	edx, edx
	mov	rcx, QWORD PTR dot_dot$2[rsp]
	call	memset

; 149  : 				dot_dot->filename[0] = '.';

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR dot_dot$2[rsp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH

; 150  : 				dot_dot->filename[1] = '.';

	mov	eax, 1
	imul	rax, 1
	mov	rcx, QWORD PTR dot_dot$2[rsp]
	mov	BYTE PTR [rcx+rax], 46			; 0000002eH

; 151  : 			    dot_dot->attrib = ATTRIBUTE_DIRECTORY;

	mov	rax, QWORD PTR dot_dot$2[rsp]
	mov	BYTE PTR [rax+11], 16

; 152  : 			    dot_dot->date_created = dirent->date_created;

	mov	rax, QWORD PTR dot_dot$2[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+16]
	mov	WORD PTR [rax+16], cx

; 153  : 				dot_dot->time_created = dirent->time_created;

	mov	rax, QWORD PTR dot_dot$2[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+14]
	mov	WORD PTR [rax+14], cx

; 154  : 			    dot_dot->date_last_accessed = dirent->date_last_accessed;

	mov	rax, QWORD PTR dot_dot$2[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+18]
	mov	WORD PTR [rax+18], cx

; 155  : 			    dot_dot->file_size = 0;

	mov	rax, QWORD PTR dot_dot$2[rsp]
	mov	DWORD PTR [rax+28], 0

; 156  : 
; 157  : 				if (is_parent_root) {

	movzx	eax, BYTE PTR is_parent_root$[rsp]
	test	eax, eax
	je	SHORT $LN4@fat32_make

; 158  : 					dot_dot->first_cluster = 0 & 0x0000FFFF;

	xor	eax, eax
	mov	rcx, QWORD PTR dot_dot$2[rsp]
	mov	WORD PTR [rcx+26], ax

; 159  : 					dot_dot->first_cluster_hi_bytes = (0 & 0x0FFF0000)>>16;

	xor	eax, eax
	mov	rcx, QWORD PTR dot_dot$2[rsp]
	mov	WORD PTR [rcx+20], ax

; 160  : 				}else {

	jmp	SHORT $LN3@fat32_make
$LN4@fat32_make:

; 161  : 					dot_dot->first_cluster = parent_clust & 0x0000FFFF;

	mov	eax, DWORD PTR parent_clust$[rsp]
	and	eax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR dot_dot$2[rsp]
	mov	WORD PTR [rcx+26], ax

; 162  : 					dot_dot->first_cluster_hi_bytes = (0 & 0x0FFF0000)>>16;

	xor	eax, eax
	mov	rcx, QWORD PTR dot_dot$2[rsp]
	mov	WORD PTR [rcx+20], ax
$LN3@fat32_make:

; 163  : 				}
; 164  : 
; 165  : 			    dot_dot->last_wrt_date = dirent->last_wrt_date;

	mov	rax, QWORD PTR dot_dot$2[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+24]
	mov	WORD PTR [rax+24], cx

; 166  : 			    dot_dot->last_wrt_time = dirent->last_wrt_time;

	mov	rax, QWORD PTR dot_dot$2[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	movzx	ecx, WORD PTR [rcx+22]
	mov	WORD PTR [rax+22], cx

; 167  : 
; 168  : 				ahci_disk_write (ahci_disk_get_port(),cluster_to_sector32(cluster),fat32_get_sector_per_cluster(),entrybuf);

	call	?fat32_get_sector_per_cluster@@YA_KXZ	; fat32_get_sector_per_cluster
	mov	QWORD PTR tv231[rsp], rax
	mov	ecx, DWORD PTR cluster$4[rsp]
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	QWORD PTR tv234[rsp], rax
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR entrybuf$7[rsp]
	mov	rcx, QWORD PTR tv231[rsp]
	mov	r8d, ecx
	mov	rcx, QWORD PTR tv234[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_write

; 169  : 			    ahci_disk_write (ahci_disk_get_port(),cluster_to_sector32(parent_clust) + j,1,buff);

	mov	eax, DWORD PTR parent_clust$[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	movsxd	rcx, DWORD PTR j$5[rsp]
	add	rax, rcx
	mov	QWORD PTR tv246[rsp], rax
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buff$[rsp]
	mov	r8d, 1
	mov	rcx, QWORD PTR tv246[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_write

; 170  : 			    AuPmmngrFree(entry);

	mov	rcx, QWORD PTR entry$8[rsp]
	call	AuPmmngrFree

; 171  : 			    AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$9[rsp]
	call	AuPmmngrFree

; 172  : 
; 173  : 				strcpy (file->filename,fname);

	mov	rax, QWORD PTR file$[rsp]
	lea	rdx, QWORD PTR fname$[rsp]
	mov	rcx, rax
	call	strcpy

; 174  : 				file->size = dirent->file_size;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR dirent$1[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+32], ecx

; 175  : 				file->eof = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 0

; 176  : 				file->pos = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	DWORD PTR [rax+40], 0

; 177  : 				file->current = dirent->first_cluster;

	mov	rax, QWORD PTR dirent$1[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	rcx, QWORD PTR file$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 178  : 				file->flags = FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+48], 1

; 179  : 				file->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+49], 4

; 180  : 
; 181  : 				_debug_print_ ("FAT32: Directory created at entry-> %d \r\n",i);

	mov	edx, DWORD PTR i$6[rsp]
	lea	rcx, OFFSET FLAT:$SG3727
	call	?_debug_print_@@YAXPEADZZ		; _debug_print_

; 182  : 			    return file;

	mov	rax, QWORD PTR file$[rsp]
	jmp	SHORT $LN14@fat32_make
$LN6@fat32_make:

; 183  : 			}
; 184  : 			dirent++;

	mov	rax, QWORD PTR dirent$1[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$1[rsp], rax

; 185  : 		}

	jmp	$LN8@fat32_make
$LN7@fat32_make:

; 186  : 	}

	jmp	$LN11@fat32_make
$LN10@fat32_make:

; 187  : 	parent_clust = fat32_read_fat(parent_clust);

	mov	ecx, DWORD PTR parent_clust$[rsp]
	call	?fat32_read_fat@@YAII@Z			; fat32_read_fat
	mov	DWORD PTR parent_clust$[rsp], eax

; 188  : 	if (parent_clust != 0x0FFFFFF7)

	cmp	DWORD PTR parent_clust$[rsp], 268435447	; 0ffffff7H
	je	SHORT $LN2@fat32_make

; 189  : 		goto search;

	jmp	$search$17

; 190  : 	else {

	jmp	SHORT $LN1@fat32_make
$LN2@fat32_make:

; 191  : 		free(file);

	mov	rcx, QWORD PTR file$[rsp]
	call	free

; 192  : 		return NULL;

	xor	eax, eax
$LN1@fat32_make:
$LN14@fat32_make:

; 193  : 	}
; 194  : }

	add	rsp, 184				; 000000b8H
	ret	0
?fat32_make_dir@@YAPEAU_vfs_node_@@IPEAD@Z ENDP		; fat32_make_dir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat_dir.cpp
_TEXT	SEGMENT
i$1 = 32
dirent$ = 40
buffer$ = 48
tv69 = 56
tv72 = 64
dir$ = 72
cluster$ = 96
?fat32_find_free_dir_entry@@YAXI@Z PROC			; fat32_find_free_dir_entry

; 60   : void fat32_find_free_dir_entry (uint32_t cluster) {

$LN7:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 61   : 	uint64_t* buffer = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buffer$[rsp], rax

; 62   : 	memset(buffer, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 63   : 
; 64   : 	ahci_disk_read (ahci_disk_get_port(),cluster_to_sector32(cluster),fat32_get_sector_per_cluster(),buffer);

	call	?fat32_get_sector_per_cluster@@YA_KXZ	; fat32_get_sector_per_cluster
	mov	QWORD PTR tv69[rsp], rax
	mov	ecx, DWORD PTR cluster$[rsp]
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	QWORD PTR tv72[rsp], rax
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	mov	r8d, ecx
	mov	rcx, QWORD PTR tv72[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 65   : 	
; 66   : 	fat32_dir *dir = 0;

	mov	QWORD PTR dir$[rsp], 0

; 67   : 	fat32_dir *dirent = (fat32_dir*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR dirent$[rsp], rax

; 68   : 
; 69   : 	printf ("Listing Files\n");

	lea	rcx, OFFSET FLAT:$SG3677
	call	printf

; 70   : 	for (int i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@fat32_find
$LN3@fat32_find:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@fat32_find:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN2@fat32_find

; 71   : 		if (dirent->attrib != 0)

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, BYTE PTR [rax+11]
	test	eax, eax
	je	SHORT $LN1@fat32_find

; 72   : 			printf ("%s         %d KB \n", dirent->filename, dirent->file_size / 1024);

	xor	edx, edx
	mov	rax, QWORD PTR dirent$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	ecx, 1024				; 00000400H
	div	ecx
	mov	rcx, QWORD PTR dirent$[rsp]
	mov	r8d, eax
	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:$SG3683
	call	printf
$LN1@fat32_find:

; 73   : 		dirent++;

	mov	rax, QWORD PTR dirent$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$[rsp], rax

; 74   : 	}

	jmp	SHORT $LN3@fat32_find
$LN2@fat32_find:

; 75   : 
; 76   : }

	add	rsp, 88					; 00000058H
	ret	0
?fat32_find_free_dir_entry@@YAXI@Z ENDP			; fat32_find_free_dir_entry
_TEXT	ENDS
END
