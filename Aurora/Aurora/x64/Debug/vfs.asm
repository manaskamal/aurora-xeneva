; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?sys@@3PAPEAU_file_system_@@A			; sys
_BSS	SEGMENT
?sys@@3PAPEAU_file_system_@@A DQ 0100H DUP (?)		; sys
_BSS	ENDS
PUBLIC	?initialize_vfs@@YAXXZ				; initialize_vfs
PUBLIC	?open@@YA?AU_file_@@PEBD@Z			; open
PUBLIC	?read@@YAXPEAU_file_@@PEAEIH@Z			; read
PUBLIC	?read_blk@@YAXPEAU_file_@@PEAEH@Z		; read_blk
PUBLIC	?vfs_register@@YAXHPEAU_file_system_@@@Z	; vfs_register
PUBLIC	?vfs_get_file_system@@YAPEAU_file_system_@@H@Z	; vfs_get_file_system
PUBLIC	?vfs_io_query@@YAXHHPEAX@Z			; vfs_io_query
EXTRN	?initialize_fat32@@YAXXZ:PROC			; initialize_fat32
EXTRN	?fat32_self_register@@YAXXZ:PROC		; fat32_self_register
pdata	SEGMENT
$pdata$?initialize_vfs@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$?initialize_vfs@@YAXXZ
$pdata$?open@@YA?AU_file_@@PEBD@Z DD imagerel $LN9
	DD	imagerel $LN9+286
	DD	imagerel $unwind$?open@@YA?AU_file_@@PEBD@Z
$pdata$?read@@YAXPEAU_file_@@PEAEIH@Z DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$?read@@YAXPEAU_file_@@PEAEIH@Z
$pdata$?read_blk@@YAXPEAU_file_@@PEAEH@Z DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$?read_blk@@YAXPEAU_file_@@PEAEH@Z
$pdata$?vfs_io_query@@YAXHHPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$?vfs_io_query@@YAXHHPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?initialize_vfs@@YAXXZ DD 010401H
	DD	04204H
$unwind$?open@@YA?AU_file_@@PEBD@Z DD 041301H
	DD	01f0113H
	DD	0600b700cH
$unwind$?read@@YAXPEAU_file_@@PEAEIH@Z DD 011801H
	DD	04218H
$unwind$?read_blk@@YAXPEAU_file_@@PEAEH@Z DD 011301H
	DD	04213H
$unwind$?vfs_io_query@@YAXHHPEAX@Z DD 011101H
	DD	04211H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\vfs.cpp
_TEXT	SEGMENT
device_id$ = 48
code$ = 56
arg$ = 64
?vfs_io_query@@YAXHHPEAX@Z PROC				; vfs_io_query

; 59   : void vfs_io_query (int device_id, int code, void* arg) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 60   : 
; 61   : 	//! INVALID device id code
; 62   : 	if (device_id < 0)

	cmp	DWORD PTR device_id$[rsp], 0
	jge	SHORT $LN1@vfs_io_que

; 63   : 		return;

	jmp	SHORT $LN2@vfs_io_que
$LN1@vfs_io_que:

; 64   : 
; 65   : 	sys[device_id]->ioquery(code, arg);

	movsxd	rax, DWORD PTR device_id$[rsp]
	lea	rcx, OFFSET FLAT:?sys@@3PAPEAU_file_system_@@A ; sys
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rdx, QWORD PTR arg$[rsp]
	mov	ecx, DWORD PTR code$[rsp]
	call	QWORD PTR [rax+32]
$LN2@vfs_io_que:

; 66   : }

	add	rsp, 40					; 00000028H
	ret	0
?vfs_io_query@@YAXHHPEAX@Z ENDP				; vfs_io_query
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\vfs.cpp
_TEXT	SEGMENT
id$ = 8
?vfs_get_file_system@@YAPEAU_file_system_@@H@Z PROC	; vfs_get_file_system

; 72   : file_system_t * vfs_get_file_system (int id) {

	mov	DWORD PTR [rsp+8], ecx

; 73   : 	return sys[id];

	movsxd	rax, DWORD PTR id$[rsp]
	lea	rcx, OFFSET FLAT:?sys@@3PAPEAU_file_system_@@A ; sys
	mov	rax, QWORD PTR [rcx+rax*8]

; 74   : }

	ret	0
?vfs_get_file_system@@YAPEAU_file_system_@@H@Z ENDP	; vfs_get_file_system
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\vfs.cpp
_TEXT	SEGMENT
id$ = 8
fsys$ = 16
?vfs_register@@YAXHPEAU_file_system_@@@Z PROC		; vfs_register

; 68   : void vfs_register (int id, file_system_t *fsys) {

	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx

; 69   : 	sys[id]  = fsys;

	movsxd	rax, DWORD PTR id$[rsp]
	lea	rcx, OFFSET FLAT:?sys@@3PAPEAU_file_system_@@A ; sys
	mov	rdx, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 70   : }

	ret	0
?vfs_register@@YAXHPEAU_file_system_@@@Z ENDP		; vfs_register
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\vfs.cpp
_TEXT	SEGMENT
f$ = 48
buffer$ = 56
device_id$ = 64
?read_blk@@YAXPEAU_file_@@PEAEH@Z PROC			; read_blk

; 55   : void read_blk (FILE *f, unsigned char *buffer, int device_id) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 56   : 	sys[device_id]->sys_read_blk(f,buffer);

	movsxd	rax, DWORD PTR device_id$[rsp]
	lea	rcx, OFFSET FLAT:?sys@@3PAPEAU_file_system_@@A ; sys
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	call	QWORD PTR [rax+24]

; 57   : }

	add	rsp, 40					; 00000028H
	ret	0
?read_blk@@YAXPEAU_file_@@PEAEH@Z ENDP			; read_blk
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\vfs.cpp
_TEXT	SEGMENT
f$ = 48
buffer$ = 56
count$ = 64
device_id$ = 72
?read@@YAXPEAU_file_@@PEAEIH@Z PROC			; read

; 51   : void read (FILE *f, unsigned char* buffer,unsigned int count, int device_id) {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 52   :     sys[device_id]->sys_read (f,buffer,count);

	movsxd	rax, DWORD PTR device_id$[rsp]
	lea	rcx, OFFSET FLAT:?sys@@3PAPEAU_file_system_@@A ; sys
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	r8d, DWORD PTR count$[rsp]
	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR f$[rsp]
	call	QWORD PTR [rax+16]

; 53   : }

	add	rsp, 40					; 00000028H
	ret	0
?read@@YAXPEAU_file_@@PEAEIH@Z ENDP			; read
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\vfs.cpp
_TEXT	SEGMENT
device$ = 32
device_id$ = 36
fname$ = 40
file$ = 48
$T1 = 112
$T2 = 176
$T3 = 272
filename$ = 280
?open@@YA?AU_file_@@PEBD@Z PROC				; open

; 31   : FILE open (const char* filename) {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 248				; 000000f8H

; 32   : 	FILE file;
; 33   : 	unsigned char device;
; 34   : 	int device_id = 0;

	mov	DWORD PTR device_id$[rsp], 0

; 35   : 
; 36   : 	char* fname = (char*)filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR fname$[rsp], rax

; 37   : 	if (filename[1] == ':') {

	mov	eax, 1
	imul	rax, 1
	mov	rcx, QWORD PTR filename$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN6@open

; 38   : 		device = filename[0];

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR filename$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR device$[rsp], al

; 39   : 		filename += 2;

	mov	rax, QWORD PTR filename$[rsp]
	add	rax, 2
	mov	QWORD PTR filename$[rsp], rax
$LN6@open:

; 40   : 	}
; 41   : 	if (device == 'a' || device == 'A')

	movzx	eax, BYTE PTR device$[rsp]
	cmp	eax, 97					; 00000061H
	je	SHORT $LN4@open
	movzx	eax, BYTE PTR device$[rsp]
	cmp	eax, 65					; 00000041H
	jne	SHORT $LN5@open
$LN4@open:

; 42   : 		device_id = 10;

	mov	DWORD PTR device_id$[rsp], 10
	jmp	SHORT $LN3@open
$LN5@open:

; 43   : 	else if (device =='c' || device == 'C')

	movzx	eax, BYTE PTR device$[rsp]
	cmp	eax, 99					; 00000063H
	je	SHORT $LN1@open
	movzx	eax, BYTE PTR device$[rsp]
	cmp	eax, 67					; 00000043H
	jne	SHORT $LN2@open
$LN1@open:

; 44   : 		device_id = 11;

	mov	DWORD PTR device_id$[rsp], 11
$LN2@open:
$LN3@open:

; 45   : 
; 46   : 	file = sys[device_id]->sys_open(filename);

	movsxd	rax, DWORD PTR device_id$[rsp]
	lea	rcx, OFFSET FLAT:?sys@@3PAPEAU_file_system_@@A ; sys
	mov	rax, QWORD PTR [rcx+rax*8]
	mov	rdx, QWORD PTR filename$[rsp]
	lea	rcx, QWORD PTR $T2[rsp]
	call	QWORD PTR [rax+8]
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	lea	rax, QWORD PTR file$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 60					; 0000003cH
	rep movsb

; 47   : 	return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T3[rsp]
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	mov	rax, QWORD PTR $T3[rsp]

; 48   : }

	add	rsp, 248				; 000000f8H
	pop	rdi
	pop	rsi
	ret	0
?open@@YA?AU_file_@@PEBD@Z ENDP				; open
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\vfs.cpp
_TEXT	SEGMENT
?initialize_vfs@@YAXXZ PROC				; initialize_vfs

; 23   : void initialize_vfs () {

$LN3:
	sub	rsp, 40					; 00000028H

; 24   : 	//! By default FAT32 is recommended for boot disk
; 25   : #ifdef ARCH_X64
; 26   : 	initialize_fat32();

	call	?initialize_fat32@@YAXXZ		; initialize_fat32

; 27   : 	fat32_self_register();

	call	?fat32_self_register@@YAXXZ		; fat32_self_register

; 28   : #endif
; 29   : }

	add	rsp, 40					; 00000028H
	ret	0
?initialize_vfs@@YAXXZ ENDP				; initialize_vfs
_TEXT	ENDS
END
