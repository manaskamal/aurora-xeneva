; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?root_dir@@3PEAU_vfs_entry_@@EA			; root_dir
_BSS	SEGMENT
?root_dir@@3PEAU_vfs_entry_@@EA DQ 01H DUP (?)		; root_dir
_BSS	ENDS
CONST	SEGMENT
$SG3556	DB	'[VFS]: Mounting filesystem to root failed, already in us'
	DB	'e', 0aH, 00H
	ORG $+5
$SG3584	DB	'Recursively calling for -> %s ', 0dH, 0aH, 00H
	ORG $+7
$SG3585	DB	'[vfs]: already mounted -> %s ', 0dH, 0aH, 00H
$SG3587	DB	'Not found entry -> %s ', 0dH, 0aH, 00H
	ORG $+7
$SG3589	DB	'Mounting path -> %s, creating entry ', 0dH, 0aH, 00H
	ORG $+1
$SG3591	DB	'Entry created -> %x ', 0dH, 0aH, 00H
	ORG $+1
$SG3593	DB	'Ent->child -> %x %x nodes-> %d ', 0dH, 0aH, 00H
	ORG $+6
$SG3594	DB	'List added %x ', 0dH, 0aH, 00H
	ORG $+7
$SG3633	DB	'Directory', 00H
	ORG $+2
$SG3636	DB	'File', 00H
	ORG $+7
$SG3637	DB	'%s -> %s ', 0aH, 00H
CONST	ENDS
PUBLIC	?AuVFSInit@@YAXXZ				; AuVFSInit
PUBLIC	?vfs_finddir@@YAPEAU_vfs_node_@@PEAD@Z		; vfs_finddir
PUBLIC	vfs_mkdir
PUBLIC	vfs_mkentry
PUBLIC	vfs_mount
PUBLIC	?vfs_lsdir@@YAXPEAD@Z				; vfs_lsdir
PUBLIC	openfs
PUBLIC	readfs
PUBLIC	writefs
PUBLIC	readfs_block
PUBLIC	vfs_ioquery
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	strchr:PROC
EXTRN	?initialize_list@@YAPEAU_list_@@XZ:PROC		; initialize_list
EXTRN	?list_add@@YAXPEAU_list_@@PEAX@Z:PROC		; list_add
EXTRN	?list_get_at@@YAPEAXPEAU_list_@@I@Z:PROC	; list_get_at
EXTRN	printf:PROC
EXTRN	malloc:PROC
EXTRN	?initialize_fat32@@YAXXZ:PROC			; initialize_fat32
EXTRN	?fat32_self_register@@YAXXZ:PROC		; fat32_self_register
EXTRN	?devfs_mount@@YAXXZ:PROC			; devfs_mount
EXTRN	_debug_print_:PROC
pdata	SEGMENT
$pdata$?AuVFSInit@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?AuVFSInit@@YAXXZ
$pdata$?vfs_finddir@@YAPEAU_vfs_node_@@PEAD@Z DD imagerel $LN20
	DD	imagerel $LN20+502
	DD	imagerel $unwind$?vfs_finddir@@YAPEAU_vfs_node_@@PEAD@Z
$pdata$vfs_mkdir DD imagerel $LN20
	DD	imagerel $LN20+504
	DD	imagerel $unwind$vfs_mkdir
$pdata$vfs_mkentry DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$vfs_mkentry
$pdata$vfs_mount DD imagerel $LN23
	DD	imagerel $LN23+793
	DD	imagerel $unwind$vfs_mount
$pdata$?vfs_lsdir@@YAXPEAD@Z DD imagerel $LN25
	DD	imagerel $LN25+594
	DD	imagerel $unwind$?vfs_lsdir@@YAXPEAD@Z
$pdata$openfs DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$openfs
$pdata$readfs DD imagerel $LN4
	DD	imagerel $LN4+69
	DD	imagerel $unwind$readfs
$pdata$writefs DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$writefs
$pdata$readfs_block DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$readfs_block
$pdata$vfs_ioquery DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$vfs_ioquery
pdata	ENDS
xdata	SEGMENT
$unwind$?AuVFSInit@@YAXXZ DD 010401H
	DD	06204H
$unwind$?vfs_finddir@@YAPEAU_vfs_node_@@PEAD@Z DD 010901H
	DD	0e209H
$unwind$vfs_mkdir DD 011301H
	DD	0c213H
$unwind$vfs_mkentry DD 010401H
	DD	06204H
$unwind$vfs_mount DD 011301H
	DD	0e213H
$unwind$?vfs_lsdir@@YAXPEAD@Z DD 010901H
	DD	0e209H
$unwind$openfs DD 010e01H
	DD	0420eH
$unwind$readfs DD 011801H
	DD	04218H
$unwind$writefs DD 011801H
	DD	04218H
$unwind$readfs_block DD 011301H
	DD	04213H
$unwind$vfs_ioquery DD 011201H
	DD	04212H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
node$ = 48
code$ = 56
arg$ = 64
vfs_ioquery PROC

; 48   : int vfs_ioquery (vfs_node_t *node, int code, void* arg) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 49   : 	if (node) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN1@vfs_ioquer

; 50   : 		return node->ioquery (node, code, arg);

	mov	r8, QWORD PTR arg$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR node$[rsp]
	call	QWORD PTR [rax+96]
$LN1@vfs_ioquer:

; 51   : 	}
; 52   : }

	add	rsp, 40					; 00000028H
	ret	0
vfs_ioquery ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
node$ = 48
file$ = 56
buffer$ = 64
readfs_block PROC

; 41   : size_t readfs_block (vfs_node_t* node, vfs_node_t* file, uint64_t *buffer) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 42   : 	if (node) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN1@readfs_blo

; 43   : 		return node->read_blk (file, buffer);

	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rax, QWORD PTR node$[rsp]
	call	QWORD PTR [rax+88]
	jmp	SHORT $LN2@readfs_blo
$LN1@readfs_blo:

; 44   : 	}
; 45   : 	return -1;

	mov	rax, -1
$LN2@readfs_blo:

; 46   : }

	add	rsp, 40					; 00000028H
	ret	0
readfs_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
node$ = 48
file$ = 56
buffer$ = 64
length$ = 72
writefs	PROC

; 35   : void writefs (vfs_node_t *node, vfs_node_t* file, uint64_t *buffer, uint32_t length) {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 36   : 	if (node) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN1@writefs

; 37   : 		node->write (file, buffer, length);

	mov	r8d, DWORD PTR length$[rsp]
	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rax, QWORD PTR node$[rsp]
	call	QWORD PTR [rax+80]
$LN1@writefs:

; 38   : 	}
; 39   : }

	add	rsp, 40					; 00000028H
	ret	0
writefs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
node$ = 48
file$ = 56
buffer$ = 64
length$ = 72
readfs	PROC

; 27   : size_t readfs (vfs_node_t *node, vfs_node_t* file, uint64_t* buffer, uint32_t length) {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 28   : 	if (node) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN1@readfs

; 29   : 		return node->read (file, buffer, length);

	mov	r8d, DWORD PTR length$[rsp]
	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rax, QWORD PTR node$[rsp]
	call	QWORD PTR [rax+72]
	jmp	SHORT $LN2@readfs
$LN1@readfs:

; 30   : 	}
; 31   : 	return -1;

	mov	rax, -1
$LN2@readfs:

; 32   : }

	add	rsp, 40					; 00000028H
	ret	0
readfs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
node$ = 48
path$ = 56
openfs	PROC

; 21   : vfs_node_t* openfs (vfs_node_t *node, char* path) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 22   : 	if (node) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN1@openfs

; 23   : 		return node->open (node, path);

	mov	rdx, QWORD PTR path$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR node$[rsp]
	call	QWORD PTR [rax+64]
$LN1@openfs:

; 24   : 	}
; 25   : }

	add	rsp, 40					; 00000028H
	ret	0
openfs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
i$1 = 32
found$ = 36
next$ = 40
j$2 = 48
i$3 = 52
ent$ = 56
file_$4 = 64
type$5 = 72
f$6 = 80
entry_found$ = 88
pathname$7 = 96
path$ = 128
?vfs_lsdir@@YAXPEAD@Z PROC				; vfs_lsdir

; 263  : void vfs_lsdir (char* path) {

$LN25:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 264  : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 265  : 	if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN22@vfs_lsdir

; 266  : 		next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN22@vfs_lsdir:

; 267  : 
; 268  : 	bool found = false;

	mov	BYTE PTR found$[rsp], 0

; 269  : 	vfs_entry *ent = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR ent$[rsp], rax

; 270  : 	vfs_node_t *entry_found = 0;

	mov	QWORD PTR entry_found$[rsp], 0

; 271  : 
; 272  : 	if (path[0] == '/' && strlen(path) == 2)

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR path$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN21@vfs_lsdir
	mov	rcx, QWORD PTR path$[rsp]
	call	strlen
	cmp	rax, 2
	jne	SHORT $LN21@vfs_lsdir

; 273  : 		found = true;

	mov	BYTE PTR found$[rsp], 1
$LN21@vfs_lsdir:
$LN20@vfs_lsdir:

; 274  : 
; 275  : 
; 276  : 	while (next) {

	cmp	QWORD PTR next$[rsp], 0
	je	$LN19@vfs_lsdir

; 277  : 		int i = 0;

	mov	DWORD PTR i$1[rsp], 0

; 278  : 	    char pathname[16];
; 279  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN18@vfs_lsdir
$LN17@vfs_lsdir:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN18@vfs_lsdir:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN16@vfs_lsdir

; 280  : 			if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN14@vfs_lsdir
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN15@vfs_lsdir
$LN14@vfs_lsdir:

; 281  : 				break;

	jmp	SHORT $LN16@vfs_lsdir
$LN15@vfs_lsdir:

; 282  : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR next$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$7[rsp+rcx], al

; 283  : 		}

	jmp	SHORT $LN17@vfs_lsdir
$LN16@vfs_lsdir:

; 284  : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$7[rsp+rax], 0

; 285  : 
; 286  : 		for (int j = 0; j < ent->childs->pointer; j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN13@vfs_lsdir
$LN12@vfs_lsdir:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN13@vfs_lsdir:
	mov	rax, QWORD PTR ent$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$2[rsp], eax
	jae	SHORT $LN11@vfs_lsdir

; 287  : 			vfs_node_t *file_ = (vfs_node_t*)list_get_at(ent->childs, j);

	mov	edx, DWORD PTR j$2[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_get_at@@YAPEAXPEAU_list_@@I@Z	; list_get_at
	mov	QWORD PTR file_$4[rsp], rax

; 288  : 			entry_found = file_;

	mov	rax, QWORD PTR file_$4[rsp]
	mov	QWORD PTR entry_found$[rsp], rax

; 289  : 			if (strcmp(file_->filename, pathname) == 0) {

	mov	rax, QWORD PTR file_$4[rsp]
	lea	rdx, QWORD PTR pathname$7[rsp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN10@vfs_lsdir

; 290  : 				if (file_->flags == FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR file_$4[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 2
	jne	SHORT $LN9@vfs_lsdir

; 291  : 					ent = (vfs_entry *)file_->device;

	mov	rax, QWORD PTR file_$4[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR ent$[rsp], rax
$LN9@vfs_lsdir:
$LN10@vfs_lsdir:

; 292  : 			}
; 293  : 		}

	jmp	SHORT $LN12@vfs_lsdir
$LN11@vfs_lsdir:

; 294  : 
; 295  : 		next = strchr(next + 1, '/');

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 296  : 		if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN8@vfs_lsdir

; 297  : 			next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN8@vfs_lsdir:

; 298  : 	}

	jmp	$LN20@vfs_lsdir
$LN19@vfs_lsdir:

; 299  : 
; 300  : 	if (ent) {

	cmp	QWORD PTR ent$[rsp], 0
	je	$LN7@vfs_lsdir

; 301  : 		/* if this entry is a directory, recursively
; 302  : 		* call the node and check it */
; 303  : 		for (int i = 0; i < ent->childs->pointer; i++) {

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN6@vfs_lsdir
$LN5@vfs_lsdir:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN6@vfs_lsdir:
	mov	rax, QWORD PTR ent$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$3[rsp], eax
	jae	SHORT $LN4@vfs_lsdir

; 304  : 			vfs_node_t *f = (vfs_node_t*)list_get_at(ent->childs, i);

	mov	edx, DWORD PTR i$3[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_get_at@@YAPEAXPEAU_list_@@I@Z	; list_get_at
	mov	QWORD PTR f$6[rsp], rax

; 305  : 			char* type = 0;

	mov	QWORD PTR type$5[rsp], 0

; 306  : 			if (f->flags == FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR f$6[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 2
	jne	SHORT $LN3@vfs_lsdir

; 307  : 				type = "Directory";

	lea	rax, OFFSET FLAT:$SG3633
	mov	QWORD PTR type$5[rsp], rax
	jmp	SHORT $LN2@vfs_lsdir
$LN3@vfs_lsdir:

; 308  : 			else if (f->flags == FS_FLAG_GENERAL)

	mov	rax, QWORD PTR f$6[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 4
	jne	SHORT $LN1@vfs_lsdir

; 309  : 				type = "File";

	lea	rax, OFFSET FLAT:$SG3636
	mov	QWORD PTR type$5[rsp], rax
$LN1@vfs_lsdir:
$LN2@vfs_lsdir:

; 310  : 			printf("%s -> %s \n",type, f->filename);

	mov	rax, QWORD PTR f$6[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR type$5[rsp]
	lea	rcx, OFFSET FLAT:$SG3637
	call	printf

; 311  : 		}

	jmp	$LN5@vfs_lsdir
$LN4@vfs_lsdir:
$LN7@vfs_lsdir:

; 312  : 		return;
; 313  : 	}
; 314  : }

	add	rsp, 120				; 00000078H
	ret	0
?vfs_lsdir@@YAXPEAD@Z ENDP				; vfs_lsdir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
found$ = 32
i$1 = 36
next$ = 40
ent$ = 48
j$2 = 56
entry_found$ = 64
entry_$3 = 72
entryn$4 = 80
file_$5 = 88
pathname$6 = 96
path$ = 128
node$ = 136
dirnode$ = 144
vfs_mount PROC

; 192  : void vfs_mount (char *path, vfs_node_t *node, vfs_entry *dirnode) {

$LN23:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 193  : 	if (path[0] == '/' && strlen(path) == 2) {

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR path$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN20@vfs_mount
	mov	rcx, QWORD PTR path$[rsp]
	call	strlen
	cmp	rax, 2
	jne	SHORT $LN20@vfs_mount

; 194  : 		vfs_entry *entry_ = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR entry_$3[rsp], rax

; 195  : 		if (entry_->node) {

	mov	rax, QWORD PTR entry_$3[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN19@vfs_mount

; 196  : 			_debug_print_ ("[VFS]: Mounting filesystem to root failed, already in use\n");

	lea	rcx, OFFSET FLAT:$SG3556
	call	_debug_print_

; 197  : 			return;   //Already a root filesystem is present

	jmp	$LN21@vfs_mount
$LN19@vfs_mount:

; 198  : 		}
; 199  : 		entry_->node = node; //else mount

	mov	rax, QWORD PTR entry_$3[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax], rcx

; 200  : 		return;

	jmp	$LN21@vfs_mount
$LN20@vfs_mount:

; 201  : 	}
; 202  : 
; 203  : 	//! seeking else? other mount points
; 204  : 	//! /home/manas
; 205  : 	char* next = strchr(path,'/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 206  : 	if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN18@vfs_mount

; 207  : 		next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN18@vfs_mount:

; 208  : 	
; 209  : 	vfs_entry *ent = dirnode;

	mov	rax, QWORD PTR dirnode$[rsp]
	mov	QWORD PTR ent$[rsp], rax

; 210  : 	bool found = false;

	mov	BYTE PTR found$[rsp], 0

; 211  : 	vfs_node_t *entry_found = 0;

	mov	QWORD PTR entry_found$[rsp], 0
$LN17@vfs_mount:

; 212  : 	while (next) {

	cmp	QWORD PTR next$[rsp], 0
	je	$LN16@vfs_mount

; 213  : 		int i = 0;

	mov	DWORD PTR i$1[rsp], 0

; 214  : 		char pathname[16];
; 215  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN15@vfs_mount
$LN14@vfs_mount:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN15@vfs_mount:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN13@vfs_mount

; 216  : 			if ( next[i] == '/'  || next[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN11@vfs_mount
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN12@vfs_mount
$LN11@vfs_mount:

; 217  : 				break;

	jmp	SHORT $LN13@vfs_mount
$LN12@vfs_mount:

; 218  : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR next$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$6[rsp+rcx], al

; 219  : 		}

	jmp	SHORT $LN14@vfs_mount
$LN13@vfs_mount:

; 220  : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$6[rsp+rax], 0

; 221  : 
; 222  : 		if (ent == NULL)

	cmp	QWORD PTR ent$[rsp], 0
	jne	SHORT $LN10@vfs_mount

; 223  : 			ent = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR ent$[rsp], rax
$LN10@vfs_mount:

; 224  : 
; 225  : 		for (int j = 0; j < ent->childs->pointer; j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN9@vfs_mount
$LN8@vfs_mount:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN9@vfs_mount:
	mov	rax, QWORD PTR ent$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$2[rsp], eax
	jae	SHORT $LN7@vfs_mount

; 226  : 			vfs_node_t *file_ = (vfs_node_t*)list_get_at(ent->childs, j);

	mov	edx, DWORD PTR j$2[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_get_at@@YAPEAXPEAU_list_@@I@Z	; list_get_at
	mov	QWORD PTR file_$5[rsp], rax

; 227  : 			if (strcmp(file_->filename, pathname)==0) {

	mov	rax, QWORD PTR file_$5[rsp]
	lea	rdx, QWORD PTR pathname$6[rsp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN6@vfs_mount

; 228  : 				entry_found = file_;

	mov	rax, QWORD PTR file_$5[rsp]
	mov	QWORD PTR entry_found$[rsp], rax

; 229  : 				found = true;

	mov	BYTE PTR found$[rsp], 1
$LN6@vfs_mount:

; 230  : 			}
; 231  : 		}

	jmp	SHORT $LN8@vfs_mount
$LN7@vfs_mount:

; 232  : 
; 233  : 		next = strchr (next + 1, '/'); 

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 234  : 		if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN5@vfs_mount

; 235  : 			next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN5@vfs_mount:

; 236  : 	}

	jmp	$LN17@vfs_mount
$LN16@vfs_mount:

; 237  : 
; 238  : 	if (found) {

	movzx	eax, BYTE PTR found$[rsp]
	test	eax, eax
	je	SHORT $LN4@vfs_mount

; 239  : 		if (entry_found->flags == FS_FLAG_DIRECTORY) {

	mov	rax, QWORD PTR entry_found$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 2
	jne	SHORT $LN3@vfs_mount

; 240  : 			ent = (vfs_entry*)entry_found->device;

	mov	rax, QWORD PTR entry_found$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR ent$[rsp], rax

; 241  : 			_debug_print_ ("Recursively calling for -> %s \r\n", path);

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, OFFSET FLAT:$SG3584
	call	_debug_print_

; 242  : 			vfs_mount(path,node,ent);

	mov	r8, QWORD PTR ent$[rsp]
	mov	rdx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR path$[rsp]
	call	vfs_mount
$LN3@vfs_mount:

; 243  : 		}
; 244  : 		_debug_print_ ("[vfs]: already mounted -> %s \r\n", path);

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, OFFSET FLAT:$SG3585
	call	_debug_print_

; 245  : 		return;

	jmp	$LN21@vfs_mount
$LN4@vfs_mount:

; 246  : 	}
; 247  : 
; 248  : 	if (!found) {

	movzx	eax, BYTE PTR found$[rsp]
	test	eax, eax
	jne	$LN2@vfs_mount

; 249  : 		_debug_print_ ("Not found entry -> %s \r\n", path);

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, OFFSET FLAT:$SG3587
	call	_debug_print_

; 250  : 		if (entry_found) {

	cmp	QWORD PTR entry_found$[rsp], 0
	je	SHORT $LN1@vfs_mount

; 251  : 			_debug_print_ ("Mounting path -> %s, creating entry \r\n", path);

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, OFFSET FLAT:$SG3589
	call	_debug_print_

; 252  : 			vfs_entry* entryn = vfs_mkentry();

	call	vfs_mkentry
	mov	QWORD PTR entryn$4[rsp], rax

; 253  : 			_debug_print_ ("Entry created -> %x \r\n", entryn);

	mov	rdx, QWORD PTR entryn$4[rsp]
	lea	rcx, OFFSET FLAT:$SG3591
	call	_debug_print_

; 254  : 			vfs_mkdir(path,node,entryn);

	mov	r8, QWORD PTR entryn$4[rsp]
	mov	rdx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR path$[rsp]
	call	vfs_mkdir
$LN1@vfs_mount:

; 255  : 		}
; 256  : 		_debug_print_ ("Ent->child -> %x %x nodes-> %d \r\n", ent->childs, node, sizeof(vfs_node_t));

	mov	r9d, 104				; 00000068H
	mov	r8, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG3593
	call	_debug_print_

; 257  : 		list_add(ent->childs, node);

	mov	rdx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_add@@YAXPEAU_list_@@PEAX@Z	; list_add

; 258  : 		_debug_print_ ("List added %x \r\n", ent->childs);

	mov	rax, QWORD PTR ent$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG3594
	call	_debug_print_
$LN2@vfs_mount:
$LN21@vfs_mount:

; 259  : 	}
; 260  : 	
; 261  : }

	add	rsp, 120				; 00000078H
	ret	0
vfs_mount ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
ent$ = 32
vfs_mkentry PROC

; 179  : vfs_entry * vfs_mkentry() {

$LN3:
	sub	rsp, 56					; 00000038H

; 180  : 	vfs_entry* ent = (vfs_entry*)malloc(sizeof(vfs_entry));

	mov	ecx, 16
	call	malloc
	mov	QWORD PTR ent$[rsp], rax

; 181  : 	ent->node = 0;

	mov	rax, QWORD PTR ent$[rsp]
	mov	QWORD PTR [rax], 0

; 182  : 	ent->childs = initialize_list();

	call	?initialize_list@@YAPEAU_list_@@XZ	; initialize_list
	mov	rcx, QWORD PTR ent$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 183  : 	return ent;

	mov	rax, QWORD PTR ent$[rsp]

; 184  : }

	add	rsp, 56					; 00000038H
	ret	0
vfs_mkentry ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
found$ = 32
i$1 = 36
j$2 = 40
next$ = 48
ent$ = 56
file_$3 = 64
entry_found$ = 72
pathname$ = 80
path$ = 112
dir$ = 120
dir_node$ = 128
vfs_mkdir PROC

; 127  : void vfs_mkdir (char* path, vfs_node_t* dir, vfs_entry* dir_node) {

$LN20:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 128  : 	dir->device = dir_node;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR dir_node$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 129  : 	bool found = false;

	mov	BYTE PTR found$[rsp], 0

; 130  : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 131  : 	if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN17@vfs_mkdir

; 132  : 		next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN17@vfs_mkdir:

; 133  : 
; 134  : 	vfs_entry* ent = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR ent$[rsp], rax

; 135  : 	vfs_node_t* entry_found = 0;

	mov	QWORD PTR entry_found$[rsp], 0
$LN16@vfs_mkdir:

; 136  : 	char pathname[16];
; 137  : 	
; 138  : 	while(next) {

	cmp	QWORD PTR next$[rsp], 0
	je	$LN15@vfs_mkdir

; 139  : 		int i = 0;

	mov	DWORD PTR i$1[rsp], 0

; 140  : 
; 141  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN14@vfs_mkdir
$LN13@vfs_mkdir:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN14@vfs_mkdir:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN12@vfs_mkdir

; 142  : 			if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN10@vfs_mkdir
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN11@vfs_mkdir
$LN10@vfs_mkdir:

; 143  : 				break;

	jmp	SHORT $LN12@vfs_mkdir
$LN11@vfs_mkdir:

; 144  : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR next$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$[rsp+rcx], al

; 145  : 		}

	jmp	SHORT $LN13@vfs_mkdir
$LN12@vfs_mkdir:

; 146  : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$[rsp+rax], 0

; 147  : 
; 148  : 		if (ent == NULL)

	cmp	QWORD PTR ent$[rsp], 0
	jne	SHORT $LN9@vfs_mkdir

; 149  : 			ent = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR ent$[rsp], rax
$LN9@vfs_mkdir:

; 150  : 
; 151  : 		for (int j = 0; j < ent->childs->pointer; j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN8@vfs_mkdir
$LN7@vfs_mkdir:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN8@vfs_mkdir:
	mov	rax, QWORD PTR ent$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$2[rsp], eax
	jae	SHORT $LN6@vfs_mkdir

; 152  : 			vfs_node_t* file_ = (vfs_node_t*)list_get_at(ent->childs, j);

	mov	edx, DWORD PTR j$2[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_get_at@@YAPEAXPEAU_list_@@I@Z	; list_get_at
	mov	QWORD PTR file_$3[rsp], rax

; 153  : 			if (strcmp(file_->filename, pathname) == 0) {

	mov	rax, QWORD PTR file_$3[rsp]
	lea	rdx, QWORD PTR pathname$[rsp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN5@vfs_mkdir

; 154  : 				if (file_->flags == FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR file_$3[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 2
	jne	SHORT $LN4@vfs_mkdir

; 155  : 					ent = (vfs_entry *)file_->device;

	mov	rax, QWORD PTR file_$3[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR ent$[rsp], rax
$LN4@vfs_mkdir:

; 156  : 				found = true;

	mov	BYTE PTR found$[rsp], 1

; 157  : 				entry_found = file_;

	mov	rax, QWORD PTR file_$3[rsp]
	mov	QWORD PTR entry_found$[rsp], rax
$LN5@vfs_mkdir:

; 158  : 			}
; 159  : 		}

	jmp	SHORT $LN7@vfs_mkdir
$LN6@vfs_mkdir:

; 160  : 
; 161  : 		next = strchr(next + 1, '/');

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 162  : 		if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN3@vfs_mkdir

; 163  : 			next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN3@vfs_mkdir:

; 164  : 	}

	jmp	$LN16@vfs_mkdir
$LN15@vfs_mkdir:

; 165  : 
; 166  : 	strcpy(dir->filename, pathname);

	mov	rax, QWORD PTR dir$[rsp]
	lea	rdx, QWORD PTR pathname$[rsp]
	mov	rcx, rax
	call	strcpy

; 167  : 	if (found) {

	movzx	eax, BYTE PTR found$[rsp]
	test	eax, eax
	je	SHORT $LN2@vfs_mkdir

; 168  : 		/* if this entry is a directory, recursively
; 169  : 		* call the node and check it */
; 170  : 		list_add(ent->childs, dir);

	mov	rdx, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_add@@YAXPEAU_list_@@PEAX@Z	; list_add

; 171  : 		return;

	jmp	SHORT $LN18@vfs_mkdir
$LN2@vfs_mkdir:

; 172  : 	}
; 173  : 	if (!found) {

	movzx	eax, BYTE PTR found$[rsp]
	test	eax, eax
	jne	SHORT $LN1@vfs_mkdir

; 174  : 		list_add(ent->childs, dir);

	mov	rdx, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_add@@YAXPEAU_list_@@PEAX@Z	; list_add
$LN1@vfs_mkdir:
$LN18@vfs_mkdir:

; 175  : 		return;
; 176  : 	}		
; 177  : }

	add	rsp, 104				; 00000068H
	ret	0
vfs_mkdir ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
i$1 = 32
next$ = 40
j$2 = 48
ent$ = 56
file_$3 = 64
entry_found$ = 72
entry_$4 = 80
pathname$ = 88
fs_path$ = 104
path$ = 128
?vfs_finddir@@YAPEAU_vfs_node_@@PEAD@Z PROC		; vfs_finddir

; 72   : vfs_node_t* vfs_finddir (char *path) {

$LN20:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 73   : 	if (path[0] == '/' && strlen(path) == 2) {

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR path$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN17@vfs_finddi
	mov	rcx, QWORD PTR path$[rsp]
	call	strlen
	cmp	rax, 2
	jne	SHORT $LN17@vfs_finddi

; 74   : 		vfs_entry *entry_ = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR entry_$4[rsp], rax

; 75   : 		return entry_->node;

	mov	rax, QWORD PTR entry_$4[rsp]
	mov	rax, QWORD PTR [rax]
	jmp	$LN18@vfs_finddi
$LN17@vfs_finddi:

; 76   : 	}
; 77   : 
; 78   : 
; 79   : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 80   : 	if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN16@vfs_finddi

; 81   : 		next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN16@vfs_finddi:

; 82   : 
; 83   : 	char* fs_path = next;

	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR fs_path$[rsp], rax

; 84   : 
; 85   : 	vfs_entry* ent = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR ent$[rsp], rax

; 86   : 	vfs_node_t* entry_found = 0;

	mov	QWORD PTR entry_found$[rsp], 0
$LN15@vfs_finddi:

; 87   : 	char pathname[16];
; 88   : 
; 89   : 	while(next) {

	cmp	QWORD PTR next$[rsp], 0
	je	$LN14@vfs_finddi

; 90   : 		int i = 0;

	mov	DWORD PTR i$1[rsp], 0

; 91   : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN13@vfs_finddi
$LN12@vfs_finddi:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN13@vfs_finddi:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN11@vfs_finddi

; 92   : 			if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN9@vfs_finddi
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN10@vfs_finddi
$LN9@vfs_finddi:

; 93   : 				break;

	jmp	SHORT $LN11@vfs_finddi
$LN10@vfs_finddi:

; 94   : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR next$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$[rsp+rcx], al

; 95   : 		}

	jmp	SHORT $LN12@vfs_finddi
$LN11@vfs_finddi:

; 96   : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$[rsp+rax], 0

; 97   : 
; 98   : 		if (ent == NULL)

	cmp	QWORD PTR ent$[rsp], 0
	jne	SHORT $LN8@vfs_finddi

; 99   : 			ent = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR ent$[rsp], rax
$LN8@vfs_finddi:

; 100  : 
; 101  : 		for (int j = 0; j < ent->childs->pointer; j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN7@vfs_finddi
$LN6@vfs_finddi:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN7@vfs_finddi:
	mov	rax, QWORD PTR ent$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$2[rsp], eax
	jae	SHORT $LN5@vfs_finddi

; 102  : 			vfs_node_t *file_ = (vfs_node_t*)list_get_at(ent->childs, j);

	mov	edx, DWORD PTR j$2[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_get_at@@YAPEAXPEAU_list_@@I@Z	; list_get_at
	mov	QWORD PTR file_$3[rsp], rax

; 103  : 			if (strcmp(file_->filename, pathname) == 0) {

	mov	rax, QWORD PTR file_$3[rsp]
	lea	rdx, QWORD PTR pathname$[rsp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN4@vfs_finddi

; 104  : 				if (file_->flags == FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR file_$3[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 2
	jne	SHORT $LN3@vfs_finddi

; 105  : 					ent = (vfs_entry*)file_->device;

	mov	rax, QWORD PTR file_$3[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR ent$[rsp], rax
$LN3@vfs_finddi:

; 106  : 				entry_found = file_;

	mov	rax, QWORD PTR file_$3[rsp]
	mov	QWORD PTR entry_found$[rsp], rax
$LN4@vfs_finddi:

; 107  : 			}
; 108  : 		}

	jmp	SHORT $LN6@vfs_finddi
$LN5@vfs_finddi:

; 109  : 
; 110  : 		next = strchr(next + 1, '/');

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 111  : 		if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN2@vfs_finddi

; 112  : 			next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN2@vfs_finddi:

; 113  : 	}

	jmp	$LN15@vfs_finddi
$LN14@vfs_finddi:

; 114  : 
; 115  : 	if (!entry_found) 

	cmp	QWORD PTR entry_found$[rsp], 0
	jne	SHORT $LN1@vfs_finddi

; 116  : 		entry_found = root_dir->node;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR entry_found$[rsp], rax
$LN1@vfs_finddi:

; 117  : 
; 118  : 	return entry_found;

	mov	rax, QWORD PTR entry_found$[rsp]
$LN18@vfs_finddi:

; 119  : }

	add	rsp, 120				; 00000078H
	ret	0
?vfs_finddir@@YAPEAU_vfs_node_@@PEAD@Z ENDP		; vfs_finddir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
root$ = 32
?AuVFSInit@@YAXXZ PROC					; AuVFSInit

; 55   : void AuVFSInit () {

$LN3:
	sub	rsp, 56					; 00000038H

; 56   : 	vfs_entry *root = (vfs_entry*)malloc(sizeof(vfs_entry));

	mov	ecx, 16
	call	malloc
	mov	QWORD PTR root$[rsp], rax

; 57   : 	root->node = 0;

	mov	rax, QWORD PTR root$[rsp]
	mov	QWORD PTR [rax], 0

; 58   : 	root->childs = initialize_list();

	call	?initialize_list@@YAPEAU_list_@@XZ	; initialize_list
	mov	rcx, QWORD PTR root$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 59   : 	root_dir = root;

	mov	rax, QWORD PTR root$[rsp]
	mov	QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA, rax ; root_dir

; 60   : 
; 61   : 
; 62   : 	//! Initialize the root file system
; 63   : 	initialize_fat32();

	call	?initialize_fat32@@YAXXZ		; initialize_fat32

; 64   : 	fat32_self_register();

	call	?fat32_self_register@@YAXXZ		; fat32_self_register

; 65   : 
; 66   : 	//! Initialize the device file system
; 67   : 	devfs_mount();

	call	?devfs_mount@@YAXXZ			; devfs_mount

; 68   : 
; 69   : 
; 70   : }

	add	rsp, 56					; 00000038H
	ret	0
?AuVFSInit@@YAXXZ ENDP					; AuVFSInit
_TEXT	ENDS
END
