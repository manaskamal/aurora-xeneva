; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?root_dir@@3PEAU_vfs_entry_@@EA			; root_dir
_BSS	SEGMENT
?root_dir@@3PEAU_vfs_entry_@@EA DQ 01H DUP (?)		; root_dir
_BSS	ENDS
CONST	SEGMENT
$SG3556	DB	'[VFS]: Mounting filesystem to root failed, already in us'
	DB	'e', 0aH, 00H
	ORG $+5
$SG3584	DB	'Recursively calling for -> %s ', 0dH, 0aH, 00H
	ORG $+7
$SG3585	DB	'[vfs]: already mounted -> %s', 0aH, 00H
	ORG $+2
$SG3587	DB	'Not found entry -> %s ', 0dH, 0aH, 00H
	ORG $+7
$SG3589	DB	'Mounting path -> %s, creating entry ', 0dH, 0aH, 00H
	ORG $+1
$SG3591	DB	'Entry created -> %x ', 0dH, 0aH, 00H
	ORG $+1
$SG3593	DB	'Ent->child -> %x %x nodes-> %d ', 0dH, 0aH, 00H
	ORG $+6
$SG3594	DB	'List added %x ', 0dH, 0aH, 00H
	ORG $+7
$SG3633	DB	'Directory', 00H
	ORG $+2
$SG3636	DB	'File', 00H
	ORG $+7
$SG3637	DB	'%s -> %s ', 0aH, 00H
CONST	ENDS
PUBLIC	?AuVFSInit@@YAXXZ				; AuVFSInit
PUBLIC	?vfs_finddir@@YAPEAU_vfs_node_@@PEAD@Z		; vfs_finddir
PUBLIC	vfs_mkdir
PUBLIC	vfs_mkentry
PUBLIC	vfs_mount
PUBLIC	?vfs_lsdir@@YAXPEAD@Z				; vfs_lsdir
PUBLIC	openfs
PUBLIC	readfs
PUBLIC	writefs
PUBLIC	readfs_block
PUBLIC	vfs_ioquery
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	strchr:PROC
EXTRN	?initialize_list@@YAPEAU_list_@@XZ:PROC		; initialize_list
EXTRN	?list_add@@YAXPEAU_list_@@PEAX@Z:PROC		; list_add
EXTRN	?list_get_at@@YAPEAXPEAU_list_@@I@Z:PROC	; list_get_at
EXTRN	printf:PROC
EXTRN	malloc:PROC
EXTRN	?initialize_fat32@@YAXXZ:PROC			; initialize_fat32
EXTRN	?fat32_self_register@@YAXXZ:PROC		; fat32_self_register
EXTRN	?devfs_mount@@YAXXZ:PROC			; devfs_mount
EXTRN	_debug_print_:PROC
pdata	SEGMENT
$pdata$?AuVFSInit@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+77
	DD	imagerel $unwind$?AuVFSInit@@YAXXZ
$pdata$?vfs_finddir@@YAPEAU_vfs_node_@@PEAD@Z DD imagerel $LN20
	DD	imagerel $LN20+502
	DD	imagerel $unwind$?vfs_finddir@@YAPEAU_vfs_node_@@PEAD@Z
$pdata$vfs_mkdir DD imagerel $LN20
	DD	imagerel $LN20+504
	DD	imagerel $unwind$vfs_mkdir
$pdata$vfs_mkentry DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$vfs_mkentry
$pdata$vfs_mount DD imagerel $LN23
	DD	imagerel $LN23+793
	DD	imagerel $unwind$vfs_mount
$pdata$?vfs_lsdir@@YAXPEAD@Z DD imagerel $LN25
	DD	imagerel $LN25+594
	DD	imagerel $unwind$?vfs_lsdir@@YAXPEAD@Z
$pdata$openfs DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$openfs
$pdata$readfs DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$readfs
$pdata$writefs DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$writefs
$pdata$readfs_block DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$readfs_block
$pdata$vfs_ioquery DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$vfs_ioquery
pdata	ENDS
xdata	SEGMENT
$unwind$?AuVFSInit@@YAXXZ DD 010401H
	DD	06204H
$unwind$?vfs_finddir@@YAPEAU_vfs_node_@@PEAD@Z DD 010901H
	DD	0e209H
$unwind$vfs_mkdir DD 011301H
	DD	0c213H
$unwind$vfs_mkentry DD 010401H
	DD	06204H
$unwind$vfs_mount DD 011301H
	DD	0e213H
$unwind$?vfs_lsdir@@YAXPEAD@Z DD 010901H
	DD	0e209H
$unwind$openfs DD 010e01H
	DD	0420eH
$unwind$readfs DD 011801H
	DD	04218H
$unwind$writefs DD 011801H
	DD	04218H
$unwind$readfs_block DD 011301H
	DD	04213H
$unwind$vfs_ioquery DD 011201H
	DD	04212H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
node$ = 48
code$ = 56
arg$ = 64
vfs_ioquery PROC

; 46   : int vfs_ioquery (vfs_node_t *node, int code, void* arg) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 47   : 	if (node) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN1@vfs_ioquer

; 48   : 		return node->ioquery (node, code, arg);

	mov	r8, QWORD PTR arg$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR node$[rsp]
	call	QWORD PTR [rax+96]
$LN1@vfs_ioquer:

; 49   : 	}
; 50   : }

	add	rsp, 40					; 00000028H
	ret	0
vfs_ioquery ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
node$ = 48
file$ = 56
buffer$ = 64
readfs_block PROC

; 40   : void readfs_block (vfs_node_t* node, vfs_node_t* file, uint64_t *buffer) {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 41   : 	if (node) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN1@readfs_blo

; 42   : 		node->read_blk (file, buffer);

	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rax, QWORD PTR node$[rsp]
	call	QWORD PTR [rax+88]
$LN1@readfs_blo:

; 43   : 	}
; 44   : }

	add	rsp, 40					; 00000028H
	ret	0
readfs_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
node$ = 48
file$ = 56
buffer$ = 64
length$ = 72
writefs	PROC

; 34   : void writefs (vfs_node_t *node, vfs_node_t* file, uint64_t *buffer, uint32_t length) {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 35   : 	if (node) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN1@writefs

; 36   : 		node->write (file, buffer, length);

	mov	r8d, DWORD PTR length$[rsp]
	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rax, QWORD PTR node$[rsp]
	call	QWORD PTR [rax+80]
$LN1@writefs:

; 37   : 	}
; 38   : }

	add	rsp, 40					; 00000028H
	ret	0
writefs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
node$ = 48
file$ = 56
buffer$ = 64
length$ = 72
readfs	PROC

; 27   : void readfs (vfs_node_t *node, vfs_node_t* file, uint64_t* buffer, uint32_t length) {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 28   : 	if (node) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN1@readfs

; 29   : 		node->read (file, buffer, length);

	mov	r8d, DWORD PTR length$[rsp]
	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	mov	rax, QWORD PTR node$[rsp]
	call	QWORD PTR [rax+72]
$LN1@readfs:

; 30   : 	}
; 31   : }

	add	rsp, 40					; 00000028H
	ret	0
readfs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
node$ = 48
path$ = 56
openfs	PROC

; 21   : vfs_node_t* openfs (vfs_node_t *node, char* path) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 22   : 	if (node) {

	cmp	QWORD PTR node$[rsp], 0
	je	SHORT $LN1@openfs

; 23   : 		return node->open (node, path);

	mov	rdx, QWORD PTR path$[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR node$[rsp]
	call	QWORD PTR [rax+64]
$LN1@openfs:

; 24   : 	}
; 25   : }

	add	rsp, 40					; 00000028H
	ret	0
openfs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
i$1 = 32
found$ = 36
next$ = 40
j$2 = 48
i$3 = 52
ent$ = 56
file_$4 = 64
type$5 = 72
f$6 = 80
entry_found$ = 88
pathname$7 = 96
path$ = 128
?vfs_lsdir@@YAXPEAD@Z PROC				; vfs_lsdir

; 261  : void vfs_lsdir (char* path) {

$LN25:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 262  : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 263  : 	if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN22@vfs_lsdir

; 264  : 		next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN22@vfs_lsdir:

; 265  : 
; 266  : 	bool found = false;

	mov	BYTE PTR found$[rsp], 0

; 267  : 	vfs_entry *ent = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR ent$[rsp], rax

; 268  : 	vfs_node_t *entry_found = 0;

	mov	QWORD PTR entry_found$[rsp], 0

; 269  : 
; 270  : 	if (path[0] == '/' && strlen(path) == 2)

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR path$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN21@vfs_lsdir
	mov	rcx, QWORD PTR path$[rsp]
	call	strlen
	cmp	rax, 2
	jne	SHORT $LN21@vfs_lsdir

; 271  : 		found = true;

	mov	BYTE PTR found$[rsp], 1
$LN21@vfs_lsdir:
$LN20@vfs_lsdir:

; 272  : 
; 273  : 
; 274  : 	while (next) {

	cmp	QWORD PTR next$[rsp], 0
	je	$LN19@vfs_lsdir

; 275  : 		int i = 0;

	mov	DWORD PTR i$1[rsp], 0

; 276  : 	    char pathname[16];
; 277  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN18@vfs_lsdir
$LN17@vfs_lsdir:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN18@vfs_lsdir:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN16@vfs_lsdir

; 278  : 			if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN14@vfs_lsdir
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN15@vfs_lsdir
$LN14@vfs_lsdir:

; 279  : 				break;

	jmp	SHORT $LN16@vfs_lsdir
$LN15@vfs_lsdir:

; 280  : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR next$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$7[rsp+rcx], al

; 281  : 		}

	jmp	SHORT $LN17@vfs_lsdir
$LN16@vfs_lsdir:

; 282  : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$7[rsp+rax], 0

; 283  : 
; 284  : 		for (int j = 0; j < ent->childs->pointer; j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN13@vfs_lsdir
$LN12@vfs_lsdir:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN13@vfs_lsdir:
	mov	rax, QWORD PTR ent$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$2[rsp], eax
	jae	SHORT $LN11@vfs_lsdir

; 285  : 			vfs_node_t *file_ = (vfs_node_t*)list_get_at(ent->childs, j);

	mov	edx, DWORD PTR j$2[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_get_at@@YAPEAXPEAU_list_@@I@Z	; list_get_at
	mov	QWORD PTR file_$4[rsp], rax

; 286  : 			entry_found = file_;

	mov	rax, QWORD PTR file_$4[rsp]
	mov	QWORD PTR entry_found$[rsp], rax

; 287  : 			if (strcmp(file_->filename, pathname) == 0) {

	mov	rax, QWORD PTR file_$4[rsp]
	lea	rdx, QWORD PTR pathname$7[rsp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN10@vfs_lsdir

; 288  : 				if (file_->flags == FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR file_$4[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 1
	jne	SHORT $LN9@vfs_lsdir

; 289  : 					ent = (vfs_entry *)file_->device;

	mov	rax, QWORD PTR file_$4[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR ent$[rsp], rax
$LN9@vfs_lsdir:
$LN10@vfs_lsdir:

; 290  : 			}
; 291  : 		}

	jmp	SHORT $LN12@vfs_lsdir
$LN11@vfs_lsdir:

; 292  : 
; 293  : 		next = strchr(next + 1, '/');

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 294  : 		if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN8@vfs_lsdir

; 295  : 			next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN8@vfs_lsdir:

; 296  : 	}

	jmp	$LN20@vfs_lsdir
$LN19@vfs_lsdir:

; 297  : 
; 298  : 	if (ent) {

	cmp	QWORD PTR ent$[rsp], 0
	je	$LN7@vfs_lsdir

; 299  : 		/* if this entry is a directory, recursively
; 300  : 		* call the node and check it */
; 301  : 		for (int i = 0; i < ent->childs->pointer; i++) {

	mov	DWORD PTR i$3[rsp], 0
	jmp	SHORT $LN6@vfs_lsdir
$LN5@vfs_lsdir:
	mov	eax, DWORD PTR i$3[rsp]
	inc	eax
	mov	DWORD PTR i$3[rsp], eax
$LN6@vfs_lsdir:
	mov	rax, QWORD PTR ent$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR i$3[rsp], eax
	jae	SHORT $LN4@vfs_lsdir

; 302  : 			vfs_node_t *f = (vfs_node_t*)list_get_at(ent->childs, i);

	mov	edx, DWORD PTR i$3[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_get_at@@YAPEAXPEAU_list_@@I@Z	; list_get_at
	mov	QWORD PTR f$6[rsp], rax

; 303  : 			char* type = 0;

	mov	QWORD PTR type$5[rsp], 0

; 304  : 			if (f->flags == FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR f$6[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 1
	jne	SHORT $LN3@vfs_lsdir

; 305  : 				type = "Directory";

	lea	rax, OFFSET FLAT:$SG3633
	mov	QWORD PTR type$5[rsp], rax
	jmp	SHORT $LN2@vfs_lsdir
$LN3@vfs_lsdir:

; 306  : 			else if (f->flags == FS_FLAG_GENERAL)

	mov	rax, QWORD PTR f$6[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 2
	jne	SHORT $LN1@vfs_lsdir

; 307  : 				type = "File";

	lea	rax, OFFSET FLAT:$SG3636
	mov	QWORD PTR type$5[rsp], rax
$LN1@vfs_lsdir:
$LN2@vfs_lsdir:

; 308  : 			printf("%s -> %s \n",type, f->filename);

	mov	rax, QWORD PTR f$6[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR type$5[rsp]
	lea	rcx, OFFSET FLAT:$SG3637
	call	printf

; 309  : 		}

	jmp	$LN5@vfs_lsdir
$LN4@vfs_lsdir:
$LN7@vfs_lsdir:

; 310  : 		return;
; 311  : 	}
; 312  : }

	add	rsp, 120				; 00000078H
	ret	0
?vfs_lsdir@@YAXPEAD@Z ENDP				; vfs_lsdir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
found$ = 32
i$1 = 36
next$ = 40
ent$ = 48
j$2 = 56
entry_found$ = 64
entry_$3 = 72
entryn$4 = 80
file_$5 = 88
pathname$6 = 96
path$ = 128
node$ = 136
dirnode$ = 144
vfs_mount PROC

; 190  : void vfs_mount (char *path, vfs_node_t *node, vfs_entry *dirnode) {

$LN23:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 191  : 	if (path[0] == '/' && strlen(path) == 2) {

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR path$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN20@vfs_mount
	mov	rcx, QWORD PTR path$[rsp]
	call	strlen
	cmp	rax, 2
	jne	SHORT $LN20@vfs_mount

; 192  : 		vfs_entry *entry_ = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR entry_$3[rsp], rax

; 193  : 		if (entry_->node) {

	mov	rax, QWORD PTR entry_$3[rsp]
	cmp	QWORD PTR [rax], 0
	je	SHORT $LN19@vfs_mount

; 194  : 			printf ("[VFS]: Mounting filesystem to root failed, already in use\n");

	lea	rcx, OFFSET FLAT:$SG3556
	call	printf

; 195  : 			return;   //Already a root filesystem is present

	jmp	$LN21@vfs_mount
$LN19@vfs_mount:

; 196  : 		}
; 197  : 		entry_->node = node; //else mount

	mov	rax, QWORD PTR entry_$3[rsp]
	mov	rcx, QWORD PTR node$[rsp]
	mov	QWORD PTR [rax], rcx

; 198  : 		return;

	jmp	$LN21@vfs_mount
$LN20@vfs_mount:

; 199  : 	}
; 200  : 
; 201  : 	//! seeking else? other mount points
; 202  : 	//! /home/manas
; 203  : 	char* next = strchr(path,'/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 204  : 	if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN18@vfs_mount

; 205  : 		next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN18@vfs_mount:

; 206  : 	
; 207  : 	vfs_entry *ent = dirnode;

	mov	rax, QWORD PTR dirnode$[rsp]
	mov	QWORD PTR ent$[rsp], rax

; 208  : 	bool found = false;

	mov	BYTE PTR found$[rsp], 0

; 209  : 	vfs_node_t *entry_found = 0;

	mov	QWORD PTR entry_found$[rsp], 0
$LN17@vfs_mount:

; 210  : 	while (next) {

	cmp	QWORD PTR next$[rsp], 0
	je	$LN16@vfs_mount

; 211  : 		int i = 0;

	mov	DWORD PTR i$1[rsp], 0

; 212  : 		char pathname[16];
; 213  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN15@vfs_mount
$LN14@vfs_mount:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN15@vfs_mount:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN13@vfs_mount

; 214  : 			if ( next[i] == '/'  || next[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN11@vfs_mount
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN12@vfs_mount
$LN11@vfs_mount:

; 215  : 				break;

	jmp	SHORT $LN13@vfs_mount
$LN12@vfs_mount:

; 216  : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR next$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$6[rsp+rcx], al

; 217  : 		}

	jmp	SHORT $LN14@vfs_mount
$LN13@vfs_mount:

; 218  : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$6[rsp+rax], 0

; 219  : 
; 220  : 		if (ent == NULL)

	cmp	QWORD PTR ent$[rsp], 0
	jne	SHORT $LN10@vfs_mount

; 221  : 			ent = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR ent$[rsp], rax
$LN10@vfs_mount:

; 222  : 
; 223  : 		for (int j = 0; j < ent->childs->pointer; j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN9@vfs_mount
$LN8@vfs_mount:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN9@vfs_mount:
	mov	rax, QWORD PTR ent$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$2[rsp], eax
	jae	SHORT $LN7@vfs_mount

; 224  : 			vfs_node_t *file_ = (vfs_node_t*)list_get_at(ent->childs, j);

	mov	edx, DWORD PTR j$2[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_get_at@@YAPEAXPEAU_list_@@I@Z	; list_get_at
	mov	QWORD PTR file_$5[rsp], rax

; 225  : 			if (strcmp(file_->filename, pathname)==0) {

	mov	rax, QWORD PTR file_$5[rsp]
	lea	rdx, QWORD PTR pathname$6[rsp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN6@vfs_mount

; 226  : 				entry_found = file_;

	mov	rax, QWORD PTR file_$5[rsp]
	mov	QWORD PTR entry_found$[rsp], rax

; 227  : 				found = true;

	mov	BYTE PTR found$[rsp], 1
$LN6@vfs_mount:

; 228  : 			}
; 229  : 		}

	jmp	SHORT $LN8@vfs_mount
$LN7@vfs_mount:

; 230  : 
; 231  : 		next = strchr (next + 1, '/'); 

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 232  : 		if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN5@vfs_mount

; 233  : 			next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN5@vfs_mount:

; 234  : 	}

	jmp	$LN17@vfs_mount
$LN16@vfs_mount:

; 235  : 
; 236  : 	if (found) {

	movzx	eax, BYTE PTR found$[rsp]
	test	eax, eax
	je	SHORT $LN4@vfs_mount

; 237  : 		if (entry_found->flags == FS_FLAG_DIRECTORY) {

	mov	rax, QWORD PTR entry_found$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 1
	jne	SHORT $LN3@vfs_mount

; 238  : 			ent = (vfs_entry*)entry_found->device;

	mov	rax, QWORD PTR entry_found$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR ent$[rsp], rax

; 239  : 			_debug_print_ ("Recursively calling for -> %s \r\n", path);

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, OFFSET FLAT:$SG3584
	call	_debug_print_

; 240  : 			vfs_mount(path,node,ent);

	mov	r8, QWORD PTR ent$[rsp]
	mov	rdx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR path$[rsp]
	call	vfs_mount
$LN3@vfs_mount:

; 241  : 		}
; 242  : 		printf ("[vfs]: already mounted -> %s\n", path);

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, OFFSET FLAT:$SG3585
	call	printf

; 243  : 		return;

	jmp	$LN21@vfs_mount
$LN4@vfs_mount:

; 244  : 	}
; 245  : 
; 246  : 	if (!found) {

	movzx	eax, BYTE PTR found$[rsp]
	test	eax, eax
	jne	$LN2@vfs_mount

; 247  : 		_debug_print_ ("Not found entry -> %s \r\n", path);

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, OFFSET FLAT:$SG3587
	call	_debug_print_

; 248  : 		if (entry_found) {

	cmp	QWORD PTR entry_found$[rsp], 0
	je	SHORT $LN1@vfs_mount

; 249  : 			_debug_print_ ("Mounting path -> %s, creating entry \r\n", path);

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, OFFSET FLAT:$SG3589
	call	_debug_print_

; 250  : 			vfs_entry* entryn = vfs_mkentry();

	call	vfs_mkentry
	mov	QWORD PTR entryn$4[rsp], rax

; 251  : 			_debug_print_ ("Entry created -> %x \r\n", entryn);

	mov	rdx, QWORD PTR entryn$4[rsp]
	lea	rcx, OFFSET FLAT:$SG3591
	call	_debug_print_

; 252  : 			vfs_mkdir(path,node,entryn);

	mov	r8, QWORD PTR entryn$4[rsp]
	mov	rdx, QWORD PTR node$[rsp]
	mov	rcx, QWORD PTR path$[rsp]
	call	vfs_mkdir
$LN1@vfs_mount:

; 253  : 		}
; 254  : 		_debug_print_ ("Ent->child -> %x %x nodes-> %d \r\n", ent->childs, node, sizeof(vfs_node_t));

	mov	r9d, 104				; 00000068H
	mov	r8, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG3593
	call	_debug_print_

; 255  : 		list_add(ent->childs, node);

	mov	rdx, QWORD PTR node$[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_add@@YAXPEAU_list_@@PEAX@Z	; list_add

; 256  : 		_debug_print_ ("List added %x \r\n", ent->childs);

	mov	rax, QWORD PTR ent$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	lea	rcx, OFFSET FLAT:$SG3594
	call	_debug_print_
$LN2@vfs_mount:
$LN21@vfs_mount:

; 257  : 	}
; 258  : 	
; 259  : }

	add	rsp, 120				; 00000078H
	ret	0
vfs_mount ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
ent$ = 32
vfs_mkentry PROC

; 177  : vfs_entry * vfs_mkentry() {

$LN3:
	sub	rsp, 56					; 00000038H

; 178  : 	vfs_entry* ent = (vfs_entry*)malloc(sizeof(vfs_entry));

	mov	ecx, 16
	call	malloc
	mov	QWORD PTR ent$[rsp], rax

; 179  : 	ent->node = 0;

	mov	rax, QWORD PTR ent$[rsp]
	mov	QWORD PTR [rax], 0

; 180  : 	ent->childs = initialize_list();

	call	?initialize_list@@YAPEAU_list_@@XZ	; initialize_list
	mov	rcx, QWORD PTR ent$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 181  : 	return ent;

	mov	rax, QWORD PTR ent$[rsp]

; 182  : }

	add	rsp, 56					; 00000038H
	ret	0
vfs_mkentry ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
found$ = 32
i$1 = 36
j$2 = 40
next$ = 48
ent$ = 56
file_$3 = 64
entry_found$ = 72
pathname$ = 80
path$ = 112
dir$ = 120
dir_node$ = 128
vfs_mkdir PROC

; 125  : void vfs_mkdir (char* path, vfs_node_t* dir, vfs_entry* dir_node) {

$LN20:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 126  : 	dir->device = dir_node;

	mov	rax, QWORD PTR dir$[rsp]
	mov	rcx, QWORD PTR dir_node$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 127  : 	bool found = false;

	mov	BYTE PTR found$[rsp], 0

; 128  : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 129  : 	if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN17@vfs_mkdir

; 130  : 		next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN17@vfs_mkdir:

; 131  : 
; 132  : 	vfs_entry* ent = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR ent$[rsp], rax

; 133  : 	vfs_node_t* entry_found = 0;

	mov	QWORD PTR entry_found$[rsp], 0
$LN16@vfs_mkdir:

; 134  : 	char pathname[16];
; 135  : 	
; 136  : 	while(next) {

	cmp	QWORD PTR next$[rsp], 0
	je	$LN15@vfs_mkdir

; 137  : 		int i = 0;

	mov	DWORD PTR i$1[rsp], 0

; 138  : 
; 139  : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN14@vfs_mkdir
$LN13@vfs_mkdir:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN14@vfs_mkdir:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN12@vfs_mkdir

; 140  : 			if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN10@vfs_mkdir
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN11@vfs_mkdir
$LN10@vfs_mkdir:

; 141  : 				break;

	jmp	SHORT $LN12@vfs_mkdir
$LN11@vfs_mkdir:

; 142  : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR next$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$[rsp+rcx], al

; 143  : 		}

	jmp	SHORT $LN13@vfs_mkdir
$LN12@vfs_mkdir:

; 144  : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$[rsp+rax], 0

; 145  : 
; 146  : 		if (ent == NULL)

	cmp	QWORD PTR ent$[rsp], 0
	jne	SHORT $LN9@vfs_mkdir

; 147  : 			ent = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR ent$[rsp], rax
$LN9@vfs_mkdir:

; 148  : 
; 149  : 		for (int j = 0; j < ent->childs->pointer; j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN8@vfs_mkdir
$LN7@vfs_mkdir:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN8@vfs_mkdir:
	mov	rax, QWORD PTR ent$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$2[rsp], eax
	jae	SHORT $LN6@vfs_mkdir

; 150  : 			vfs_node_t* file_ = (vfs_node_t*)list_get_at(ent->childs, j);

	mov	edx, DWORD PTR j$2[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_get_at@@YAPEAXPEAU_list_@@I@Z	; list_get_at
	mov	QWORD PTR file_$3[rsp], rax

; 151  : 			if (strcmp(file_->filename, pathname) == 0) {

	mov	rax, QWORD PTR file_$3[rsp]
	lea	rdx, QWORD PTR pathname$[rsp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN5@vfs_mkdir

; 152  : 				if (file_->flags == FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR file_$3[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 1
	jne	SHORT $LN4@vfs_mkdir

; 153  : 					ent = (vfs_entry *)file_->device;

	mov	rax, QWORD PTR file_$3[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR ent$[rsp], rax
$LN4@vfs_mkdir:

; 154  : 				found = true;

	mov	BYTE PTR found$[rsp], 1

; 155  : 				entry_found = file_;

	mov	rax, QWORD PTR file_$3[rsp]
	mov	QWORD PTR entry_found$[rsp], rax
$LN5@vfs_mkdir:

; 156  : 			}
; 157  : 		}

	jmp	SHORT $LN7@vfs_mkdir
$LN6@vfs_mkdir:

; 158  : 
; 159  : 		next = strchr(next + 1, '/');

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 160  : 		if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN3@vfs_mkdir

; 161  : 			next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN3@vfs_mkdir:

; 162  : 	}

	jmp	$LN16@vfs_mkdir
$LN15@vfs_mkdir:

; 163  : 
; 164  : 	strcpy(dir->filename, pathname);

	mov	rax, QWORD PTR dir$[rsp]
	lea	rdx, QWORD PTR pathname$[rsp]
	mov	rcx, rax
	call	strcpy

; 165  : 	if (found) {

	movzx	eax, BYTE PTR found$[rsp]
	test	eax, eax
	je	SHORT $LN2@vfs_mkdir

; 166  : 		/* if this entry is a directory, recursively
; 167  : 		* call the node and check it */
; 168  : 		list_add(ent->childs, dir);

	mov	rdx, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_add@@YAXPEAU_list_@@PEAX@Z	; list_add

; 169  : 		return;

	jmp	SHORT $LN18@vfs_mkdir
$LN2@vfs_mkdir:

; 170  : 	}
; 171  : 	if (!found) {

	movzx	eax, BYTE PTR found$[rsp]
	test	eax, eax
	jne	SHORT $LN1@vfs_mkdir

; 172  : 		list_add(ent->childs, dir);

	mov	rdx, QWORD PTR dir$[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_add@@YAXPEAU_list_@@PEAX@Z	; list_add
$LN1@vfs_mkdir:
$LN18@vfs_mkdir:

; 173  : 		return;
; 174  : 	}		
; 175  : }

	add	rsp, 104				; 00000068H
	ret	0
vfs_mkdir ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
i$1 = 32
next$ = 40
j$2 = 48
ent$ = 56
file_$3 = 64
entry_found$ = 72
entry_$4 = 80
pathname$ = 88
fs_path$ = 104
path$ = 128
?vfs_finddir@@YAPEAU_vfs_node_@@PEAD@Z PROC		; vfs_finddir

; 70   : vfs_node_t* vfs_finddir (char *path) {

$LN20:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 71   : 	if (path[0] == '/' && strlen(path) == 2) {

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR path$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN17@vfs_finddi
	mov	rcx, QWORD PTR path$[rsp]
	call	strlen
	cmp	rax, 2
	jne	SHORT $LN17@vfs_finddi

; 72   : 		vfs_entry *entry_ = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR entry_$4[rsp], rax

; 73   : 		return entry_->node;

	mov	rax, QWORD PTR entry_$4[rsp]
	mov	rax, QWORD PTR [rax]
	jmp	$LN18@vfs_finddi
$LN17@vfs_finddi:

; 74   : 	}
; 75   : 
; 76   : 
; 77   : 	char* next = strchr(path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 78   : 	if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN16@vfs_finddi

; 79   : 		next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN16@vfs_finddi:

; 80   : 
; 81   : 	char* fs_path = next;

	mov	rax, QWORD PTR next$[rsp]
	mov	QWORD PTR fs_path$[rsp], rax

; 82   : 
; 83   : 	vfs_entry* ent = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR ent$[rsp], rax

; 84   : 	vfs_node_t* entry_found = 0;

	mov	QWORD PTR entry_found$[rsp], 0
$LN15@vfs_finddi:

; 85   : 	char pathname[16];
; 86   : 
; 87   : 	while(next) {

	cmp	QWORD PTR next$[rsp], 0
	je	$LN14@vfs_finddi

; 88   : 		int i = 0;

	mov	DWORD PTR i$1[rsp], 0

; 89   : 		for (i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN13@vfs_finddi
$LN12@vfs_finddi:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN13@vfs_finddi:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN11@vfs_finddi

; 90   : 			if (next[i] == '/' || next[i] == '\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN9@vfs_finddi
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR next$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN10@vfs_finddi
$LN9@vfs_finddi:

; 91   : 				break;

	jmp	SHORT $LN11@vfs_finddi
$LN10@vfs_finddi:

; 92   : 			pathname[i] = next[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR next$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$[rsp+rcx], al

; 93   : 		}

	jmp	SHORT $LN12@vfs_finddi
$LN11@vfs_finddi:

; 94   : 		pathname[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$[rsp+rax], 0

; 95   : 
; 96   : 		if (ent == NULL)

	cmp	QWORD PTR ent$[rsp], 0
	jne	SHORT $LN8@vfs_finddi

; 97   : 			ent = root_dir;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	QWORD PTR ent$[rsp], rax
$LN8@vfs_finddi:

; 98   : 
; 99   : 		for (int j = 0; j < ent->childs->pointer; j++) {

	mov	DWORD PTR j$2[rsp], 0
	jmp	SHORT $LN7@vfs_finddi
$LN6@vfs_finddi:
	mov	eax, DWORD PTR j$2[rsp]
	inc	eax
	mov	DWORD PTR j$2[rsp], eax
$LN7@vfs_finddi:
	mov	rax, QWORD PTR ent$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax]
	cmp	DWORD PTR j$2[rsp], eax
	jae	SHORT $LN5@vfs_finddi

; 100  : 			vfs_node_t *file_ = (vfs_node_t*)list_get_at(ent->childs, j);

	mov	edx, DWORD PTR j$2[rsp]
	mov	rax, QWORD PTR ent$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?list_get_at@@YAPEAXPEAU_list_@@I@Z	; list_get_at
	mov	QWORD PTR file_$3[rsp], rax

; 101  : 			if (strcmp(file_->filename, pathname) == 0) {

	mov	rax, QWORD PTR file_$3[rsp]
	lea	rdx, QWORD PTR pathname$[rsp]
	mov	rcx, rax
	call	strcmp
	test	eax, eax
	jne	SHORT $LN4@vfs_finddi

; 102  : 				if (file_->flags == FS_FLAG_DIRECTORY)

	mov	rax, QWORD PTR file_$3[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 1
	jne	SHORT $LN3@vfs_finddi

; 103  : 					ent = (vfs_entry*)file_->device;

	mov	rax, QWORD PTR file_$3[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR ent$[rsp], rax
$LN3@vfs_finddi:

; 104  : 				entry_found = file_;

	mov	rax, QWORD PTR file_$3[rsp]
	mov	QWORD PTR entry_found$[rsp], rax
$LN4@vfs_finddi:

; 105  : 			}
; 106  : 		}

	jmp	SHORT $LN6@vfs_finddi
$LN5@vfs_finddi:

; 107  : 
; 108  : 		next = strchr(next + 1, '/');

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR next$[rsp], rax

; 109  : 		if (next)

	cmp	QWORD PTR next$[rsp], 0
	je	SHORT $LN2@vfs_finddi

; 110  : 			next++;

	mov	rax, QWORD PTR next$[rsp]
	inc	rax
	mov	QWORD PTR next$[rsp], rax
$LN2@vfs_finddi:

; 111  : 	}

	jmp	$LN15@vfs_finddi
$LN14@vfs_finddi:

; 112  : 
; 113  : 	if (!entry_found) 

	cmp	QWORD PTR entry_found$[rsp], 0
	jne	SHORT $LN1@vfs_finddi

; 114  : 		entry_found = root_dir->node;

	mov	rax, QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA ; root_dir
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR entry_found$[rsp], rax
$LN1@vfs_finddi:

; 115  : 
; 116  : 	return entry_found;

	mov	rax, QWORD PTR entry_found$[rsp]
$LN18@vfs_finddi:

; 117  : }

	add	rsp, 120				; 00000078H
	ret	0
?vfs_finddir@@YAPEAU_vfs_node_@@PEAD@Z ENDP		; vfs_finddir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\vfs.cpp
_TEXT	SEGMENT
root$ = 32
?AuVFSInit@@YAXXZ PROC					; AuVFSInit

; 53   : void AuVFSInit () {

$LN3:
	sub	rsp, 56					; 00000038H

; 54   : 	vfs_entry *root = (vfs_entry*)malloc(sizeof(vfs_entry));

	mov	ecx, 16
	call	malloc
	mov	QWORD PTR root$[rsp], rax

; 55   : 	root->node = 0;

	mov	rax, QWORD PTR root$[rsp]
	mov	QWORD PTR [rax], 0

; 56   : 	root->childs = initialize_list();

	call	?initialize_list@@YAPEAU_list_@@XZ	; initialize_list
	mov	rcx, QWORD PTR root$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 57   : 	root_dir = root;

	mov	rax, QWORD PTR root$[rsp]
	mov	QWORD PTR ?root_dir@@3PEAU_vfs_entry_@@EA, rax ; root_dir

; 58   : 
; 59   : 
; 60   : 	//! Initialize the root file system
; 61   : 	initialize_fat32();

	call	?initialize_fat32@@YAXXZ		; initialize_fat32

; 62   : 	fat32_self_register();

	call	?fat32_self_register@@YAXXZ		; fat32_self_register

; 63   : 
; 64   : 	//! Initialize the device file system
; 65   : 	devfs_mount();

	call	?devfs_mount@@YAXXZ			; devfs_mount

; 66   : 
; 67   : 
; 68   : }

	add	rsp, 56					; 00000038H
	ret	0
?AuVFSInit@@YAXXZ ENDP					; AuVFSInit
_TEXT	ENDS
END
