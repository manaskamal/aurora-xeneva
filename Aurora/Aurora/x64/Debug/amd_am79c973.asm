; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?amd_io_base@@3_KA				; amd_io_base
PUBLIC	?amd_mac@@3PAEA					; amd_mac
PUBLIC	?amd_irq@@3IA					; amd_irq
_BSS	SEGMENT
?amd_io_base@@3_KA DQ 01H DUP (?)			; amd_io_base
?amd_mac@@3PAEA DB 06H DUP (?)				; amd_mac
	ALIGN	4

?amd_irq@@3IA DD 01H DUP (?)				; amd_irq
_BSS	ENDS
CONST	SEGMENT
$SG3227	DB	'AMD NIC Interrupt handler++', 0aH, 00H
	ORG $+3
$SG3233	DB	'AMD PCNet card not found', 0aH, 00H
	ORG $+6
$SG3234	DB	'AMD PCNet card found -> device id -> %x, vendor id -> %x'
	DB	0aH, 00H
	ORG $+6
$SG3235	DB	'AMD Base Address -> %x, -> %x', 0aH, 00H
	ORG $+1
$SG3236	DB	'AMD Interrupt line -> %d', 0aH, 00H
CONST	ENDS
PUBLIC	?amd_pcnet_initialize@@YAXXZ			; amd_pcnet_initialize
PUBLIC	?amd_write_bcr@@YAXGG@Z				; amd_write_bcr
PUBLIC	?amd_write_csr@@YAXEG@Z				; amd_write_csr
PUBLIC	?amd_read_csr@@YAGE@Z				; amd_read_csr
PUBLIC	?amd_interrupt_handler@@YAX_KPEAX@Z		; amd_interrupt_handler
EXTRN	x64_cli:PROC
EXTRN	x64_inportw:PROC
EXTRN	x64_outportw:PROC
EXTRN	?interrupt_end@@YAXI@Z:PROC			; interrupt_end
EXTRN	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z:PROC	; interrupt_set
EXTRN	?pci_find_device_class@@YA_NEEPEATpci_device_info@@@Z:PROC ; pci_find_device_class
EXTRN	?pci_print_capabilities@@YAXPEATpci_device_info@@@Z:PROC ; pci_print_capabilities
EXTRN	?pmmngr_alloc@@YAPEAXXZ:PROC			; pmmngr_alloc
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
pdata	SEGMENT
$pdata$?amd_pcnet_initialize@@YAXXZ DD imagerel $LN10
	DD	imagerel $LN10+629
	DD	imagerel $unwind$?amd_pcnet_initialize@@YAXXZ
$pdata$?amd_write_bcr@@YAXGG@Z DD imagerel $LN3
	DD	imagerel $LN3+60
	DD	imagerel $unwind$?amd_write_bcr@@YAXGG@Z
$pdata$?amd_write_csr@@YAXEG@Z DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$?amd_write_csr@@YAXEG@Z
$pdata$?amd_read_csr@@YAGE@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$?amd_read_csr@@YAGE@Z
$pdata$?amd_interrupt_handler@@YAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$?amd_interrupt_handler@@YAX_KPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?amd_pcnet_initialize@@YAXXZ DD 010401H
	DD	08204H
$unwind$?amd_write_bcr@@YAXGG@Z DD 010e01H
	DD	0420eH
$unwind$?amd_write_csr@@YAXEG@Z DD 010d01H
	DD	0420dH
$unwind$?amd_read_csr@@YAGE@Z DD 010801H
	DD	04208H
$unwind$?amd_interrupt_handler@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
xdata	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\net\amd_am79c973.cpp
_TEXT	SEGMENT
v$ = 48
p$ = 56
?amd_interrupt_handler@@YAX_KPEAX@Z PROC		; amd_interrupt_handler

; 36   : void amd_interrupt_handler (size_t v, void* p) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 37   : 	x64_cli();

	call	x64_cli

; 38   : 	printf ("AMD NIC Interrupt handler++\n");

	lea	rcx, OFFSET FLAT:$SG3227
	call	?printf@@YAXPEBDZZ			; printf

; 39   : 	//apic_local_eoi();
; 40   : 	interrupt_end(amd_irq);

	mov	ecx, DWORD PTR ?amd_irq@@3IA		; amd_irq
	call	?interrupt_end@@YAXI@Z			; interrupt_end

; 41   : }

	add	rsp, 40					; 00000028H
	ret	0
?amd_interrupt_handler@@YAX_KPEAX@Z ENDP		; amd_interrupt_handler
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\net\amd_am79c973.cpp
_TEXT	SEGMENT
csr$ = 48
?amd_read_csr@@YAGE@Z PROC				; amd_read_csr

; 30   : uint16_t amd_read_csr (uint8_t csr) {

$LN3:
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 40					; 00000028H

; 31   : 	x64_outportw (amd_io_base + RAP, csr);

	movzx	eax, BYTE PTR csr$[rsp]
	mov	rcx, QWORD PTR ?amd_io_base@@3_KA	; amd_io_base
	add	rcx, 18
	movzx	edx, ax
	call	x64_outportw

; 32   : 	return x64_inportw (amd_io_base+RDP);

	mov	rax, QWORD PTR ?amd_io_base@@3_KA	; amd_io_base
	add	rax, 16
	movzx	ecx, ax
	call	x64_inportw

; 33   : }

	add	rsp, 40					; 00000028H
	ret	0
?amd_read_csr@@YAGE@Z ENDP				; amd_read_csr
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\net\amd_am79c973.cpp
_TEXT	SEGMENT
csr$ = 48
value$ = 56
?amd_write_csr@@YAXEG@Z PROC				; amd_write_csr

; 25   : void amd_write_csr (uint8_t csr, uint16_t value) {

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 40					; 00000028H

; 26   : 	x64_outportw (amd_io_base + RAP, csr);

	movzx	eax, BYTE PTR csr$[rsp]
	mov	rcx, QWORD PTR ?amd_io_base@@3_KA	; amd_io_base
	add	rcx, 18
	movzx	edx, ax
	call	x64_outportw

; 27   : 	x64_outportw (amd_io_base + RDP, value);

	mov	rax, QWORD PTR ?amd_io_base@@3_KA	; amd_io_base
	add	rax, 16
	movzx	edx, WORD PTR value$[rsp]
	movzx	ecx, ax
	call	x64_outportw

; 28   : }

	add	rsp, 40					; 00000028H
	ret	0
?amd_write_csr@@YAXEG@Z ENDP				; amd_write_csr
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\net\amd_am79c973.cpp
_TEXT	SEGMENT
bcr$ = 48
value$ = 56
?amd_write_bcr@@YAXGG@Z PROC				; amd_write_bcr

; 20   : void amd_write_bcr (uint16_t bcr, uint16_t value) {

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 40					; 00000028H

; 21   : 	x64_outportw (amd_io_base + RAP, bcr);

	mov	rax, QWORD PTR ?amd_io_base@@3_KA	; amd_io_base
	add	rax, 18
	movzx	edx, WORD PTR bcr$[rsp]
	movzx	ecx, ax
	call	x64_outportw

; 22   : 	x64_outportw (amd_io_base, value);

	movzx	edx, WORD PTR value$[rsp]
	movzx	ecx, WORD PTR ?amd_io_base@@3_KA
	call	x64_outportw

; 23   : }

	add	rsp, 40					; 00000028H
	ret	0
?amd_write_bcr@@YAXGG@Z ENDP				; amd_write_bcr
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\net\amd_am79c973.cpp
_TEXT	SEGMENT
temp$ = 32
i$1 = 36
i$2 = 40
dev$ = 48
?amd_pcnet_initialize@@YAXXZ PROC			; amd_pcnet_initialize

; 44   : void amd_pcnet_initialize () {

$LN10:
	sub	rsp, 72					; 00000048H

; 45   : 	pci_device_info *dev = (pci_device_info*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR dev$[rsp], rax

; 46   : 
; 47   : 	if (!pci_find_device_class (0x02,0x00,dev)) {

	mov	r8, QWORD PTR dev$[rsp]
	xor	edx, edx
	mov	cl, 2
	call	?pci_find_device_class@@YA_NEEPEATpci_device_info@@@Z ; pci_find_device_class
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@amd_pcnet_

; 48   : 		printf ("AMD PCNet card not found\n");

	lea	rcx, OFFSET FLAT:$SG3233
	call	?printf@@YAXPEBDZZ			; printf
$LN7@amd_pcnet_:

; 49   : 	}
; 50   : 
; 51   : 	amd_io_base = dev->device.nonBridge.baseAddress[0];

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR dev$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	mov	QWORD PTR ?amd_io_base@@3_KA, rax	; amd_io_base

; 52   : 	printf ("AMD PCNet card found -> device id -> %x, vendor id -> %x\n", dev->device.deviceID, dev->device.vendorID);

	mov	rax, QWORD PTR dev$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	rcx, QWORD PTR dev$[rsp]
	movzx	ecx, WORD PTR [rcx+2]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:$SG3234
	call	?printf@@YAXPEBDZZ			; printf

; 53   : 	printf ("AMD Base Address -> %x, -> %x\n", dev->device.nonBridge.baseAddress[0], dev->device.nonBridge.baseAddress[1]);

	mov	eax, 4
	imul	rax, 1
	mov	ecx, 4
	imul	rcx, 0
	mov	rdx, QWORD PTR dev$[rsp]
	mov	r8d, DWORD PTR [rdx+rax+16]
	mov	rax, QWORD PTR dev$[rsp]
	mov	edx, DWORD PTR [rax+rcx+16]
	lea	rcx, OFFSET FLAT:$SG3235
	call	?printf@@YAXPEBDZZ			; printf

; 54   : 	printf ("AMD Interrupt line -> %d\n", dev->device.nonBridge.interruptLine);

	mov	rax, QWORD PTR dev$[rsp]
	movzx	eax, BYTE PTR [rax+60]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3236
	call	?printf@@YAXPEBDZZ			; printf

; 55   : 
; 56   : 	amd_irq = dev->device.nonBridge.interruptLine;

	mov	rax, QWORD PTR dev$[rsp]
	movzx	eax, BYTE PTR [rax+60]
	mov	DWORD PTR ?amd_irq@@3IA, eax		; amd_irq

; 57   : 	pci_print_capabilities(dev);

	mov	rcx, QWORD PTR dev$[rsp]
	call	?pci_print_capabilities@@YAXPEATpci_device_info@@@Z ; pci_print_capabilities

; 58   : 
; 59   : 	uint16_t temp = x64_inportw (amd_io_base + APROM0);

	movzx	ecx, WORD PTR ?amd_io_base@@3_KA
	call	x64_inportw
	mov	WORD PTR temp$[rsp], ax

; 60   : 	amd_mac[0] = temp;

	mov	eax, 1
	imul	rax, 0
	lea	rcx, OFFSET FLAT:?amd_mac@@3PAEA	; amd_mac
	movzx	edx, BYTE PTR temp$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 61   : 	amd_mac[1] = temp >> 8;

	movzx	eax, WORD PTR temp$[rsp]
	sar	eax, 8
	mov	ecx, 1
	imul	rcx, 1
	lea	rdx, OFFSET FLAT:?amd_mac@@3PAEA	; amd_mac
	mov	BYTE PTR [rdx+rcx], al

; 62   : 	temp = x64_inportw (amd_io_base + APROM2);

	mov	rax, QWORD PTR ?amd_io_base@@3_KA	; amd_io_base
	add	rax, 2
	movzx	ecx, ax
	call	x64_inportw
	mov	WORD PTR temp$[rsp], ax

; 63   : 	amd_mac[2] = temp;

	mov	eax, 1
	imul	rax, 2
	lea	rcx, OFFSET FLAT:?amd_mac@@3PAEA	; amd_mac
	movzx	edx, BYTE PTR temp$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 64   : 	amd_mac[3] = temp >> 8;

	movzx	eax, WORD PTR temp$[rsp]
	sar	eax, 8
	mov	ecx, 1
	imul	rcx, 3
	lea	rdx, OFFSET FLAT:?amd_mac@@3PAEA	; amd_mac
	mov	BYTE PTR [rdx+rcx], al

; 65   : 	temp = x64_inportw(amd_io_base + APROM4);

	mov	rax, QWORD PTR ?amd_io_base@@3_KA	; amd_io_base
	add	rax, 4
	movzx	ecx, ax
	call	x64_inportw
	mov	WORD PTR temp$[rsp], ax

; 66   : 	amd_mac[4] = temp;

	mov	eax, 1
	imul	rax, 4
	lea	rcx, OFFSET FLAT:?amd_mac@@3PAEA	; amd_mac
	movzx	edx, BYTE PTR temp$[rsp]
	mov	BYTE PTR [rcx+rax], dl

; 67   : 	amd_mac[5] = temp>>8;

	movzx	eax, WORD PTR temp$[rsp]
	sar	eax, 8
	mov	ecx, 1
	imul	rcx, 5
	lea	rdx, OFFSET FLAT:?amd_mac@@3PAEA	; amd_mac
	mov	BYTE PTR [rdx+rcx], al

; 68   : 
; 69   : 	x64_inportw (amd_io_base + RESET);

	mov	rax, QWORD PTR ?amd_io_base@@3_KA	; amd_io_base
	add	rax, 20
	movzx	ecx, ax
	call	x64_inportw

; 70   : 	x64_outportw (amd_io_base + RESET, 0);

	mov	rax, QWORD PTR ?amd_io_base@@3_KA	; amd_io_base
	add	rax, 20
	xor	edx, edx
	movzx	ecx, ax
	call	x64_outportw

; 71   : 	for (int i = 0; i < 5; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@amd_pcnet_
$LN5@amd_pcnet_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@amd_pcnet_:
	cmp	DWORD PTR i$1[rsp], 5
	jge	SHORT $LN4@amd_pcnet_

; 72   : 		;

	jmp	SHORT $LN5@amd_pcnet_
$LN4@amd_pcnet_:

; 73   : 	amd_write_csr (20,0x0102);

	mov	dx, 258					; 00000102H
	mov	cl, 20
	call	?amd_write_csr@@YAXEG@Z			; amd_write_csr

; 74   : 
; 75   : 	
; 76   : 
; 77   : 	//!stop
; 78   : 	amd_write_csr (0, 0x04);

	mov	dx, 4
	xor	ecx, ecx
	call	?amd_write_csr@@YAXEG@Z			; amd_write_csr

; 79   : 
; 80   : 	//!initialize
; 81   : 	amd_write_csr (0, 0x41);

	mov	dx, 65					; 00000041H
	xor	ecx, ecx
	call	?amd_write_csr@@YAXEG@Z			; amd_write_csr

; 82   : 	for (int i = 0; i < 1000; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@amd_pcnet_
$LN2@amd_pcnet_:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@amd_pcnet_:
	cmp	DWORD PTR i$2[rsp], 1000		; 000003e8H
	jge	SHORT $LN1@amd_pcnet_

; 83   : 		;

	jmp	SHORT $LN2@amd_pcnet_
$LN1@amd_pcnet_:

; 84   : 	amd_write_csr (4, 0x4C00 | amd_read_csr (4));

	mov	cl, 4
	call	?amd_read_csr@@YAGE@Z			; amd_read_csr
	movzx	eax, ax
	or	eax, 19456				; 00004c00H
	movzx	edx, ax
	mov	cl, 4
	call	?amd_write_csr@@YAXEG@Z			; amd_write_csr

; 85   : 	amd_write_csr (0,0x42);

	mov	dx, 66					; 00000042H
	xor	ecx, ecx
	call	?amd_write_csr@@YAXEG@Z			; amd_write_csr

; 86   : 
; 87   : 	interrupt_set (dev->device.nonBridge.interruptLine, amd_interrupt_handler, dev->device.nonBridge.interruptLine);

	mov	rax, QWORD PTR dev$[rsp]
	movzx	eax, BYTE PTR [rax+60]
	mov	rcx, QWORD PTR dev$[rsp]
	movzx	r8d, BYTE PTR [rcx+60]
	lea	rdx, OFFSET FLAT:?amd_interrupt_handler@@YAX_KPEAX@Z ; amd_interrupt_handler
	mov	ecx, eax
	call	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z	; interrupt_set

; 88   : }

	add	rsp, 72					; 00000048H
	ret	0
?amd_pcnet_initialize@@YAXXZ ENDP			; amd_pcnet_initialize
_TEXT	ENDS
END
