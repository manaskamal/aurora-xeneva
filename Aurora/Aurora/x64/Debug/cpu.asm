; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_fxsave	DB	01H DUP (?)
	ALIGN	4

_xsave	DB	01H DUP (?)
	ALIGN	4

pit_tick DD	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
$SG3592	DB	'*** [x64_idt] x64_default_handler: Unhandled Exception *'
	DB	'** ', 0aH, 00H
	ORG $+3
$SG3652	DB	'IDT initialized', 0aH, 00H
	ORG $+7
$SG3653	DB	'Exception initialized', 0aH, 00H
	ORG $+1
$SG3654	DB	'APIC initialized', 0aH, 00H
	ORG $+6
$SG3656	DB	'EFER.SYSCALL enabled', 0aH, 00H
	ORG $+2
$SG3657	DB	'User Land Initialized', 0aH, 00H
	ORG $+1
$SG3658	DB	'System call initialized', 0aH, 00H
CONST	ENDS
PUBLIC	?x86_64_gdt_init@@YAXXZ				; x86_64_gdt_init
PUBLIC	setvect
PUBLIC	gdt_initialize
PUBLIC	?gdt_initialize_ap@@YAXXZ			; gdt_initialize_ap
PUBLIC	?interrupt_initialize_ap@@YAXXZ			; interrupt_initialize_ap
PUBLIC	?interrupt_initialize@@YAXXZ			; interrupt_initialize
PUBLIC	?x86_64_init_cpu@@YAXXZ				; x86_64_init_cpu
PUBLIC	?x86_64_cpu_get_id@@YAEXZ			; x86_64_cpu_get_id
PUBLIC	?hal_cpu_feature_enable@@YAXXZ			; hal_cpu_feature_enable
PUBLIC	?is_cpu_fxsave_supported@@YA_NXZ		; is_cpu_fxsave_supported
PUBLIC	?is_cpu_xsave_supported@@YA_NXZ			; is_cpu_xsave_supported
PUBLIC	?cpu_msi_address@@YA_KPEA_K_KIEE@Z		; cpu_msi_address
PUBLIC	?cpu_rdtsc@@YAIXZ				; cpu_rdtsc
PUBLIC	load_default_sregs
PUBLIC	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z		; set_gdt_entry
PUBLIC	?save_sregs@@YAXXZ				; save_sregs
PUBLIC	interrupt_dispatcher
PUBLIC	?default_irq@@YAX_KPEAX@Z			; default_irq
PUBLIC	?pit_handler_callback@@YAX_KPEAX@Z		; pit_handler_callback
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	x64_cli:PROC
EXTRN	x64_sti:PROC
EXTRN	x64_read_msr:PROC
EXTRN	x64_write_msr:PROC
EXTRN	x64_cpuid:PROC
EXTRN	x64_read_cr0:PROC
EXTRN	x64_read_cr4:PROC
EXTRN	x64_write_cr0:PROC
EXTRN	x64_write_cr4:PROC
EXTRN	x64_lgdt:PROC
EXTRN	x64_sgdt:PROC
EXTRN	x64_rdtsc:PROC
EXTRN	?exception_init@@YAXXZ:PROC			; exception_init
EXTRN	printf:PROC
EXTRN	?initialize_syscall@@YAXXZ:PROC			; initialize_syscall
EXTRN	?initialize_user_land@@YAX_K@Z:PROC		; initialize_user_land
EXTRN	?initialize_apic@@YAX_N@Z:PROC			; initialize_apic
EXTRN	apic_local_eoi:PROC
EXTRN	malloc:PROC
EXTRN	?AuCreatePCPU@@YAXPEAX@Z:PROC			; AuCreatePCPU
EXTRN	?AuPCPUSetKernelTSS@@YAXPEAU_tss@@@Z:PROC	; AuPCPUSetKernelTSS
EXTRN	x64_get_segment_register:PROC
EXTRN	x64_set_segment_register:PROC
EXTRN	x64_ltr:PROC
EXTRN	x64_lidt:PROC
EXTRN	?debug_print@@YAXPEBDZZ:PROC			; debug_print
EXTRN	default_irq_handlers:BYTE
_BSS	SEGMENT
	ALIGN	8

gdt	DQ	09H DUP (?)
the_gdtr DB	0aH DUP (?)
	ALIGN	4

old_gdtr DB	0aH DUP (?)
	ALIGN	4

oldsregs DW	08H DUP (?)
interrupts_handlers DQ 0100H DUP (?)
the_idt	DB	01000H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$?x86_64_gdt_init@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?x86_64_gdt_init@@YAXXZ
$pdata$gdt_initialize DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$gdt_initialize
$pdata$?gdt_initialize_ap@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+106
	DD	imagerel $unwind$?gdt_initialize_ap@@YAXXZ
$pdata$?interrupt_initialize_ap@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+413
	DD	imagerel $unwind$?interrupt_initialize_ap@@YAXXZ
$pdata$?interrupt_initialize@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+415
	DD	imagerel $unwind$?interrupt_initialize@@YAXXZ
$pdata$?x86_64_init_cpu@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+227
	DD	imagerel $unwind$?x86_64_init_cpu@@YAXXZ
$pdata$?x86_64_cpu_get_id@@YAEXZ DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$?x86_64_cpu_get_id@@YAEXZ
$pdata$?hal_cpu_feature_enable@@YAXXZ DD imagerel $LN10
	DD	imagerel $LN10+270
	DD	imagerel $unwind$?hal_cpu_feature_enable@@YAXXZ
$pdata$?cpu_msi_address@@YA_KPEA_K_KIEE@Z DD imagerel $LN7
	DD	imagerel $LN7+131
	DD	imagerel $unwind$?cpu_msi_address@@YA_KPEA_K_KIEE@Z
$pdata$?cpu_rdtsc@@YAIXZ DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?cpu_rdtsc@@YAIXZ
$pdata$load_default_sregs DD imagerel $LN3
	DD	imagerel $LN3+90
	DD	imagerel $unwind$load_default_sregs
$pdata$?set_gdt_entry@@YAXAEAU_gdt@@EE@Z DD imagerel ?set_gdt_entry@@YAXAEAU_gdt@@EE@Z
	DD	imagerel ?set_gdt_entry@@YAXAEAU_gdt@@EE@Z+82
	DD	imagerel $unwind$?set_gdt_entry@@YAXAEAU_gdt@@EE@Z
$pdata$?fill_gdt@@YAXPEAU_gdt@@@Z DD imagerel ?fill_gdt@@YAXPEAU_gdt@@@Z
	DD	imagerel ?fill_gdt@@YAXPEAU_gdt@@@Z+253
	DD	imagerel $unwind$?fill_gdt@@YAXPEAU_gdt@@@Z
$pdata$?save_sregs@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+67
	DD	imagerel $unwind$?save_sregs@@YAXXZ
$pdata$?register_irq@@YAXPEAU_idt@@PEAX@Z DD imagerel ?register_irq@@YAXPEAU_idt@@PEAX@Z
	DD	imagerel ?register_irq@@YAXPEAU_idt@@PEAX@Z+93
	DD	imagerel $unwind$?register_irq@@YAXPEAU_idt@@PEAX@Z
$pdata$interrupt_dispatcher DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$interrupt_dispatcher
$pdata$?default_irq@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+38
	DD	imagerel $unwind$?default_irq@@YAX_KPEAX@Z
$pdata$?pit_handler_callback@@YAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?pit_handler_callback@@YAX_KPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?x86_64_gdt_init@@YAXXZ DD 010401H
	DD	04204H
$unwind$gdt_initialize DD 010401H
	DD	04204H
$unwind$?gdt_initialize_ap@@YAXXZ DD 010401H
	DD	08204H
$unwind$?interrupt_initialize_ap@@YAXXZ DD 010401H
	DD	0e204H
$unwind$?interrupt_initialize@@YAXXZ DD 010401H
	DD	0e204H
$unwind$?x86_64_init_cpu@@YAXXZ DD 010401H
	DD	06204H
$unwind$?x86_64_cpu_get_id@@YAEXZ DD 010401H
	DD	0c204H
$unwind$?hal_cpu_feature_enable@@YAXXZ DD 010401H
	DD	0e204H
$unwind$?cpu_msi_address@@YA_KPEA_K_KIEE@Z DD 011801H
	DD	02218H
$unwind$?cpu_rdtsc@@YAIXZ DD 010401H
	DD	06204H
$unwind$load_default_sregs DD 010401H
	DD	04204H
$unwind$?set_gdt_entry@@YAXAEAU_gdt@@EE@Z DD 011201H
	DD	06212H
$unwind$?fill_gdt@@YAXPEAU_gdt@@@Z DD 010901H
	DD	06209H
$unwind$?save_sregs@@YAXXZ DD 010401H
	DD	06204H
$unwind$?register_irq@@YAXPEAU_idt@@PEAX@Z DD 010e01H
	DD	0220eH
$unwind$interrupt_dispatcher DD 010e01H
	DD	0420eH
$unwind$?default_irq@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
$unwind$?pit_handler_callback@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
p$ = 48
param$ = 56
?pit_handler_callback@@YAX_KPEAX@Z PROC			; pit_handler_callback

; 239  : void pit_handler_callback (size_t p, void* param) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 240  : 	apic_local_eoi();

	call	apic_local_eoi

; 241  : }

	add	rsp, 40					; 00000028H
	ret	0
?pit_handler_callback@@YAX_KPEAX@Z ENDP			; pit_handler_callback
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
vect$ = 48
param$ = 56
?default_irq@@YAX_KPEAX@Z PROC				; default_irq

; 155  : void default_irq(size_t vect, void* param){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 156  : 	x64_cli();

	call	x64_cli

; 157  : 	printf("*** [x64_idt] x64_default_handler: Unhandled Exception *** \n");

	lea	rcx, OFFSET FLAT:$SG3592
	call	printf
$LN2@default_ir:

; 158  : 	for(;;);

	jmp	SHORT $LN2@default_ir

; 159  : }

	add	rsp, 40					; 00000028H
	ret	0
?default_irq@@YAX_KPEAX@Z ENDP				; default_irq
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
num$ = 48
frame$ = 56
interrupt_dispatcher PROC

; 149  : {	

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 150  : 	interrupts_handlers[num](num, frame);

	lea	rax, OFFSET FLAT:interrupts_handlers
	mov	rdx, QWORD PTR frame$[rsp]
	mov	rcx, QWORD PTR num$[rsp]
	mov	r8, QWORD PTR num$[rsp]
	call	QWORD PTR [rax+r8*8]

; 151  : 	return;
; 152  : }

	add	rsp, 40					; 00000028H
	ret	0
interrupt_dispatcher ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
faddr$ = 0
entry$ = 32
function$ = 40
?register_irq@@YAXPEAU_idt@@PEAX@Z PROC			; register_irq

; 136  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 137  : 	size_t faddr = (size_t)function;

	mov	rax, QWORD PTR function$[rsp]
	mov	QWORD PTR faddr$[rsp], rax

; 138  : 	entry->offset_1 = faddr & UINT16_MAX;

	mov	rax, QWORD PTR faddr$[rsp]
	and	rax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR entry$[rsp]
	mov	WORD PTR [rcx], ax

; 139  : 	entry->offset_2 = (faddr >> 16) & UINT16_MAX;

	mov	rax, QWORD PTR faddr$[rsp]
	shr	rax, 16
	and	rax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR entry$[rsp]
	mov	WORD PTR [rcx+6], ax

; 140  : 	entry->offset_3 = (faddr >> 32) & UINT32_MAX;

	mov	rax, QWORD PTR faddr$[rsp]
	shr	rax, 32					; 00000020H
	mov	ecx, -1					; ffffffffH
	and	rax, rcx
	mov	rcx, QWORD PTR entry$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 141  : }

	add	rsp, 24
	ret	0
?register_irq@@YAXPEAU_idt@@PEAX@Z ENDP			; register_irq
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
reg$1 = 32
?save_sregs@@YAXXZ PROC					; save_sregs

; 86   : {

$LN6:
	sub	rsp, 56					; 00000038H

; 87   : 	for (uint_fast8_t reg = 0; reg < 8; ++reg)

	mov	BYTE PTR reg$1[rsp], 0
	jmp	SHORT $LN3@save_sregs
$LN2@save_sregs:
	movzx	eax, BYTE PTR reg$1[rsp]
	inc	al
	mov	BYTE PTR reg$1[rsp], al
$LN3@save_sregs:
	movzx	eax, BYTE PTR reg$1[rsp]
	cmp	eax, 8
	jge	SHORT $LN1@save_sregs

; 88   : 		oldsregs[reg] = x64_get_segment_register(reg);

	movzx	eax, BYTE PTR reg$1[rsp]
	mov	ecx, eax
	call	x64_get_segment_register
	movzx	ecx, BYTE PTR reg$1[rsp]
	lea	rdx, OFFSET FLAT:oldsregs
	mov	WORD PTR [rdx+rcx*2], ax
	jmp	SHORT $LN2@save_sregs
$LN1@save_sregs:

; 89   : }

	add	rsp, 56					; 00000038H
	ret	0
?save_sregs@@YAXXZ ENDP					; save_sregs
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
thegdt$ = 64
?fill_gdt@@YAXPEAU_gdt@@@Z PROC				; fill_gdt

; 69   : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 70   : 	set_gdt_entry(thegdt[GDT_ENTRY_NULL], 0, 0, 0, 0);    //0x00

	mov	eax, 8
	imul	rax, 0
	mov	rcx, QWORD PTR thegdt$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z	; set_gdt_entry

; 71   : 	//Kernel Code segment: STAR.SYSCALL_CS
; 72   : 	set_gdt_entry(thegdt[GDT_ENTRY_KERNEL_CODE], GDT_ACCESS_PRIVL(0) | GDT_ACCESS_RW | GDT_ACCESS_EX, GDT_FLAG_64BT);  //0x08

	mov	eax, 8
	imul	rax, 1
	mov	rcx, QWORD PTR thegdt$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 2
	mov	dl, 10
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@EE@Z	; set_gdt_entry

; 73   : 	//Kernel Data segment
; 74   : 	set_gdt_entry(thegdt[GDT_ENTRY_KERNEL_DATA], GDT_ACCESS_PRIVL(0) | GDT_ACCESS_RW, GDT_FLAG_32BT);    //0x10

	mov	eax, 8
	imul	rax, 2
	mov	rcx, QWORD PTR thegdt$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	dl, 2
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@EE@Z	; set_gdt_entry

; 75   : 	//User Code segment (32 bit): STAR.SYSRET_CS
; 76   : 	set_gdt_entry(thegdt[GDT_ENTRY_USER_CODE32], GDT_ACCESS_PRIVL(3) | GDT_ACCESS_RW | GDT_ACCESS_EX, GDT_FLAG_32BT);  //0x18

	mov	eax, 8
	imul	rax, 3
	mov	rcx, QWORD PTR thegdt$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	dl, 106					; 0000006aH
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@EE@Z	; set_gdt_entry

; 77   : 	//User Data segment
; 78   : 	set_gdt_entry(thegdt[GDT_ENTRY_USER_DATA], GDT_ACCESS_PRIVL(3) | GDT_ACCESS_RW, GDT_FLAG_32BT);    //0x20

	mov	eax, 8
	imul	rax, 4
	mov	rcx, QWORD PTR thegdt$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	dl, 98					; 00000062H
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@EE@Z	; set_gdt_entry

; 79   : 	//User Code segment (64 bit)
; 80   : 	set_gdt_entry(thegdt[GDT_ENTRY_USER_CODE], GDT_ACCESS_PRIVL(3) | GDT_ACCESS_RW | GDT_ACCESS_EX, GDT_FLAG_64BT);   //0x28  | 3 -- 0x2B

	mov	eax, 8
	imul	rax, 5
	mov	rcx, QWORD PTR thegdt$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 2
	mov	dl, 106					; 0000006aH
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@EE@Z	; set_gdt_entry

; 81   : 	//Kernel Code segment (32 bit)
; 82   : 	set_gdt_entry(thegdt[GDT_ENTRY_KERNEL_CODE32], GDT_ACCESS_PRIVL(3) | GDT_ACCESS_RW | GDT_ACCESS_EX , GDT_FLAG_32BT);  //0x30

	mov	eax, 8
	imul	rax, 6
	mov	rcx, QWORD PTR thegdt$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8b, 4
	mov	dl, 106					; 0000006aH
	mov	rcx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@EE@Z	; set_gdt_entry

; 83   : }

	add	rsp, 56					; 00000038H
	ret	0
?fill_gdt@@YAXPEAU_gdt@@@Z ENDP				; fill_gdt
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
entry$ = 64
access$ = 72
flags$ = 80
?set_gdt_entry@@YAXAEAU_gdt@@EE@Z PROC			; set_gdt_entry

; 62   : {

	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 63   : 	access |= GDT_ACCESS_PRESENT | GDT_ACCESS_TYPE;

	movzx	eax, BYTE PTR access$[rsp]
	or	eax, 144				; 00000090H
	mov	BYTE PTR access$[rsp], al

; 64   : 	flags |= GDT_FLAG_GRAN;

	movzx	eax, BYTE PTR flags$[rsp]
	or	eax, 8
	mov	BYTE PTR flags$[rsp], al

; 65   : 	set_gdt_entry(entry, 0, SIZE_MAX, access, flags);

	movzx	eax, BYTE PTR flags$[rsp]
	mov	BYTE PTR [rsp+32], al
	movzx	r9d, BYTE PTR access$[rsp]
	mov	r8d, 1048575				; 000fffffH
	xor	edx, edx
	mov	rcx, QWORD PTR entry$[rsp]
	call	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z	; set_gdt_entry

; 66   : }

	add	rsp, 56					; 00000038H
	ret	0
?set_gdt_entry@@YAXAEAU_gdt@@EE@Z ENDP			; set_gdt_entry
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
entry$ = 8
base$ = 16
limit$ = 24
access$ = 32
flags$ = 40
?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z PROC		; set_gdt_entry

; 52   : {

	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 53   : 	entry.base_low = base & 0xFFFF;

	mov	rax, QWORD PTR base$[rsp]
	and	rax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR entry$[rsp]
	mov	WORD PTR [rcx+2], ax

; 54   : 	entry.base_mid = (base >> 16) & 0xFF;

	mov	rax, QWORD PTR base$[rsp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR entry$[rsp]
	mov	BYTE PTR [rcx+4], al

; 55   : 	entry.base_high = (base >> 24) & 0xFF;

	mov	rax, QWORD PTR base$[rsp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR entry$[rsp]
	mov	BYTE PTR [rcx+7], al

; 56   : 	entry.limit_low = limit & 0xFFFF;

	mov	rax, QWORD PTR limit$[rsp]
	and	rax, 65535				; 0000ffffH
	mov	rcx, QWORD PTR entry$[rsp]
	mov	WORD PTR [rcx], ax

; 57   : 	entry.access = access;

	mov	rax, QWORD PTR entry$[rsp]
	movzx	ecx, BYTE PTR access$[rsp]
	mov	BYTE PTR [rax+5], cl

; 58   : 	entry.flags_limit = (flags << 4) | ((limit >> 16) & 0xF);

	movzx	eax, BYTE PTR flags$[rsp]
	shl	eax, 4
	cdqe
	mov	rcx, QWORD PTR limit$[rsp]
	shr	rcx, 16
	and	rcx, 15
	or	rax, rcx
	mov	rcx, QWORD PTR entry$[rsp]
	mov	BYTE PTR [rcx+6], al

; 59   : }

	ret	0
?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z ENDP		; set_gdt_entry
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
load_default_sregs PROC

; 92   : {

$LN3:
	sub	rsp, 40					; 00000028H

; 93   : 	x64_set_segment_register(SREG_CS, SEGVAL(GDT_ENTRY_KERNEL_CODE, 0));		

	mov	dx, 8
	xor	ecx, ecx
	call	x64_set_segment_register

; 94   : 	x64_set_segment_register(SREG_DS, SEGVAL(GDT_ENTRY_KERNEL_DATA, 0));

	mov	dx, 16
	mov	ecx, 1
	call	x64_set_segment_register

; 95   : 	x64_set_segment_register(SREG_ES, SEGVAL(GDT_ENTRY_KERNEL_DATA, 0));

	mov	dx, 16
	mov	ecx, 2
	call	x64_set_segment_register

; 96   : 	x64_set_segment_register(SREG_SS, SEGVAL(GDT_ENTRY_KERNEL_DATA, 0));

	mov	dx, 16
	mov	ecx, 5
	call	x64_set_segment_register

; 97   : 	//Per CPU data
; 98   : 	x64_set_segment_register(SREG_FS, SEGVAL(GDT_ENTRY_KERNEL_DATA, 0));

	mov	dx, 16
	mov	ecx, 3
	call	x64_set_segment_register

; 99   : 	x64_set_segment_register(SREG_GS, SEGVAL(GDT_ENTRY_KERNEL_DATA, 0));

	mov	dx, 16
	mov	ecx, 4
	call	x64_set_segment_register

; 100  : }

	add	rsp, 40					; 00000028H
	ret	0
load_default_sregs ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
lo$ = 32
hi$ = 36
?cpu_rdtsc@@YAIXZ PROC					; cpu_rdtsc

; 364  : uint32_t cpu_rdtsc () {

$LN3:
	sub	rsp, 56					; 00000038H

; 365  : 	uint32_t hi;
; 366  : 	uint32_t lo;
; 367  : 	x64_rdtsc(&hi, &lo);

	lea	rdx, QWORD PTR lo$[rsp]
	lea	rcx, QWORD PTR hi$[rsp]
	call	x64_rdtsc

; 368  : 	return (hi | lo);

	mov	eax, DWORD PTR lo$[rsp]
	mov	ecx, DWORD PTR hi$[rsp]
	or	ecx, eax
	mov	eax, ecx

; 369  : }

	add	rsp, 56					; 00000038H
	ret	0
?cpu_rdtsc@@YAIXZ ENDP					; cpu_rdtsc
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
tv67 = 0
tv72 = 4
data$ = 32
vector$ = 40
processor$ = 48
edge$ = 56
deassert$ = 64
?cpu_msi_address@@YA_KPEA_K_KIEE@Z PROC			; cpu_msi_address

; 356  : uint64_t cpu_msi_address (uint64_t* data, size_t vector, uint32_t processor, uint8_t edge, uint8_t deassert) {

$LN7:
	mov	BYTE PTR [rsp+32], r9b
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 357  : 	*data = (vector & 0xFF) | (edge == 1 ? 0 : (1<<15)) | (deassert == 1 ? 0 : (1<<14));

	movzx	eax, BYTE PTR edge$[rsp]
	cmp	eax, 1
	jne	SHORT $LN3@cpu_msi_ad
	mov	DWORD PTR tv67[rsp], 0
	jmp	SHORT $LN4@cpu_msi_ad
$LN3@cpu_msi_ad:
	mov	DWORD PTR tv67[rsp], 32768		; 00008000H
$LN4@cpu_msi_ad:
	movzx	eax, BYTE PTR deassert$[rsp]
	cmp	eax, 1
	jne	SHORT $LN5@cpu_msi_ad
	mov	DWORD PTR tv72[rsp], 0
	jmp	SHORT $LN6@cpu_msi_ad
$LN5@cpu_msi_ad:
	mov	DWORD PTR tv72[rsp], 16384		; 00004000H
$LN6@cpu_msi_ad:
	mov	rax, QWORD PTR vector$[rsp]
	and	rax, 255				; 000000ffH
	movsxd	rcx, DWORD PTR tv67[rsp]
	or	rax, rcx
	movsxd	rcx, DWORD PTR tv72[rsp]
	or	rax, rcx
	mov	rcx, QWORD PTR data$[rsp]
	mov	QWORD PTR [rcx], rax

; 358  : 	return (0xFEE00000 | (processor << 12));

	mov	eax, DWORD PTR processor$[rsp]
	shl	eax, 12
	or	eax, -18874368				; fee00000H
	mov	eax, eax

; 359  : }

	add	rsp, 24
	ret	0
?cpu_msi_address@@YA_KPEA_K_KIEE@Z ENDP			; cpu_msi_address
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
?is_cpu_xsave_supported@@YA_NXZ PROC			; is_cpu_xsave_supported

; 345  : 	return _xsave;

	movzx	eax, BYTE PTR _xsave

; 346  : }

	ret	0
?is_cpu_xsave_supported@@YA_NXZ ENDP			; is_cpu_xsave_supported
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
?is_cpu_fxsave_supported@@YA_NXZ PROC			; is_cpu_fxsave_supported

; 341  : 	return _fxsave;

	movzx	eax, BYTE PTR _fxsave

; 342  : }

	ret	0
?is_cpu_fxsave_supported@@YA_NXZ ENDP			; is_cpu_fxsave_supported
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
cr0$ = 48
cr4$1 = 56
cr4$2 = 64
d$ = 72
c$ = 80
b$ = 88
a$ = 96
?hal_cpu_feature_enable@@YAXXZ PROC			; hal_cpu_feature_enable

; 305  : void hal_cpu_feature_enable () {

$LN10:
	sub	rsp, 120				; 00000078H

; 306  : 	uint64_t cr0 = x64_read_cr0();

	call	x64_read_cr0
	mov	QWORD PTR cr0$[rsp], rax

; 307  : 	cr0 &= ~(1<<2);

	mov	rax, QWORD PTR cr0$[rsp]
	and	rax, -5
	mov	QWORD PTR cr0$[rsp], rax

; 308  : 	cr0 |= (1<<1);

	mov	rax, QWORD PTR cr0$[rsp]
	or	rax, 2
	mov	QWORD PTR cr0$[rsp], rax

; 309  : 	x64_write_cr0(cr0);

	mov	rcx, QWORD PTR cr0$[rsp]
	call	x64_write_cr0

; 310  : 
; 311  : 	size_t a, b, c, d;
; 312  : 	x64_cpuid(1, &a, &b, &c, &d, 0);

	mov	QWORD PTR [rsp+40], 0
	lea	rax, QWORD PTR d$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR c$[rsp]
	lea	r8, QWORD PTR b$[rsp]
	lea	rdx, QWORD PTR a$[rsp]
	mov	ecx, 1
	call	x64_cpuid

; 313  : 	if ((c & (1<<26)) != 0) {

	mov	rax, QWORD PTR c$[rsp]
	and	rax, 67108864				; 04000000H
	test	rax, rax
	je	SHORT $LN7@hal_cpu_fe

; 314  : 			/* Enable XCR0 register */
; 315  : 		uint64_t cr4 = x64_read_cr4();

	call	x64_read_cr4
	mov	QWORD PTR cr4$2[rsp], rax

; 316  : 		cr4 |= (1 << 18);

	mov	rax, QWORD PTR cr4$2[rsp]
	bts	rax, 18
	mov	QWORD PTR cr4$2[rsp], rax

; 317  : 		x64_write_cr4(cr4);

	mov	rcx, QWORD PTR cr4$2[rsp]
	call	x64_write_cr4
$LN7@hal_cpu_fe:

; 318  : 	}
; 319  : 
; 320  : 	if ((d & (1 << 25)) != 0){

	mov	rax, QWORD PTR d$[rsp]
	and	rax, 33554432				; 02000000H
	test	rax, rax
	je	SHORT $LN6@hal_cpu_fe

; 321  : 		size_t cr4 = x64_read_cr4();

	call	x64_read_cr4
	mov	QWORD PTR cr4$1[rsp], rax

; 322  : 		
; 323  : 
; 324  : 		if ((d & (1 << 24)) != 0) {

	mov	rax, QWORD PTR d$[rsp]
	and	rax, 16777216				; 01000000H
	test	rax, rax
	je	SHORT $LN5@hal_cpu_fe

; 325  : 			cr4 |= (1 << 9);

	mov	rax, QWORD PTR cr4$1[rsp]
	bts	rax, 9
	mov	QWORD PTR cr4$1[rsp], rax

; 326  : 			//printf("FXSAVE enabled\n");
; 327  : 			_fxsave = true;

	mov	BYTE PTR _fxsave, 1
$LN5@hal_cpu_fe:

; 328  : 		}
; 329  : 		cr4 |= (1 << 10);

	mov	rax, QWORD PTR cr4$1[rsp]
	bts	rax, 10
	mov	QWORD PTR cr4$1[rsp], rax

; 330  : 		x64_write_cr4(cr4);

	mov	rcx, QWORD PTR cr4$1[rsp]
	call	x64_write_cr4
	jmp	SHORT $LN4@hal_cpu_fe
$LN6@hal_cpu_fe:

; 331  : 	}
; 332  : 	else if ((d & (1 << 26)) != 0) {

	mov	rax, QWORD PTR d$[rsp]
	and	rax, 67108864				; 04000000H
	test	rax, rax
	je	SHORT $LN3@hal_cpu_fe
	jmp	SHORT $LN2@hal_cpu_fe
$LN3@hal_cpu_fe:

; 333  : 		//printf("[aurora]: SSE2 is supported \n");
; 334  : 	}
; 335  : 	else if ((c & (1 << 0)) != 0){

	mov	rax, QWORD PTR c$[rsp]
	and	rax, 1
$LN2@hal_cpu_fe:
$LN4@hal_cpu_fe:

; 336  : 		//printf("[aurora]: SSE3 is supported \n");
; 337  : 	}
; 338  : }

	add	rsp, 120				; 00000078H
	ret	0
?hal_cpu_feature_enable@@YAXXZ ENDP			; hal_cpu_feature_enable
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
id$ = 48
b$ = 56
d$ = 64
c$ = 72
a$ = 80
?x86_64_cpu_get_id@@YAEXZ PROC				; x86_64_cpu_get_id

; 246  : uint8_t x86_64_cpu_get_id () {

$LN3:
	sub	rsp, 104				; 00000068H

; 247  : 	size_t a, b, c, d;
; 248  : 	x64_cpuid(0x1, &a, &b, &c, &d);

	mov	QWORD PTR [rsp+40], 0
	lea	rax, QWORD PTR d$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR c$[rsp]
	lea	r8, QWORD PTR b$[rsp]
	lea	rdx, QWORD PTR a$[rsp]
	mov	ecx, 1
	call	x64_cpuid

; 249  : 	uint8_t id = (b >> 24);

	mov	rax, QWORD PTR b$[rsp]
	shr	rax, 24
	mov	BYTE PTR id$[rsp], al

; 250  : 	return id;

	movzx	eax, BYTE PTR id$[rsp]

; 251  : }

	add	rsp, 104				; 00000068H
	ret	0
?x86_64_cpu_get_id@@YAEXZ ENDP				; x86_64_cpu_get_id
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
efer$ = 32
?x86_64_init_cpu@@YAXXZ PROC				; x86_64_init_cpu

; 253  : void x86_64_init_cpu () {

$LN3:
	sub	rsp, 56					; 00000038H

; 254  : 	x64_cli();

	call	x64_cli

; 255  : 
; 256  : 	AuCreatePCPU(NULL);

	xor	ecx, ecx
	call	?AuCreatePCPU@@YAXPEAX@Z		; AuCreatePCPU

; 257  : 	////! initialize the interrupt descriptor table
; 258  : 	interrupt_initialize();

	call	?interrupt_initialize@@YAXXZ		; interrupt_initialize

; 259  : 
; 260  : 	
; 261  : 	debug_print ("IDT initialized\n");

	lea	rcx, OFFSET FLAT:$SG3652
	call	?debug_print@@YAXPEBDZZ			; debug_print

; 262  : 
; 263  : 	x64_sti();

	call	x64_sti

; 264  : 	////! initialize all exception handlers
; 265  : 	exception_init ();

	call	?exception_init@@YAXXZ			; exception_init

; 266  : 
; 267  : 	debug_print ("Exception initialized\n");

	lea	rcx, OFFSET FLAT:$SG3653
	call	?debug_print@@YAXPEBDZZ			; debug_print

; 268  : 	
; 269  : 	//initialize_pic();
; 270  : 
; 271  : #ifdef USE_APIC
; 272  : 	//!Initialize APIC   FIXME: Causes triple fault now
; 273  : 	initialize_apic (true);

	mov	cl, 1
	call	?initialize_apic@@YAX_N@Z		; initialize_apic

; 274  : #endif
; 275  : 	
; 276  : 	debug_print ("APIC initialized\n");

	lea	rcx, OFFSET FLAT:$SG3654
	call	?debug_print@@YAXPEBDZZ			; debug_print

; 277  : 
; 278  : //	//!Enable EFER and SYSCALL Extension
; 279  : 	size_t efer = x64_read_msr(IA32_EFER);

	mov	ecx, -1073741696			; c0000080H
	call	x64_read_msr
	mov	QWORD PTR efer$[rsp], rax

; 280  : 	efer |= (1<<11);

	mov	rax, QWORD PTR efer$[rsp]
	bts	rax, 11
	mov	QWORD PTR efer$[rsp], rax

; 281  : 	efer |= 1;

	mov	rax, QWORD PTR efer$[rsp]
	or	rax, 1
	mov	QWORD PTR efer$[rsp], rax

; 282  : 	efer |= (1<<0);

	mov	rax, QWORD PTR efer$[rsp]
	or	rax, 1
	mov	QWORD PTR efer$[rsp], rax

; 283  : 	efer |= 1;

	mov	rax, QWORD PTR efer$[rsp]
	or	rax, 1
	mov	QWORD PTR efer$[rsp], rax

; 284  : 	x64_write_msr(IA32_EFER, efer);

	mov	rdx, QWORD PTR efer$[rsp]
	mov	ecx, -1073741696			; c0000080H
	call	x64_write_msr

; 285  : 	//! now start the interrupts
; 286  : 
; 287  : 	debug_print ("EFER.SYSCALL enabled\n");

	lea	rcx, OFFSET FLAT:$SG3656
	call	?debug_print@@YAXPEBDZZ			; debug_print

; 288  : 	//! initialize the user land environment
; 289  : 	initialize_user_land (64);

	mov	ecx, 64					; 00000040H
	call	?initialize_user_land@@YAX_K@Z		; initialize_user_land

; 290  : 
; 291  : 	debug_print ("User Land Initialized\n");

	lea	rcx, OFFSET FLAT:$SG3657
	call	?debug_print@@YAXPEBDZZ			; debug_print

; 292  : 	//! initialize the syscall entries
; 293  : 	initialize_syscall ();

	call	?initialize_syscall@@YAXXZ		; initialize_syscall

; 294  : 
; 295  : 	debug_print ("System call initialized\n");

	lea	rcx, OFFSET FLAT:$SG3658
	call	?debug_print@@YAXPEBDZZ			; debug_print

; 296  : 
; 297  : 	hal_cpu_feature_enable();

	call	?hal_cpu_feature_enable@@YAXXZ		; hal_cpu_feature_enable

; 298  : 
; 299  : 
; 300  :     x64_sti ();

	call	x64_sti

; 301  : 	
; 302  : }

	add	rsp, 56					; 00000038H
	ret	0
?x86_64_init_cpu@@YAXXZ ENDP				; x86_64_init_cpu
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
n$1 = 48
tss$ = 56
idtr$ = 64
tss_addr$ = 72
thegdt$ = 80
tv142 = 88
curr_gdt$ = 96
?interrupt_initialize@@YAXXZ PROC			; interrupt_initialize

; 163  : void  interrupt_initialize() {

$LN6:
	sub	rsp, 120				; 00000078H

; 164  :  
; 165  : 	TSS* tss = (TSS*)malloc(sizeof(TSS));

	mov	ecx, 104				; 00000068H
	call	malloc
	mov	QWORD PTR tss$[rsp], rax

; 166  : 	tss->iomapbase = sizeof(TSS);

	mov	eax, 104				; 00000068H
	mov	rcx, QWORD PTR tss$[rsp]
	mov	WORD PTR [rcx+102], ax

; 167  : 	size_t tss_addr = (size_t)tss;

	mov	rax, QWORD PTR tss$[rsp]
	mov	QWORD PTR tss_addr$[rsp], rax

; 168  : 
; 169  : 	gdtr curr_gdt;
; 170  : 	x64_sgdt(&curr_gdt);

	lea	rcx, QWORD PTR curr_gdt$[rsp]
	call	x64_sgdt

; 171  : 	gdt_entry* thegdt = the_gdtr.gdtaddr; //curr_gdt.gdtaddr;

	mov	rax, QWORD PTR the_gdtr+2
	mov	QWORD PTR thegdt$[rsp], rax

; 172  : 	set_gdt_entry(thegdt[GDT_ENTRY_TSS], (tss_addr & UINT32_MAX), sizeof(TSS), GDT_ACCESS_PRESENT | 0x9, 0);

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR tss_addr$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, 7
	mov	rdx, QWORD PTR thegdt$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	BYTE PTR [rsp+32], 0
	mov	r9b, 137				; 00000089H
	mov	r8d, 104				; 00000068H
	mov	rdx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z	; set_gdt_entry

; 173  : 	*(uint64_t*)&thegdt[GDT_ENTRY_TSS + 1] = (tss_addr >> 32);

	mov	rax, QWORD PTR tss_addr$[rsp]
	shr	rax, 32					; 00000020H
	mov	ecx, 8
	imul	rcx, 8
	mov	rdx, QWORD PTR thegdt$[rsp]
	mov	QWORD PTR [rdx+rcx], rax

; 174  : 	x64_ltr(SEGVAL(GDT_ENTRY_TSS, 3));

	mov	cx, 59					; 0000003bH
	call	x64_ltr

; 175  : 
; 176  : 	AuPCPUSetKernelTSS(tss);

	mov	rcx, QWORD PTR tss$[rsp]
	call	?AuPCPUSetKernelTSS@@YAXPEAU_tss@@@Z	; AuPCPUSetKernelTSS

; 177  : 
; 178  : 	IDTR *idtr = (IDTR*)malloc(sizeof(IDTR));  //0xFFFFD80000000000;

	mov	ecx, 10
	call	malloc
	mov	QWORD PTR idtr$[rsp], rax

; 179  : 	idtr->idtaddr = the_idt;

	mov	rax, QWORD PTR idtr$[rsp]
	lea	rcx, OFFSET FLAT:the_idt
	mov	QWORD PTR [rax+2], rcx

; 180  : 	idtr->length = 256 * sizeof(IDT) - 1;

	mov	eax, 4095				; 00000fffH
	mov	rcx, QWORD PTR idtr$[rsp]
	mov	WORD PTR [rcx], ax

; 181  : 	x64_lidt(idtr);

	mov	rcx, QWORD PTR idtr$[rsp]
	call	x64_lidt

; 182  : 	for (int n = 0; n < 256; n++)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN3@interrupt_
$LN2@interrupt_:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN3@interrupt_:
	cmp	DWORD PTR n$1[rsp], 256			; 00000100H
	jge	$LN1@interrupt_

; 183  : 	{
; 184  : 		the_idt[n].ist = 0;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	BYTE PTR [rcx+rax+4], 0

; 185  : 		the_idt[n].selector = SEGVAL(GDT_ENTRY_KERNEL_CODE, 0);

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	edx, 8
	mov	WORD PTR [rcx+rax+2], dx

; 186  : 		the_idt[n].zero = 0;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	DWORD PTR [rcx+rax+12], 0

; 187  : 		the_idt[n].type_attr = GDT_ACCESS_PRESENT | 0xE;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	BYTE PTR [rcx+rax+5], 142		; 0000008eH

; 188  : 		register_irq(&the_idt[n], default_irq_handlers[n]);

	movsxd	rax, DWORD PTR n$1[rsp]
	lea	rcx, OFFSET FLAT:default_irq_handlers
	movsxd	rdx, DWORD PTR n$1[rsp]
	imul	rdx, 16
	lea	r8, OFFSET FLAT:the_idt
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv142[rsp], rdx
	mov	rdx, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR tv142[rsp]
	mov	rcx, rax
	call	?register_irq@@YAXPEAU_idt@@PEAX@Z	; register_irq

; 189  : 	}

	jmp	$LN2@interrupt_
$LN1@interrupt_:

; 190  : }

	add	rsp, 120				; 00000078H
	ret	0
?interrupt_initialize@@YAXXZ ENDP			; interrupt_initialize
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
n$1 = 48
tss$ = 56
idtr$ = 64
tss_addr$ = 72
thegdt$ = 80
tv142 = 88
curr_gdt$ = 96
?interrupt_initialize_ap@@YAXXZ PROC			; interrupt_initialize_ap

; 207  : void interrupt_initialize_ap() {

$LN6:
	sub	rsp, 120				; 00000078H

; 208  : 	TSS* tss = (TSS*)malloc(sizeof(TSS));

	mov	ecx, 104				; 00000068H
	call	malloc
	mov	QWORD PTR tss$[rsp], rax

; 209  : 	tss->iomapbase = sizeof(TSS);

	mov	eax, 104				; 00000068H
	mov	rcx, QWORD PTR tss$[rsp]
	mov	WORD PTR [rcx+102], ax

; 210  : 	size_t tss_addr = (size_t)tss;

	mov	rax, QWORD PTR tss$[rsp]
	mov	QWORD PTR tss_addr$[rsp], rax

; 211  : 
; 212  : 	gdtr curr_gdt;
; 213  : 	x64_sgdt(&curr_gdt);

	lea	rcx, QWORD PTR curr_gdt$[rsp]
	call	x64_sgdt

; 214  : 	gdt_entry* thegdt = curr_gdt.gdtaddr; //curr_gdt.gdtaddr;

	mov	rax, QWORD PTR curr_gdt$[rsp+2]
	mov	QWORD PTR thegdt$[rsp], rax

; 215  : 	set_gdt_entry(thegdt[GDT_ENTRY_TSS], (tss_addr & UINT32_MAX), sizeof(TSS), GDT_ACCESS_PRESENT | 0x9, 0);

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR tss_addr$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, 7
	mov	rdx, QWORD PTR thegdt$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	BYTE PTR [rsp+32], 0
	mov	r9b, 137				; 00000089H
	mov	r8d, 104				; 00000068H
	mov	rdx, rax
	call	?set_gdt_entry@@YAXAEAU_gdt@@_K1EE@Z	; set_gdt_entry

; 216  : 	*(uint64_t*)&thegdt[GDT_ENTRY_TSS + 1] = (tss_addr >> 32);

	mov	rax, QWORD PTR tss_addr$[rsp]
	shr	rax, 32					; 00000020H
	mov	ecx, 8
	imul	rcx, 8
	mov	rdx, QWORD PTR thegdt$[rsp]
	mov	QWORD PTR [rdx+rcx], rax

; 217  : 	x64_ltr(SEGVAL(GDT_ENTRY_TSS, 3));

	mov	cx, 59					; 0000003bH
	call	x64_ltr

; 218  : 
; 219  : 	
; 220  : 
; 221  : 	AuPCPUSetKernelTSS(tss);

	mov	rcx, QWORD PTR tss$[rsp]
	call	?AuPCPUSetKernelTSS@@YAXPEAU_tss@@@Z	; AuPCPUSetKernelTSS

; 222  : 
; 223  : 	IDTR *idtr = (IDTR*)malloc(sizeof(IDTR));  //0xFFFFD80000000000;

	mov	ecx, 10
	call	malloc
	mov	QWORD PTR idtr$[rsp], rax

; 224  : 	idtr->idtaddr = the_idt;

	mov	rax, QWORD PTR idtr$[rsp]
	lea	rcx, OFFSET FLAT:the_idt
	mov	QWORD PTR [rax+2], rcx

; 225  : 	idtr->length = 256 * sizeof(IDT) - 1;

	mov	eax, 4095				; 00000fffH
	mov	rcx, QWORD PTR idtr$[rsp]
	mov	WORD PTR [rcx], ax

; 226  : 	x64_lidt(idtr);

	mov	rcx, QWORD PTR idtr$[rsp]
	call	x64_lidt

; 227  : 	for (int n = 0; n < 256; n++)

	mov	DWORD PTR n$1[rsp], 0
	jmp	SHORT $LN3@interrupt_
$LN2@interrupt_:
	mov	eax, DWORD PTR n$1[rsp]
	inc	eax
	mov	DWORD PTR n$1[rsp], eax
$LN3@interrupt_:
	cmp	DWORD PTR n$1[rsp], 256			; 00000100H
	jge	$LN1@interrupt_

; 228  : 	{
; 229  : 		the_idt[n].ist = 0;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	BYTE PTR [rcx+rax+4], 0

; 230  : 		the_idt[n].selector = SEGVAL(GDT_ENTRY_KERNEL_CODE, 0);

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	edx, 8
	mov	WORD PTR [rcx+rax+2], dx

; 231  : 		the_idt[n].zero = 0;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	DWORD PTR [rcx+rax+12], 0

; 232  : 		the_idt[n].type_attr = GDT_ACCESS_PRESENT | 0xE;

	movsxd	rax, DWORD PTR n$1[rsp]
	imul	rax, 16
	lea	rcx, OFFSET FLAT:the_idt
	mov	BYTE PTR [rcx+rax+5], 142		; 0000008eH

; 233  : 		register_irq(&the_idt[n], default_irq_handlers[n]);

	movsxd	rax, DWORD PTR n$1[rsp]
	lea	rcx, OFFSET FLAT:default_irq_handlers
	movsxd	rdx, DWORD PTR n$1[rsp]
	imul	rdx, 16
	lea	r8, OFFSET FLAT:the_idt
	add	r8, rdx
	mov	rdx, r8
	mov	QWORD PTR tv142[rsp], rdx
	mov	rdx, QWORD PTR [rcx+rax*8]
	mov	rax, QWORD PTR tv142[rsp]
	mov	rcx, rax
	call	?register_irq@@YAXPEAU_idt@@PEAX@Z	; register_irq

; 234  : 	}

	jmp	$LN2@interrupt_
$LN1@interrupt_:

; 235  : }

	add	rsp, 120				; 00000078H
	ret	0
?interrupt_initialize_ap@@YAXXZ ENDP			; interrupt_initialize_ap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
new_gdtr$ = 32
new_gdt$ = 40
$T1 = 48
$T2 = 56
?gdt_initialize_ap@@YAXXZ PROC				; gdt_initialize_ap

; 118  : void gdt_initialize_ap() {

$LN3:
	sub	rsp, 72					; 00000048H

; 119  : 	gdtr* new_gdtr = new gdtr;

	mov	ecx, 10
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR new_gdtr$[rsp], rax

; 120  : 	gdt_entry* new_gdt = new gdt_entry[GDT_ENTRIES];

	mov	ecx, 72					; 00000048H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T2[rsp], rax
	mov	rax, QWORD PTR $T2[rsp]
	mov	QWORD PTR new_gdt$[rsp], rax

; 121  : 	fill_gdt(new_gdt);

	mov	rcx, QWORD PTR new_gdt$[rsp]
	call	?fill_gdt@@YAXPEAU_gdt@@@Z		; fill_gdt

; 122  : 	new_gdtr->gdtaddr = new_gdt;

	mov	rax, QWORD PTR new_gdtr$[rsp]
	mov	rcx, QWORD PTR new_gdt$[rsp]
	mov	QWORD PTR [rax+2], rcx

; 123  : 	new_gdtr->size = GDT_ENTRIES * sizeof(gdt_entry) - 1;

	mov	eax, 71					; 00000047H
	mov	rcx, QWORD PTR new_gdtr$[rsp]
	mov	WORD PTR [rcx], ax

; 124  : 	x64_lgdt(new_gdtr);

	mov	rcx, QWORD PTR new_gdtr$[rsp]
	call	x64_lgdt

; 125  : }

	add	rsp, 72					; 00000048H
	ret	0
?gdt_initialize_ap@@YAXXZ ENDP				; gdt_initialize_ap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
gdt_initialize PROC

; 104  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 105  : 	x64_sgdt(&old_gdtr);

	lea	rcx, OFFSET FLAT:old_gdtr
	call	x64_sgdt

; 106  : 	save_sregs();

	call	?save_sregs@@YAXXZ			; save_sregs

; 107  : 	fill_gdt(gdt);

	lea	rcx, OFFSET FLAT:gdt
	call	?fill_gdt@@YAXPEAU_gdt@@@Z		; fill_gdt

; 108  : 	the_gdtr.gdtaddr = gdt;

	lea	rax, OFFSET FLAT:gdt
	mov	QWORD PTR the_gdtr+2, rax

; 109  : 	the_gdtr.size = GDT_ENTRIES * sizeof(gdt_entry) - 1;

	mov	eax, 71					; 00000047H
	mov	WORD PTR the_gdtr, ax

; 110  : 	x64_lgdt(&the_gdtr);

	lea	rcx, OFFSET FLAT:the_gdtr
	call	x64_lgdt

; 111  : 	load_default_sregs();

	call	load_default_sregs

; 112  : }

	add	rsp, 40					; 00000028H
	ret	0
gdt_initialize ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
vector$ = 8
function$ = 16
setvect	PROC

; 144  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 145  : 	interrupts_handlers[vector] = function;

	lea	rax, OFFSET FLAT:interrupts_handlers
	mov	rcx, QWORD PTR vector$[rsp]
	mov	rdx, QWORD PTR function$[rsp]
	mov	QWORD PTR [rax+rcx*8], rdx

; 146  : };

	ret	0
setvect	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\cpu.cpp
_TEXT	SEGMENT
?x86_64_gdt_init@@YAXXZ PROC				; x86_64_gdt_init

; 193  : void x86_64_gdt_init () {

$LN3:
	sub	rsp, 40					; 00000028H

; 194  : 	//! clear interrupts first
; 195  :     x64_cli ();

	call	x64_cli

; 196  : 
; 197  : 	////! initialize the global descriptor table
; 198  : 	gdt_initialize();

	call	gdt_initialize

; 199  : 
; 200  : 	x64_sti();

	call	x64_sti

; 201  : }

	add	rsp, 40					; 00000028H
	ret	0
?x86_64_gdt_init@@YAXXZ ENDP				; x86_64_gdt_init
_TEXT	ENDS
END
