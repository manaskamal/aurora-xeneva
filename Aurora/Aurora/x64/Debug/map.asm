; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?map_memory@@YAPEAX_KIEE@Z			; map_memory
PUBLIC	?unmap_memory@@YAXPEAXI@Z			; unmap_memory
EXTRN	?pmmngr_alloc@@YAPEAXXZ:PROC			; pmmngr_alloc
EXTRN	?map_page@@YA_N_K0@Z:PROC			; map_page
EXTRN	?unmap_page@@YAX_K@Z:PROC			; unmap_page
EXTRN	?get_free_page@@YAPEA_K_K_N@Z:PROC		; get_free_page
pdata	SEGMENT
$pdata$?map_memory@@YAPEAX_KIEE@Z DD imagerel $LN14
	DD	imagerel $LN14+343
	DD	imagerel $unwind$?map_memory@@YAPEAX_KIEE@Z
$pdata$?unmap_memory@@YAXPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+130
	DD	imagerel $unwind$?unmap_memory@@YAXPEAXI@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?map_memory@@YAPEAX_KIEE@Z DD 011701H
	DD	08217H
$unwind$?unmap_memory@@YAXPEAXI@Z DD 010d01H
	DD	0620dH
xdata	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\map.cpp
_TEXT	SEGMENT
i$1 = 32
address$ = 40
addr$ = 64
length$ = 72
?unmap_memory@@YAXPEAXI@Z PROC				; unmap_memory

; 54   : void unmap_memory (void* addr, uint32_t length) {

$LN8:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 55   : 	/*unsigned char* buffer = (unsigned char*)addr;
; 56   : 	fat32_create_file ("MM1.txt",buffer, length);*/
; 57   : 
; 58   : 	uint64_t address = (uint64_t)addr;

	mov	rax, QWORD PTR addr$[rsp]
	mov	QWORD PTR address$[rsp], rax

; 59   : 
; 60   : 	if (length == 4096) 

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jne	SHORT $LN5@unmap_memo

; 61   : 		unmap_page (address);

	mov	rcx, QWORD PTR address$[rsp]
	call	?unmap_page@@YAX_K@Z			; unmap_page
$LN5@unmap_memo:

; 62   : 
; 63   : 	if (length > 4096) {

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jbe	SHORT $LN4@unmap_memo

; 64   : 		for (int i = 0; i < length / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@unmap_memo
$LN2@unmap_memo:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@unmap_memo:
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN1@unmap_memo

; 65   : 			unmap_page (address + i * 4096);

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR address$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?unmap_page@@YAX_K@Z			; unmap_page

; 66   : 		}

	jmp	SHORT $LN2@unmap_memo
$LN1@unmap_memo:
$LN4@unmap_memo:

; 67   : 	}
; 68   : }

	add	rsp, 56					; 00000038H
	ret	0
?unmap_memory@@YAXPEAXI@Z ENDP				; unmap_memory
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\map.cpp
_TEXT	SEGMENT
user$ = 32
i$1 = 36
i$2 = 40
tv82 = 48
tv95 = 56
addr$ = 80
length$ = 88
map_type$ = 96
attribute$ = 104
?map_memory@@YAPEAX_KIEE@Z PROC				; map_memory

; 20   : void *map_memory (uint64_t addr, uint32_t length, uint8_t map_type, uint8_t attribute) {

$LN14:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 21   : 	bool user = false;

	mov	BYTE PTR user$[rsp], 0

; 22   : 	if (attribute & ATTRIBUTE_USER)

	movzx	eax, BYTE PTR attribute$[rsp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN11@map_memory

; 23   : 		user = true;

	mov	BYTE PTR user$[rsp], 1
$LN11@map_memory:

; 24   : 	if (addr == NULL) {

	cmp	QWORD PTR addr$[rsp], 0
	jne	$LN10@map_memory

; 25   : 		addr = (uint64_t)get_free_page (length, user);

	mov	eax, DWORD PTR length$[rsp]
	movzx	edx, BYTE PTR user$[rsp]
	mov	ecx, eax
	call	?get_free_page@@YAPEA_K_K_N@Z		; get_free_page
	mov	QWORD PTR addr$[rsp], rax

; 26   : 		if (length == 4096) {

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jne	SHORT $LN9@map_memory

; 27   : 			map_page ((uint64_t)pmmngr_alloc(), addr);

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	rdx, QWORD PTR addr$[rsp]
	mov	rcx, rax
	call	?map_page@@YA_N_K0@Z			; map_page

; 28   : 			return (void*)addr;

	mov	rax, QWORD PTR addr$[rsp]
	jmp	$LN12@map_memory
$LN9@map_memory:

; 29   : 		}
; 30   : 
; 31   : 		for (int i = 0; i < length / 4096; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN8@map_memory
$LN7@map_memory:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN8@map_memory:
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN6@map_memory

; 32   : 				map_page ((uint64_t)pmmngr_alloc(),addr + i * 4096);

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv82[rsp], rax
	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	rcx, QWORD PTR tv82[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?map_page@@YA_N_K0@Z			; map_page
	jmp	SHORT $LN7@map_memory
$LN6@map_memory:
	jmp	SHORT $LN5@map_memory
$LN10@map_memory:

; 33   : 
; 34   : 
; 35   : 	} else {
; 36   : 		if (length == 4096) {

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jne	SHORT $LN4@map_memory

; 37   : 			map_page ((uint64_t)pmmngr_alloc(), addr);

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	rdx, QWORD PTR addr$[rsp]
	mov	rcx, rax
	call	?map_page@@YA_N_K0@Z			; map_page

; 38   : 			return (void*)addr;

	mov	rax, QWORD PTR addr$[rsp]
	jmp	SHORT $LN12@map_memory
$LN4@map_memory:

; 39   : 		}
; 40   : 
; 41   : 		for (int i = 0; i < length / 4096; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@map_memory
$LN2@map_memory:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@map_memory:
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	cmp	DWORD PTR i$2[rsp], eax
	jae	SHORT $LN1@map_memory

; 42   : 				map_page ((uint64_t)pmmngr_alloc(),addr + i * 4096);

	mov	eax, DWORD PTR i$2[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv95[rsp], rax
	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	rcx, QWORD PTR tv95[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?map_page@@YA_N_K0@Z			; map_page
	jmp	SHORT $LN2@map_memory
$LN1@map_memory:
$LN5@map_memory:

; 43   : 	}
; 44   : 
; 45   : 	return (void*)addr;

	mov	rax, QWORD PTR addr$[rsp]
$LN12@map_memory:

; 46   : }

	add	rsp, 72					; 00000048H
	ret	0
?map_memory@@YAPEAX_KIEE@Z ENDP				; map_memory
_TEXT	ENDS
END
