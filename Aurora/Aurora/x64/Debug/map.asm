; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3893	DB	'[AU_UNMAP]: VMA Found ', 0dH, 0aH, 00H
CONST	ENDS
PUBLIC	?map_memory@@YAPEAX_KIE@Z			; map_memory
PUBLIC	?unmap_memory@@YAXPEAXI@Z			; unmap_memory
EXTRN	AuPmmngrAlloc:PROC
EXTRN	x64_cli:PROC
EXTRN	AuMapPage:PROC
EXTRN	AuUnmapPage:PROC
EXTRN	AuGetFreePage:PROC
EXTRN	?AuRemoveVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z:PROC ; AuRemoveVMArea
EXTRN	?AuFindVMA@@YAPEAU_vma_area_@@_K@Z:PROC		; AuFindVMA
EXTRN	?get_current_process@@YAPEAU_process_@@XZ:PROC	; get_current_process
EXTRN	_debug_print_:PROC
pdata	SEGMENT
$pdata$?map_memory@@YAPEAX_KIE@Z DD imagerel $LN22
	DD	imagerel $LN22+501
	DD	imagerel $unwind$?map_memory@@YAPEAX_KIE@Z
$pdata$?unmap_memory@@YAXPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+193
	DD	imagerel $unwind$?unmap_memory@@YAXPEAXI@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?map_memory@@YAPEAX_KIE@Z DD 011201H
	DD	0c212H
$unwind$?unmap_memory@@YAXPEAXI@Z DD 010d01H
	DD	0820dH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\map.cpp
_TEXT	SEGMENT
i$1 = 32
vm$ = 40
address$ = 48
c_proc$ = 56
addr$ = 80
length$ = 88
?unmap_memory@@YAXPEAXI@Z PROC				; unmap_memory

; 74   : void unmap_memory (void* addr, uint32_t length) {

$LN9:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 75   : 	x64_cli();

	call	x64_cli

; 76   : 	process_t *c_proc = get_current_process();

	call	?get_current_process@@YAPEAU_process_@@XZ ; get_current_process
	mov	QWORD PTR c_proc$[rsp], rax

; 77   : 	/*
; 78   : 	 * Before unmapping the object, we should get the object
; 79   : 	 * and write it to a file if object is not null
; 80   : 	 * but for now object manager is not implemented,
; 81   : 	 * kept for future use
; 82   : 	 */
; 83   : 
; 84   : 	au_vm_area_t *vm = AuFindVMA((uint64_t)addr);

	mov	rcx, QWORD PTR addr$[rsp]
	call	?AuFindVMA@@YAPEAU_vma_area_@@_K@Z	; AuFindVMA
	mov	QWORD PTR vm$[rsp], rax

; 85   : 	if (vm != NULL) {

	cmp	QWORD PTR vm$[rsp], 0
	je	SHORT $LN6@unmap_memo

; 86   : 		_debug_print_ ("[AU_UNMAP]: VMA Found \r\n");

	lea	rcx, OFFSET FLAT:$SG3893
	call	_debug_print_

; 87   : 		AuRemoveVMArea(c_proc, vm);

	mov	rdx, QWORD PTR vm$[rsp]
	mov	rcx, QWORD PTR c_proc$[rsp]
	call	?AuRemoveVMArea@@YAXPEAU_process_@@PEAU_vma_area_@@@Z ; AuRemoveVMArea
$LN6@unmap_memo:

; 88   : 	}
; 89   : 
; 90   : 	uint64_t address = (uint64_t)addr;

	mov	rax, QWORD PTR addr$[rsp]
	mov	QWORD PTR address$[rsp], rax

; 91   : 	if (length == 1) 

	cmp	DWORD PTR length$[rsp], 1
	jne	SHORT $LN5@unmap_memo

; 92   : 		AuUnmapPage(address, true);

	mov	dl, 1
	mov	rcx, QWORD PTR address$[rsp]
	call	AuUnmapPage
$LN5@unmap_memo:

; 93   : 
; 94   : 	if (length > 1) {

	cmp	DWORD PTR length$[rsp], 1
	jbe	SHORT $LN4@unmap_memo

; 95   : 		for (int i = 0; i < length / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@unmap_memo
$LN2@unmap_memo:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@unmap_memo:
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN1@unmap_memo

; 96   : 			AuUnmapPage(address + i * 4096, true);

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR address$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	dl, 1
	mov	rcx, rax
	call	AuUnmapPage

; 97   : 		}

	jmp	SHORT $LN2@unmap_memo
$LN1@unmap_memo:
$LN4@unmap_memo:

; 98   : 	}
; 99   : 
; 100  : 
; 101  : }

	add	rsp, 72					; 00000048H
	ret	0
?unmap_memory@@YAXPEAXI@Z ENDP				; unmap_memory
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\map.cpp
_TEXT	SEGMENT
user$ = 32
i$1 = 36
i$2 = 40
tv89 = 44
tv144 = 48
tv133 = 52
tv78 = 56
tv94 = 64
tv149 = 72
c_proc$ = 80
addr$ = 112
length$ = 120
attribute$ = 128
?map_memory@@YAPEAX_KIE@Z PROC				; map_memory

; 21   : void *map_memory (uint64_t addr, uint32_t length,uint8_t attribute) {

$LN22:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 22   : 	x64_cli();

	call	x64_cli

; 23   : 	process_t * c_proc = get_current_process();

	call	?get_current_process@@YAPEAU_process_@@XZ ; get_current_process
	mov	QWORD PTR c_proc$[rsp], rax

; 24   : 	
; 25   : 	//!Attribute check
; 26   : 	bool user = false;

	mov	BYTE PTR user$[rsp], 0

; 27   : 	if (attribute & ATTRIBUTE_USER)

	movzx	eax, BYTE PTR attribute$[rsp]
	and	eax, 5
	test	eax, eax
	je	SHORT $LN11@map_memory

; 28   : 		user = true;

	mov	BYTE PTR user$[rsp], 1
$LN11@map_memory:

; 29   : 
; 30   : 	//! For more convenient, give a null to address parameter 
; 31   : 	//! cause, null parameter will cause map_memory to look for free
; 32   : 	//! memory in process's address space
; 33   : 	if (addr == NULL) {

	cmp	QWORD PTR addr$[rsp], 0
	jne	$LN10@map_memory

; 34   : 		addr = (uint64_t)AuGetFreePage(length, user, 0);

	mov	eax, DWORD PTR length$[rsp]
	xor	r8d, r8d
	movzx	edx, BYTE PTR user$[rsp]
	mov	ecx, eax
	call	AuGetFreePage
	mov	QWORD PTR addr$[rsp], rax

; 35   : 		if (length == 4096) {

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jne	SHORT $LN9@map_memory

; 36   : 			AuMapPage((uint64_t)AuPmmngrAlloc(), addr,(user == true) ? PAGING_USER : 0);

	movzx	eax, BYTE PTR user$[rsp]
	cmp	eax, 1
	jne	SHORT $LN14@map_memory
	mov	DWORD PTR tv78[rsp], 4
	jmp	SHORT $LN15@map_memory
$LN14@map_memory:
	mov	DWORD PTR tv78[rsp], 0
$LN15@map_memory:
	call	AuPmmngrAlloc
	movzx	r8d, BYTE PTR tv78[rsp]
	mov	rdx, QWORD PTR addr$[rsp]
	mov	rcx, rax
	call	AuMapPage

; 37   : 			return (void*)addr;

	mov	rax, QWORD PTR addr$[rsp]
	jmp	$LN12@map_memory
$LN9@map_memory:

; 38   : 		}
; 39   : 
; 40   : 		for (int i = 0; i < length / 4096; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN8@map_memory
$LN7@map_memory:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN8@map_memory:
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN6@map_memory

; 41   : 			AuMapPage((uint64_t)AuPmmngrAlloc(),addr + i * 4096,(user == true) ? PAGING_USER : 0);

	movzx	eax, BYTE PTR user$[rsp]
	cmp	eax, 1
	jne	SHORT $LN16@map_memory
	mov	DWORD PTR tv89[rsp], 4
	jmp	SHORT $LN17@map_memory
$LN16@map_memory:
	mov	DWORD PTR tv89[rsp], 0
$LN17@map_memory:
	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv94[rsp], rax
	call	AuPmmngrAlloc
	movzx	r8d, BYTE PTR tv89[rsp]
	mov	rcx, QWORD PTR tv94[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	AuMapPage
	jmp	SHORT $LN7@map_memory
$LN6@map_memory:

; 42   : 
; 43   : 
; 44   : 	} 
; 45   : 	//! use the given address to map a region
; 46   : 	//! TODO: Check if there's already a mapped region, and relocate the mapping
; 47   : 	else {

	jmp	$LN5@map_memory
$LN10@map_memory:

; 48   : 		if (length == 4096) {

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jne	SHORT $LN4@map_memory

; 49   : 			AuMapPage((uint64_t)AuPmmngrAlloc(), addr,(user == true) ? PAGING_USER : 0);

	movzx	eax, BYTE PTR user$[rsp]
	cmp	eax, 1
	jne	SHORT $LN18@map_memory
	mov	DWORD PTR tv133[rsp], 4
	jmp	SHORT $LN19@map_memory
$LN18@map_memory:
	mov	DWORD PTR tv133[rsp], 0
$LN19@map_memory:
	call	AuPmmngrAlloc
	movzx	r8d, BYTE PTR tv133[rsp]
	mov	rdx, QWORD PTR addr$[rsp]
	mov	rcx, rax
	call	AuMapPage

; 50   : 			return (void*)addr;

	mov	rax, QWORD PTR addr$[rsp]
	jmp	$LN12@map_memory
$LN4@map_memory:

; 51   : 		}
; 52   : 
; 53   : 		for (int i = 0; i < length / 4096; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@map_memory
$LN2@map_memory:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@map_memory:
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	cmp	DWORD PTR i$2[rsp], eax
	jae	SHORT $LN1@map_memory

; 54   : 			AuMapPage((uint64_t)AuPmmngrAlloc(),addr + i * 4096,(user == true) ? PAGING_USER : 0);

	movzx	eax, BYTE PTR user$[rsp]
	cmp	eax, 1
	jne	SHORT $LN20@map_memory
	mov	DWORD PTR tv144[rsp], 4
	jmp	SHORT $LN21@map_memory
$LN20@map_memory:
	mov	DWORD PTR tv144[rsp], 0
$LN21@map_memory:
	mov	eax, DWORD PTR i$2[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv149[rsp], rax
	call	AuPmmngrAlloc
	movzx	r8d, BYTE PTR tv144[rsp]
	mov	rcx, QWORD PTR tv149[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	AuMapPage
	jmp	SHORT $LN2@map_memory
$LN1@map_memory:
$LN5@map_memory:

; 55   : 	}
; 56   : 
; 57   : 	//! MAP_GLOBAL flag will cause the map_memory to map the address
; 58   : 	//! in its child process, for now its not implemented
; 59   : 
; 60   : 	//if (attribute & MAP_GLOBAL) {
; 61   : 	//	process_map_addresses (addr,length,(uint64_t*)c_proc->thread_data_pointer->cr3,c_proc);
; 62   : 	//}
; 63   : 	
; 64   : 	//! return the mapped address
; 65   : 	return (void*)addr;

	mov	rax, QWORD PTR addr$[rsp]
$LN12@map_memory:

; 66   : }

	add	rsp, 104				; 00000068H
	ret	0
?map_memory@@YAPEAX_KIE@Z ENDP				; map_memory
_TEXT	ENDS
END
