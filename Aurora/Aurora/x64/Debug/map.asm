; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?map_memory@@YAPEAX_KIE@Z			; map_memory
PUBLIC	?unmap_memory@@YAXPEAXI@Z			; unmap_memory
EXTRN	AuPmmngrAlloc:PROC
EXTRN	x64_cli:PROC
EXTRN	AuMapPage:PROC
EXTRN	AuUnmapPage:PROC
EXTRN	AuGetFreePage:PROC
EXTRN	?get_current_process@@YAPEAU_process_@@XZ:PROC	; get_current_process
pdata	SEGMENT
$pdata$?map_memory@@YAPEAX_KIE@Z DD imagerel $LN22
	DD	imagerel $LN22+501
	DD	imagerel $unwind$?map_memory@@YAPEAX_KIE@Z
$pdata$?unmap_memory@@YAXPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+145
	DD	imagerel $unwind$?unmap_memory@@YAXPEAXI@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?map_memory@@YAPEAX_KIE@Z DD 011201H
	DD	0c212H
$unwind$?unmap_memory@@YAXPEAXI@Z DD 010d01H
	DD	0820dH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\map.cpp
_TEXT	SEGMENT
i$1 = 32
address$ = 40
c_proc$ = 48
addr$ = 80
length$ = 88
?unmap_memory@@YAXPEAXI@Z PROC				; unmap_memory

; 73   : void unmap_memory (void* addr, uint32_t length) {

$LN8:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 74   : 	x64_cli();

	call	x64_cli

; 75   : 	process_t *c_proc = get_current_process();

	call	?get_current_process@@YAPEAU_process_@@XZ ; get_current_process
	mov	QWORD PTR c_proc$[rsp], rax

; 76   : 	/*
; 77   : 	 * Before unmapping the object, we should get the object
; 78   : 	 * and write it to a file if object is not null
; 79   : 	 * but for now object manager is not implemented,
; 80   : 	 * kept for future use
; 81   : 	 */
; 82   : 
; 83   : 	uint64_t address = (uint64_t)addr;

	mov	rax, QWORD PTR addr$[rsp]
	mov	QWORD PTR address$[rsp], rax

; 84   : 
; 85   : 	if (length == 4096) 

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jne	SHORT $LN5@unmap_memo

; 86   : 		AuUnmapPage(address);

	mov	rcx, QWORD PTR address$[rsp]
	call	AuUnmapPage
$LN5@unmap_memo:

; 87   : 
; 88   : 	if (length > 4096) {

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jbe	SHORT $LN4@unmap_memo

; 89   : 		for (int i = 0; i < length / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@unmap_memo
$LN2@unmap_memo:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@unmap_memo:
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN1@unmap_memo

; 90   : 			AuUnmapPage(address + i * 4096);

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR address$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	AuUnmapPage

; 91   : 		}

	jmp	SHORT $LN2@unmap_memo
$LN1@unmap_memo:
$LN4@unmap_memo:

; 92   : 	}
; 93   : 
; 94   : 
; 95   : }

	add	rsp, 72					; 00000048H
	ret	0
?unmap_memory@@YAXPEAXI@Z ENDP				; unmap_memory
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\map.cpp
_TEXT	SEGMENT
user$ = 32
i$1 = 36
i$2 = 40
tv89 = 44
tv144 = 48
tv133 = 52
tv78 = 56
tv94 = 64
tv149 = 72
c_proc$ = 80
addr$ = 112
length$ = 120
attribute$ = 128
?map_memory@@YAPEAX_KIE@Z PROC				; map_memory

; 20   : void *map_memory (uint64_t addr, uint32_t length,uint8_t attribute) {

$LN22:
	mov	BYTE PTR [rsp+24], r8b
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 21   : 	x64_cli();

	call	x64_cli

; 22   : 	process_t * c_proc = get_current_process();

	call	?get_current_process@@YAPEAU_process_@@XZ ; get_current_process
	mov	QWORD PTR c_proc$[rsp], rax

; 23   : 	
; 24   : 	//!Attribute check
; 25   : 	bool user = false;

	mov	BYTE PTR user$[rsp], 0

; 26   : 	if (attribute & ATTRIBUTE_USER)

	movzx	eax, BYTE PTR attribute$[rsp]
	and	eax, 5
	test	eax, eax
	je	SHORT $LN11@map_memory

; 27   : 		user = true;

	mov	BYTE PTR user$[rsp], 1
$LN11@map_memory:

; 28   : 
; 29   : 	//! For more convenient, give a null to address parameter 
; 30   : 	//! cause, null parameter will cause map_memory to look for free
; 31   : 	//! memory in process's address space
; 32   : 	if (addr == NULL) {

	cmp	QWORD PTR addr$[rsp], 0
	jne	$LN10@map_memory

; 33   : 		addr = (uint64_t)AuGetFreePage(length, user, 0);

	mov	eax, DWORD PTR length$[rsp]
	xor	r8d, r8d
	movzx	edx, BYTE PTR user$[rsp]
	mov	ecx, eax
	call	AuGetFreePage
	mov	QWORD PTR addr$[rsp], rax

; 34   : 		if (length == 4096) {

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jne	SHORT $LN9@map_memory

; 35   : 			AuMapPage((uint64_t)AuPmmngrAlloc(), addr,(user == true) ? PAGING_USER : 0);

	movzx	eax, BYTE PTR user$[rsp]
	cmp	eax, 1
	jne	SHORT $LN14@map_memory
	mov	DWORD PTR tv78[rsp], 4
	jmp	SHORT $LN15@map_memory
$LN14@map_memory:
	mov	DWORD PTR tv78[rsp], 0
$LN15@map_memory:
	call	AuPmmngrAlloc
	movzx	r8d, BYTE PTR tv78[rsp]
	mov	rdx, QWORD PTR addr$[rsp]
	mov	rcx, rax
	call	AuMapPage

; 36   : 			return (void*)addr;

	mov	rax, QWORD PTR addr$[rsp]
	jmp	$LN12@map_memory
$LN9@map_memory:

; 37   : 		}
; 38   : 
; 39   : 		for (int i = 0; i < length / 4096; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN8@map_memory
$LN7@map_memory:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN8@map_memory:
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN6@map_memory

; 40   : 			AuMapPage((uint64_t)AuPmmngrAlloc(),addr + i * 4096,(user == true) ? PAGING_USER : 0);

	movzx	eax, BYTE PTR user$[rsp]
	cmp	eax, 1
	jne	SHORT $LN16@map_memory
	mov	DWORD PTR tv89[rsp], 4
	jmp	SHORT $LN17@map_memory
$LN16@map_memory:
	mov	DWORD PTR tv89[rsp], 0
$LN17@map_memory:
	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv94[rsp], rax
	call	AuPmmngrAlloc
	movzx	r8d, BYTE PTR tv89[rsp]
	mov	rcx, QWORD PTR tv94[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	AuMapPage
	jmp	SHORT $LN7@map_memory
$LN6@map_memory:

; 41   : 
; 42   : 
; 43   : 	} 
; 44   : 	//! use the given address to map a region
; 45   : 	//! TODO: Check if there's already a mapped region, and relocate the mapping
; 46   : 	else {

	jmp	$LN5@map_memory
$LN10@map_memory:

; 47   : 		if (length == 4096) {

	cmp	DWORD PTR length$[rsp], 4096		; 00001000H
	jne	SHORT $LN4@map_memory

; 48   : 			AuMapPage((uint64_t)AuPmmngrAlloc(), addr,(user == true) ? PAGING_USER : 0);

	movzx	eax, BYTE PTR user$[rsp]
	cmp	eax, 1
	jne	SHORT $LN18@map_memory
	mov	DWORD PTR tv133[rsp], 4
	jmp	SHORT $LN19@map_memory
$LN18@map_memory:
	mov	DWORD PTR tv133[rsp], 0
$LN19@map_memory:
	call	AuPmmngrAlloc
	movzx	r8d, BYTE PTR tv133[rsp]
	mov	rdx, QWORD PTR addr$[rsp]
	mov	rcx, rax
	call	AuMapPage

; 49   : 			return (void*)addr;

	mov	rax, QWORD PTR addr$[rsp]
	jmp	$LN12@map_memory
$LN4@map_memory:

; 50   : 		}
; 51   : 
; 52   : 		for (int i = 0; i < length / 4096; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@map_memory
$LN2@map_memory:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@map_memory:
	xor	edx, edx
	mov	eax, DWORD PTR length$[rsp]
	mov	ecx, 4096				; 00001000H
	div	ecx
	cmp	DWORD PTR i$2[rsp], eax
	jae	SHORT $LN1@map_memory

; 53   : 			AuMapPage((uint64_t)AuPmmngrAlloc(),addr + i * 4096,(user == true) ? PAGING_USER : 0);

	movzx	eax, BYTE PTR user$[rsp]
	cmp	eax, 1
	jne	SHORT $LN20@map_memory
	mov	DWORD PTR tv144[rsp], 4
	jmp	SHORT $LN21@map_memory
$LN20@map_memory:
	mov	DWORD PTR tv144[rsp], 0
$LN21@map_memory:
	mov	eax, DWORD PTR i$2[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR tv149[rsp], rax
	call	AuPmmngrAlloc
	movzx	r8d, BYTE PTR tv144[rsp]
	mov	rcx, QWORD PTR tv149[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	AuMapPage
	jmp	SHORT $LN2@map_memory
$LN1@map_memory:
$LN5@map_memory:

; 54   : 	}
; 55   : 
; 56   : 	//! MAP_GLOBAL flag will cause the map_memory to map the address
; 57   : 	//! in its child process, for now its not implemented
; 58   : 
; 59   : 	//if (attribute & MAP_GLOBAL) {
; 60   : 	//	process_map_addresses (addr,length,(uint64_t*)c_proc->thread_data_pointer->cr3,c_proc);
; 61   : 	//}
; 62   : 	
; 63   : 	//! return the mapped address
; 64   : 	return (void*)addr;

	mov	rax, QWORD PTR addr$[rsp]
$LN12@map_memory:

; 65   : }

	add	rsp, 104				; 00000068H
	ret	0
?map_memory@@YAPEAX_KIE@Z ENDP				; map_memory
_TEXT	ENDS
END
