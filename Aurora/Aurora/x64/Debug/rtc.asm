; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?century@@3EA					; century
PUBLIC	?year@@3EA					; year
PUBLIC	?month@@3EA					; month
PUBLIC	?day@@3EA					; day
PUBLIC	?hour@@3EA					; hour
PUBLIC	?minute@@3EA					; minute
PUBLIC	?second@@3EA					; second
_BSS	SEGMENT
?century@@3EA DB 01H DUP (?)				; century
?year@@3EA DB	01H DUP (?)				; year
?month@@3EA DB	01H DUP (?)				; month
?day@@3EA DB	01H DUP (?)				; day
?hour@@3EA DB	01H DUP (?)				; hour
?minute@@3EA DB	01H DUP (?)				; minute
?second@@3EA DB	01H DUP (?)				; second
_BSS	ENDS
PUBLIC	?AuInitializeRTC@@YAXXZ				; AuInitializeRTC
PUBLIC	AuGetYear
PUBLIC	AuGetSecond
PUBLIC	AuGetDay
PUBLIC	AuGetHour
PUBLIC	AuGetMinutes
PUBLIC	AuGetCentury
PUBLIC	AuGetMonth
PUBLIC	?AuGetRTCRegister@@YAEH@Z			; AuGetRTCRegister
PUBLIC	?AuSetRTCRegister@@YAXGE@Z			; AuSetRTCRegister
PUBLIC	?AuIsUpdatingRTC@@YAHXZ				; AuIsUpdatingRTC
PUBLIC	?AuRTCReadDateTime@@YAXXZ			; AuRTCReadDateTime
PUBLIC	?AuRTCClockUpdate@@YAX_KPEAX@Z			; AuRTCClockUpdate
EXTRN	x64_cli:PROC
EXTRN	x64_sti:PROC
EXTRN	x64_inportb:PROC
EXTRN	x64_outportb:PROC
EXTRN	AuInterruptEnd:PROC
EXTRN	AuInterruptSet:PROC
_BSS	SEGMENT
bcd	DB	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$?AuInitializeRTC@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+254
	DD	imagerel $unwind$?AuInitializeRTC@@YAXXZ
$pdata$?AuGetRTCRegister@@YAEH@Z DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$?AuGetRTCRegister@@YAEH@Z
$pdata$?AuSetRTCRegister@@YAXGE@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?AuSetRTCRegister@@YAXGE@Z
$pdata$?AuIsUpdatingRTC@@YAHXZ DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$?AuIsUpdatingRTC@@YAHXZ
$pdata$?AuRTCReadDateTime@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+455
	DD	imagerel $unwind$?AuRTCReadDateTime@@YAXXZ
$pdata$?AuRTCClockUpdate@@YAX_KPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+94
	DD	imagerel $unwind$?AuRTCClockUpdate@@YAX_KPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuInitializeRTC@@YAXXZ DD 010401H
	DD	06204H
$unwind$?AuGetRTCRegister@@YAEH@Z DD 010801H
	DD	04208H
$unwind$?AuSetRTCRegister@@YAXGE@Z DD 010d01H
	DD	0420dH
$unwind$?AuIsUpdatingRTC@@YAHXZ DD 010401H
	DD	06204H
$unwind$?AuRTCReadDateTime@@YAXXZ DD 010401H
	DD	08204H
$unwind$?AuRTCClockUpdate@@YAX_KPEAX@Z DD 010e01H
	DD	0620eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
tv69 = 32
ready$ = 33
s$ = 64
p$ = 72
?AuRTCClockUpdate@@YAX_KPEAX@Z PROC			; AuRTCClockUpdate

; 85   : void AuRTCClockUpdate(size_t s, void* p) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 86   : 	x64_cli ();

	call	x64_cli

; 87   : 
; 88   : 	bool ready = AuGetRTCRegister(0x0C) & 0x10;

	mov	ecx, 12
	call	?AuGetRTCRegister@@YAEH@Z		; AuGetRTCRegister
	movzx	eax, al
	and	eax, 16
	test	eax, eax
	je	SHORT $LN4@AuRTCClock
	mov	BYTE PTR tv69[rsp], 1
	jmp	SHORT $LN5@AuRTCClock
$LN4@AuRTCClock:
	mov	BYTE PTR tv69[rsp], 0
$LN5@AuRTCClock:
	movzx	eax, BYTE PTR tv69[rsp]
	mov	BYTE PTR ready$[rsp], al

; 89   : 	if (ready) {

	movzx	eax, BYTE PTR ready$[rsp]
	test	eax, eax
	je	SHORT $LN1@AuRTCClock

; 90   : 		AuRTCReadDateTime();

	call	?AuRTCReadDateTime@@YAXXZ		; AuRTCReadDateTime
$LN1@AuRTCClock:

; 91   : 	}
; 92   : 
; 93   : 	
; 94   : 	//pri_event_t msg;
; 95   : 	//msg.type = CLOCK_MESSAGE;
; 96   : 	//msg.dword = second;
; 97   : 	//msg.dword2 = minute;
; 98   : 	//msg.dword3 = hour;
; 99   : 	//msg.dword5 = day;
; 100  : 	//msg.dword6 = month;
; 101  : 	//msg.dword7 = year;
; 102  : 	//msg.to_id = 3; //the dock bar
; 103  : 
; 104  : 	//pri_put_message(&msg);
; 105  : 	//!send a EOI to apic
; 106  : 	AuInterruptEnd(8);

	mov	ecx, 8
	call	AuInterruptEnd

; 107  : 	x64_sti();

	call	x64_sti

; 108  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuRTCClockUpdate@@YAX_KPEAX@Z ENDP			; AuRTCClockUpdate
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
registerB$ = 32
tv84 = 36
tv91 = 40
tv130 = 44
tv141 = 48
tv148 = 52
tv155 = 56
?AuRTCReadDateTime@@YAXXZ PROC				; AuRTCReadDateTime

; 59   : void AuRTCReadDateTime() {

$LN6:
	sub	rsp, 72					; 00000048H
$LN3@AuRTCReadD:

; 60   :     // Wait until rtc is not updating
; 61   : 	while(AuIsUpdatingRTC());

	call	?AuIsUpdatingRTC@@YAHXZ			; AuIsUpdatingRTC
	test	eax, eax
	je	SHORT $LN2@AuRTCReadD
	jmp	SHORT $LN3@AuRTCReadD
$LN2@AuRTCReadD:

; 62   : 
; 63   : 	second = AuGetRTCRegister(0x00);

	xor	ecx, ecx
	call	?AuGetRTCRegister@@YAEH@Z		; AuGetRTCRegister
	mov	BYTE PTR ?second@@3EA, al		; second

; 64   :     minute = AuGetRTCRegister(0x02);

	mov	ecx, 2
	call	?AuGetRTCRegister@@YAEH@Z		; AuGetRTCRegister
	mov	BYTE PTR ?minute@@3EA, al		; minute

; 65   :     hour = AuGetRTCRegister(0x04);

	mov	ecx, 4
	call	?AuGetRTCRegister@@YAEH@Z		; AuGetRTCRegister
	mov	BYTE PTR ?hour@@3EA, al			; hour

; 66   :     day = AuGetRTCRegister(0x07);

	mov	ecx, 7
	call	?AuGetRTCRegister@@YAEH@Z		; AuGetRTCRegister
	mov	BYTE PTR ?day@@3EA, al			; day

; 67   :     month = AuGetRTCRegister(0x08);

	mov	ecx, 8
	call	?AuGetRTCRegister@@YAEH@Z		; AuGetRTCRegister
	mov	BYTE PTR ?month@@3EA, al		; month

; 68   :     year = AuGetRTCRegister(0x09);

	mov	ecx, 9
	call	?AuGetRTCRegister@@YAEH@Z		; AuGetRTCRegister
	mov	BYTE PTR ?year@@3EA, al			; year

; 69   : 
; 70   :     uint8_t registerB = AuGetRTCRegister(0x0B);

	mov	ecx, 11
	call	?AuGetRTCRegister@@YAEH@Z		; AuGetRTCRegister
	mov	BYTE PTR registerB$[rsp], al

; 71   : 
; 72   :     // Convert BCD to binary values if necessary
; 73   :     if (!(registerB & 0x04)) {

	movzx	eax, BYTE PTR registerB$[rsp]
	and	eax, 4
	test	eax, eax
	jne	$LN1@AuRTCReadD

; 74   :         second = (second & 0x0F) + ((second / 16) * 10);

	movzx	eax, BYTE PTR ?second@@3EA		; second
	and	eax, 15
	mov	DWORD PTR tv84[rsp], eax
	movzx	ecx, BYTE PTR ?second@@3EA		; second
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, 10
	mov	ecx, DWORD PTR tv84[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR ?second@@3EA, al		; second

; 75   :         minute = (minute & 0x0F) + ((minute / 16) * 10);

	movzx	eax, BYTE PTR ?minute@@3EA		; minute
	and	eax, 15
	mov	DWORD PTR tv91[rsp], eax
	movzx	ecx, BYTE PTR ?minute@@3EA		; minute
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, 10
	mov	ecx, DWORD PTR tv91[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR ?minute@@3EA, al		; minute

; 76   :         hour = ( (hour & 0x0F) + (((hour & 0x70) / 16) * 10) ) | (hour & 0x80);

	movzx	eax, BYTE PTR ?hour@@3EA		; hour
	and	eax, 15
	mov	DWORD PTR tv130[rsp], eax
	movzx	ecx, BYTE PTR ?hour@@3EA		; hour
	and	ecx, 112				; 00000070H
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, 10
	mov	ecx, DWORD PTR tv130[rsp]
	add	ecx, eax
	mov	eax, ecx
	movzx	ecx, BYTE PTR ?hour@@3EA		; hour
	and	ecx, 128				; 00000080H
	or	eax, ecx
	mov	BYTE PTR ?hour@@3EA, al			; hour

; 77   :         day = (day & 0x0F) + ((day / 16) * 10);

	movzx	eax, BYTE PTR ?day@@3EA			; day
	and	eax, 15
	mov	DWORD PTR tv141[rsp], eax
	movzx	ecx, BYTE PTR ?day@@3EA			; day
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, 10
	mov	ecx, DWORD PTR tv141[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR ?day@@3EA, al			; day

; 78   :         month = (month & 0x0F) + ((month / 16) * 10);

	movzx	eax, BYTE PTR ?month@@3EA		; month
	and	eax, 15
	mov	DWORD PTR tv148[rsp], eax
	movzx	ecx, BYTE PTR ?month@@3EA		; month
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, 10
	mov	ecx, DWORD PTR tv148[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR ?month@@3EA, al		; month

; 79   :         year = (year & 0x0F) + ((year / 16) * 10);

	movzx	eax, BYTE PTR ?year@@3EA		; year
	and	eax, 15
	mov	DWORD PTR tv155[rsp], eax
	movzx	ecx, BYTE PTR ?year@@3EA		; year
	mov	eax, ecx
	cdq
	and	edx, 15
	add	eax, edx
	sar	eax, 4
	imul	eax, 10
	mov	ecx, DWORD PTR tv155[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	BYTE PTR ?year@@3EA, al			; year
$LN1@AuRTCReadD:

; 80   :     }
; 81   : }

	add	rsp, 72					; 00000048H
	ret	0
?AuRTCReadDateTime@@YAXXZ ENDP				; AuRTCReadDateTime
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
status$ = 32
?AuIsUpdatingRTC@@YAHXZ PROC				; AuIsUpdatingRTC

; 49   : int AuIsUpdatingRTC() {

$LN3:
	sub	rsp, 56					; 00000038H

; 50   : 	x64_outportb(CMOS_ADDR, 0x0A);

	mov	dl, 10
	mov	cx, 112					; 00000070H
	call	x64_outportb

; 51   :     uint32_t status = x64_inportb(CMOS_DATA);

	mov	cx, 113					; 00000071H
	call	x64_inportb
	movzx	eax, al
	mov	DWORD PTR status$[rsp], eax

; 52   :     return (status & 0x80);

	mov	eax, DWORD PTR status$[rsp]
	and	eax, 128				; 00000080H

; 53   : }

	add	rsp, 56					; 00000038H
	ret	0
?AuIsUpdatingRTC@@YAHXZ ENDP				; AuIsUpdatingRTC
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
reg_num$ = 48
val$ = 56
?AuSetRTCRegister@@YAXGE@Z PROC				; AuSetRTCRegister

; 40   : void AuSetRTCRegister(uint16_t reg_num, uint8_t val) {

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 40					; 00000028H

; 41   :     x64_outportb(CMOS_ADDR, reg_num);

	movzx	edx, BYTE PTR reg_num$[rsp]
	mov	cx, 112					; 00000070H
	call	x64_outportb

; 42   :     x64_outportb(CMOS_DATA, val);

	movzx	edx, BYTE PTR val$[rsp]
	mov	cx, 113					; 00000071H
	call	x64_outportb

; 43   : }

	add	rsp, 40					; 00000028H
	ret	0
?AuSetRTCRegister@@YAXGE@Z ENDP				; AuSetRTCRegister
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
reg_num$ = 48
?AuGetRTCRegister@@YAEH@Z PROC				; AuGetRTCRegister

; 32   : uint8_t AuGetRTCRegister(int reg_num) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 33   :     x64_outportb(CMOS_ADDR, reg_num);

	movzx	edx, BYTE PTR reg_num$[rsp]
	mov	cx, 112					; 00000070H
	call	x64_outportb

; 34   :     return x64_inportb(CMOS_DATA);

	mov	cx, 113					; 00000071H
	call	x64_inportb

; 35   : }

	add	rsp, 40					; 00000028H
	ret	0
?AuGetRTCRegister@@YAEH@Z ENDP				; AuGetRTCRegister
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
AuGetMonth PROC

; 168  : 	return month;

	movzx	eax, BYTE PTR ?month@@3EA		; month

; 169  : }

	ret	0
AuGetMonth ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
AuGetCentury PROC

; 148  : 	return century;

	movzx	eax, BYTE PTR ?century@@3EA		; century

; 149  : }

	ret	0
AuGetCentury ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
AuGetMinutes PROC

; 152  : 	return minute;

	movzx	eax, BYTE PTR ?minute@@3EA		; minute

; 153  : }

	ret	0
AuGetMinutes ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
AuGetHour PROC

; 164  : 	return hour;

	movzx	eax, BYTE PTR ?hour@@3EA		; hour

; 165  : }

	ret	0
AuGetHour ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
AuGetDay PROC

; 160  : 	return day;

	movzx	eax, BYTE PTR ?day@@3EA			; day

; 161  : }

	ret	0
AuGetDay ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
AuGetSecond PROC

; 156  : 	return second;

	movzx	eax, BYTE PTR ?second@@3EA		; second

; 157  : }

	ret	0
AuGetSecond ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
AuGetYear PROC

; 144  : 	return year;

	movzx	eax, BYTE PTR ?year@@3EA		; year

; 145  : }

	ret	0
AuGetYear ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\rtc.cpp
_TEXT	SEGMENT
status$ = 32
tv81 = 36
?AuInitializeRTC@@YAXXZ PROC				; AuInitializeRTC

; 113  : void AuInitializeRTC () {

$LN5:
	sub	rsp, 56					; 00000038H

; 114  : 
; 115  : 	century = year = month = day = 0;

	mov	BYTE PTR ?day@@3EA, 0			; day
	movzx	eax, BYTE PTR ?day@@3EA			; day
	mov	BYTE PTR ?month@@3EA, al		; month
	movzx	eax, BYTE PTR ?month@@3EA		; month
	mov	BYTE PTR ?year@@3EA, al			; year
	movzx	eax, BYTE PTR ?year@@3EA		; year
	mov	BYTE PTR ?century@@3EA, al		; century

; 116  :     hour = minute = second = 0;

	mov	BYTE PTR ?second@@3EA, 0		; second
	movzx	eax, BYTE PTR ?second@@3EA		; second
	mov	BYTE PTR ?minute@@3EA, al		; minute
	movzx	eax, BYTE PTR ?minute@@3EA		; minute
	mov	BYTE PTR ?hour@@3EA, al			; hour

; 117  : 
; 118  : 	unsigned char status = AuGetRTCRegister(0x0B);

	mov	ecx, 11
	call	?AuGetRTCRegister@@YAEH@Z		; AuGetRTCRegister
	mov	BYTE PTR status$[rsp], al

; 119  : 	status |= 0x02;

	movzx	eax, BYTE PTR status$[rsp]
	or	eax, 2
	mov	BYTE PTR status$[rsp], al

; 120  : 	status |= 0x10;

	movzx	eax, BYTE PTR status$[rsp]
	or	eax, 16
	mov	BYTE PTR status$[rsp], al

; 121  : 	status &= ~0x20;

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, -33				; ffffffffffffffdfH
	mov	BYTE PTR status$[rsp], al

; 122  : 	status &= ~0x40;

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, -65				; ffffffffffffffbfH
	mov	BYTE PTR status$[rsp], al

; 123  : 	bcd = !(status & 0x04);

	movzx	eax, BYTE PTR status$[rsp]
	and	eax, 4
	test	eax, eax
	jne	SHORT $LN3@AuInitiali
	mov	DWORD PTR tv81[rsp], 1
	jmp	SHORT $LN4@AuInitiali
$LN3@AuInitiali:
	mov	DWORD PTR tv81[rsp], 0
$LN4@AuInitiali:
	movzx	eax, BYTE PTR tv81[rsp]
	mov	BYTE PTR bcd, al

; 124  : 
; 125  : 	//! Write status to rtc
; 126  : 	x64_outportb (0x70, 0x0B);

	mov	dl, 11
	mov	cx, 112					; 00000070H
	call	x64_outportb

; 127  : 	x64_outportb (0x71, status);

	movzx	edx, BYTE PTR status$[rsp]
	mov	cx, 113					; 00000071H
	call	x64_outportb

; 128  : 
; 129  : 	//! Read status from RTC
; 130  : 	AuGetRTCRegister(0x0C);

	mov	ecx, 12
	call	?AuGetRTCRegister@@YAEH@Z		; AuGetRTCRegister

; 131  : 
; 132  : 	AuRTCReadDateTime();

	call	?AuRTCReadDateTime@@YAXXZ		; AuRTCReadDateTime

; 133  : 
; 134  : 	//!register interrupt
; 135  : 	AuInterruptSet(8,AuRTCClockUpdate, 8, false);

	xor	r9d, r9d
	mov	r8b, 8
	lea	rdx, OFFSET FLAT:?AuRTCClockUpdate@@YAX_KPEAX@Z ; AuRTCClockUpdate
	mov	ecx, 8
	call	AuInterruptSet

; 136  : 
; 137  : #ifdef USE_PIC
; 138  : 	AuIrqMask(8,false);
; 139  : #endif
; 140  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuInitializeRTC@@YAXXZ ENDP				; AuInitializeRTC
_TEXT	ENDS
END
