; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?sata_drive_port@@3PEAU_hba_port_@@EA		; sata_drive_port
_BSS	SEGMENT
?sata_drive_port@@3PEAU_hba_port_@@EA DQ 01H DUP (?)	; sata_drive_port
_BSS	ENDS
CONST	SEGMENT
$SG3980	DB	'[AHCI]:Port Hung', 0aH, 00H
	ORG $+6
$SG4013	DB	'[AHCI]:Port Hung', 0aH, 00H
	ORG $+6
$SG4046	DB	'[AHCI]:Port Hung', 0aH, 00H
	ORG $+6
$SG4065	DB	'[AHCI]: Port Supports cold presence %d', 0aH, 00H
$SG4082	DB	'[AHCI]: Model -> %s', 0aH, 00H
CONST	ENDS
PUBLIC	?ahci_disk_initialize@@YAXPEAU_hba_port_@@@Z	; ahci_disk_initialize
PUBLIC	?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z	; ahci_disk_write
PUBLIC	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z	; ahci_disk_read
PUBLIC	?ahci_disk_stop_cmd@@YAXPEAU_hba_port_@@@Z	; ahci_disk_stop_cmd
PUBLIC	?ahci_disk_start_cmd@@YAXPEAU_hba_port_@@@Z	; ahci_disk_start_cmd
PUBLIC	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ	; ahci_disk_get_port
PUBLIC	?ahci_disk_find_slot@@YAIPEAU_hba_port_@@@Z	; ahci_disk_find_slot
PUBLIC	?ahci_disk_identify@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_identify
EXTRN	?pmmngr_alloc@@YAPEAXXZ:PROC			; pmmngr_alloc
EXTRN	?memset@@YAXPEAXEI@Z:PROC			; memset
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
pdata	SEGMENT
$pdata$?ahci_disk_initialize@@YAXPEAU_hba_port_@@@Z DD imagerel $LN10
	DD	imagerel $LN10+776
	DD	imagerel $unwind$?ahci_disk_initialize@@YAXPEAU_hba_port_@@@Z
$pdata$?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD imagerel $LN12
	DD	imagerel $LN12+930
	DD	imagerel $unwind$?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z
$pdata$?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD imagerel $LN12
	DD	imagerel $LN12+984
	DD	imagerel $unwind$?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z
$pdata$?ahci_disk_find_slot@@YAIPEAU_hba_port_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+87
	DD	imagerel $unwind$?ahci_disk_find_slot@@YAIPEAU_hba_port_@@@Z
$pdata$?ahci_disk_identify@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD imagerel $LN12
	DD	imagerel $LN12+930
	DD	imagerel $unwind$?ahci_disk_identify@@YAXPEAU_hba_port_@@_KIPEA_K@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?ahci_disk_initialize@@YAXPEAU_hba_port_@@@Z DD 020c01H
	DD	013010cH
$unwind$?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD 011801H
	DD	0a218H
$unwind$?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD 011801H
	DD	0c218H
$unwind$?ahci_disk_find_slot@@YAIPEAU_hba_port_@@@Z DD 010901H
	DD	02209H
$unwind$?ahci_disk_identify@@YAXPEAU_hba_port_@@_KIPEA_K@Z DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci_disk.cpp
_TEXT	SEGMENT
i$ = 32
spin$ = 36
command_slot$ = 40
tbl$ = 48
fis$ = 56
cmd_list$ = 64
buffer_whole$ = 72
port$ = 96
lba$ = 104
count$ = 112
buffer$ = 120
?ahci_disk_identify@@YAXPEAU_hba_port_@@_KIPEA_K@Z PROC	; ahci_disk_identify

; 222  : void ahci_disk_identify (HBA_PORT *port, uint64_t lba, uint32_t count, uint64_t *buffer) {

$LN12:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 223  : 	int spin = 0;

	mov	DWORD PTR spin$[rsp], 0

; 224  : 	HBA_CMD_HEADER *cmd_list = (HBA_CMD_HEADER*)port->clb;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	QWORD PTR cmd_list$[rsp], rax

; 225  : 	uint64_t buffer_whole = (uint64_t)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR buffer_whole$[rsp], rax

; 226  : 
; 227  : 	cmd_list->cfl = sizeof(FIS_REG_H2D)/sizeof(uint32_t);

	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	al, 224					; 000000e0H
	or	al, 5
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rcx], al

; 228  : 	cmd_list->w = 0;

	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	al, 191					; 000000bfH
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rcx], al

; 229  : 	cmd_list->prdtl = (uint16_t)((count-1)>>4)+1;

	mov	eax, DWORD PTR count$[rsp]
	dec	eax
	shr	eax, 4
	movzx	eax, ax
	inc	eax
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	WORD PTR [rcx+2], ax

; 230  : 
; 231  : 	uint32_t command_slot = ahci_disk_find_slot(port);

	mov	rcx, QWORD PTR port$[rsp]
	call	?ahci_disk_find_slot@@YAIPEAU_hba_port_@@@Z ; ahci_disk_find_slot
	mov	DWORD PTR command_slot$[rsp], eax

; 232  : 
; 233  : 	HBA_CMD_TABLE *tbl = (HBA_CMD_TABLE*)cmd_list[command_slot].ctba;

	mov	eax, DWORD PTR command_slot$[rsp]
	imul	rax, 32					; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	QWORD PTR tbl$[rsp], rax

; 234  : 	int i=0;

	mov	DWORD PTR i$[rsp], 0

; 235  : 	for (i = 0; i < cmd_list->prdtl; i++){

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN9@ahci_disk_
$LN8@ahci_disk_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN9@ahci_disk_:
	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN7@ahci_disk_

; 236  : 		tbl->prdt[i].data_base_address = buffer_whole & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_whole$[rsp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 237  : 		tbl->prdt[i].dbau = buffer_whole >> 32;

	mov	rax, QWORD PTR buffer_whole$[rsp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 238  : 		tbl->prdt[i].data_byte_count = (512 * count) - 1;

	mov	eax, DWORD PTR count$[rsp]
	imul	eax, 512				; 00000200H
	dec	eax
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 239  : 		tbl->prdt[i].i = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 16
	mov	rcx, QWORD PTR tbl$[rsp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 240  : 		buffer += 512*count;

	mov	eax, DWORD PTR count$[rsp]
	imul	eax, 512				; 00000200H
	mov	eax, eax
	mov	rcx, QWORD PTR buffer$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR buffer$[rsp], rax

; 241  : 		buffer_whole = (uint32_t)buffer;

	mov	eax, DWORD PTR buffer$[rsp]
	mov	QWORD PTR buffer_whole$[rsp], rax

; 242  : 	}

	jmp	$LN8@ahci_disk_
$LN7@ahci_disk_:

; 243  : 	tbl->prdt[i].data_base_address = buffer_whole & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_whole$[rsp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 244  : 	tbl->prdt[i].dbau = buffer_whole >> 32;

	mov	rax, QWORD PTR buffer_whole$[rsp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 245  : 	tbl->prdt[i].data_byte_count = (512 * count) - 1;

	mov	eax, DWORD PTR count$[rsp]
	imul	eax, 512				; 00000200H
	dec	eax
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 246  : 	tbl->prdt[i].i = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 16
	mov	rcx, QWORD PTR tbl$[rsp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 247  : 
; 248  : 	FIS_REG_H2D *fis = (FIS_REG_H2D*)tbl->cmd_fis;

	mov	rax, QWORD PTR tbl$[rsp]
	mov	QWORD PTR fis$[rsp], rax

; 249  : 	fis->fis_type = FIS_TYPE_REG_H2D;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax], 39			; 00000027H

; 250  : 	fis->c = 1;

	mov	rax, QWORD PTR fis$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+1], al

; 251  : 	fis->command = ATA_CMD_IDENTIFY;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax+2], 236			; 000000ecH

; 252  : 	fis->lba0 = lba & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+4], al

; 253  : 	fis->lba1 = (lba>>8) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 8
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+5], al

; 254  : 	fis->lba2 = (lba>>16) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+6], al

; 255  : 	fis->device = 1<<6;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax+7], 64			; 00000040H

; 256  : 	fis->lba3 = (lba>>24) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+8], al

; 257  : 	fis->lba4 = (lba>>32) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 32					; 00000020H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+9], al

; 258  : 	fis->lba5 = (lba>>40) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 40					; 00000028H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+10], al

; 259  : 	fis->countl = count & 0xff;

	mov	eax, DWORD PTR count$[rsp]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+12], al

; 260  : 	fis->counth = (count >> 8) & 0xff;

	mov	eax, DWORD PTR count$[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+13], al
$LN6@ahci_disk_:

; 261  : 
; 262  : 	while((port->tfd & (ATA_SR_BSY  | ATA_SR_DRQ)) && spin < 1000000) {

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 136				; 00000088H
	test	eax, eax
	je	SHORT $LN5@ahci_disk_
	cmp	DWORD PTR spin$[rsp], 1000000		; 000f4240H
	jge	SHORT $LN5@ahci_disk_

; 263  : 		spin++;

	mov	eax, DWORD PTR spin$[rsp]
	inc	eax
	mov	DWORD PTR spin$[rsp], eax

; 264  : 	}

	jmp	SHORT $LN6@ahci_disk_
$LN5@ahci_disk_:

; 265  : 	if (spin==1000000)

	cmp	DWORD PTR spin$[rsp], 1000000		; 000f4240H
	jne	SHORT $LN4@ahci_disk_

; 266  : 		printf ("[AHCI]:Port Hung\n");

	lea	rcx, OFFSET FLAT:$SG4046
	call	?printf@@YAXPEBDZZ			; printf
$LN4@ahci_disk_:

; 267  : 
; 268  : 	port->ci = 1<<0;

	mov	rax, QWORD PTR port$[rsp]
	mov	DWORD PTR [rax+56], 1
$LN3@ahci_disk_:

; 269  : 	while(1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@ahci_disk_

; 270  : 		if ((port->ci & (1<<0)) == 0) 

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+56]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN1@ahci_disk_

; 271  : 			break;

	jmp	SHORT $LN2@ahci_disk_
$LN1@ahci_disk_:

; 272  : 		/*if (port->is & (1<<30)) 
; 273  : 			break;*/
; 274  : 	}

	jmp	SHORT $LN3@ahci_disk_
$LN2@ahci_disk_:

; 275  : }

	add	rsp, 88					; 00000058H
	ret	0
?ahci_disk_identify@@YAXPEAU_hba_port_@@_KIPEA_K@Z ENDP	; ahci_disk_identify
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci_disk.cpp
_TEXT	SEGMENT
i$1 = 0
slots$ = 4
port$ = 32
?ahci_disk_find_slot@@YAIPEAU_hba_port_@@@Z PROC	; ahci_disk_find_slot

; 77   : uint32_t ahci_disk_find_slot (HBA_PORT *port) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 78   : 	uint32_t slots = (port->sact | port->ci);

	mov	rax, QWORD PTR port$[rsp]
	mov	rcx, QWORD PTR port$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	mov	eax, DWORD PTR [rax+52]
	or	eax, ecx
	mov	DWORD PTR slots$[rsp], eax

; 79   : 	for (int i = 0; i < 32; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@ahci_disk_
$LN3@ahci_disk_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@ahci_disk_:
	cmp	DWORD PTR i$1[rsp], 32			; 00000020H
	jge	SHORT $LN2@ahci_disk_

; 80   : 		if ((slots & 1) == 0)

	mov	eax, DWORD PTR slots$[rsp]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN1@ahci_disk_

; 81   : 			return i;

	mov	eax, DWORD PTR i$1[rsp]
	jmp	SHORT $LN5@ahci_disk_
$LN1@ahci_disk_:

; 82   : 		slots >>= 1;

	mov	eax, DWORD PTR slots$[rsp]
	shr	eax, 1
	mov	DWORD PTR slots$[rsp], eax

; 83   : 	}

	jmp	SHORT $LN3@ahci_disk_
$LN2@ahci_disk_:
$LN5@ahci_disk_:

; 84   : }

	add	rsp, 24
	ret	0
?ahci_disk_find_slot@@YAIPEAU_hba_port_@@@Z ENDP	; ahci_disk_find_slot
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci_disk.cpp
_TEXT	SEGMENT
?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ PROC		; ahci_disk_get_port

; 356  : 	return sata_drive_port;

	mov	rax, QWORD PTR ?sata_drive_port@@3PEAU_hba_port_@@EA ; sata_drive_port

; 357  : }

	ret	0
?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ENDP		; ahci_disk_get_port
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci_disk.cpp
_TEXT	SEGMENT
port$ = 8
?ahci_disk_start_cmd@@YAXPEAU_hba_port_@@@Z PROC	; ahci_disk_start_cmd

; 64   : void ahci_disk_start_cmd (HBA_PORT *port) {

	mov	QWORD PTR [rsp+8], rcx
$LN2@ahci_disk_:

; 65   : 	while (port->cmd & PX_CMD_CR)

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 32768				; 00008000H
	test	eax, eax
	je	SHORT $LN1@ahci_disk_

; 66   : 		;

	jmp	SHORT $LN2@ahci_disk_
$LN1@ahci_disk_:

; 67   : 	port->cmd |= PX_CMD_FRE;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	or	eax, 16
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 68   : 	port->cmd |= PX_CMD_START;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	or	eax, 1
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 69   : }

	ret	0
?ahci_disk_start_cmd@@YAXPEAU_hba_port_@@@Z ENDP	; ahci_disk_start_cmd
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci_disk.cpp
_TEXT	SEGMENT
port$ = 8
?ahci_disk_stop_cmd@@YAXPEAU_hba_port_@@@Z PROC		; ahci_disk_stop_cmd

; 48   : void ahci_disk_stop_cmd (HBA_PORT *port) {

	mov	QWORD PTR [rsp+8], rcx

; 49   : 	port->cmd &= ~PX_CMD_START;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, -2					; fffffffeH
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 50   : 	port->cmd &= ~PX_CMD_FRE;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, -17				; ffffffefH
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+24], eax
$LN7@ahci_disk_:
$LN4@ahci_disk_:

; 51   : 	while(1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN3@ahci_disk_

; 52   : 		if (port->cmd & PX_CMD_FR)

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 16384				; 00004000H
	test	eax, eax
	je	SHORT $LN2@ahci_disk_

; 53   : 			continue;

	jmp	SHORT $LN4@ahci_disk_
$LN2@ahci_disk_:

; 54   : 		if (port->cmd & PX_CMD_CR)

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 32768				; 00008000H
	test	eax, eax
	je	SHORT $LN1@ahci_disk_

; 55   : 			continue;

	jmp	SHORT $LN7@ahci_disk_
$LN1@ahci_disk_:

; 56   : 		break;

	jmp	SHORT $LN3@ahci_disk_

; 57   : 	}

	jmp	SHORT $LN4@ahci_disk_
$LN3@ahci_disk_:

; 58   : }

	fatret	0
?ahci_disk_stop_cmd@@YAXPEAU_hba_port_@@@Z ENDP		; ahci_disk_stop_cmd
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci_disk.cpp
_TEXT	SEGMENT
i$ = 32
fis$ = 40
tbl$ = 48
spin$ = 56
command_slot$ = 60
cmd_list$ = 64
buffer_whole$ = 72
tv356 = 80
tv351 = 84
port$ = 112
lba$ = 120
count$ = 128
buffer$ = 136
?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z PROC	; ahci_disk_read

; 94   : void ahci_disk_read (HBA_PORT *port, uint64_t lba, uint32_t count, uint64_t *buffer) {

$LN12:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 95   : 	//port->is = (uint32_t)-1;
; 96   : 	int spin = 0;

	mov	DWORD PTR spin$[rsp], 0

; 97   : 	HBA_CMD_HEADER *cmd_list = (HBA_CMD_HEADER*)port->clb;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	QWORD PTR cmd_list$[rsp], rax

; 98   : 	uint64_t buffer_whole = (uint64_t)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR buffer_whole$[rsp], rax

; 99   : 
; 100  : 	cmd_list->cfl = sizeof(FIS_REG_H2D)/sizeof(uint32_t);

	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	al, 224					; 000000e0H
	or	al, 5
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rcx], al

; 101  : 	cmd_list->w = 0;

	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	al, 191					; 000000bfH
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rcx], al

; 102  : 	cmd_list->prdtl = (uint16_t)((count-1)>>4)+1;

	mov	eax, DWORD PTR count$[rsp]
	dec	eax
	shr	eax, 4
	movzx	eax, ax
	inc	eax
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	WORD PTR [rcx+2], ax

; 103  : 	
; 104  : 	uint32_t command_slot = ahci_disk_find_slot(port);

	mov	rcx, QWORD PTR port$[rsp]
	call	?ahci_disk_find_slot@@YAIPEAU_hba_port_@@@Z ; ahci_disk_find_slot
	mov	DWORD PTR command_slot$[rsp], eax

; 105  : 
; 106  : 	HBA_CMD_TABLE *tbl = (HBA_CMD_TABLE*)cmd_list[command_slot].ctba;

	mov	eax, DWORD PTR command_slot$[rsp]
	imul	rax, 32					; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	QWORD PTR tbl$[rsp], rax

; 107  : 	int i=0;

	mov	DWORD PTR i$[rsp], 0

; 108  : 	for (i = 0; i < cmd_list->prdtl -1; i++){

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN9@ahci_disk_
$LN8@ahci_disk_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN9@ahci_disk_:
	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, WORD PTR [rax+2]
	dec	eax
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN7@ahci_disk_

; 109  : 		tbl->prdt[i].data_base_address = buffer_whole & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_whole$[rsp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 110  : 		tbl->prdt[i].dbau = buffer_whole >> 32;

	mov	rax, QWORD PTR buffer_whole$[rsp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 111  : 		tbl->prdt[i].data_byte_count = 8*1024-1;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 16
	mov	rcx, QWORD PTR tbl$[rsp]
	mov	eax, DWORD PTR [rcx+rax+140]
	and	eax, -4194304				; ffc00000H
	or	eax, 8191				; 00001fffH
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 112  : 		tbl->prdt[i].i = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 16
	mov	rcx, QWORD PTR tbl$[rsp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 113  : 		buffer += 4*1024;;

	mov	rax, QWORD PTR buffer$[rsp]
	add	rax, 32768				; 00008000H
	mov	QWORD PTR buffer$[rsp], rax

; 114  : 		buffer_whole = (uint32_t)buffer;

	mov	eax, DWORD PTR buffer$[rsp]
	mov	QWORD PTR buffer_whole$[rsp], rax

; 115  : 		count -= 16;

	mov	eax, DWORD PTR count$[rsp]
	sub	eax, 16
	mov	DWORD PTR count$[rsp], eax

; 116  : 	}

	jmp	$LN8@ahci_disk_
$LN7@ahci_disk_:

; 117  : 	tbl->prdt[i].data_base_address = buffer_whole & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_whole$[rsp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 118  : 	tbl->prdt[i].dbau = buffer_whole >> 32;

	mov	rax, QWORD PTR buffer_whole$[rsp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 119  : 	tbl->prdt[i].data_byte_count = (count<<9) - 1;

	mov	eax, DWORD PTR count$[rsp]
	shl	eax, 9
	dec	eax
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 120  : 	tbl->prdt[i].i = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 16
	mov	rcx, QWORD PTR tbl$[rsp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 121  : 
; 122  : 	FIS_REG_H2D *fis = (FIS_REG_H2D*)tbl->cmd_fis;

	mov	rax, QWORD PTR tbl$[rsp]
	mov	QWORD PTR fis$[rsp], rax

; 123  : 	fis->fis_type = FIS_TYPE_REG_H2D;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax], 39			; 00000027H

; 124  : 	fis->c = 1;

	mov	rax, QWORD PTR fis$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+1], al

; 125  : 	fis->command = ATA_CMD_READ_DMA_EXT;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax+2], 37			; 00000025H

; 126  : 	fis->lba0 = lba & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+4], al

; 127  : 	fis->lba1 = (lba>>8) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 8
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+5], al

; 128  : 	fis->lba2 = (lba>>16) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+6], al

; 129  : 	fis->device = 1<<6;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax+7], 64			; 00000040H

; 130  : 	fis->lba3 = (lba>>24) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+8], al

; 131  : 	fis->lba4 = (lba>>32) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 32					; 00000020H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+9], al

; 132  : 	fis->lba5 = (lba>>40) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 40					; 00000028H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+10], al

; 133  : 	fis->countl = count & 0xff;

	mov	eax, DWORD PTR count$[rsp]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+12], al

; 134  : 	fis->counth = (count >> 8) & 0xff;

	mov	eax, DWORD PTR count$[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+13], al
$LN6@ahci_disk_:

; 135  : 
; 136  : 	while((port->tfd & (ATA_SR_BSY  | ATA_SR_DRQ)) && spin < 1000000) {

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 136				; 00000088H
	test	eax, eax
	je	SHORT $LN5@ahci_disk_
	cmp	DWORD PTR spin$[rsp], 1000000		; 000f4240H
	jge	SHORT $LN5@ahci_disk_

; 137  : 		spin++;

	mov	eax, DWORD PTR spin$[rsp]
	inc	eax
	mov	DWORD PTR spin$[rsp], eax

; 138  : 	}

	jmp	SHORT $LN6@ahci_disk_
$LN5@ahci_disk_:

; 139  : 	if (spin==1000000)

	cmp	DWORD PTR spin$[rsp], 1000000		; 000f4240H
	jne	SHORT $LN4@ahci_disk_

; 140  : 		printf ("[AHCI]:Port Hung\n");

	lea	rcx, OFFSET FLAT:$SG3980
	call	?printf@@YAXPEBDZZ			; printf
$LN4@ahci_disk_:

; 141  : 
; 142  : 	port->ci = 1<<command_slot;

	mov	eax, DWORD PTR command_slot$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv351[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv351[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+56], eax
$LN3@ahci_disk_:

; 143  : 	while(1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@ahci_disk_

; 144  : 		if ((port->ci & (1<<command_slot)) == 0) 

	mov	eax, DWORD PTR command_slot$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv356[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv356[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR port$[rsp]
	mov	ecx, DWORD PTR [rcx+56]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	jne	SHORT $LN1@ahci_disk_

; 145  : 			break;

	jmp	SHORT $LN2@ahci_disk_
$LN1@ahci_disk_:

; 146  : 		/*if (port->is & (1<<30)) 
; 147  : 			break;*/
; 148  : 	}

	jmp	SHORT $LN3@ahci_disk_
$LN2@ahci_disk_:

; 149  : }

	add	rsp, 104				; 00000068H
	ret	0
?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ENDP	; ahci_disk_read
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci_disk.cpp
_TEXT	SEGMENT
i$ = 32
spin$ = 36
command_slot$ = 40
tbl$ = 48
fis$ = 56
cmd_list$ = 64
buffer_whole$ = 72
port$ = 96
lba$ = 104
count$ = 112
buffer$ = 120
?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z PROC	; ahci_disk_write

; 159  : void ahci_disk_write (HBA_PORT *port, uint64_t lba, uint32_t count, uint64_t *buffer) {

$LN12:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 160  : 	//port->is = (uint32_t)-1;
; 161  : 	int spin = 0;

	mov	DWORD PTR spin$[rsp], 0

; 162  : 	HBA_CMD_HEADER *cmd_list = (HBA_CMD_HEADER*)port->clb;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	QWORD PTR cmd_list$[rsp], rax

; 163  : 	uint64_t buffer_whole = (uint64_t)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR buffer_whole$[rsp], rax

; 164  : 
; 165  : 	cmd_list->cfl = sizeof(FIS_REG_H2D)/sizeof(uint32_t);

	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rax]
	and	al, 224					; 000000e0H
	or	al, 5
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rcx], al

; 166  : 	cmd_list->w = 1;

	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rax]
	or	al, 64					; 00000040H
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rcx], al

; 167  : 	cmd_list->prdtl = (uint16_t)((count-1)>>4)+1;

	mov	eax, DWORD PTR count$[rsp]
	dec	eax
	shr	eax, 4
	movzx	eax, ax
	inc	eax
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	WORD PTR [rcx+2], ax

; 168  : 	
; 169  : 	uint32_t command_slot = ahci_disk_find_slot(port);

	mov	rcx, QWORD PTR port$[rsp]
	call	?ahci_disk_find_slot@@YAIPEAU_hba_port_@@@Z ; ahci_disk_find_slot
	mov	DWORD PTR command_slot$[rsp], eax

; 170  : 
; 171  : 	HBA_CMD_TABLE *tbl = (HBA_CMD_TABLE*)cmd_list[command_slot].ctba;

	mov	eax, DWORD PTR command_slot$[rsp]
	imul	rax, 32					; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rsp]
	mov	eax, DWORD PTR [rcx+rax+8]
	mov	QWORD PTR tbl$[rsp], rax

; 172  : 	int i=0;

	mov	DWORD PTR i$[rsp], 0

; 173  : 	for (i = 0; i < cmd_list->prdtl; i++){

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN9@ahci_disk_
$LN8@ahci_disk_:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN9@ahci_disk_:
	mov	rax, QWORD PTR cmd_list$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN7@ahci_disk_

; 174  : 		tbl->prdt[i].data_base_address = buffer_whole & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_whole$[rsp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 175  : 		tbl->prdt[i].dbau = buffer_whole >> 32;

	mov	rax, QWORD PTR buffer_whole$[rsp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 176  : 		tbl->prdt[i].data_byte_count = (512 * count) - 1;

	mov	eax, DWORD PTR count$[rsp]
	imul	eax, 512				; 00000200H
	dec	eax
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 177  : 		tbl->prdt[i].i = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 16
	mov	rcx, QWORD PTR tbl$[rsp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 178  : 		buffer += 512*count;

	mov	eax, DWORD PTR count$[rsp]
	imul	eax, 512				; 00000200H
	mov	eax, eax
	mov	rcx, QWORD PTR buffer$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR buffer$[rsp], rax

; 179  : 		buffer_whole = (uint32_t)buffer;

	mov	eax, DWORD PTR buffer$[rsp]
	mov	QWORD PTR buffer_whole$[rsp], rax

; 180  : 	}

	jmp	$LN8@ahci_disk_
$LN7@ahci_disk_:

; 181  : 	tbl->prdt[i].data_base_address = buffer_whole & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR buffer_whole$[rsp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+128], eax

; 182  : 	tbl->prdt[i].dbau = buffer_whole >> 32;

	mov	rax, QWORD PTR buffer_whole$[rsp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+132], eax

; 183  : 	tbl->prdt[i].data_byte_count = (512 * count) - 1;

	mov	eax, DWORD PTR count$[rsp]
	imul	eax, 512				; 00000200H
	dec	eax
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	and	eax, 4194303				; 003fffffH
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+140]
	and	ecx, -4194304				; ffc00000H
	or	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 184  : 	tbl->prdt[i].i = 1;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 16
	mov	rcx, QWORD PTR tbl$[rsp]
	mov	eax, DWORD PTR [rcx+rax+140]
	bts	eax, 31
	movsxd	rcx, DWORD PTR i$[rsp]
	imul	rcx, 16
	mov	rdx, QWORD PTR tbl$[rsp]
	mov	DWORD PTR [rdx+rcx+140], eax

; 185  : 
; 186  : 	FIS_REG_H2D *fis = (FIS_REG_H2D*)tbl->cmd_fis;

	mov	rax, QWORD PTR tbl$[rsp]
	mov	QWORD PTR fis$[rsp], rax

; 187  : 	fis->fis_type = FIS_TYPE_REG_H2D;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax], 39			; 00000027H

; 188  : 	fis->c = 1;

	mov	rax, QWORD PTR fis$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	or	al, 128					; 00000080H
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+1], al

; 189  : 	fis->command = ATA_CMD_WRITE_DMA_EXT;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax+2], 53			; 00000035H

; 190  : 	fis->lba0 = lba & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+4], al

; 191  : 	fis->lba1 = (lba>>8) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 8
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+5], al

; 192  : 	fis->lba2 = (lba>>16) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 16
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+6], al

; 193  : 	fis->device = 1<<6;

	mov	rax, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rax+7], 64			; 00000040H

; 194  : 	fis->lba3 = (lba>>24) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 24
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+8], al

; 195  : 	fis->lba4 = (lba>>32) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 32					; 00000020H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+9], al

; 196  : 	fis->lba5 = (lba>>40) & 0xff;

	mov	rax, QWORD PTR lba$[rsp]
	shr	rax, 40					; 00000028H
	and	rax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+10], al

; 197  : 	fis->countl = count & 0xff;

	mov	eax, DWORD PTR count$[rsp]
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+12], al

; 198  : 	fis->counth = (count >> 8) & 0xff;

	mov	eax, DWORD PTR count$[rsp]
	shr	eax, 8
	and	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR fis$[rsp]
	mov	BYTE PTR [rcx+13], al
$LN6@ahci_disk_:

; 199  : 
; 200  : 	while((port->tfd & (ATA_SR_BSY  | ATA_SR_DRQ)) && spin < 1000000) {

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+32]
	and	eax, 136				; 00000088H
	test	eax, eax
	je	SHORT $LN5@ahci_disk_
	cmp	DWORD PTR spin$[rsp], 1000000		; 000f4240H
	jge	SHORT $LN5@ahci_disk_

; 201  : 		spin++;

	mov	eax, DWORD PTR spin$[rsp]
	inc	eax
	mov	DWORD PTR spin$[rsp], eax

; 202  : 	}

	jmp	SHORT $LN6@ahci_disk_
$LN5@ahci_disk_:

; 203  : 	if (spin==1000000)

	cmp	DWORD PTR spin$[rsp], 1000000		; 000f4240H
	jne	SHORT $LN4@ahci_disk_

; 204  : 		printf ("[AHCI]:Port Hung\n");

	lea	rcx, OFFSET FLAT:$SG4013
	call	?printf@@YAXPEBDZZ			; printf
$LN4@ahci_disk_:

; 205  : 
; 206  : 	port->ci = 1<<0;

	mov	rax, QWORD PTR port$[rsp]
	mov	DWORD PTR [rax+56], 1
$LN3@ahci_disk_:

; 207  : 	while(1) {

	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN2@ahci_disk_

; 208  : 		if ((port->ci & (1<<0)) == 0) 

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+56]
	and	eax, 1
	test	eax, eax
	jne	SHORT $LN1@ahci_disk_

; 209  : 			break;

	jmp	SHORT $LN2@ahci_disk_
$LN1@ahci_disk_:

; 210  : 		/*if (port->is & (1<<30)) 
; 211  : 			break;*/
; 212  : 	}

	jmp	SHORT $LN3@ahci_disk_
$LN2@ahci_disk_:

; 213  : }

	add	rsp, 88					; 00000058H
	ret	0
?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z ENDP	; ahci_disk_write
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\ahci_disk.cpp
_TEXT	SEGMENT
cold_presence$ = 32
i$1 = 36
i$2 = 40
phys$ = 48
current_slot$ = 56
cmd_list$ = 64
addr$ = 72
ide_buf$ = 80
fis_dev$ = 88
ata_device_name$ = 96
port$ = 160
?ahci_disk_initialize@@YAXPEAU_hba_port_@@@Z PROC	; ahci_disk_initialize

; 282  : void ahci_disk_initialize (HBA_PORT *port) {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 283  : 
; 284  : 	/* stop the DMA engine */
; 285  : 	ahci_disk_stop_cmd(port);

	mov	rcx, QWORD PTR port$[rsp]
	call	?ahci_disk_stop_cmd@@YAXPEAU_hba_port_@@@Z ; ahci_disk_stop_cmd

; 286  : 
; 287  : 	sata_drive_port = port;

	mov	rax, QWORD PTR port$[rsp]
	mov	QWORD PTR ?sata_drive_port@@3PEAU_hba_port_@@EA, rax ; sata_drive_port

; 288  : 
; 289  : 
; 290  : 
; 291  : 	uint64_t phys;
; 292  : 
; 293  : 	/* Allocate command list */
; 294  : 	phys = (uint64_t)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR phys$[rsp], rax

; 295  : 	port->clb = phys & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR phys$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx], eax

; 296  : 	port->clbu = phys >> 32;

	mov	rax, QWORD PTR phys$[rsp]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+4], eax

; 297  : 
; 298  : 	HBA_CMD_HEADER *cmd_list = (HBA_CMD_HEADER*)phys;

	mov	rax, QWORD PTR phys$[rsp]
	mov	QWORD PTR cmd_list$[rsp], rax

; 299  : 	memset((void*)phys, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR phys$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 300  : 
; 301  : 	/* Allocate FIS */
; 302  : 	phys = (uint64_t)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR phys$[rsp], rax

; 303  : 	port->fb = phys & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR phys$[rsp]
	and	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 304  : 	port->fbu = (phys >> 32);

	mov	rax, QWORD PTR phys$[rsp]
	shr	rax, 32					; 00000020H
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 305  : 
; 306  : 	HBA_FIS *fis_dev = (HBA_FIS*)phys;

	mov	rax, QWORD PTR phys$[rsp]
	mov	QWORD PTR fis_dev$[rsp], rax

; 307  : 	memset((void*)phys, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR phys$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 308  : 
; 309  : 	uint8_t cold_presence = port->cmd & (1<<20);

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 1048576				; 00100000H
	mov	BYTE PTR cold_presence$[rsp], al

; 310  : 	if (cold_presence) {

	movzx	eax, BYTE PTR cold_presence$[rsp]
	test	eax, eax
	je	SHORT $LN7@ahci_disk_

; 311  : 		printf ("[AHCI]: Port Supports cold presence %d\n",cold_presence);

	movzx	eax, BYTE PTR cold_presence$[rsp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG4065
	call	?printf@@YAXPEBDZZ			; printf
$LN7@ahci_disk_:

; 312  : 	}
; 313  : 
; 314  : 	for (int i = 0; i < 31; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@ahci_disk_
$LN5@ahci_disk_:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@ahci_disk_:
	cmp	DWORD PTR i$1[rsp], 31
	jge	$LN4@ahci_disk_

; 315  : 		cmd_list[i].prdtl = 1;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, 32					; 00000020H
	mov	ecx, 1
	mov	rdx, QWORD PTR cmd_list$[rsp]
	mov	WORD PTR [rdx+rax+2], cx

; 316  : 		phys = (uint64_t)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR phys$[rsp], rax

; 317  : 		cmd_list[i].ctba = phys & 0xffffffff;

	mov	eax, -1					; ffffffffH
	mov	rcx, QWORD PTR phys$[rsp]
	and	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i$1[rsp]
	imul	rcx, 32					; 00000020H
	mov	rdx, QWORD PTR cmd_list$[rsp]
	mov	DWORD PTR [rdx+rcx+8], eax

; 318  : 		cmd_list[i].ctbau = phys >> 32;

	mov	rax, QWORD PTR phys$[rsp]
	shr	rax, 32					; 00000020H
	movsxd	rcx, DWORD PTR i$1[rsp]
	imul	rcx, 32					; 00000020H
	mov	rdx, QWORD PTR cmd_list$[rsp]
	mov	DWORD PTR [rdx+rcx+12], eax

; 319  : 		cmd_list[i].p = 1;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, 32					; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	or	al, 128					; 00000080H
	movsxd	rcx, DWORD PTR i$1[rsp]
	imul	rcx, 32					; 00000020H
	mov	rdx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 320  : 		cmd_list[i].cfl = 0x10;

	movsxd	rax, DWORD PTR i$1[rsp]
	imul	rax, 32					; 00000020H
	mov	rcx, QWORD PTR cmd_list$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	and	al, 224					; 000000e0H
	or	al, 16
	movsxd	rcx, DWORD PTR i$1[rsp]
	imul	rcx, 32					; 00000020H
	mov	rdx, QWORD PTR cmd_list$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 321  : 		memset((void*)phys, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR phys$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 322  : 	}

	jmp	$LN5@ahci_disk_
$LN4@ahci_disk_:

; 323  : 
; 324  : 	port->serr = 0xffffffff;

	mov	rax, QWORD PTR port$[rsp]
	mov	DWORD PTR [rax+48], -1			; ffffffffH

; 325  : 
; 326  : 	port->cmd &= ~HBA_PX_CMD_ICC;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 268435455				; 0fffffffH
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 327  : 	port->cmd |= PX_CMD_POD | PX_CMD_SUD | HBA_PX_CMD_ICC_ACTIVE;

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	or	eax, 268435462				; 10000006H
	mov	rcx, QWORD PTR port$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 328  : 
; 329  : 
; 330  : 	port->ie = (1<<0) | (1<<1) | (1<<2) | (1<<3) | (1<<4) | (1<<5) | (1<<6) |
; 331  : 		(1<<7) | (1<<22) | (1<<23) | (1<<24) | (1<<26) | (1<<27) | (1<<28) | 
; 332  : 		(1<<29) | (1<<30) | (1<<31);

	mov	rax, QWORD PTR port$[rsp]
	mov	DWORD PTR [rax+20], -37748481		; fdc000ffH

; 333  : 
; 334  : 	/* start the command DMA engine */
; 335  : 	ahci_disk_start_cmd(port);

	mov	rcx, QWORD PTR port$[rsp]
	call	?ahci_disk_start_cmd@@YAXPEAU_hba_port_@@@Z ; ahci_disk_start_cmd

; 336  : 
; 337  : 	uint8_t current_slot = port->cmd & (1<<8);

	mov	rax, QWORD PTR port$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, 256				; 00000100H
	mov	BYTE PTR current_slot$[rsp], al

; 338  : 
; 339  : 	uint64_t *addr = (uint64_t*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR addr$[rsp], rax

; 340  : 	memset(addr,0,4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR addr$[rsp]
	call	?memset@@YAXPEAXEI@Z			; memset

; 341  : 	ahci_disk_identify(port,0,1,addr);

	mov	r9, QWORD PTR addr$[rsp]
	mov	r8d, 1
	xor	edx, edx
	mov	rcx, QWORD PTR port$[rsp]
	call	?ahci_disk_identify@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_identify

; 342  : 	char ata_device_name[40];
; 343  : 	uint8_t *ide_buf = (uint8_t*)addr;

	mov	rax, QWORD PTR addr$[rsp]
	mov	QWORD PTR ide_buf$[rsp], rax

; 344  : 	for (int i= 0; i < 40; i += 2)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@ahci_disk_
$LN2@ahci_disk_:
	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 2
	mov	DWORD PTR i$2[rsp], eax
$LN3@ahci_disk_:
	cmp	DWORD PTR i$2[rsp], 40			; 00000028H
	jge	SHORT $LN1@ahci_disk_

; 345  : 	{
; 346  : 		ata_device_name[i] = ide_buf[54 + i + 1];

	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 55					; 00000037H
	cdqe
	movsxd	rcx, DWORD PTR i$2[rsp]
	mov	rdx, QWORD PTR ide_buf$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR ata_device_name$[rsp+rcx], al

; 347  : 		ata_device_name[i + 1] = ide_buf[54 + i];

	mov	eax, DWORD PTR i$2[rsp]
	add	eax, 54					; 00000036H
	cdqe
	mov	ecx, DWORD PTR i$2[rsp]
	inc	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR ide_buf$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR ata_device_name$[rsp+rcx], al

; 348  : 	}

	jmp	SHORT $LN2@ahci_disk_
$LN1@ahci_disk_:

; 349  : 	printf ("[AHCI]: Model -> %s\n", ata_device_name);

	lea	rdx, QWORD PTR ata_device_name$[rsp]
	lea	rcx, OFFSET FLAT:$SG4082
	call	?printf@@YAXPEBDZZ			; printf

; 350  : }

	add	rsp, 152				; 00000098H
	ret	0
?ahci_disk_initialize@@YAXPEAU_hba_port_@@@Z ENDP	; ahci_disk_initialize
_TEXT	ENDS
END
