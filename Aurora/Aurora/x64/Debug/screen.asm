; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?display@@3PEAU__display__@@EA			; display
_BSS	SEGMENT
?display@@3PEAU__display__@@EA DQ 01H DUP (?)		; display
_BSS	ENDS
CONST	SEGMENT
$SG3924	DB	'fb', 00H
	ORG $+5
$SG3925	DB	'/dev/fb', 00H
CONST	ENDS
PUBLIC	?AuInitializeScreen@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ; AuInitializeScreen
PUBLIC	?AuScreenMap@@YAXII@Z				; AuScreenMap
PUBLIC	AuGetScreenWidth
PUBLIC	AuGetScreenHeight
PUBLIC	AuGetFramebuffer
PUBLIC	AuGetScreenBPP
PUBLIC	AuGetScreenScanline
PUBLIC	AuGetFramebufferSize
PUBLIC	AuDrawPixel
PUBLIC	AuGetScreenMngrID
PUBLIC	?screen_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z	; screen_io_query
EXTRN	strcpy:PROC
EXTRN	memset:PROC
EXTRN	vfs_mount:PROC
EXTRN	AuMapPage:PROC
EXTRN	malloc:PROC
EXTRN	get_current_thread:PROC
EXTRN	__ImageBase:BYTE
pdata	SEGMENT
$pdata$?AuInitializeScreen@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD imagerel $LN9
	DD	imagerel $LN9+527
	DD	imagerel $unwind$?AuInitializeScreen@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z
$pdata$?AuScreenMap@@YAXII@Z DD imagerel $LN6
	DD	imagerel $LN6+172
	DD	imagerel $unwind$?AuScreenMap@@YAXII@Z
$pdata$?screen_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z DD imagerel $LN13
	DD	imagerel $LN13+296
	DD	imagerel $unwind$?screen_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuInitializeScreen@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD 010901H
	DD	06209H
$unwind$?AuScreenMap@@YAXII@Z DD 010c01H
	DD	0620cH
$unwind$?screen_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z DD 011201H
	DD	08212H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\screen.cpp
_TEXT	SEGMENT
scanline$1 = 32
ret$ = 36
tv64 = 40
width$2 = 44
height$3 = 48
bpp$4 = 52
thr$5 = 56
node$ = 80
code$ = 88
arg$ = 96
?screen_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z PROC	; screen_io_query

; 160  : int screen_io_query (vfs_node_t* node, int code, void* arg) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 161  : 	int ret = 0;

	mov	DWORD PTR ret$[rsp], 0

; 162  : 	switch (code) {

	mov	eax, DWORD PTR code$[rsp]
	mov	DWORD PTR tv64[rsp], eax
	mov	eax, DWORD PTR tv64[rsp]
	sub	eax, 257				; 00000101H
	mov	DWORD PTR tv64[rsp], eax
	cmp	DWORD PTR tv64[rsp], 8
	ja	$LN8@screen_io_
	movsxd	rax, DWORD PTR tv64[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN12@screen_io_[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN7@screen_io_:

; 163  : 	case SCREEN_GETWIDTH:{
; 164  : 		uint32_t width = display->width;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR width$2[rsp], eax

; 165  : 		ret = width;

	mov	eax, DWORD PTR width$2[rsp]
	mov	DWORD PTR ret$[rsp], eax

; 166  : 		break;

	jmp	$LN8@screen_io_
$LN6@screen_io_:

; 167  : 	}
; 168  : 	case SCREEN_GETHEIGHT:{
; 169  : 		uint32_t height = display->height;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR height$3[rsp], eax

; 170  : 		ret = height;

	mov	eax, DWORD PTR height$3[rsp]
	mov	DWORD PTR ret$[rsp], eax

; 171  : 		break;

	jmp	SHORT $LN8@screen_io_
$LN5@screen_io_:

; 172  : 	}
; 173  : 	case SCREEN_GETBPP:{
; 174  : 		uint32_t bpp = display->bpp;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR bpp$4[rsp], eax

; 175  : 		ret =  bpp;

	mov	eax, DWORD PTR bpp$4[rsp]
	mov	DWORD PTR ret$[rsp], eax

; 176  : 		break;

	jmp	SHORT $LN8@screen_io_
$LN4@screen_io_:

; 177  : 	 }
; 178  : 	case SCREEN_GET_SCANLINE: {
; 179  : 		uint16_t scanline = display->scanline;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	movzx	eax, WORD PTR [rax+20]
	mov	WORD PTR scanline$1[rsp], ax

; 180  : 		ret =  scanline;

	movzx	eax, WORD PTR scanline$1[rsp]
	mov	DWORD PTR ret$[rsp], eax

; 181  : 		break;

	jmp	SHORT $LN8@screen_io_
$LN3@screen_io_:

; 182  : 	}
; 183  : 	case SCREEN_GET_PITCH:
; 184  : 		ret = display->pitch;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR ret$[rsp], eax

; 185  : 		break;

	jmp	SHORT $LN8@screen_io_
$LN2@screen_io_:

; 186  : 
; 187  : 	case SCREEN_REGISTER_MNGR: {
; 188  : 		if (display->screen_mngr_pid == -1) {

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	movsx	eax, WORD PTR [rax+32]
	cmp	eax, -1
	jne	SHORT $LN1@screen_io_

; 189  : 			thread_t* thr = get_current_thread();

	call	get_current_thread
	mov	QWORD PTR thr$5[rsp], rax

; 190  : 			display->screen_mngr_pid = thr->id;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	rcx, QWORD PTR thr$5[rsp]
	movzx	ecx, WORD PTR [rcx+238]
	mov	WORD PTR [rax+32], cx
$LN1@screen_io_:
$LN8@screen_io_:

; 191  : 		}
; 192  : 		break;
; 193  :     }
; 194  : 	}
; 195  : 	return ret;

	mov	eax, DWORD PTR ret$[rsp]

; 196  : }

	add	rsp, 72					; 00000048H
	ret	0
	npad	3
$LN12@screen_io_:
	DD	$LN7@screen_io_
	DD	$LN6@screen_io_
	DD	$LN5@screen_io_
	DD	$LN8@screen_io_
	DD	$LN8@screen_io_
	DD	$LN8@screen_io_
	DD	$LN4@screen_io_
	DD	$LN3@screen_io_
	DD	$LN2@screen_io_
?screen_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z ENDP	; screen_io_query
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\screen.cpp
_TEXT	SEGMENT
AuGetScreenMngrID PROC

; 203  : 	return display->screen_mngr_pid;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	movzx	eax, WORD PTR [rax+32]

; 204  : }

	ret	0
AuGetScreenMngrID ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\screen.cpp
_TEXT	SEGMENT
x$ = 8
y$ = 16
color$ = 24
AuDrawPixel PROC

; 149  : void AuDrawPixel (unsigned x, unsigned y, uint32_t color ) {

	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx

; 150  : 	display->buffer[x + y * display->width] = color;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	ecx, DWORD PTR y$[rsp]
	imul	ecx, DWORD PTR [rax]
	mov	eax, ecx
	mov	ecx, DWORD PTR x$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	rcx, QWORD PTR [rcx+8]
	mov	edx, DWORD PTR color$[rsp]
	mov	DWORD PTR [rcx+rax*4], edx

; 151  : }

	ret	0
AuDrawPixel ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\screen.cpp
_TEXT	SEGMENT
AuGetFramebufferSize PROC

; 140  : 	return display->size;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	eax, DWORD PTR [rax+24]

; 141  : }

	ret	0
AuGetFramebufferSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\screen.cpp
_TEXT	SEGMENT
AuGetScreenScanline PROC

; 132  : 	return display->scanline;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	movzx	eax, WORD PTR [rax+20]

; 133  : }

	ret	0
AuGetScreenScanline ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\screen.cpp
_TEXT	SEGMENT
AuGetScreenBPP PROC

; 124  : 	return display->bpp;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	eax, DWORD PTR [rax+16]

; 125  : }

	ret	0
AuGetScreenBPP ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\screen.cpp
_TEXT	SEGMENT
AuGetFramebuffer PROC

; 116  : 	return display->buffer;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	rax, QWORD PTR [rax+8]

; 117  : }

	ret	0
AuGetFramebuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\screen.cpp
_TEXT	SEGMENT
AuGetScreenHeight PROC

; 107  : 	return display->height;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	eax, DWORD PTR [rax+4]

; 108  : }

	ret	0
AuGetScreenHeight ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\screen.cpp
_TEXT	SEGMENT
AuGetScreenWidth PROC

; 99   : 	return display->width;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	eax, DWORD PTR [rax]

; 100  : }

	ret	0
AuGetScreenWidth ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\screen.cpp
_TEXT	SEGMENT
i$1 = 32
width$ = 64
height$ = 72
?AuScreenMap@@YAXII@Z PROC				; AuScreenMap

; 84   : void AuScreenMap (uint32_t width, uint32_t height) {

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 85   : 	display->width = width;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	ecx, DWORD PTR width$[rsp]
	mov	DWORD PTR [rax], ecx

; 86   : 	display->height = height;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	ecx, DWORD PTR height$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 87   : 	//! Map a shared region for other processes to output
; 88   : 	for (int i = 0; i < display->size / 4096; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@AuScreenMa
$LN2@AuScreenMa:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@AuScreenMa:
	xor	edx, edx
	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	eax, DWORD PTR [rax+24]
	mov	ecx, 4096				; 00001000H
	div	ecx
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN1@AuScreenMa

; 89   : 		AuMapPage((uint64_t)display->buffer + i * 4096, 0xFFFFD00000200000 + i * 4096, PAGING_USER);

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, 52776556036096			; 00002fffffe00000H
	sub	rax, rcx
	mov	ecx, DWORD PTR i$1[rsp]
	imul	ecx, 4096				; 00001000H
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	add	rcx, QWORD PTR [rdx+8]
	mov	r8b, 4
	mov	rdx, rax
	call	AuMapPage
	jmp	SHORT $LN2@AuScreenMa
$LN1@AuScreenMa:

; 90   : 
; 91   : 	display->buffer = (uint32_t*)0xFFFFD00000200000;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	rcx, -52776556036096			; ffffd00000200000H
	mov	QWORD PTR [rax+8], rcx

; 92   : }

	add	rsp, 56					; 00000038H
	ret	0
?AuScreenMap@@YAXII@Z ENDP				; AuScreenMap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\screen.cpp
_TEXT	SEGMENT
h$1 = 32
w$2 = 36
svga$ = 40
info$ = 64
?AuInitializeScreen@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z PROC	; AuInitializeScreen

; 37   : void AuInitializeScreen (KERNEL_BOOT_INFO *info){

$LN9:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 38   : 	display = (display_t*)malloc(sizeof(display_t));

	mov	ecx, 40					; 00000028H
	call	malloc
	mov	QWORD PTR ?display@@3PEAU__display__@@EA, rax ; display

; 39   : 	memset(display, 0, sizeof(display_t));

	mov	r8d, 40					; 00000028H
	xor	edx, edx
	mov	rcx, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	call	memset

; 40   : 	display->buffer = info->graphics_framebuffer;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+44]
	mov	QWORD PTR [rax+8], rcx

; 41   : 	display->width = info->X_Resolution;

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+60]
	mov	rcx, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	DWORD PTR [rcx], eax

; 42   : 	display->height = info->Y_Resolution;

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+62]
	mov	rcx, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	DWORD PTR [rcx+4], eax

; 43   : 	display->bpp = 32;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	DWORD PTR [rax+16], 32			; 00000020H

; 44   : 	display->scanline = info->pixels_per_line;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	rcx, QWORD PTR info$[rsp]
	movzx	ecx, WORD PTR [rcx+64]
	mov	WORD PTR [rax+20], cx

; 45   : 	display->pitch = 4*info->pixels_per_line;

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+64]
	shl	eax, 2
	mov	rcx, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	DWORD PTR [rcx+28], eax

; 46   : 	display->size = info->fb_size;

	mov	rax, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	rcx, QWORD PTR info$[rsp]
	mov	ecx, DWORD PTR [rcx+52]
	mov	DWORD PTR [rax+24], ecx

; 47   : 	display->screen_mngr_pid = -1;

	mov	eax, -1
	mov	rcx, QWORD PTR ?display@@3PEAU__display__@@EA ; display
	mov	WORD PTR [rcx+32], ax

; 48   : 
; 49   : 	/**
; 50   : 	 * register the device node for screen interface
; 51   : 	 */
; 52   : 	vfs_node_t * svga = (vfs_node_t*)malloc(sizeof(vfs_node_t)); //AuPmmngrAlloc(); 

	mov	ecx, 112				; 00000070H
	call	malloc
	mov	QWORD PTR svga$[rsp], rax

; 53   : 	strcpy (svga->filename, "fb");

	mov	rax, QWORD PTR svga$[rsp]
	lea	rdx, OFFSET FLAT:$SG3924
	mov	rcx, rax
	call	strcpy

; 54   : 	svga->size = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	DWORD PTR [rax+32], 0

; 55   : 	svga->eof = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	BYTE PTR [rax+36], 0

; 56   : 	svga->pos = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	DWORD PTR [rax+40], 0

; 57   : 	svga->current = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	DWORD PTR [rax+44], 0

; 58   : 	svga->flags = FS_FLAG_GENERAL | FS_FLAG_DEVICE;

	mov	rax, QWORD PTR svga$[rsp]
	mov	BYTE PTR [rax+48], 12

; 59   : 	svga->status = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	BYTE PTR [rax+49], 0

; 60   : 	svga->open = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	QWORD PTR [rax+64], 0

; 61   : 	svga->read = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	QWORD PTR [rax+72], 0

; 62   : 	svga->write = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	QWORD PTR [rax+80], 0

; 63   : 	svga->read_blk = 0;

	mov	rax, QWORD PTR svga$[rsp]
	mov	QWORD PTR [rax+96], 0

; 64   : 	svga->ioquery = screen_io_query;

	mov	rax, QWORD PTR svga$[rsp]
	lea	rcx, OFFSET FLAT:?screen_io_query@@YAHPEAU_vfs_node_@@HPEAX@Z ; screen_io_query
	mov	QWORD PTR [rax+104], rcx

; 65   : 	vfs_mount ("/dev/fb", svga, 0);

	xor	r8d, r8d
	mov	rdx, QWORD PTR svga$[rsp]
	lea	rcx, OFFSET FLAT:$SG3925
	call	vfs_mount

; 66   : 
; 67   : 	/* clear the screen */
; 68   : 	for (int w = 0; w < info->X_Resolution; w++) {

	mov	DWORD PTR w$2[rsp], 0
	jmp	SHORT $LN6@AuInitiali
$LN5@AuInitiali:
	mov	eax, DWORD PTR w$2[rsp]
	inc	eax
	mov	DWORD PTR w$2[rsp], eax
$LN6@AuInitiali:
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+60]
	cmp	DWORD PTR w$2[rsp], eax
	jge	SHORT $LN4@AuInitiali

; 69   : 		for (int h = 0; h < info->Y_Resolution; h++) {

	mov	DWORD PTR h$1[rsp], 0
	jmp	SHORT $LN3@AuInitiali
$LN2@AuInitiali:
	mov	eax, DWORD PTR h$1[rsp]
	inc	eax
	mov	DWORD PTR h$1[rsp], eax
$LN3@AuInitiali:
	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+62]
	cmp	DWORD PTR h$1[rsp], eax
	jge	SHORT $LN1@AuInitiali

; 70   : 			info->graphics_framebuffer[w + h * info->X_Resolution] = 0x00000000;

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+60]
	mov	ecx, DWORD PTR h$1[rsp]
	imul	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR w$2[rsp]
	add	ecx, eax
	mov	eax, ecx
	cdqe
	mov	rcx, QWORD PTR info$[rsp]
	mov	rcx, QWORD PTR [rcx+44]
	mov	DWORD PTR [rcx+rax*4], 0

; 71   : 		}

	jmp	SHORT $LN2@AuInitiali
$LN1@AuInitiali:

; 72   : 	}

	jmp	SHORT $LN5@AuInitiali
$LN4@AuInitiali:

; 73   : 
; 74   : 	AuScreenMap(info->X_Resolution, info->Y_Resolution);

	mov	rax, QWORD PTR info$[rsp]
	movzx	eax, WORD PTR [rax+62]
	mov	rcx, QWORD PTR info$[rsp]
	movzx	ecx, WORD PTR [rcx+60]
	mov	edx, eax
	call	?AuScreenMap@@YAXII@Z			; AuScreenMap

; 75   : }

	add	rsp, 56					; 00000038H
	ret	0
?AuInitializeScreen@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ENDP	; AuInitializeScreen
_TEXT	ENDS
END
