; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?xusb_dev@@3PEAU_xhci_@@EA			; xusb_dev
_BSS	SEGMENT
?xusb_dev@@3PEAU_xhci_@@EA DQ 01H DUP (?)		; xusb_dev
_BSS	ENDS
CONST	SEGMENT
$SG3324	DB	'[XHCI USB]: Interrupt fired', 0aH, 00H
	ORG $+3
$SG3334	DB	'USB xHCI: not found', 0aH, 00H
	ORG $+3
$SG3338	DB	'USB: xHCI version - (%d.%d%d)', 0aH, 00H
CONST	ENDS
PUBLIC	?xhci_initialize@@YAXXZ				; xhci_initialize
PUBLIC	?xhci_handler@@YAX_KPEAX@Z			; xhci_handler
EXTRN	x64_cli:PROC
EXTRN	x64_sti:PROC
EXTRN	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z:PROC	; interrupt_set
EXTRN	?pci_find_device_class@@YA_NEEPEATpci_device_info@@PEAH11@Z:PROC ; pci_find_device_class
EXTRN	?pmmngr_alloc@@YAPEAXXZ:PROC			; pmmngr_alloc
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
pdata	SEGMENT
$pdata$?xhci_initialize@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+400
	DD	imagerel $unwind$?xhci_initialize@@YAXXZ
$pdata$?xhci_handler@@YAX_KPEAX@Z DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$?xhci_handler@@YAX_KPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?xhci_initialize@@YAXXZ DD 010401H
	DD	0a204H
$unwind$?xhci_handler@@YAX_KPEAX@Z DD 010e01H
	DD	0420eH
xdata	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\usb\xhci.cpp
_TEXT	SEGMENT
v$ = 48
p$ = 56
?xhci_handler@@YAX_KPEAX@Z PROC				; xhci_handler

; 20   : void xhci_handler (size_t v, void* p) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 21   : 	printf ("[XHCI USB]: Interrupt fired\n");

	lea	rcx, OFFSET FLAT:$SG3324
	call	?printf@@YAXPEBDZZ			; printf

; 22   : }

	add	rsp, 40					; 00000028H
	ret	0
?xhci_handler@@YAX_KPEAX@Z ENDP				; xhci_handler
_TEXT	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\usb\xhci.cpp
_TEXT	SEGMENT
version$ = 48
func_$ = 52
dev_$ = 56
bus$ = 60
cap$ = 64
dev$ = 72
?xhci_initialize@@YAXXZ PROC				; xhci_initialize

; 25   : void xhci_initialize () {

$LN5:
	sub	rsp, 88					; 00000058H

; 26   : 	pci_device_info *dev = (pci_device_info*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR dev$[rsp], rax

; 27   : 	xusb_dev = (xhci*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR ?xusb_dev@@3PEAU_xhci_@@EA, rax ; xusb_dev

; 28   : 
; 29   : 	int bus, dev_, func_ = 0;

	mov	DWORD PTR func_$[rsp], 0

; 30   : 	if (!pci_find_device_class(0x0C, 0x03, dev, &bus, &dev_, &func_)) {

	lea	rax, QWORD PTR func_$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR dev_$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR bus$[rsp]
	mov	r8, QWORD PTR dev$[rsp]
	mov	dl, 3
	mov	cl, 12
	call	?pci_find_device_class@@YA_NEEPEATpci_device_info@@PEAH11@Z ; pci_find_device_class
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@xhci_initi

; 31   : 		printf ("USB xHCI: not found\n");

	lea	rcx, OFFSET FLAT:$SG3334
	call	?printf@@YAXPEBDZZ			; printf

; 32   : 		return;

	jmp	$LN3@xhci_initi
$LN2@xhci_initi:

; 33   : 	}
; 34   : 	x64_cli ();

	call	x64_cli

; 35   : 	xusb_dev->xhci_base_address = (dev->device.nonBridge.baseAddress[0] & 0xFFFFFFF0) +((dev->device.nonBridge.baseAddress[1] & 0xFFFFFFFF) << 32);

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR dev$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	and	eax, -16				; fffffff0H
	mov	ecx, 4
	imul	rcx, 1
	mov	rdx, QWORD PTR dev$[rsp]
	mov	ecx, DWORD PTR [rdx+rcx+16]
	shl	ecx, 32					; 00000020H
	add	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR ?xusb_dev@@3PEAU_xhci_@@EA ; xusb_dev
	mov	QWORD PTR [rcx], rax

; 36   : 
; 37   : 	xhci_cap_reg *cap = (xhci_cap_reg*)xusb_dev->xhci_base_address;

	mov	rax, QWORD PTR ?xusb_dev@@3PEAU_xhci_@@EA ; xusb_dev
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR cap$[rsp], rax

; 38   :     uint32_t version = cap->caps_len_hciver >> 16;

	mov	rax, QWORD PTR cap$[rsp]
	mov	eax, DWORD PTR [rax]
	shr	eax, 16
	mov	DWORD PTR version$[rsp], eax

; 39   : 	printf ("USB: xHCI version - (%d.%d%d)\n",((version >> 8) & 0xFF), ((version>>4) & 0xF), (version & 0xF));

	mov	eax, DWORD PTR version$[rsp]
	and	eax, 15
	mov	ecx, DWORD PTR version$[rsp]
	shr	ecx, 4
	and	ecx, 15
	mov	edx, DWORD PTR version$[rsp]
	shr	edx, 8
	and	edx, 255				; 000000ffH
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:$SG3338
	call	?printf@@YAXPEBDZZ			; printf

; 40   : 
; 41   : 	xusb_dev->xhci_op_address = ((size_t)cap + (cap->caps_len_hciver & 0xFF));

	mov	rax, QWORD PTR cap$[rsp]
	mov	eax, DWORD PTR [rax]
	and	eax, 255				; 000000ffH
	mov	eax, eax
	mov	rcx, QWORD PTR cap$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR ?xusb_dev@@3PEAU_xhci_@@EA ; xusb_dev
	mov	QWORD PTR [rcx+8], rax

; 42   : 	xusb_dev->doorbell_address = ((size_t)cap + (cap->dboffset & ~0x3UL));

	mov	rax, QWORD PTR cap$[rsp]
	mov	eax, DWORD PTR [rax+20]
	and	eax, -4					; fffffffcH
	mov	eax, eax
	mov	rcx, QWORD PTR cap$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR ?xusb_dev@@3PEAU_xhci_@@EA ; xusb_dev
	mov	QWORD PTR [rcx+16], rax

; 43   : 	xusb_dev->runtime_address = ((size_t)cap + (cap->runtime_offset & ~0x1FUL));

	mov	rax, QWORD PTR cap$[rsp]
	mov	eax, DWORD PTR [rax+24]
	and	eax, -32				; ffffffe0H
	mov	eax, eax
	mov	rcx, QWORD PTR cap$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR ?xusb_dev@@3PEAU_xhci_@@EA ; xusb_dev
	mov	QWORD PTR [rcx+24], rax

; 44   : 
; 45   : 	if (dev->device.nonBridge.interruptLine != 255)

	mov	rax, QWORD PTR dev$[rsp]
	movzx	eax, BYTE PTR [rax+60]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN1@xhci_initi

; 46   : 		interrupt_set (dev->device.nonBridge.interruptLine, xhci_handler, dev->device.nonBridge.interruptLine);

	mov	rax, QWORD PTR dev$[rsp]
	movzx	eax, BYTE PTR [rax+60]
	mov	rcx, QWORD PTR dev$[rsp]
	movzx	r8d, BYTE PTR [rcx+60]
	lea	rdx, OFFSET FLAT:?xhci_handler@@YAX_KPEAX@Z ; xhci_handler
	mov	ecx, eax
	call	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z	; interrupt_set
$LN1@xhci_initi:

; 47   : 
; 48   : 
; 49   : 	x64_sti();

	call	x64_sti
$LN3@xhci_initi:

; 50   : 	//for(;;);
; 51   : }

	add	rsp, 88					; 00000058H
	ret	0
?xhci_initialize@@YAXXZ ENDP				; xhci_initialize
_TEXT	ENDS
END
