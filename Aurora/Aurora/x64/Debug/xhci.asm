; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?xhci_base_address@@3_KA			; xhci_base_address
_BSS	SEGMENT
?xhci_base_address@@3_KA DQ 01H DUP (?)			; xhci_base_address
_BSS	ENDS
CONST	SEGMENT
$SG3236	DB	'USB xHCI: not found', 0aH, 00H
	ORG $+3
$SG3237	DB	'USB xHCI: found', 0aH, 00H
	ORG $+7
$SG3238	DB	'XHCI Base Address -> %x', 0aH, 00H
	ORG $+7
$SG3241	DB	'XHCI Version -> %x', 0aH, 00H
	ORG $+4
$SG3246	DB	'[XHCI] has 64-bit addressing capability', 0aH, 00H
	ORG $+7
$SG3247	DB	'PCI Interrupt line -> %d', 0aH, 00H
CONST	ENDS
PUBLIC	?xhci_initialize@@YAXXZ				; xhci_initialize
EXTRN	?pci_find_device_class@@YA_NEEPEATpci_device_info@@@Z:PROC ; pci_find_device_class
EXTRN	?pci_print_capabilities@@YAXPEATpci_device_info@@@Z:PROC ; pci_print_capabilities
EXTRN	?pmmngr_alloc@@YAPEAXXZ:PROC			; pmmngr_alloc
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
pdata	SEGMENT
$pdata$?xhci_initialize@@YAXXZ DD imagerel $LN7
	DD	imagerel $LN7+282
	DD	imagerel $unwind$?xhci_initialize@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?xhci_initialize@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
; Function compile flags: /Odtp
; File e:\xeneva project\xeneva\aurora\aurora\drivers\usb\xhci.cpp
_TEXT	SEGMENT
version_address$ = 32
dev$ = 40
hccparams1adr$ = 48
hccparams1$ = 56
?xhci_initialize@@YAXXZ PROC				; xhci_initialize

; 20   : void xhci_initialize () {

$LN7:
	sub	rsp, 72					; 00000048H

; 21   : 	pci_device_info *dev = (pci_device_info*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR dev$[rsp], rax

; 22   : 	if (!pci_find_device_class(0x0C, 0x03, dev)) {

	mov	r8, QWORD PTR dev$[rsp]
	mov	dl, 3
	mov	cl, 12
	call	?pci_find_device_class@@YA_NEEPEATpci_device_info@@@Z ; pci_find_device_class
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@xhci_initi

; 23   : 		printf ("USB xHCI: not found\n");

	lea	rcx, OFFSET FLAT:$SG3236
	call	?printf@@YAXPEBDZZ			; printf

; 24   : 		return;

	jmp	$LN5@xhci_initi
$LN4@xhci_initi:

; 25   : 	}
; 26   : 
; 27   : 	xhci_base_address = ((dev->device.nonBridge.baseAddress[0] & 0xFFFFFFF0) +( dev->device.nonBridge.baseAddress[1] & 0xFFFFFFFF) << 32);

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR dev$[rsp]
	mov	eax, DWORD PTR [rcx+rax+16]
	and	eax, -16				; fffffff0H
	mov	ecx, 4
	imul	rcx, 1
	mov	rdx, QWORD PTR dev$[rsp]
	add	eax, DWORD PTR [rdx+rcx+16]
	shl	eax, 32					; 00000020H
	mov	eax, eax
	mov	QWORD PTR ?xhci_base_address@@3_KA, rax	; xhci_base_address

; 28   : 	printf ("USB xHCI: found\n");

	lea	rcx, OFFSET FLAT:$SG3237
	call	?printf@@YAXPEBDZZ			; printf

; 29   : 	printf ("XHCI Base Address -> %x\n", xhci_base_address);

	mov	rdx, QWORD PTR ?xhci_base_address@@3_KA	; xhci_base_address
	lea	rcx, OFFSET FLAT:$SG3238
	call	?printf@@YAXPEBDZZ			; printf

; 30   : 
; 31   : 	uint32_t version_address = xhci_base_address + XHCI_CAPREG_HCIVERSION;

	mov	rax, QWORD PTR ?xhci_base_address@@3_KA	; xhci_base_address
	add	rax, 2
	mov	DWORD PTR version_address$[rsp], eax

; 32   : 	printf ("XHCI Version -> %x\n", ((uint64_t*)version_address)[0]);

	mov	eax, DWORD PTR version_address$[rsp]
	mov	ecx, 8
	imul	rcx, 0
	mov	rdx, QWORD PTR [rax+rcx]
	lea	rcx, OFFSET FLAT:$SG3241
	call	?printf@@YAXPEBDZZ			; printf

; 33   : 
; 34   : 	uint64_t hccparams1adr = xhci_base_address + XHCI_CAPREG_HCCPARAMS1;

	mov	rax, QWORD PTR ?xhci_base_address@@3_KA	; xhci_base_address
	add	rax, 16
	mov	QWORD PTR hccparams1adr$[rsp], rax

; 35   : 	uint64_t hccparams1 = ((unsigned long*)hccparams1adr)[0];

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR hccparams1adr$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	QWORD PTR hccparams1$[rsp], rax

; 36   : 	if (hccparams1 & 1) {

	mov	rax, QWORD PTR hccparams1$[rsp]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN3@xhci_initi

; 37   : 		printf ("[XHCI] has 64-bit addressing capability\n");

	lea	rcx, OFFSET FLAT:$SG3246
	call	?printf@@YAXPEBDZZ			; printf
$LN3@xhci_initi:

; 38   : 	}
; 39   : 
; 40   : 	printf ("PCI Interrupt line -> %d\n", dev->device.nonBridge.interruptLine);

	mov	rax, QWORD PTR dev$[rsp]
	movzx	eax, BYTE PTR [rax+60]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3247
	call	?printf@@YAXPEBDZZ			; printf

; 41   : 	pci_print_capabilities(dev);

	mov	rcx, QWORD PTR dev$[rsp]
	call	?pci_print_capabilities@@YAXPEATpci_device_info@@@Z ; pci_print_capabilities
$LN2@xhci_initi:

; 42   : 	for(;;);

	jmp	SHORT $LN2@xhci_initi
$LN5@xhci_initi:

; 43   : }

	add	rsp, 72					; 00000048H
	ret	0
?xhci_initialize@@YAXXZ ENDP				; xhci_initialize
_TEXT	ENDS
END
