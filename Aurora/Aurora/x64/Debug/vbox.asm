; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA	; vbox_mouse
_BSS	SEGMENT
?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA DQ 01H DUP (?) ; vbox_mouse
_BSS	ENDS
CONST	SEGMENT
$SG3291	DB	'Virtual Box Guest Driver not found', 0aH, 00H
	ORG $+4
$SG3292	DB	'Initialize Virtual Box Driver', 0aH, 00H
	ORG $+1
$SG3305	DB	'Virtual Box Driver initialized -> %d', 0aH, 00H
CONST	ENDS
PUBLIC	?initialize_guest_vbox@@YAXXZ			; initialize_guest_vbox
PUBLIC	?vbox_handler@@YAX_KPEAX@Z			; vbox_handler
EXTRN	?outportd@@YAXGI@Z:PROC				; outportd
EXTRN	?interrupt_end@@YAXI@Z:PROC			; interrupt_end
EXTRN	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z:PROC	; interrupt_set
EXTRN	?pci_find_device_id@@YA_NGGPEATpci_device_info@@@Z:PROC ; pci_find_device_id
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
EXTRN	?pmmngr_alloc@@YAPEAXXZ:PROC			; pmmngr_alloc
_BSS	SEGMENT
vbox_port DD	01H DUP (?)
	ALIGN	8

vbox_vmmdev DQ	01H DUP (?)
vbox_mouse_phys DD 01H DUP (?)
vbox_ack_phys DD 01H DUP (?)
ack	DQ	01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$?initialize_guest_vbox@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+610
	DD	imagerel $unwind$?initialize_guest_vbox@@YAXXZ
$pdata$?vbox_handler@@YAX_KPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+178
	DD	imagerel $unwind$?vbox_handler@@YAX_KPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?initialize_guest_vbox@@YAXXZ DD 020701H
	DD	0270107H
$unwind$?vbox_handler@@YAX_KPEAX@Z DD 010e01H
	DD	0620eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\vbox.cpp
_TEXT	SEGMENT
x$ = 32
y$ = 36
v$ = 64
p$ = 72
?vbox_handler@@YAX_KPEAX@Z PROC				; vbox_handler

; 22   : void vbox_handler (size_t v, void* p) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 23   :    if (!vbox_vmmdev[2])goto end;

	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR vbox_vmmdev
	cmp	DWORD PTR [rcx+rax], 0
	jne	SHORT $LN2@vbox_handl
	jmp	SHORT $LN1@vbox_handl
	jmp	SHORT $end$6
$LN2@vbox_handl:

; 24   : 
; 25   : 	//printf ("VBox Interrupt fired\n");
; 26   : 	ack->event = vbox_vmmdev[2];

	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR ack
	mov	rdx, QWORD PTR vbox_vmmdev
	mov	eax, DWORD PTR [rdx+rax]
	mov	DWORD PTR [rcx+24], eax

; 27   : 	outportd (vbox_port, vbox_ack_phys);

	mov	edx, DWORD PTR vbox_ack_phys
	movzx	ecx, WORD PTR vbox_port
	call	?outportd@@YAXGI@Z			; outportd

; 28   : 	outportd (vbox_port, (uint32_t)vbox_mouse_phys);

	mov	edx, DWORD PTR vbox_mouse_phys
	movzx	ecx, WORD PTR vbox_port
	call	?outportd@@YAXGI@Z			; outportd

; 29   : 
; 30   : 	unsigned int x = ((unsigned int)vbox_mouse->x * 1024) / 0xFFFF;

	mov	rax, QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA ; vbox_mouse
	mov	eax, DWORD PTR [rax+28]
	imul	eax, 1024				; 00000400H
	xor	edx, edx
	mov	ecx, 65535				; 0000ffffH
	div	ecx
	mov	DWORD PTR x$[rsp], eax

; 31   : 	unsigned int y = ((unsigned int)vbox_mouse->y * 720) / 0xFFFF;

	mov	rax, QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA ; vbox_mouse
	mov	eax, DWORD PTR [rax+32]
	imul	eax, 720				; 000002d0H
	xor	edx, edx
	mov	ecx, 65535				; 0000ffffH
	div	ecx
	mov	DWORD PTR y$[rsp], eax
$LN1@vbox_handl:
$end$6:

; 32   : 
; 33   : end:
; 34   : 	interrupt_end(11);

	mov	ecx, 11
	call	?interrupt_end@@YAXI@Z			; interrupt_end

; 35   : }

	add	rsp, 56					; 00000038H
	ret	0
?vbox_handler@@YAX_KPEAX@Z ENDP				; vbox_handler
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\vbox.cpp
_TEXT	SEGMENT
guest_info$ = 32
vbox_guest_phys$ = 40
addr$ = 48
?initialize_guest_vbox@@YAXXZ PROC			; initialize_guest_vbox

; 36   : void initialize_guest_vbox () {

$LN4:
	sub	rsp, 312				; 00000138H

; 37   : 	pci_device_info addr;
; 38   : 	if (!pci_find_device_id(0xCAFE, 0x80EE,&addr)) {

	lea	r8, QWORD PTR addr$[rsp]
	mov	dx, 33006				; 000080eeH
	mov	cx, 51966				; 0000cafeH
	call	?pci_find_device_id@@YA_NGGPEATpci_device_info@@@Z ; pci_find_device_id
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@initialize

; 39   : 		printf ("Virtual Box Guest Driver not found\n");

	lea	rcx, OFFSET FLAT:$SG3291
	call	?printf@@YAXPEBDZZ			; printf

; 40   : 		return;

	jmp	$LN2@initialize
$LN1@initialize:

; 41   : 	}
; 42   : 
; 43   : 	interrupt_set (10, vbox_handler, 10);

	mov	r8b, 10
	lea	rdx, OFFSET FLAT:?vbox_handler@@YAX_KPEAX@Z ; vbox_handler
	mov	ecx, 10
	call	?interrupt_set@@YAX_KP6AX0PEAX@ZE@Z	; interrupt_set

; 44   : 	printf ("Initialize Virtual Box Driver\n");

	lea	rcx, OFFSET FLAT:$SG3292
	call	?printf@@YAXPEBDZZ			; printf

; 45   : 	vbox_port = addr.device.nonBridge.baseAddress[0] & 0xFFFFFFFC;

	mov	eax, 4
	imul	rax, 0
	mov	eax, DWORD PTR addr$[rsp+rax+16]
	and	eax, -4					; fffffffcH
	mov	DWORD PTR vbox_port, eax

; 46   : 	
; 47   : 	vbox_vmmdev = (uint32_t*)(addr.device.nonBridge.baseAddress[1] & 0xFFFFFFF0);

	mov	eax, 4
	imul	rax, 1
	mov	eax, DWORD PTR addr$[rsp+rax+16]
	and	eax, -16				; fffffff0H
	mov	eax, eax
	mov	QWORD PTR vbox_vmmdev, rax

; 48   : 	
; 49   : 	uint32_t vbox_guest_phys;
; 50   : 	vbox_guest_info *guest_info = (vbox_guest_info*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR guest_info$[rsp], rax

; 51   : 	guest_info->header.size = sizeof(vbox_guest_info);

	mov	rax, QWORD PTR guest_info$[rsp]
	mov	DWORD PTR [rax], 32			; 00000020H

; 52   : 	guest_info->header.version = VBOX_REQUEST_HEADER_VERSION;

	mov	rax, QWORD PTR guest_info$[rsp]
	mov	DWORD PTR [rax+4], 65537		; 00010001H

; 53   : 	guest_info->header.request_type = VBOX_REQUEST_GUEST_INFO;

	mov	rax, QWORD PTR guest_info$[rsp]
	mov	DWORD PTR [rax+8], 50			; 00000032H

; 54   : 	guest_info->header.rc = 0;

	mov	rax, QWORD PTR guest_info$[rsp]
	mov	DWORD PTR [rax+12], 0

; 55   : 	guest_info->header.reserved1 = 0;

	mov	rax, QWORD PTR guest_info$[rsp]
	mov	DWORD PTR [rax+16], 0

; 56   : 	guest_info->header.reserved2 = 0;

	mov	rax, QWORD PTR guest_info$[rsp]
	mov	DWORD PTR [rax+20], 0

; 57   : 	guest_info->version = VBOX_VMMDEV_VERSION;

	mov	rax, QWORD PTR guest_info$[rsp]
	mov	DWORD PTR [rax+24], 65539		; 00010003H

; 58   : 	guest_info->ostype = 0;

	mov	rax, QWORD PTR guest_info$[rsp]
	mov	DWORD PTR [rax+28], 0

; 59   : 
; 60   : 	vbox_guest_phys = (uint32_t)guest_info;

	mov	eax, DWORD PTR guest_info$[rsp]
	mov	DWORD PTR vbox_guest_phys$[rsp], eax

; 61   : 	outportd (vbox_port, vbox_guest_phys);

	mov	edx, DWORD PTR vbox_guest_phys$[rsp]
	movzx	ecx, WORD PTR vbox_port
	call	?outportd@@YAXGI@Z			; outportd

; 62   : 
; 63   : 	ack = (vbox_ack_events*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR ack, rax

; 64   : 	ack->header.size = sizeof(vbox_ack_events);

	mov	rax, QWORD PTR ack
	mov	DWORD PTR [rax], 28

; 65   : 	ack->header.version = VBOX_REQUEST_HEADER_VERSION;

	mov	rax, QWORD PTR ack
	mov	DWORD PTR [rax+4], 65537		; 00010001H

; 66   : 	ack->header.request_type = VBOX_REQUEST_ACK_EVENTS;

	mov	rax, QWORD PTR ack
	mov	DWORD PTR [rax+8], 41			; 00000029H

; 67   : 	ack->header.rc = 0;

	mov	rax, QWORD PTR ack
	mov	DWORD PTR [rax+12], 0

; 68   : 	ack->header.reserved1 = 0;

	mov	rax, QWORD PTR ack
	mov	DWORD PTR [rax+16], 0

; 69   : 	ack->header.reserved2 = 0;

	mov	rax, QWORD PTR ack
	mov	DWORD PTR [rax+20], 0

; 70   : 	ack->event = 0;

	mov	rax, QWORD PTR ack
	mov	DWORD PTR [rax+24], 0

; 71   : 	vbox_ack_phys = (uint32_t)ack;

	mov	eax, DWORD PTR ack
	mov	DWORD PTR vbox_ack_phys, eax

; 72   : 
; 73   : 
; 74   : 	vbox_mouse = (vbox_mouse_absolute*)pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA, rax ; vbox_mouse

; 75   : 	vbox_mouse->header.size = sizeof(vbox_mouse_absolute);

	mov	rax, QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA ; vbox_mouse
	mov	DWORD PTR [rax], 36			; 00000024H

; 76   : 	vbox_mouse->header.version = VBOX_REQUEST_HEADER_VERSION;

	mov	rax, QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA ; vbox_mouse
	mov	DWORD PTR [rax+4], 65537		; 00010001H

; 77   : 	vbox_mouse->header.request_type = VBOX_REQUEST_SET_MOUSE;

	mov	rax, QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA ; vbox_mouse
	mov	DWORD PTR [rax+8], 2

; 78   : 	vbox_mouse->header.rc = 0;

	mov	rax, QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA ; vbox_mouse
	mov	DWORD PTR [rax+12], 0

; 79   : 	vbox_mouse->header.reserved1 = 0;

	mov	rax, QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA ; vbox_mouse
	mov	DWORD PTR [rax+16], 0

; 80   : 	vbox_mouse->header.reserved2 = 0;

	mov	rax, QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA ; vbox_mouse
	mov	DWORD PTR [rax+20], 0

; 81   : 	vbox_mouse->features = (1<<0) | (1<<4);

	mov	rax, QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA ; vbox_mouse
	mov	DWORD PTR [rax+24], 17

; 82   : 	vbox_mouse->x = 0;

	mov	rax, QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA ; vbox_mouse
	mov	DWORD PTR [rax+28], 0

; 83   : 	vbox_mouse->y = 0;

	mov	rax, QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA ; vbox_mouse
	mov	DWORD PTR [rax+32], 0

; 84   : 	vbox_mouse_phys = (uint32_t)vbox_mouse;

	mov	eax, DWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA
	mov	DWORD PTR vbox_mouse_phys, eax

; 85   : 	outportd (vbox_port,vbox_mouse_phys);

	mov	edx, DWORD PTR vbox_mouse_phys
	movzx	ecx, WORD PTR vbox_port
	call	?outportd@@YAXGI@Z			; outportd

; 86   : 
; 87   : 	vbox_mouse->header.request_type = VBOX_REQUEST_GET_MOUSE;

	mov	rax, QWORD PTR ?vbox_mouse@@3PEAU_vbox_mouse_absolute_@@EA ; vbox_mouse
	mov	DWORD PTR [rax+8], 1

; 88   : 
; 89   : 	printf ("Virtual Box Driver initialized -> %d\n", guest_info->header.rc);

	mov	rax, QWORD PTR guest_info$[rsp]
	mov	edx, DWORD PTR [rax+12]
	lea	rcx, OFFSET FLAT:$SG3305
	call	?printf@@YAXPEBDZZ			; printf

; 90   : 	vbox_vmmdev[3] =  0xFFFFFFFF;

	mov	eax, 4
	imul	rax, 3
	mov	rcx, QWORD PTR vbox_vmmdev
	mov	DWORD PTR [rcx+rax], -1			; ffffffffH
$LN2@initialize:

; 91   : }

	add	rsp, 312				; 00000138H
	ret	0
?initialize_guest_vbox@@YAXXZ ENDP			; initialize_guest_vbox
_TEXT	ENDS
END
