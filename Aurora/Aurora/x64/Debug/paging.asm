; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?mmio_base_address@@3PEA_KEA			; mmio_base_address
PUBLIC	?root_cr3@@3PEA_KEA				; root_cr3
PUBLIC	?first@@3_NA					; first
_BSS	SEGMENT
?mmio_base_address@@3PEA_KEA DQ 01H DUP (?)		; mmio_base_address
?root_cr3@@3PEA_KEA DQ 01H DUP (?)			; root_cr3
?first@@3_NA DB	01H DUP (?)				; first
_BSS	ENDS
CONST	SEGMENT
$SG3832	DB	'Already present -> %x ', 0aH, 00H
CONST	ENDS
PUBLIC	?pml4_index@@YA_K_K@Z				; pml4_index
PUBLIC	?pdp_index@@YA_K_K@Z				; pdp_index
PUBLIC	?pd_index@@YA_K_K@Z				; pd_index
PUBLIC	?pt_index@@YA_K_K@Z				; pt_index
PUBLIC	?p_index@@YA_K_K@Z				; p_index
PUBLIC	?AuPagingInit@@YAXXZ				; AuPagingInit
PUBLIC	AuMapPage
PUBLIC	?AuMapPageEx@@YA_NPEA_K_K1E@Z			; AuMapPageEx
PUBLIC	?AuUnmapPageEx@@YAXPEA_K_K_N@Z			; AuUnmapPageEx
PUBLIC	AuUnmapPage
PUBLIC	?AuCreateAddressSpace@@YAPEA_KXZ		; AuCreateAddressSpace
PUBLIC	AuGetPage
PUBLIC	AuGetPhysicalAddress
PUBLIC	AuGetFreePage
PUBLIC	AuGetRootPageTable
PUBLIC	AuFreePages
PUBLIC	AuMapMMIO
PUBLIC	?AuPagingClearLow@@YAXXZ			; AuPagingClearLow
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	?AuPmmngrMoveHigher@@YAXXZ:PROC			; AuPmmngrMoveHigher
EXTRN	p2v:PROC
EXTRN	v2p:PROC
EXTRN	x64_mfence:PROC
EXTRN	x64_read_cr3:PROC
EXTRN	x64_write_cr3:PROC
EXTRN	flush_tlb:PROC
EXTRN	memset:PROC
EXTRN	printf:PROC
pdata	SEGMENT
$pdata$?AuPagingInit@@YAXXZ DD imagerel $LN12
	DD	imagerel $LN12+396
	DD	imagerel $unwind$?AuPagingInit@@YAXXZ
$pdata$AuMapPage DD imagerel $LN7
	DD	imagerel $LN7+616
	DD	imagerel $unwind$AuMapPage
$pdata$?AuMapPageEx@@YA_NPEA_K_K1E@Z DD imagerel $LN9
	DD	imagerel $LN9+659
	DD	imagerel $unwind$?AuMapPageEx@@YA_NPEA_K_K1E@Z
$pdata$?AuUnmapPageEx@@YAXPEA_K_K_N@Z DD imagerel $LN5
	DD	imagerel $LN5+246
	DD	imagerel $unwind$?AuUnmapPageEx@@YAXPEA_K_K_N@Z
$pdata$AuUnmapPage DD imagerel $LN5
	DD	imagerel $LN5+277
	DD	imagerel $unwind$AuUnmapPage
$pdata$?AuCreateAddressSpace@@YAPEA_KXZ DD imagerel $LN9
	DD	imagerel $LN9+182
	DD	imagerel $unwind$?AuCreateAddressSpace@@YAPEA_KXZ
$pdata$AuGetPage DD imagerel $LN8
	DD	imagerel $LN8+692
	DD	imagerel $unwind$AuGetPage
$pdata$AuGetPhysicalAddress DD imagerel $LN4
	DD	imagerel $LN4+201
	DD	imagerel $unwind$AuGetPhysicalAddress
$pdata$AuGetFreePage DD imagerel $LN13
	DD	imagerel $LN13+403
	DD	imagerel $unwind$AuGetFreePage
$pdata$AuFreePages DD imagerel $LN8
	DD	imagerel $LN8+343
	DD	imagerel $unwind$AuFreePages
$pdata$AuMapMMIO DD imagerel $LN6
	DD	imagerel $LN6+171
	DD	imagerel $unwind$AuMapMMIO
$pdata$?AuPagingClearLow@@YAXXZ DD imagerel $LN6
	DD	imagerel $LN6+69
	DD	imagerel $unwind$?AuPagingClearLow@@YAXXZ
$pdata$?clear@@YAXPEAX@Z DD imagerel ?clear@@YAXPEAX@Z
	DD	imagerel ?clear@@YAXPEAX@Z+74
	DD	imagerel $unwind$?clear@@YAXPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuPagingInit@@YAXXZ DD 010401H
	DD	0c204H
$unwind$AuMapPage DD 011301H
	DD	0e213H
$unwind$?AuMapPageEx@@YA_NPEA_K_K1E@Z DD 011801H
	DD	0e218H
$unwind$?AuUnmapPageEx@@YAXPEA_K_K_N@Z DD 011301H
	DD	0a213H
$unwind$AuUnmapPage DD 010d01H
	DD	0a20dH
$unwind$?AuCreateAddressSpace@@YAPEA_KXZ DD 010401H
	DD	08204H
$unwind$AuGetPage DD 021001H
	DD	0130110H
$unwind$AuGetPhysicalAddress DD 010e01H
	DD	0a20eH
$unwind$AuGetFreePage DD 011201H
	DD	0c212H
$unwind$AuFreePages DD 011201H
	DD	0c212H
$unwind$AuMapMMIO DD 010e01H
	DD	0820eH
$unwind$?AuPagingClearLow@@YAXXZ DD 010401H
	DD	06204H
$unwind$?clear@@YAXPEAX@Z DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
n$1 = 0
t$ = 8
addr$ = 32
?clear@@YAXPEAX@Z PROC					; clear

; 97   : static void clear(void* addr){

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 98   : 	uint64_t* t = (uint64_t*)addr;

	mov	rax, QWORD PTR addr$[rsp]
	mov	QWORD PTR t$[rsp], rax

; 99   : 	for (size_t n = 0; n < 4096 / sizeof(uint64_t); ++n){

	mov	QWORD PTR n$1[rsp], 0
	jmp	SHORT $LN3@clear
$LN2@clear:
	mov	rax, QWORD PTR n$1[rsp]
	inc	rax
	mov	QWORD PTR n$1[rsp], rax
$LN3@clear:
	cmp	QWORD PTR n$1[rsp], 512			; 00000200H
	jae	SHORT $LN1@clear

; 100  : 		t[n] = 0;

	mov	rax, QWORD PTR t$[rsp]
	mov	rcx, QWORD PTR n$1[rsp]
	mov	QWORD PTR [rax+rcx*8], 0

; 101  : 	}

	jmp	SHORT $LN2@clear
$LN1@clear:

; 102  : }

	add	rsp, 24
	ret	0
?clear@@YAXPEAX@Z ENDP					; clear
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
i$1 = 32
cr3$ = 40
?AuPagingClearLow@@YAXXZ PROC				; AuPagingClearLow

; 429  : void AuPagingClearLow() {

$LN6:
	sub	rsp, 56					; 00000038H

; 430  : 	uint64_t* cr3 = (uint64_t*)x64_read_cr3();

	call	x64_read_cr3
	mov	QWORD PTR cr3$[rsp], rax

; 431  : 	for (int i = 0; i < 256; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@AuPagingCl
$LN2@AuPagingCl:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@AuPagingCl:
	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN1@AuPagingCl

; 432  : 		cr3[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR cr3$[rsp]
	mov	QWORD PTR [rcx+rax*8], 0
	jmp	SHORT $LN2@AuPagingCl
$LN1@AuPagingCl:

; 433  : }

	add	rsp, 56					; 00000038H
	ret	0
?AuPagingClearLow@@YAXXZ ENDP				; AuPagingClearLow
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
i$1 = 32
out$ = 40
address$ = 48
phys_addr$ = 80
page_count$ = 88
AuMapMMIO PROC

; 506  : void* AuMapMMIO (uint64_t phys_addr, size_t page_count) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 507  : 	uint64_t out = (uint64_t)mmio_base_address;

	mov	rax, QWORD PTR ?mmio_base_address@@3PEA_KEA ; mmio_base_address
	mov	QWORD PTR out$[rsp], rax

; 508  : 	for (size_t i = 0; i < page_count; i++) {

	mov	QWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@AuMapMMIO
$LN2@AuMapMMIO:
	mov	rax, QWORD PTR i$1[rsp]
	inc	rax
	mov	QWORD PTR i$1[rsp], rax
$LN3@AuMapMMIO:
	mov	rax, QWORD PTR page_count$[rsp]
	cmp	QWORD PTR i$1[rsp], rax
	jae	SHORT $LN1@AuMapMMIO

; 509  : 		AuMapPage(phys_addr + i * 4096, out + i * 4096,0x04 | 0x08);  //

	mov	rax, QWORD PTR i$1[rsp]
	imul	rax, 4096				; 00001000H
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR i$1[rsp]
	imul	rcx, 4096				; 00001000H
	mov	rdx, QWORD PTR phys_addr$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8b, 12
	mov	rdx, rax
	call	AuMapPage

; 510  : 	}

	jmp	SHORT $LN2@AuMapMMIO
$LN1@AuMapMMIO:

; 511  : 
; 512  : 	uint64_t address = out;

	mov	rax, QWORD PTR out$[rsp]
	mov	QWORD PTR address$[rsp], rax

; 513  : 	mmio_base_address = (uint64_t*)(address + (page_count * 4096));

	mov	rax, QWORD PTR page_count$[rsp]
	imul	rax, 4096				; 00001000H
	mov	rcx, QWORD PTR address$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?mmio_base_address@@3PEA_KEA, rax ; mmio_base_address

; 514  : 
; 515  : 	return (void*)out;

	mov	rax, QWORD PTR out$[rsp]

; 516  : }

	add	rsp, 72					; 00000048H
	ret	0
AuMapMMIO ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
i$1 = 32
i1$ = 36
pt$2 = 40
page$3 = 48
tv68 = 56
pml4_$4 = 64
pdpt$5 = 72
pd$6 = 80
virt_addr$ = 112
free_physical$ = 120
s$ = 128
AuFreePages PROC

; 327  : void AuFreePages(uint64_t virt_addr, bool free_physical, size_t s){

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 328  : 	
; 329  : 	const long i1 = pml4_index(virt_addr);

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pml4_index@@YA_K_K@Z			; pml4_index
	mov	DWORD PTR i1$[rsp], eax

; 330  : 
; 331  : 	for (int i = 0; i < (s /  4096) + 1; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN5@AuFreePage
$LN4@AuFreePage:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN5@AuFreePage:
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	QWORD PTR tv68[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR s$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	inc	rax
	mov	rcx, QWORD PTR tv68[rsp]
	cmp	rcx, rax
	jae	$LN3@AuFreePage

; 332  : 		uint64_t *pml4_ = (uint64_t*)x64_read_cr3();

	call	x64_read_cr3
	mov	QWORD PTR pml4_$4[rsp], rax

; 333  : 		uint64_t *pdpt = (uint64_t*)(pml4_[pml4_index(virt_addr)] & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pml4_index@@YA_K_K@Z			; pml4_index
	mov	rcx, QWORD PTR pml4_$4[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$5[rsp], rax

; 334  : 		uint64_t *pd = (uint64_t*)(pdpt[pdp_index(virt_addr)] & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pdp_index@@YA_K_K@Z			; pdp_index
	mov	rcx, QWORD PTR pdpt$5[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$6[rsp], rax

; 335  : 		uint64_t *pt = (uint64_t*)(pd[pd_index(virt_addr)] & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pd_index@@YA_K_K@Z			; pd_index
	mov	rcx, QWORD PTR pd$6[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$2[rsp], rax

; 336  : 		uint64_t *page = (uint64_t*)(pt[pt_index(virt_addr)] & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pt_index@@YA_K_K@Z			; pt_index
	mov	rcx, QWORD PTR pt$2[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR page$3[rsp], rax

; 337  : 
; 338  : 		if ((pt[pt_index(virt_addr)] & PAGING_PRESENT) != 0) {

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pt_index@@YA_K_K@Z			; pt_index
	mov	rcx, QWORD PTR pt$2[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN2@AuFreePage

; 339  : 			pt[pt_index(virt_addr)] = 0;

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pt_index@@YA_K_K@Z			; pt_index
	mov	rcx, QWORD PTR pt$2[rsp]
	mov	QWORD PTR [rcx+rax*8], 0
$LN2@AuFreePage:

; 340  : 		}
; 341  : 
; 342  : 		if (free_physical && page != 0) 

	movzx	eax, BYTE PTR free_physical$[rsp]
	test	eax, eax
	je	SHORT $LN1@AuFreePage
	cmp	QWORD PTR page$3[rsp], 0
	je	SHORT $LN1@AuFreePage

; 343  : 			AuPmmngrFree(page);

	mov	rcx, QWORD PTR page$3[rsp]
	call	AuPmmngrFree
$LN1@AuFreePage:

; 344  : 
; 345  : 		virt_addr = virt_addr + i * 4096;

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR virt_addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR virt_addr$[rsp], rax

; 346  : 	}

	jmp	$LN4@AuFreePage
$LN3@AuFreePage:

; 347  : 
; 348  : }

	add	rsp, 104				; 00000068H
	ret	0
AuFreePages ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
AuGetRootPageTable PROC

; 520  : 	return root_cr3;

	mov	rax, QWORD PTR ?root_cr3@@3PEA_KEA	; root_cr3

; 521  : }

	ret	0
AuGetRootPageTable ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
start$ = 32
pml4$ = 40
pdpt$1 = 48
pd$2 = 56
pt$3 = 64
page$ = 72
end$ = 80
s$ = 112
user$ = 120
ptr$ = 128
AuGetFreePage PROC

; 463  : uint64_t* AuGetFreePage (size_t s, bool user, void* ptr) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 464  : 	uint64_t* page = 0;

	mov	QWORD PTR page$[rsp], 0

; 465  : 	uint64_t start = 0;

	mov	QWORD PTR start$[rsp], 0

; 466  : 	if (user) {

	movzx	eax, BYTE PTR user$[rsp]
	test	eax, eax
	je	SHORT $LN10@AuGetFreeP

; 467  : 		if (ptr)

	cmp	QWORD PTR ptr$[rsp], 0
	je	SHORT $LN9@AuGetFreeP

; 468  : 			start = (uint64_t)ptr;

	mov	rax, QWORD PTR ptr$[rsp]
	mov	QWORD PTR start$[rsp], rax

; 469  : 		else

	jmp	SHORT $LN8@AuGetFreeP
$LN9@AuGetFreeP:

; 470  : 			start = USER_BASE_ADDRESS;

	mov	QWORD PTR start$[rsp], 1610612736	; 60000000H
$LN8@AuGetFreeP:

; 471  : 	}else

	jmp	SHORT $LN7@AuGetFreeP
$LN10@AuGetFreeP:

; 472  : 		start = KERNEL_BASE_ADDRESS;

	mov	rax, -35184372088832			; ffffe00000000000H
	mov	QWORD PTR start$[rsp], rax
$LN7@AuGetFreeP:

; 473  : 
; 474  : 	uint64_t* end = 0;

	mov	QWORD PTR end$[rsp], 0

; 475  : 	uint64_t *pml4 = (uint64_t*)p2v(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	p2v
	mov	QWORD PTR pml4$[rsp], rax
$LN6@AuGetFreeP:

; 476  : 	
; 477  : 	/* Walk through every page tables */
; 478  : 	for (;;) {
; 479  : 		if (!(pml4[pml4_index(start)] & PAGING_PRESENT))

	mov	rcx, QWORD PTR start$[rsp]
	call	?pml4_index@@YA_K_K@Z			; pml4_index
	mov	rcx, QWORD PTR pml4$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN4@AuGetFreeP

; 480  : 			return (uint64_t*)start;

	mov	rax, QWORD PTR start$[rsp]
	jmp	$LN11@AuGetFreeP
$LN4@AuGetFreeP:

; 481  : 
; 482  : 		uint64_t *pdpt = (uint64_t*)(p2v(pml4[pml4_index(start)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR start$[rsp]
	call	?pml4_index@@YA_K_K@Z			; pml4_index
	mov	rcx, QWORD PTR pml4$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$1[rsp], rax

; 483  : 		if (!(pdpt[pdp_index(start)] & PAGING_PRESENT))

	mov	rcx, QWORD PTR start$[rsp]
	call	?pdp_index@@YA_K_K@Z			; pdp_index
	mov	rcx, QWORD PTR pdpt$1[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN3@AuGetFreeP

; 484  : 			return (uint64_t*)start;

	mov	rax, QWORD PTR start$[rsp]
	jmp	$LN11@AuGetFreeP
$LN3@AuGetFreeP:

; 485  : 
; 486  : 		uint64_t *pd = (uint64_t*)(p2v(pdpt[pdp_index(start)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR start$[rsp]
	call	?pdp_index@@YA_K_K@Z			; pdp_index
	mov	rcx, QWORD PTR pdpt$1[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$2[rsp], rax

; 487  : 		if (!(pd[pd_index(start)] & PAGING_PRESENT))

	mov	rcx, QWORD PTR start$[rsp]
	call	?pd_index@@YA_K_K@Z			; pd_index
	mov	rcx, QWORD PTR pd$2[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN2@AuGetFreeP

; 488  : 			return (uint64_t*)start;

	mov	rax, QWORD PTR start$[rsp]
	jmp	SHORT $LN11@AuGetFreeP
$LN2@AuGetFreeP:

; 489  : 
; 490  : 		uint64_t *pt = (uint64_t*)(p2v(pd[pd_index(start)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR start$[rsp]
	call	?pd_index@@YA_K_K@Z			; pd_index
	mov	rcx, QWORD PTR pd$2[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$3[rsp], rax

; 491  : 
; 492  : 		if (!(pt[pt_index(start)] & PAGING_PRESENT))

	mov	rcx, QWORD PTR start$[rsp]
	call	?pt_index@@YA_K_K@Z			; pt_index
	mov	rcx, QWORD PTR pt$3[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN1@AuGetFreeP

; 493  : 			return (uint64_t*)start;

	mov	rax, QWORD PTR start$[rsp]
	jmp	SHORT $LN11@AuGetFreeP
$LN1@AuGetFreeP:

; 494  : 		
; 495  : 		start += 4096;

	mov	rax, QWORD PTR start$[rsp]
	add	rax, 4096				; 00001000H
	mov	QWORD PTR start$[rsp], rax

; 496  : 	}

	jmp	$LN6@AuGetFreeP

; 497  : 	return 0;

	xor	eax, eax
$LN11@AuGetFreeP:

; 498  : }

	add	rsp, 104				; 00000068H
	ret	0
AuGetFreePage ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
i1$ = 32
page$ = 40
pml4$ = 48
pdpt$ = 56
pd$ = 64
pt$ = 72
cr3$ = 96
virt_addr$ = 104
AuGetPhysicalAddress PROC

; 352  : uint64_t* AuGetPhysicalAddress (uint64_t cr3,uint64_t virt_addr) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 353  : 	const long i1 = pml4_index(virt_addr);

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pml4_index@@YA_K_K@Z			; pml4_index
	mov	DWORD PTR i1$[rsp], eax

; 354  : 
; 355  : 	uint64_t *pml4 = (uint64_t*)p2v(cr3);

	mov	rcx, QWORD PTR cr3$[rsp]
	call	p2v
	mov	QWORD PTR pml4$[rsp], rax

; 356  : 	uint64_t *pdpt = (uint64_t*)(p2v(pml4[pml4_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pml4_index@@YA_K_K@Z			; pml4_index
	mov	rcx, QWORD PTR pml4$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$[rsp], rax

; 357  : 	uint64_t *pd = (uint64_t*)(p2v(pdpt[pdp_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pdp_index@@YA_K_K@Z			; pdp_index
	mov	rcx, QWORD PTR pdpt$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$[rsp], rax

; 358  : 	uint64_t *pt = (uint64_t*)(p2v(pd[pd_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pd_index@@YA_K_K@Z			; pd_index
	mov	rcx, QWORD PTR pd$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$[rsp], rax

; 359  : 	uint64_t *page = (uint64_t*)(p2v(pt[pt_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pt_index@@YA_K_K@Z			; pt_index
	mov	rcx, QWORD PTR pt$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR page$[rsp], rax

; 360  : 
; 361  : 	if (page != NULL)

	cmp	QWORD PTR page$[rsp], 0
	je	SHORT $LN1@AuGetPhysi

; 362  : 		return page;

	mov	rax, QWORD PTR page$[rsp]
$LN1@AuGetPhysi:

; 363  : }

	add	rsp, 88					; 00000058H
	ret	0
AuGetPhysicalAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
flags$ = 32
i1$ = 36
i4$ = 40
i2$ = 44
i3$ = 48
pml1$ = 56
pml4i$ = 64
page$1 = 72
pml2$ = 80
page$2 = 88
page$3 = 96
pml3$ = 104
phys_addr$4 = 112
page$5 = 120
vpage$6 = 128
virtual_address$ = 160
attrib$ = 168
AuGetPage PROC

; 264  : AuVPage* AuGetPage (uint64_t virtual_address, uint8_t attrib) {

$LN8:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 265  : 	uint8_t flags = PAGING_PRESENT | PAGING_WRITABLE | attrib ;

	movzx	eax, BYTE PTR attrib$[rsp]
	or	eax, 3
	mov	BYTE PTR flags$[rsp], al

; 266  : 
; 267  : 	
; 268  : 	const long i4 = (virtual_address >> 39) & 0x1FF;

	mov	rax, QWORD PTR virtual_address$[rsp]
	shr	rax, 39					; 00000027H
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i4$[rsp], eax

; 269  : 	const long i3 = (virtual_address >> 30) & 0x1FF;

	mov	rax, QWORD PTR virtual_address$[rsp]
	shr	rax, 30
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i3$[rsp], eax

; 270  : 	const long i2 = (virtual_address >> 21) & 0x1FF;

	mov	rax, QWORD PTR virtual_address$[rsp]
	shr	rax, 21
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i2$[rsp], eax

; 271  : 	const long i1 = (virtual_address >> 12) & 0x1FF;

	mov	rax, QWORD PTR virtual_address$[rsp]
	shr	rax, 12
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i1$[rsp], eax

; 272  : 
; 273  : 	uint64_t *pml4i = (uint64_t*)p2v(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	p2v
	mov	QWORD PTR pml4i$[rsp], rax

; 274  : 
; 275  : 	if (!(pml4i[i4] & PAGING_PRESENT))

	movsxd	rax, DWORD PTR i4$[rsp]
	mov	rcx, QWORD PTR pml4i$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN5@AuGetPage

; 276  : 	{
; 277  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$3[rsp], rax

; 278  : 		pml4i[i4] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$3[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i4$[rsp]
	mov	rdx, QWORD PTR pml4i$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 279  : 		clear((void*)p2v(page));

	mov	rcx, QWORD PTR page$3[rsp]
	call	p2v
	mov	rcx, rax
	call	?clear@@YAXPEAX@Z			; clear

; 280  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$3[rsp]
	call	flush_tlb

; 281  : 		x64_mfence();

	call	x64_mfence
$LN5@AuGetPage:

; 282  : 	}
; 283  : 	uint64_t* pml3 = (uint64_t*)(p2v(pml4i[i4]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i4$[rsp]
	mov	rcx, QWORD PTR pml4i$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml3$[rsp], rax

; 284  : 	
; 285  : 	if (!(pml3[i3] & PAGING_PRESENT))

	movsxd	rax, DWORD PTR i3$[rsp]
	mov	rcx, QWORD PTR pml3$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN4@AuGetPage

; 286  : 	{
; 287  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$2[rsp], rax

; 288  : 		pml3[i3] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$2[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i3$[rsp]
	mov	rdx, QWORD PTR pml3$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 289  : 		clear((void*)p2v(page));

	mov	rcx, QWORD PTR page$2[rsp]
	call	p2v
	mov	rcx, rax
	call	?clear@@YAXPEAX@Z			; clear

; 290  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$2[rsp]
	call	flush_tlb

; 291  : 		x64_mfence();

	call	x64_mfence
$LN4@AuGetPage:

; 292  : 		
; 293  : 	}
; 294  :     
; 295  : 	
; 296  : 	uint64_t* pml2 = (uint64_t*)(p2v(pml3[i3]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i3$[rsp]
	mov	rcx, QWORD PTR pml3$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml2$[rsp], rax

; 297  : 	
; 298  : 	if (!(pml2[i2] & PAGING_PRESENT))

	movsxd	rax, DWORD PTR i2$[rsp]
	mov	rcx, QWORD PTR pml2$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN3@AuGetPage

; 299  : 	{
; 300  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$1[rsp], rax

; 301  : 		pml2[i2] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$1[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i2$[rsp]
	mov	rdx, QWORD PTR pml2$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 302  : 		clear((void*)p2v(page));

	mov	rcx, QWORD PTR page$1[rsp]
	call	p2v
	mov	rcx, rax
	call	?clear@@YAXPEAX@Z			; clear

; 303  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$1[rsp]
	call	flush_tlb

; 304  : 		x64_mfence();

	call	x64_mfence
$LN3@AuGetPage:

; 305  : 		
; 306  : 	}
; 307  : 	
; 308  : 	uint64_t* pml1 = (uint64_t*)(p2v(pml2[i2]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i2$[rsp]
	mov	rcx, QWORD PTR pml2$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml1$[rsp], rax

; 309  : 	if (pml1[i1] & PAGING_PRESENT)

	movsxd	rax, DWORD PTR i1$[rsp]
	mov	rcx, QWORD PTR pml1$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN2@AuGetPage

; 310  : 	{
; 311  : 
; 312  : 		AuVPage *page = (AuVPage*)&pml1[i1];

	movsxd	rax, DWORD PTR i1$[rsp]
	mov	rcx, QWORD PTR pml1$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR page$5[rsp], rax

; 313  : 		return page;

	mov	rax, QWORD PTR page$5[rsp]
	jmp	SHORT $LN6@AuGetPage

; 314  : 	} else {

	jmp	SHORT $LN1@AuGetPage
$LN2@AuGetPage:

; 315  : 		uint64_t phys_addr = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR phys_addr$4[rsp], rax

; 316  : 		memset((void*)p2v(phys_addr), 0, 4096);

	mov	rcx, QWORD PTR phys_addr$4[rsp]
	call	p2v
	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, rax
	call	memset

; 317  : 		pml1[i1] = phys_addr | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR phys_addr$4[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i1$[rsp]
	mov	rdx, QWORD PTR pml1$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 318  : 		flush_tlb ((void*)virtual_address);

	mov	rcx, QWORD PTR virtual_address$[rsp]
	call	flush_tlb

; 319  : 		x64_mfence ();

	call	x64_mfence

; 320  : 		AuVPage *vpage = (AuVPage*)&pml1[i1];

	movsxd	rax, DWORD PTR i1$[rsp]
	mov	rcx, QWORD PTR pml1$[rsp]
	lea	rax, QWORD PTR [rcx+rax*8]
	mov	QWORD PTR vpage$6[rsp], rax

; 321  : 		return vpage;

	mov	rax, QWORD PTR vpage$6[rsp]
	jmp	SHORT $LN6@AuGetPage
$LN1@AuGetPage:

; 322  : 	}
; 323  : 	return NULL;

	xor	eax, eax
$LN6@AuGetPage:

; 324  : }

	add	rsp, 152				; 00000098H
	ret	0
AuGetPage ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
i$1 = 32
new_cr3$ = 40
cr3$ = 48
?AuCreateAddressSpace@@YAPEA_KXZ PROC			; AuCreateAddressSpace

; 438  : uint64_t *AuCreateAddressSpace (){

$LN9:
	sub	rsp, 72					; 00000048H

; 439  : 	
; 440  : 	uint64_t *cr3 = (uint64_t*)p2v((uint64_t)root_cr3);

	mov	rcx, QWORD PTR ?root_cr3@@3PEA_KEA	; root_cr3
	call	p2v
	mov	QWORD PTR cr3$[rsp], rax

; 441  : 	uint64_t *new_cr3 = (uint64_t*)p2v((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	p2v
	mov	QWORD PTR new_cr3$[rsp], rax

; 442  : 	memset(new_cr3,0,4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR new_cr3$[rsp]
	call	memset

; 443  : 
; 444  : 	//! For now, copy the 4 GiB identity mapping from old pml4
; 445  : 	//! but later, we should avoid this by mapping only those physical
; 446  : 	//! addresses that are needed, like physical addresses allocated for 
; 447  : 	//! paging tables creations and memory mapped I/O which are not
; 448  : 	//! virtually allocated in higher half sections
; 449  : 	//! Copy Kernel's Higher Half section
; 450  : 	for (int i = 0; i < 512; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@AuCreateAd
$LN5@AuCreateAd:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@AuCreateAd:
	cmp	DWORD PTR i$1[rsp], 512			; 00000200H
	jge	SHORT $LN4@AuCreateAd

; 451  : 		if (i < 256)

	cmp	DWORD PTR i$1[rsp], 256			; 00000100H
	jge	SHORT $LN3@AuCreateAd

; 452  : 			continue;

	jmp	SHORT $LN5@AuCreateAd
$LN3@AuCreateAd:

; 453  : 		if ((cr3[i] & PAGING_PRESENT))

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR cr3$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN2@AuCreateAd

; 454  : 			new_cr3[i] = cr3[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR new_cr3$[rsp]
	mov	r8, QWORD PTR cr3$[rsp]
	mov	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rdx+rcx*8], rax

; 455  : 		else

	jmp	SHORT $LN1@AuCreateAd
$LN2@AuCreateAd:

; 456  : 			new_cr3[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR new_cr3$[rsp]
	mov	QWORD PTR [rcx+rax*8], 0
$LN1@AuCreateAd:

; 457  : 	}

	jmp	SHORT $LN5@AuCreateAd
$LN4@AuCreateAd:

; 458  : 
; 459  : 	return new_cr3;

	mov	rax, QWORD PTR new_cr3$[rsp]

; 460  : }

	add	rsp, 72					; 00000048H
	ret	0
?AuCreateAddressSpace@@YAPEA_KXZ ENDP			; AuCreateAddressSpace
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
i1$ = 32
pt$ = 40
page$ = 48
pml4_$ = 56
pdpt$ = 64
pd$ = 72
virt_addr$ = 96
free_physical$ = 104
AuUnmapPage PROC

; 217  : void AuUnmapPage(uint64_t virt_addr, bool free_physical){

$LN5:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 218  : 	
; 219  : 	const long i1 = pml4_index(virt_addr);

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pml4_index@@YA_K_K@Z			; pml4_index
	mov	DWORD PTR i1$[rsp], eax

; 220  : 
; 221  : 	uint64_t *pml4_ = (uint64_t*)p2v(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	p2v
	mov	QWORD PTR pml4_$[rsp], rax

; 222  : 	uint64_t *pdpt = (uint64_t*)(p2v(pml4_[pml4_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pml4_index@@YA_K_K@Z			; pml4_index
	mov	rcx, QWORD PTR pml4_$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$[rsp], rax

; 223  : 	uint64_t *pd = (uint64_t*)(p2v(pdpt[pdp_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pdp_index@@YA_K_K@Z			; pdp_index
	mov	rcx, QWORD PTR pdpt$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$[rsp], rax

; 224  : 	uint64_t *pt = (uint64_t*)(p2v(pd[pd_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pd_index@@YA_K_K@Z			; pd_index
	mov	rcx, QWORD PTR pd$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$[rsp], rax

; 225  : 	uint64_t *page = (uint64_t*)(p2v(pt[pt_index(virt_addr)]) & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pt_index@@YA_K_K@Z			; pt_index
	mov	rcx, QWORD PTR pt$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR page$[rsp], rax

; 226  : 	
; 227  : 	if ((pt[pt_index(virt_addr)] & PAGING_PRESENT) != 0) {

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pt_index@@YA_K_K@Z			; pt_index
	mov	rcx, QWORD PTR pt$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN2@AuUnmapPag

; 228  : 		
; 229  : 		pt[pt_index(virt_addr)] = 0;

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pt_index@@YA_K_K@Z			; pt_index
	mov	rcx, QWORD PTR pt$[rsp]
	mov	QWORD PTR [rcx+rax*8], 0
$LN2@AuUnmapPag:

; 230  : 	}
; 231  : 
; 232  : 	if (page != 0 && free_physical == true) {

	cmp	QWORD PTR page$[rsp], 0
	je	SHORT $LN1@AuUnmapPag
	movzx	eax, BYTE PTR free_physical$[rsp]
	cmp	eax, 1
	jne	SHORT $LN1@AuUnmapPag

; 233  : 		AuPmmngrFree((void*)v2p((size_t)page));

	mov	rcx, QWORD PTR page$[rsp]
	call	v2p
	mov	rcx, rax
	call	AuPmmngrFree
$LN1@AuUnmapPag:

; 234  : 	}
; 235  : }

	add	rsp, 88					; 00000058H
	ret	0
AuUnmapPage ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
i1$ = 32
pt$ = 40
page$ = 48
pml4_$ = 56
pdpt$ = 64
pd$ = 72
cr3$ = 96
virt_addr$ = 104
free_physical$ = 112
?AuUnmapPageEx@@YAXPEA_K_K_N@Z PROC			; AuUnmapPageEx

; 238  : void AuUnmapPageEx(uint64_t* cr3, uint64_t virt_addr, bool free_physical){

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 239  : 	
; 240  : 	const long i1 = pml4_index(virt_addr);

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pml4_index@@YA_K_K@Z			; pml4_index
	mov	DWORD PTR i1$[rsp], eax

; 241  : 
; 242  : 	uint64_t *pml4_ = cr3;

	mov	rax, QWORD PTR cr3$[rsp]
	mov	QWORD PTR pml4_$[rsp], rax

; 243  : 	uint64_t *pdpt = (uint64_t*)(pml4_[pml4_index(virt_addr)] & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pml4_index@@YA_K_K@Z			; pml4_index
	mov	rcx, QWORD PTR pml4_$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pdpt$[rsp], rax

; 244  : 	uint64_t *pd = (uint64_t*)(pdpt[pdp_index(virt_addr)] & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pdp_index@@YA_K_K@Z			; pdp_index
	mov	rcx, QWORD PTR pdpt$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pd$[rsp], rax

; 245  : 	uint64_t *pt = (uint64_t*)(pd[pd_index(virt_addr)] & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pd_index@@YA_K_K@Z			; pd_index
	mov	rcx, QWORD PTR pd$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pt$[rsp], rax

; 246  : 	uint64_t *page = (uint64_t*)(pt[pt_index(virt_addr)] & ~(4096 - 1));

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pt_index@@YA_K_K@Z			; pt_index
	mov	rcx, QWORD PTR pt$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR page$[rsp], rax

; 247  : 
; 248  : 	if ((pt[pt_index(virt_addr)] & PAGING_PRESENT) != 0) {

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pt_index@@YA_K_K@Z			; pt_index
	mov	rcx, QWORD PTR pt$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN2@AuUnmapPag

; 249  : 		pt[pt_index(virt_addr)] = 0;

	mov	rcx, QWORD PTR virt_addr$[rsp]
	call	?pt_index@@YA_K_K@Z			; pt_index
	mov	rcx, QWORD PTR pt$[rsp]
	mov	QWORD PTR [rcx+rax*8], 0
$LN2@AuUnmapPag:

; 250  : 	}
; 251  : 
; 252  : 	if (free_physical && page != 0) 

	movzx	eax, BYTE PTR free_physical$[rsp]
	test	eax, eax
	je	SHORT $LN1@AuUnmapPag
	cmp	QWORD PTR page$[rsp], 0
	je	SHORT $LN1@AuUnmapPag

; 253  : 		AuPmmngrFree(page);

	mov	rcx, QWORD PTR page$[rsp]
	call	AuPmmngrFree
$LN1@AuUnmapPag:

; 254  : 
; 255  : }

	add	rsp, 88					; 00000058H
	ret	0
?AuUnmapPageEx@@YAXPEA_K_K_N@Z ENDP			; AuUnmapPageEx
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
i2$ = 32
i4$ = 36
i3$ = 40
flags$ = 48
i1$ = 56
page$1 = 64
page$2 = 72
page$3 = 80
pml2$ = 88
pml3$ = 96
pml1$ = 104
pml4i$ = 128
physical_address$ = 136
virtual_address$ = 144
attrib$ = 152
?AuMapPageEx@@YA_NPEA_K_K1E@Z PROC			; AuMapPageEx

; 367  : bool AuMapPageEx (uint64_t *pml4i,uint64_t physical_address, uint64_t virtual_address, uint8_t attrib){

$LN9:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 368  : 
; 369  : 
; 370  : 	size_t flags = 0;

	mov	QWORD PTR flags$[rsp], 0

; 371  : 	if (attrib == PAGING_USER)

	movzx	eax, BYTE PTR attrib$[rsp]
	cmp	eax, 4
	jne	SHORT $LN6@AuMapPageE

; 372  : 		flags  = PAGING_PRESENT | PAGING_WRITABLE | PAGING_USER;

	mov	QWORD PTR flags$[rsp], 7

; 373  : 	else

	jmp	SHORT $LN5@AuMapPageE
$LN6@AuMapPageE:

; 374  : 		flags = PAGING_PRESENT | PAGING_WRITABLE;

	mov	QWORD PTR flags$[rsp], 3
$LN5@AuMapPageE:

; 375  : 
; 376  : 	const long i4 = (virtual_address >> 39) & 0x1FF;

	mov	rax, QWORD PTR virtual_address$[rsp]
	shr	rax, 39					; 00000027H
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i4$[rsp], eax

; 377  : 	const long i3 = (virtual_address >> 30) & 0x1FF;

	mov	rax, QWORD PTR virtual_address$[rsp]
	shr	rax, 30
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i3$[rsp], eax

; 378  : 	const long i2 = (virtual_address >> 21) & 0x1FF;

	mov	rax, QWORD PTR virtual_address$[rsp]
	shr	rax, 21
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i2$[rsp], eax

; 379  : 	const long i1 = (virtual_address >> 12) & 0x1FF;

	mov	rax, QWORD PTR virtual_address$[rsp]
	shr	rax, 12
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i1$[rsp], eax

; 380  : 
; 381  : 	if (!(pml4i[i4] & PAGING_PRESENT)){

	movsxd	rax, DWORD PTR i4$[rsp]
	mov	rcx, QWORD PTR pml4i$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN4@AuMapPageE

; 382  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$1[rsp], rax

; 383  : 		pml4i[i4] = page | flags;

	mov	rax, QWORD PTR flags$[rsp]
	mov	rcx, QWORD PTR page$1[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i4$[rsp]
	mov	rdx, QWORD PTR pml4i$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 384  : 		clear((void*)p2v(page));

	mov	rcx, QWORD PTR page$1[rsp]
	call	p2v
	mov	rcx, rax
	call	?clear@@YAXPEAX@Z			; clear

; 385  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$1[rsp]
	call	flush_tlb

; 386  : 		x64_mfence();

	call	x64_mfence
$LN4@AuMapPageE:

; 387  : 	}
; 388  : 	uint64_t* pml3 = (uint64_t*)(p2v(pml4i[i4]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i4$[rsp]
	mov	rcx, QWORD PTR pml4i$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml3$[rsp], rax

; 389  : 
; 390  : 	if (!(pml3[i3] & PAGING_PRESENT)){

	movsxd	rax, DWORD PTR i3$[rsp]
	mov	rcx, QWORD PTR pml3$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN3@AuMapPageE

; 391  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$3[rsp], rax

; 392  : 		pml3[i3] = page | flags;

	mov	rax, QWORD PTR flags$[rsp]
	mov	rcx, QWORD PTR page$3[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i3$[rsp]
	mov	rdx, QWORD PTR pml3$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 393  : 		clear((void*)p2v(page));

	mov	rcx, QWORD PTR page$3[rsp]
	call	p2v
	mov	rcx, rax
	call	?clear@@YAXPEAX@Z			; clear

; 394  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$3[rsp]
	call	flush_tlb

; 395  : 		x64_mfence();

	call	x64_mfence
$LN3@AuMapPageE:

; 396  : 		
; 397  : 	}
; 398  : 
; 399  : 	uint64_t* pml2 = (uint64_t*)(p2v(pml3[i3]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i3$[rsp]
	mov	rcx, QWORD PTR pml3$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml2$[rsp], rax

; 400  : 	if (!(pml2[i2] & PAGING_PRESENT)){

	movsxd	rax, DWORD PTR i2$[rsp]
	mov	rcx, QWORD PTR pml2$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN2@AuMapPageE

; 401  : 
; 402  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$2[rsp], rax

; 403  : 		pml2[i2] = page | flags;

	mov	rax, QWORD PTR flags$[rsp]
	mov	rcx, QWORD PTR page$2[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i2$[rsp]
	mov	rdx, QWORD PTR pml2$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 404  : 		clear((void*)p2v(page));

	mov	rcx, QWORD PTR page$2[rsp]
	call	p2v
	mov	rcx, rax
	call	?clear@@YAXPEAX@Z			; clear

; 405  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$2[rsp]
	call	flush_tlb

; 406  : 		x64_mfence();

	call	x64_mfence
$LN2@AuMapPageE:

; 407  : 		
; 408  : 	}
; 409  : 
; 410  : 	uint64_t* pml1 = (uint64_t*)(p2v(pml2[i2]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i2$[rsp]
	mov	rcx, QWORD PTR pml2$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml1$[rsp], rax

; 411  : 
; 412  : 	if (pml1[i1] & PAGING_PRESENT){

	movsxd	rax, DWORD PTR i1$[rsp]
	mov	rcx, QWORD PTR pml1$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN1@AuMapPageE

; 413  : 		AuPmmngrFree((void*)physical_address);

	mov	rcx, QWORD PTR physical_address$[rsp]
	call	AuPmmngrFree

; 414  : 		printf ("Already present -> %x \n", virtual_address);

	mov	rdx, QWORD PTR virtual_address$[rsp]
	lea	rcx, OFFSET FLAT:$SG3832
	call	printf

; 415  : 		return false;

	xor	al, al
	jmp	SHORT $LN7@AuMapPageE
$LN1@AuMapPageE:

; 416  : 	}
; 417  : 
; 418  : 	pml1[i1] = physical_address | flags;

	mov	rax, QWORD PTR flags$[rsp]
	mov	rcx, QWORD PTR physical_address$[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i1$[rsp]
	mov	rdx, QWORD PTR pml1$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 419  : 	flush_tlb ((void*)virtual_address);

	mov	rcx, QWORD PTR virtual_address$[rsp]
	call	flush_tlb

; 420  : 	x64_mfence ();

	call	x64_mfence

; 421  : 	return true;

	mov	al, 1
$LN7@AuMapPageE:

; 422  : }

	add	rsp, 120				; 00000078H
	ret	0
?AuMapPageEx@@YA_NPEA_K_K1E@Z ENDP			; AuMapPageEx
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
flags$ = 32
i3$ = 36
i2$ = 40
i4$ = 44
i1$ = 48
page$1 = 56
pml3$ = 64
page$2 = 72
page$3 = 80
pml2$ = 88
pml4i$ = 96
pml1$ = 104
physical_address$ = 128
virtual_address$ = 136
attrib$ = 144
AuMapPage PROC

; 154  : bool AuMapPage(uint64_t physical_address, uint64_t virtual_address, uint8_t attrib){

$LN7:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 155  : 	uint8_t flags = PAGING_PRESENT | PAGING_WRITABLE | attrib;

	movzx	eax, BYTE PTR attrib$[rsp]
	or	eax, 3
	mov	BYTE PTR flags$[rsp], al

; 156  : 
; 157  : 	
; 158  : 	const long i4 = (virtual_address >> 39) & 0x1FF;

	mov	rax, QWORD PTR virtual_address$[rsp]
	shr	rax, 39					; 00000027H
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i4$[rsp], eax

; 159  : 	const long i3 = (virtual_address >> 30) & 0x1FF;

	mov	rax, QWORD PTR virtual_address$[rsp]
	shr	rax, 30
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i3$[rsp], eax

; 160  : 	const long i2 = (virtual_address >> 21) & 0x1FF;

	mov	rax, QWORD PTR virtual_address$[rsp]
	shr	rax, 21
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i2$[rsp], eax

; 161  : 	const long i1 = (virtual_address >> 12) & 0x1FF;

	mov	rax, QWORD PTR virtual_address$[rsp]
	shr	rax, 12
	and	rax, 511				; 000001ffH
	mov	DWORD PTR i1$[rsp], eax

; 162  : 
; 163  : 	uint64_t *pml4i = (uint64_t*)p2v(x64_read_cr3());

	call	x64_read_cr3
	mov	rcx, rax
	call	p2v
	mov	QWORD PTR pml4i$[rsp], rax

; 164  : 
; 165  : 	if (!(pml4i[i4] & PAGING_PRESENT))

	movsxd	rax, DWORD PTR i4$[rsp]
	mov	rcx, QWORD PTR pml4i$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN4@AuMapPage

; 166  : 	{
; 167  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$1[rsp], rax

; 168  : 		pml4i[i4] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$1[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i4$[rsp]
	mov	rdx, QWORD PTR pml4i$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 169  : 		clear((void*)p2v(page));

	mov	rcx, QWORD PTR page$1[rsp]
	call	p2v
	mov	rcx, rax
	call	?clear@@YAXPEAX@Z			; clear

; 170  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$1[rsp]
	call	flush_tlb

; 171  : 		x64_mfence();

	call	x64_mfence
$LN4@AuMapPage:

; 172  : 	}
; 173  : 	uint64_t* pml3 = (uint64_t*)(p2v(pml4i[i4]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i4$[rsp]
	mov	rcx, QWORD PTR pml4i$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml3$[rsp], rax

; 174  : 	
; 175  : 	if (!(pml3[i3] & PAGING_PRESENT))

	movsxd	rax, DWORD PTR i3$[rsp]
	mov	rcx, QWORD PTR pml3$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN3@AuMapPage

; 176  : 	{
; 177  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$3[rsp], rax

; 178  : 		pml3[i3] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$3[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i3$[rsp]
	mov	rdx, QWORD PTR pml3$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 179  : 		clear((void*)p2v(page));

	mov	rcx, QWORD PTR page$3[rsp]
	call	p2v
	mov	rcx, rax
	call	?clear@@YAXPEAX@Z			; clear

; 180  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$3[rsp]
	call	flush_tlb

; 181  : 		x64_mfence();

	call	x64_mfence
$LN3@AuMapPage:

; 182  : 		
; 183  : 	}
; 184  :     
; 185  : 	
; 186  : 	uint64_t* pml2 = (uint64_t*)(p2v(pml3[i3]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i3$[rsp]
	mov	rcx, QWORD PTR pml3$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml2$[rsp], rax

; 187  : 	
; 188  : 	if (!(pml2[i2] & PAGING_PRESENT))

	movsxd	rax, DWORD PTR i2$[rsp]
	mov	rcx, QWORD PTR pml2$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	jne	SHORT $LN2@AuMapPage

; 189  : 	{
; 190  : 		const uint64_t page = (uint64_t)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR page$2[rsp], rax

; 191  : 		pml2[i2] = page | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR page$2[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i2$[rsp]
	mov	rdx, QWORD PTR pml2$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 192  : 		clear((void*)p2v(page));

	mov	rcx, QWORD PTR page$2[rsp]
	call	p2v
	mov	rcx, rax
	call	?clear@@YAXPEAX@Z			; clear

; 193  : 		flush_tlb((void*)page);

	mov	rcx, QWORD PTR page$2[rsp]
	call	flush_tlb

; 194  : 		x64_mfence();

	call	x64_mfence
$LN2@AuMapPage:

; 195  : 		
; 196  : 	}
; 197  : 	
; 198  : 	uint64_t* pml1 = (uint64_t*)(p2v(pml2[i2]) & ~(4096 - 1));

	movsxd	rax, DWORD PTR i2$[rsp]
	mov	rcx, QWORD PTR pml2$[rsp]
	mov	rcx, QWORD PTR [rcx+rax*8]
	call	p2v
	and	rax, -4096				; fffffffffffff000H
	mov	QWORD PTR pml1$[rsp], rax

; 199  : 	if (pml1[i1] & PAGING_PRESENT)

	movsxd	rax, DWORD PTR i1$[rsp]
	mov	rcx, QWORD PTR pml1$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN1@AuMapPage

; 200  : 	{
; 201  : 		AuPmmngrFree((void*)physical_address);

	mov	rcx, QWORD PTR physical_address$[rsp]
	call	AuPmmngrFree

; 202  : 		return false;

	xor	al, al
	jmp	SHORT $LN5@AuMapPage
$LN1@AuMapPage:

; 203  : 	}
; 204  : 
; 205  : 	pml1[i1] = physical_address | flags;

	movzx	eax, BYTE PTR flags$[rsp]
	mov	rcx, QWORD PTR physical_address$[rsp]
	or	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR i1$[rsp]
	mov	rdx, QWORD PTR pml1$[rsp]
	mov	QWORD PTR [rdx+rcx*8], rax

; 206  : 	flush_tlb ((void*)virtual_address);

	mov	rcx, QWORD PTR virtual_address$[rsp]
	call	flush_tlb

; 207  : 	x64_mfence ();

	call	x64_mfence

; 208  : 	return true;

	mov	al, 1
$LN5@AuMapPage:

; 209  : }

	add	rsp, 120				; 00000078H
	ret	0
AuMapPage ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
i$1 = 32
new_cr3$ = 40
i$2 = 48
pdpt$ = 56
cr3$ = 64
tv95 = 72
tv140 = 80
?AuPagingInit@@YAXXZ PROC				; AuPagingInit

; 109  : void AuPagingInit() {

$LN12:
	sub	rsp, 104				; 00000068H

; 110  : 
; 111  : 	uint64_t *cr3 = (uint64_t*)x64_read_cr3();

	call	x64_read_cr3
	mov	QWORD PTR cr3$[rsp], rax

; 112  : 	uint64_t *new_cr3 = (uint64_t*)AuPmmngrAlloc();    

	call	AuPmmngrAlloc
	mov	QWORD PTR new_cr3$[rsp], rax

; 113  : 
; 114  : 	memset (new_cr3, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR new_cr3$[rsp]
	call	memset

; 115  : 	mmio_base_address = (uint64_t*)MMIO_BASE;

	mov	rax, -1030792151040			; ffffff1000000000H
	mov	QWORD PTR ?mmio_base_address@@3PEA_KEA, rax ; mmio_base_address

; 116  : 
; 117  : 	//! Copy all higher half mappings to new mapping
; 118  : 	for (int i = 0; i < 512; ++i) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN9@AuPagingIn
$LN8@AuPagingIn:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN9@AuPagingIn:
	cmp	DWORD PTR i$1[rsp], 512			; 00000200H
	jge	SHORT $LN7@AuPagingIn

; 119  : 		if (i == 511)

	cmp	DWORD PTR i$1[rsp], 511			; 000001ffH
	jne	SHORT $LN6@AuPagingIn

; 120  : 			continue;

	jmp	SHORT $LN8@AuPagingIn
$LN6@AuPagingIn:

; 121  : 
; 122  : 		if (cr3[i] & PAGING_PRESENT) {

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR cr3$[rsp]
	mov	rax, QWORD PTR [rcx+rax*8]
	and	rax, 1
	test	rax, rax
	je	SHORT $LN5@AuPagingIn

; 123  : 			new_cr3[i] = cr3[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR new_cr3$[rsp]
	mov	r8, QWORD PTR cr3$[rsp]
	mov	rax, QWORD PTR [r8+rax*8]
	mov	QWORD PTR [rdx+rcx*8], rax

; 124  : 		}else {

	jmp	SHORT $LN4@AuPagingIn
$LN5@AuPagingIn:

; 125  : 			new_cr3[i] = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR new_cr3$[rsp]
	mov	QWORD PTR [rcx+rax*8], 0
$LN4@AuPagingIn:

; 126  : 		}
; 127  : 		
; 128  : 	}

	jmp	SHORT $LN8@AuPagingIn
$LN7@AuPagingIn:

; 129  : 
; 130  : 	uint64_t* pdpt = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR pdpt$[rsp], rax

; 131  : 	memset(pdpt, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR pdpt$[rsp]
	call	memset

; 132  : 
; 133  : 	new_cr3[pml4_index(PHYSICAL_MEMORY_BASE)] = (uint64_t)pdpt | PAGING_PRESENT | PAGING_WRITABLE;

	mov	rax, QWORD PTR pdpt$[rsp]
	or	rax, 1
	or	rax, 2
	mov	QWORD PTR tv95[rsp], rax
	mov	rcx, -140737488355328			; ffff800000000000H
	call	?pml4_index@@YA_K_K@Z			; pml4_index
	mov	rcx, QWORD PTR new_cr3$[rsp]
	mov	rdx, QWORD PTR tv95[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx

; 134  : 
; 135  : 	for (size_t i = 0; i < 512; i++)

	mov	QWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@AuPagingIn
$LN2@AuPagingIn:
	mov	rax, QWORD PTR i$2[rsp]
	inc	rax
	mov	QWORD PTR i$2[rsp], rax
$LN3@AuPagingIn:
	cmp	QWORD PTR i$2[rsp], 512			; 00000200H
	jae	SHORT $LN1@AuPagingIn

; 136  : 		pdpt[pdp_index(PHYSICAL_MEMORY_BASE) + i] = i * 512 * 512 * 4096 | 0x80 | PAGING_PRESENT | PAGING_WRITABLE;

	mov	rax, QWORD PTR i$2[rsp]
	imul	rax, 512				; 00000200H
	imul	rax, 512				; 00000200H
	imul	rax, 4096				; 00001000H
	bts	rax, 7
	or	rax, 1
	or	rax, 2
	mov	QWORD PTR tv140[rsp], rax
	mov	rcx, -140737488355328			; ffff800000000000H
	call	?pdp_index@@YA_K_K@Z			; pdp_index
	add	rax, QWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR pdpt$[rsp]
	mov	rdx, QWORD PTR tv140[rsp]
	mov	QWORD PTR [rcx+rax*8], rdx
	jmp	SHORT $LN2@AuPagingIn
$LN1@AuPagingIn:

; 137  : 
; 138  : 	//! Store the kernel's address space
; 139  : 	root_cr3 = new_cr3;

	mov	rax, QWORD PTR new_cr3$[rsp]
	mov	QWORD PTR ?root_cr3@@3PEA_KEA, rax	; root_cr3

; 140  : 
; 141  : 	//! Switch to new mapping!!!
; 142  : 	x64_write_cr3 ((size_t)new_cr3);

	mov	rcx, QWORD PTR new_cr3$[rsp]
	call	x64_write_cr3

; 143  : 
; 144  : 	AuPmmngrMoveHigher();

	call	?AuPmmngrMoveHigher@@YAXXZ		; AuPmmngrMoveHigher

; 145  : }

	add	rsp, 104				; 00000068H
	ret	0
?AuPagingInit@@YAXXZ ENDP				; AuPagingInit
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
addr$ = 8
?p_index@@YA_K_K@Z PROC					; p_index

; 91   : size_t p_index (uint64_t addr){

	mov	QWORD PTR [rsp+8], rcx

; 92   : 	return (addr & 0x7ff);

	mov	rax, QWORD PTR addr$[rsp]
	and	rax, 2047				; 000007ffH

; 93   : }

	ret	0
?p_index@@YA_K_K@Z ENDP					; p_index
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
addr$ = 8
?pt_index@@YA_K_K@Z PROC				; pt_index

; 87   : size_t pt_index (uint64_t addr){

	mov	QWORD PTR [rsp+8], rcx

; 88   : 	return (addr >> 12) & 0x1ff;

	mov	rax, QWORD PTR addr$[rsp]
	shr	rax, 12
	and	rax, 511				; 000001ffH

; 89   : }

	ret	0
?pt_index@@YA_K_K@Z ENDP				; pt_index
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
addr$ = 8
?pd_index@@YA_K_K@Z PROC				; pd_index

; 83   : size_t pd_index (uint64_t addr){

	mov	QWORD PTR [rsp+8], rcx

; 84   : 	return (addr >> 21) & 0x1ff;

	mov	rax, QWORD PTR addr$[rsp]
	shr	rax, 21
	and	rax, 511				; 000001ffH

; 85   : }

	ret	0
?pd_index@@YA_K_K@Z ENDP				; pd_index
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
addr$ = 8
?pdp_index@@YA_K_K@Z PROC				; pdp_index

; 79   : size_t pdp_index (uint64_t addr){

	mov	QWORD PTR [rsp+8], rcx

; 80   : 	return (addr >> 30) & 0x1ff;

	mov	rax, QWORD PTR addr$[rsp]
	shr	rax, 30
	and	rax, 511				; 000001ffH

; 81   : }

	ret	0
?pdp_index@@YA_K_K@Z ENDP				; pdp_index
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\arch\x86_64\paging.cpp
_TEXT	SEGMENT
addr$ = 8
?pml4_index@@YA_K_K@Z PROC				; pml4_index

; 75   : size_t  pml4_index (uint64_t addr){

	mov	QWORD PTR [rsp+8], rcx

; 76   : 	return (addr >> 39) & 0x1ff;

	mov	rax, QWORD PTR addr$[rsp]
	shr	rax, 39					; 00000027H
	and	rax, 511				; 000001ffH

; 77   : }

	ret	0
?pml4_index@@YA_K_K@Z ENDP				; pml4_index
_TEXT	ENDS
END
