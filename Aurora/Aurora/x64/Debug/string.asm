; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?strcmp@@YAHPEBD0@Z				; strcmp
PUBLIC	?strcpy@@YAPEADPEADPEBD@Z			; strcpy
PUBLIC	?strlen@@YA_KPEBD@Z				; strlen
PUBLIC	?strncmp@@YAHPEBD0_K@Z				; strncmp
PUBLIC	?strncpy@@YAPEADPEADPEBD_K@Z			; strncpy
PUBLIC	?strchr@@YAPEADPEADH@Z				; strchr
PUBLIC	?memset@@YAXPEAXEI@Z				; memset
PUBLIC	?memcmp@@YAHPEBX0_K@Z				; memcmp
pdata	SEGMENT
$pdata$?strcmp@@YAHPEBD0@Z DD imagerel $LN7
	DD	imagerel $LN7+122
	DD	imagerel $unwind$?strcmp@@YAHPEBD0@Z
$pdata$?strcpy@@YAPEADPEADPEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$?strcpy@@YAPEADPEADPEBD@Z
$pdata$?strlen@@YA_KPEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$?strlen@@YA_KPEBD@Z
$pdata$?strncmp@@YAHPEBD0_K@Z DD imagerel $LN7
	DD	imagerel $LN7+150
	DD	imagerel $unwind$?strncmp@@YAHPEBD0_K@Z
$pdata$?strncpy@@YAPEADPEADPEBD_K@Z DD imagerel $LN11
	DD	imagerel $LN11+171
	DD	imagerel $unwind$?strncpy@@YAPEADPEADPEBD_K@Z
$pdata$?strchr@@YAPEADPEADH@Z DD imagerel $LN7
	DD	imagerel $LN7+71
	DD	imagerel $unwind$?strchr@@YAPEADPEADH@Z
$pdata$?memset@@YAXPEAXEI@Z DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$?memset@@YAXPEAXEI@Z
$pdata$?memcmp@@YAHPEBX0_K@Z DD imagerel $LN9
	DD	imagerel $LN9+156
	DD	imagerel $unwind$?memcmp@@YAHPEBX0_K@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?strcmp@@YAHPEBD0@Z DD 010e01H
	DD	0220eH
$unwind$?strcpy@@YAPEADPEADPEBD@Z DD 010e01H
	DD	0220eH
$unwind$?strlen@@YA_KPEBD@Z DD 010901H
	DD	02209H
$unwind$?strncmp@@YAHPEBD0_K@Z DD 011301H
	DD	02213H
$unwind$?strncpy@@YAPEADPEADPEBD_K@Z DD 011301H
	DD	02213H
$unwind$?strchr@@YAPEADPEADH@Z DD 010d01H
	DD	0220dH
$unwind$?memset@@YAXPEAXEI@Z DD 011201H
	DD	02212H
$unwind$?memcmp@@YAHPEBX0_K@Z DD 011301H
	DD	02213H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\string.cpp
_TEXT	SEGMENT
count$ = 0
first$ = 32
second$ = 40
length$ = 48
?memcmp@@YAHPEBX0_K@Z PROC				; memcmp

; 28   : {

$LN9:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 29   : 
; 30   : 	size_t count;
; 31   : 	for (count = 0; count < length; count++)

	mov	QWORD PTR count$[rsp], 0
	jmp	SHORT $LN6@memcmp
$LN5@memcmp:
	mov	rax, QWORD PTR count$[rsp]
	inc	rax
	mov	QWORD PTR count$[rsp], rax
$LN6@memcmp:
	mov	rax, QWORD PTR length$[rsp]
	cmp	QWORD PTR count$[rsp], rax
	jae	SHORT $LN4@memcmp

; 32   : 	{
; 33   : 		if (((unsigned char*)first)[count] != ((unsigned char *) second)[count])

	mov	rax, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR first$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR count$[rsp]
	mov	rdx, QWORD PTR second$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movzx	ecx, BYTE PTR [rcx]
	cmp	eax, ecx
	je	SHORT $LN3@memcmp

; 34   : 		{
; 35   : 			if (((unsigned char*)first)[count] < ((unsigned char *)second)[count])

	mov	rax, QWORD PTR count$[rsp]
	mov	rcx, QWORD PTR first$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR count$[rsp]
	mov	rdx, QWORD PTR second$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movzx	ecx, BYTE PTR [rcx]
	cmp	eax, ecx
	jge	SHORT $LN2@memcmp

; 36   : 			{
; 37   : 				return (-1);

	mov	eax, -1
	jmp	SHORT $LN7@memcmp

; 38   : 			}
; 39   : 			else

	jmp	SHORT $LN1@memcmp
$LN2@memcmp:

; 40   : 			{
; 41   : 				return (1);

	mov	eax, 1
	jmp	SHORT $LN7@memcmp
$LN1@memcmp:
$LN3@memcmp:

; 42   : 			}
; 43   : 		}
; 44   : 	}

	jmp	SHORT $LN5@memcmp
$LN4@memcmp:

; 45   : 
; 46   : 	return (0); //return successful code

	xor	eax, eax
$LN7@memcmp:

; 47   : }

	add	rsp, 24
	ret	0
?memcmp@@YAHPEBX0_K@Z ENDP				; memcmp
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\string.cpp
_TEXT	SEGMENT
tv66 = 0
t$ = 8
targ$ = 32
val$ = 40
len$ = 48
?memset@@YAXPEAXEI@Z PROC				; memset

; 21   : void memset(void *targ, uint8_t val, uint32_t len){

$LN5:
	mov	DWORD PTR [rsp+24], r8d
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 22   : 	uint8_t *t = (uint8_t*) targ;

	mov	rax, QWORD PTR targ$[rsp]
	mov	QWORD PTR t$[rsp], rax
$LN2@memset:

; 23   : 	while (len--)

	mov	eax, DWORD PTR len$[rsp]
	mov	DWORD PTR tv66[rsp], eax
	mov	eax, DWORD PTR len$[rsp]
	dec	eax
	mov	DWORD PTR len$[rsp], eax
	cmp	DWORD PTR tv66[rsp], 0
	je	SHORT $LN1@memset

; 24   : 		*t++ = val;

	mov	rax, QWORD PTR t$[rsp]
	movzx	ecx, BYTE PTR val$[rsp]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR t$[rsp]
	inc	rax
	mov	QWORD PTR t$[rsp], rax
	jmp	SHORT $LN2@memset
$LN1@memset:

; 25   : }

	add	rsp, 24
	ret	0
?memset@@YAXPEAXEI@Z ENDP				; memset
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\string.cpp
_TEXT	SEGMENT
tv69 = 0
str$ = 32
character$ = 40
?strchr@@YAPEADPEADH@Z PROC				; strchr

; 117  : char* strchr (char* str, int character) {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
$LN4@strchr:

; 118  : 
; 119  : 	do {
; 120  : 		if (*str == character)

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, DWORD PTR character$[rsp]
	jne	SHORT $LN1@strchr

; 121  : 			return (char*)str;

	mov	rax, QWORD PTR str$[rsp]
	jmp	SHORT $LN5@strchr
$LN1@strchr:

; 122  : 	}
; 123  : 	while (*str++);

	mov	rax, QWORD PTR str$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv69[rsp], eax
	mov	rax, QWORD PTR str$[rsp]
	inc	rax
	mov	QWORD PTR str$[rsp], rax
	cmp	DWORD PTR tv69[rsp], 0
	jne	SHORT $LN4@strchr

; 124  : 
; 125  : 	return 0;

	xor	eax, eax
$LN5@strchr:

; 126  : }

	add	rsp, 24
	ret	0
?strchr@@YAPEADPEADH@Z ENDP				; strchr
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\string.cpp
_TEXT	SEGMENT
count$ = 0
destString$ = 32
sourceString$ = 40
maxLength$ = 48
?strncpy@@YAPEADPEADPEBD_K@Z PROC			; strncpy

; 89   : {

$LN11:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 90   : 	unsigned count;
; 91   : 
; 92   : 	if ((destString == (char*) NULL) || (sourceString == (char*) NULL))

	cmp	QWORD PTR destString$[rsp], 0
	je	SHORT $LN7@strncpy
	cmp	QWORD PTR sourceString$[rsp], 0
	jne	SHORT $LN8@strncpy
$LN7@strncpy:

; 93   : 	{
; 94   : 		return (destString = NULL);

	mov	QWORD PTR destString$[rsp], 0
	mov	rax, QWORD PTR destString$[rsp]
	jmp	SHORT $LN9@strncpy
$LN8@strncpy:

; 95   : 	}
; 96   : 
; 97   : 	if (maxLength > MAX_STRING_LENGTH)

	cmp	QWORD PTR maxLength$[rsp], 25
	jbe	SHORT $LN6@strncpy

; 98   : 		maxLength = MAX_STRING_LENGTH;

	mov	QWORD PTR maxLength$[rsp], 25
$LN6@strncpy:

; 99   : 
; 100  : 	for (count = 0; count < maxLength; count++ )

	mov	DWORD PTR count$[rsp], 0
	jmp	SHORT $LN5@strncpy
$LN4@strncpy:
	mov	eax, DWORD PTR count$[rsp]
	inc	eax
	mov	DWORD PTR count$[rsp], eax
$LN5@strncpy:
	mov	eax, DWORD PTR count$[rsp]
	cmp	rax, QWORD PTR maxLength$[rsp]
	jae	SHORT $LN3@strncpy

; 101  : 	{
; 102  : 		destString[count] = sourceString[count];

	mov	eax, DWORD PTR count$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	mov	rdx, QWORD PTR destString$[rsp]
	mov	r8, QWORD PTR sourceString$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 103  : 		 
; 104  : 		if (sourceString[count] == '\0')

	mov	eax, DWORD PTR count$[rsp]
	mov	rcx, QWORD PTR sourceString$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN2@strncpy

; 105  : 			break;

	jmp	SHORT $LN3@strncpy
$LN2@strncpy:

; 106  : 	}

	jmp	SHORT $LN4@strncpy
$LN3@strncpy:

; 107  : 
; 108  : 	if (count >= MAX_STRING_LENGTH)

	cmp	DWORD PTR count$[rsp], 25
	jb	SHORT $LN1@strncpy

; 109  : 	{
; 110  : 		return (destString = NULL);

	mov	QWORD PTR destString$[rsp], 0
	mov	rax, QWORD PTR destString$[rsp]
	jmp	SHORT $LN9@strncpy
$LN1@strncpy:

; 111  : 	}
; 112  : 
; 113  : 	return (destString);

	mov	rax, QWORD PTR destString$[rsp]
$LN9@strncpy:

; 114  : }

	add	rsp, 24
	ret	0
?strncpy@@YAPEADPEADPEBD_K@Z ENDP			; strncpy
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\string.cpp
_TEXT	SEGMENT
tv78 = 0
s1$ = 32
s2$ = 40
n$ = 48
?strncmp@@YAHPEBD0_K@Z PROC				; strncmp

; 80   : {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
$LN2@strncmp:

; 81   : 	while (n > 0 && *s1 != '\0' && *s1 == *s2) {

	cmp	QWORD PTR n$[rsp], 0
	jbe	SHORT $LN1@strncmp
	mov	rax, QWORD PTR s1$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN1@strncmp
	mov	rax, QWORD PTR s1$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR s2$[rsp]
	movsx	ecx, BYTE PTR [rcx]
	cmp	eax, ecx
	jne	SHORT $LN1@strncmp

; 82   : 		n --, s1 ++, s2 ++;

	mov	rax, QWORD PTR n$[rsp]
	dec	rax
	mov	QWORD PTR n$[rsp], rax
	mov	rax, QWORD PTR s1$[rsp]
	inc	rax
	mov	QWORD PTR s1$[rsp], rax
	mov	rax, QWORD PTR s2$[rsp]
	inc	rax
	mov	QWORD PTR s2$[rsp], rax

; 83   : 	}

	jmp	SHORT $LN2@strncmp
$LN1@strncmp:

; 84   : 
; 85   : 	return (n==0)? 0: (size_t)((unsigned char)*s1 - (unsigned char)*s2);

	cmp	QWORD PTR n$[rsp], 0
	jne	SHORT $LN5@strncmp
	mov	QWORD PTR tv78[rsp], 0
	jmp	SHORT $LN6@strncmp
$LN5@strncmp:
	mov	rax, QWORD PTR s1$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR s2$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sub	eax, ecx
	cdqe
	mov	QWORD PTR tv78[rsp], rax
$LN6@strncmp:
	mov	eax, DWORD PTR tv78[rsp]

; 86   : }

	add	rsp, 24
	ret	0
?strncmp@@YAHPEBD0_K@Z ENDP				; strncmp
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\string.cpp
_TEXT	SEGMENT
tv69 = 0
len$ = 8
str$ = 32
?strlen@@YA_KPEBD@Z PROC				; strlen

; 72   : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 73   : 	size_t len=0;

	mov	QWORD PTR len$[rsp], 0
$LN2@strlen:

; 74   : 	while (str[len++]);

	mov	rax, QWORD PTR len$[rsp]
	mov	rcx, QWORD PTR str$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv69[rsp], eax
	mov	rax, QWORD PTR len$[rsp]
	inc	rax
	mov	QWORD PTR len$[rsp], rax
	cmp	DWORD PTR tv69[rsp], 0
	je	SHORT $LN1@strlen
	jmp	SHORT $LN2@strlen
$LN1@strlen:

; 75   : 	return len;

	mov	rax, QWORD PTR len$[rsp]

; 76   : }

	add	rsp, 24
	ret	0
?strlen@@YA_KPEBD@Z ENDP				; strlen
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\string.cpp
_TEXT	SEGMENT
tv68 = 0
s1_p$ = 8
s1$ = 32
s2$ = 40
?strcpy@@YAPEADPEADPEBD@Z PROC				; strcpy

; 65   : {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 66   : 	char *s1_p = s1;

	mov	rax, QWORD PTR s1$[rsp]
	mov	QWORD PTR s1_p$[rsp], rax
$LN2@strcpy:

; 67   : 	while (*s1++ = *s2++);

	mov	rax, QWORD PTR s1$[rsp]
	mov	rcx, QWORD PTR s2$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
	mov	rax, QWORD PTR s1$[rsp]
	movsx	eax, BYTE PTR [rax]
	mov	DWORD PTR tv68[rsp], eax
	mov	rax, QWORD PTR s1$[rsp]
	inc	rax
	mov	QWORD PTR s1$[rsp], rax
	mov	rax, QWORD PTR s2$[rsp]
	inc	rax
	mov	QWORD PTR s2$[rsp], rax
	cmp	DWORD PTR tv68[rsp], 0
	je	SHORT $LN1@strcpy
	jmp	SHORT $LN2@strcpy
$LN1@strcpy:

; 68   : 	return s1_p;

	mov	rax, QWORD PTR s1_p$[rsp]

; 69   : }

	add	rsp, 24
	ret	0
?strcpy@@YAPEADPEADPEBD@Z ENDP				; strcpy
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\string.cpp
_TEXT	SEGMENT
res$ = 0
str1$ = 32
str2$ = 40
?strcmp@@YAHPEBD0@Z PROC				; strcmp

; 51   : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 52   : 	int res=0;

	mov	DWORD PTR res$[rsp], 0
$LN4@strcmp:

; 53   : 	while (!(res = *(unsigned char*)str1 - *(unsigned char*)str2) && *str2)

	mov	rax, QWORD PTR str1$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR str2$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	sub	eax, ecx
	mov	DWORD PTR res$[rsp], eax
	cmp	DWORD PTR res$[rsp], 0
	jne	SHORT $LN3@strcmp
	mov	rax, QWORD PTR str2$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@strcmp

; 54   : 		++str1, ++str2;

	mov	rax, QWORD PTR str1$[rsp]
	inc	rax
	mov	QWORD PTR str1$[rsp], rax
	mov	rax, QWORD PTR str2$[rsp]
	inc	rax
	mov	QWORD PTR str2$[rsp], rax
	jmp	SHORT $LN4@strcmp
$LN3@strcmp:

; 55   : 
; 56   : 	if (res < 0)

	cmp	DWORD PTR res$[rsp], 0
	jge	SHORT $LN2@strcmp

; 57   : 		res = -1;

	mov	DWORD PTR res$[rsp], -1
$LN2@strcmp:

; 58   : 	if (res > 0)

	cmp	DWORD PTR res$[rsp], 0
	jle	SHORT $LN1@strcmp

; 59   : 		res = 1;

	mov	DWORD PTR res$[rsp], 1
$LN1@strcmp:

; 60   : 
; 61   : 	return res;

	mov	eax, DWORD PTR res$[rsp]

; 62   : }

	add	rsp, 24
	ret	0
?strcmp@@YAHPEBD0@Z ENDP				; strcmp
_TEXT	ENDS
END
