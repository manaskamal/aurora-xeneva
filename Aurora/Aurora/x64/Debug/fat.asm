; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?part_lba@@3IA					; part_lba
PUBLIC	?fat_begin_lba@@3KA				; fat_begin_lba
PUBLIC	?cluster_begin_lba@@3KA				; cluster_begin_lba
PUBLIC	?sectors_per_cluster@@3EA			; sectors_per_cluster
PUBLIC	?root_dir_first_cluster@@3IA			; root_dir_first_cluster
PUBLIC	?root_sector@@3KA				; root_sector
PUBLIC	?sectors_per_fat32@@3IA				; sectors_per_fat32
PUBLIC	?alloc_counter@@3HA				; alloc_counter
PUBLIC	?total_clusters@@3IA				; total_clusters
PUBLIC	?root_dir_cache@@3PEAEEA			; root_dir_cache
_BSS	SEGMENT
?part_lba@@3IA DD 01H DUP (?)				; part_lba
?fat_begin_lba@@3KA DD 01H DUP (?)			; fat_begin_lba
?cluster_begin_lba@@3KA DD 01H DUP (?)			; cluster_begin_lba
?sectors_per_cluster@@3EA DB 01H DUP (?)		; sectors_per_cluster
	ALIGN	4

?root_dir_first_cluster@@3IA DD 01H DUP (?)		; root_dir_first_cluster
?root_sector@@3KA DD 01H DUP (?)			; root_sector
?sectors_per_fat32@@3IA DD 01H DUP (?)			; sectors_per_fat32
?alloc_counter@@3HA DD 01H DUP (?)			; alloc_counter
?total_clusters@@3IA DD 01H DUP (?)			; total_clusters
	ALIGN	8

?root_dir_cache@@3PEAEEA DQ 01H DUP (?)			; root_dir_cache
_BSS	ENDS
CONST	SEGMENT
$SG3721	DB	'FAT32 BOOT PARAMETER BLOCK ', 0dH, 0aH, 00H
	ORG $+2
$SG3722	DB	'Bytes/Sector -> %d ', 0dH, 0aH, 00H
	ORG $+2
$SG3723	DB	'Sectors/Cluster -> %d ', 0dH, 0aH, 00H
	ORG $+3
$SG3732	DB	'%c', 00H
	ORG $+1
$SG3724	DB	'Reserved Sectors -> %d ', 0dH, 0aH, 00H
	ORG $+2
$SG3733	DB	0dH, 0aH, 00H
	ORG $+1
$SG3725	DB	'Number Of FATs -> %d ', 0dH, 0aH, 00H
$SG3726	DB	'Root Base Cluster -> %d ', 0dH, 0aH, 00H
	ORG $+1
$SG3738	DB	'%c', 00H
	ORG $+1
$SG3727	DB	'Sector/FAT32 -> %d ', 0dH, 0aH, 00H
	ORG $+2
$SG3739	DB	0dH, 0aH, 00H
	ORG $+1
$SG3927	DB	'/', 00H
	ORG $+2
$SG3740	DB	'FAT32 Total clusters -> %d ', 0dH, 0aH, 00H
	ORG $+2
$SG3928	DB	'/', 00H
	ORG $+6
$SG3929	DB	'File System registered', 0aH, 00H
CONST	ENDS
PUBLIC	?initialize_fat32@@YAXXZ			; initialize_fat32
PUBLIC	?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z	; fat32_open
PUBLIC	?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z	; fat32_read_file
PUBLIC	?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z		; fat32_read
PUBLIC	?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z	; fat32_locate_dir
PUBLIC	?fat32_self_register@@YAXXZ			; fat32_self_register
PUBLIC	?fat32_find_free_cluster@@YAIXZ			; fat32_find_free_cluster
PUBLIC	?fat32_alloc_cluster@@YAXHI@Z			; fat32_alloc_cluster
PUBLIC	?fat32_get_root_sector@@YA_KXZ			; fat32_get_root_sector
PUBLIC	?fat32_get_root_cluster@@YAIXZ			; fat32_get_root_cluster
PUBLIC	?fat32_get_sector_per_cluster@@YA_KXZ		; fat32_get_sector_per_cluster
PUBLIC	?cluster_to_sector32@@YA_K_K@Z			; cluster_to_sector32
PUBLIC	?fat32_read_fat@@YAII@Z				; fat32_read_fat
PUBLIC	?fat32_clear_cluster@@YAXI@Z			; fat32_clear_cluster
PUBLIC	?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z ; fat32_locate_subdir
PUBLIC	?fat32_format_date@@YAGXZ			; fat32_format_date
PUBLIC	?fat32_format_time@@YAGXZ			; fat32_format_time
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	vfs_mount:PROC
EXTRN	?fat32_to_dos_file_name@@YAXPEBDPEADI@Z:PROC	; fat32_to_dos_file_name
EXTRN	printf:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	p2v:PROC
EXTRN	v2p:PROC
EXTRN	malloc:PROC
EXTRN	?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z:PROC ; ahci_disk_write
EXTRN	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z:PROC ; ahci_disk_read
EXTRN	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ:PROC	; ahci_disk_get_port
EXTRN	_debug_print_:PROC
EXTRN	AuGetYear:PROC
EXTRN	AuGetSecond:PROC
EXTRN	AuGetDay:PROC
EXTRN	AuGetHour:PROC
EXTRN	AuGetMinutes:PROC
EXTRN	AuGetMonth:PROC
pdata	SEGMENT
$pdata$?initialize_fat32@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+535
	DD	imagerel $unwind$?initialize_fat32@@YAXXZ
$pdata$?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z DD imagerel $LN17
	DD	imagerel $LN17+745
	DD	imagerel $unwind$?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z
$pdata$?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z DD imagerel $LN7
	DD	imagerel $LN7+103
	DD	imagerel $unwind$?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z
$pdata$?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z DD imagerel $LN5
	DD	imagerel $LN5+139
	DD	imagerel $unwind$?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z
$pdata$?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+521
	DD	imagerel $unwind$?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z
$pdata$?fat32_self_register@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+213
	DD	imagerel $unwind$?fat32_self_register@@YAXXZ
$pdata$?fat32_find_free_cluster@@YAIXZ DD imagerel $LN7
	DD	imagerel $LN7+235
	DD	imagerel $unwind$?fat32_find_free_cluster@@YAIXZ
$pdata$?fat32_alloc_cluster@@YAXHI@Z DD imagerel $LN3
	DD	imagerel $LN3+265
	DD	imagerel $unwind$?fat32_alloc_cluster@@YAXHI@Z
$pdata$?fat32_read_fat@@YAII@Z DD imagerel $LN3
	DD	imagerel $LN3+218
	DD	imagerel $unwind$?fat32_read_fat@@YAII@Z
$pdata$?fat32_clear_cluster@@YAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+119
	DD	imagerel $unwind$?fat32_clear_cluster@@YAXI@Z
$pdata$?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+470
	DD	imagerel $unwind$?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z
$pdata$?fat32_format_date@@YAGXZ DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$?fat32_format_date@@YAGXZ
$pdata$?fat32_format_time@@YAGXZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?fat32_format_time@@YAGXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?initialize_fat32@@YAXXZ DD 010401H
	DD	08204H
$unwind$?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z DD 041801H
	DD	0910118H
	DD	060107011H
$unwind$?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z DD 011301H
	DD	06213H
$unwind$?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z DD 010e01H
	DD	0620eH
$unwind$?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z DD 041301H
	DD	01d0113H
	DD	0600b700cH
$unwind$?fat32_self_register@@YAXXZ DD 010401H
	DD	06204H
$unwind$?fat32_find_free_cluster@@YAIXZ DD 010401H
	DD	0a204H
$unwind$?fat32_alloc_cluster@@YAXHI@Z DD 010c01H
	DD	0a20cH
$unwind$?fat32_read_fat@@YAII@Z DD 010801H
	DD	0a208H
$unwind$?fat32_clear_cluster@@YAXI@Z DD 010801H
	DD	08208H
$unwind$?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z DD 041801H
	DD	01b0118H
	DD	060107011H
$unwind$?fat32_format_date@@YAGXZ DD 010401H
	DD	06204H
$unwind$?fat32_format_time@@YAGXZ DD 010401H
	DD	06204H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
tv66 = 32
tv70 = 36
?fat32_format_time@@YAGXZ PROC				; fat32_format_time

; 474  : uint16_t fat32_format_time () {

$LN3:
	sub	rsp, 56					; 00000038H

; 475  : 	return (uint16_t)AuGetHour() << 11 | (uint16_t)AuGetMinutes() << 5 | (uint16_t)AuGetSecond()/2;

	call	AuGetHour
	movzx	eax, al
	shl	eax, 11
	mov	DWORD PTR tv66[rsp], eax
	call	AuGetMinutes
	movzx	eax, al
	shl	eax, 5
	mov	ecx, DWORD PTR tv66[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv70[rsp], eax
	call	AuGetSecond
	movzx	eax, al
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR tv70[rsp]
	or	ecx, eax
	mov	eax, ecx

; 476  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_format_time@@YAGXZ ENDP				; fat32_format_time
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
tv70 = 32
tv74 = 36
?fat32_format_date@@YAGXZ PROC				; fat32_format_date

; 466  : uint16_t fat32_format_date () {

$LN3:
	sub	rsp, 56					; 00000038H

; 467  : 	return (uint16_t)(2000 + AuGetYear()-1980)<<9 | (uint16_t)AuGetMonth() << 5 | (uint16_t)AuGetDay();

	call	AuGetYear
	movzx	eax, al
	add	eax, 20
	movzx	eax, ax
	shl	eax, 9
	mov	DWORD PTR tv70[rsp], eax
	call	AuGetMonth
	movzx	eax, al
	shl	eax, 5
	mov	ecx, DWORD PTR tv70[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv74[rsp], eax
	call	AuGetDay
	movzx	eax, al
	mov	ecx, DWORD PTR tv74[rsp]
	or	ecx, eax
	mov	eax, ecx

; 468  : 	//return (uint16_t)(2022-1980) <<9 | (uint16_t)3 << 5 | (uint16_t)6;
; 469  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_format_date@@YAGXZ ENDP				; fat32_format_date
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
pkDir$2 = 40
buf$ = 48
aligned_buf$3 = 56
name$4 = 64
dos_file_name$ = 80
file$ = 96
$T5 = 240
kfile$ = 248
filename$ = 256
?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z PROC	; fat32_locate_subdir

; 300  : vfs_node_t fat32_locate_subdir (vfs_node_t kfile, const char* filename) {

$LN12:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 216				; 000000d8H

; 301  : 
; 302  : 	vfs_node_t file;
; 303  : 
; 304  : 	char dos_file_name[11];
; 305  : 	fat32_to_dos_file_name (filename, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?fat32_to_dos_file_name@@YAXPEBDPEADI@Z	; fat32_to_dos_file_name

; 306  : 	//dos_file_name[11] = 0;
; 307  : 	uint64_t* buf = (uint64_t*)p2v((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	p2v
	mov	QWORD PTR buf$[rsp], rax

; 308  : 	if (kfile.flags != FS_FLAG_INVALID) {

	mov	rax, QWORD PTR kfile$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 3
	je	$LN9@fat32_loca
$LN8@fat32_loca:

; 309  : 		
; 310  : 		//! read the directory
; 311  : 		while (!kfile.eof) {

	mov	rax, QWORD PTR kfile$[rsp]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	jne	$LN7@fat32_loca

; 312  : 
; 313  : 			//! read 
; 314  : 		
; 315  : 			fat32_read (&kfile, (uint64_t*)v2p((uint64_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	v2p
	mov	rdx, rax
	mov	rcx, QWORD PTR kfile$[rsp]
	call	?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z	; fat32_read

; 316  : 			//! set directory
; 317  : 			uint8_t* aligned_buf = (uint8_t*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR aligned_buf$3[rsp], rax

; 318  : 			fat32_dir* pkDir = (fat32_dir*)aligned_buf;

	mov	rax, QWORD PTR aligned_buf$3[rsp]
	mov	QWORD PTR pkDir$2[rsp], rax

; 319  : 
; 320  : 			//! 16 entries
; 321  : 			for (unsigned int i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@fat32_loca
$LN5@fat32_loca:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@fat32_loca:
	cmp	DWORD PTR i$1[rsp], 16
	jae	$LN4@fat32_loca

; 322  : 
; 323  : 				//! get current filename;
; 324  : 				char name[11];
; 325  : 				memcpy (name, pkDir->filename, 11);

	mov	rax, QWORD PTR pkDir$2[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$4[rsp]
	call	memcpy

; 326  : 				//name[11] = 0;
; 327  : 
; 328  : 				if (strcmp (name, dos_file_name) == 0) {

	lea	rdx, QWORD PTR dos_file_name$[rsp]
	lea	rcx, QWORD PTR name$4[rsp]
	call	strcmp
	test	eax, eax
	jne	$LN3@fat32_loca

; 329  : 
; 330  : 					//! found file
; 331  : 					strcpy (file.filename, filename);

	mov	rdx, QWORD PTR filename$[rsp]
	lea	rcx, QWORD PTR file$[rsp]
	call	strcpy

; 332  : 					file.current = pkDir->first_cluster;

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	DWORD PTR file$[rsp+44], eax

; 333  : 					file.size = pkDir->file_size;

	mov	rax, QWORD PTR pkDir$2[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR file$[rsp+32], eax

; 334  : 					file.eof = 0;

	mov	BYTE PTR file$[rsp+36], 0

; 335  : 					file.status = FS_STATUS_FOUND;

	mov	BYTE PTR file$[rsp+49], 4

; 336  : 					//! set file type
; 337  : 					if (pkDir->attrib == 0x10)

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	eax, 16
	jne	SHORT $LN2@fat32_loca

; 338  : 						file.flags = FS_FLAG_DIRECTORY;

	mov	BYTE PTR file$[rsp+48], 1

; 339  : 					else

	jmp	SHORT $LN1@fat32_loca
$LN2@fat32_loca:

; 340  : 						file.flags = FS_FLAG_GENERAL;

	mov	BYTE PTR file$[rsp+48], 2
$LN1@fat32_loca:

; 341  : 
; 342  : 					AuPmmngrFree((void*)v2p((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	v2p
	mov	rcx, rax
	call	AuPmmngrFree

; 343  : 					//!return file
; 344  : 					return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T5[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T5[rsp]
	jmp	SHORT $LN10@fat32_loca
$LN3@fat32_loca:

; 345  : 				}
; 346  : 
; 347  : 				//! go to next entry
; 348  : 				pkDir++;

	mov	rax, QWORD PTR pkDir$2[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR pkDir$2[rsp], rax

; 349  : 			}

	jmp	$LN5@fat32_loca
$LN4@fat32_loca:

; 350  : 
; 351  : 			//pmmngr_free (buf);
; 352  : 		}

	jmp	$LN8@fat32_loca
$LN7@fat32_loca:
$LN9@fat32_loca:

; 353  : 	}
; 354  : 
; 355  : 	AuPmmngrFree((void*)v2p((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	v2p
	mov	rcx, rax
	call	AuPmmngrFree

; 356  : 	file.flags = FS_FLAG_INVALID;

	mov	BYTE PTR file$[rsp+48], 3

; 357  : 	return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T5[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T5[rsp]
$LN10@fat32_loca:

; 358  : }

	add	rsp, 216				; 000000d8H
	pop	rdi
	pop	rsi
	ret	0
?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z ENDP	; fat32_locate_subdir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
sector$ = 32
tv73 = 36
buffer$ = 40
tv75 = 48
cluster$ = 80
?fat32_clear_cluster@@YAXI@Z PROC			; fat32_clear_cluster

; 186  : void fat32_clear_cluster (uint32_t cluster) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 187  : 	uint64_t *buffer = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buffer$[rsp], rax

; 188  : 	memset (buffer, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 189  : 	//update_cluster (buffer,cluster);
; 190  : 	uint32_t sector = cluster_to_sector32 (cluster);

	mov	eax, DWORD PTR cluster$[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR sector$[rsp], eax

; 191  : 	ahci_disk_write (ahci_disk_get_port(),sector,sectors_per_cluster,buffer);

	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	mov	DWORD PTR tv73[rsp], eax
	mov	ecx, DWORD PTR sector$[rsp]
	mov	QWORD PTR tv75[rsp], rcx
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buffer$[rsp]
	mov	ecx, DWORD PTR tv73[rsp]
	mov	r8d, ecx
	mov	rcx, QWORD PTR tv75[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_write

; 192  : 	AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$[rsp]
	call	AuPmmngrFree

; 193  : }

	add	rsp, 72					; 00000048H
	ret	0
?fat32_clear_cluster@@YAXI@Z ENDP			; fat32_clear_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
buf_area$ = 40
tv76 = 48
fat_sector$ = 56
ent_offset$ = 64
buf$ = 72
cluster_index$ = 96
?fat32_read_fat@@YAII@Z PROC				; fat32_read_fat

; 120  : uint32_t fat32_read_fat (uint32_t cluster_index) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 121  : 	auto fat_offset = cluster_index * 4;

	mov	eax, DWORD PTR cluster_index$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 122  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 123  : 	size_t ent_offset = fat_offset  % 512;

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	mov	eax, eax
	mov	QWORD PTR ent_offset$[rsp], rax

; 124  : 	uint64_t *buf_area = (uint64_t*)p2v((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	p2v
	mov	QWORD PTR buf_area$[rsp], rax

; 125  : 	memset(buf_area,0,4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf_area$[rsp]
	call	memset

; 126  : 	//ata_read_28 (fat_sector,1,buf);
; 127  : 	ahci_disk_read (ahci_disk_get_port(),fat_sector,1,(uint64_t*)v2p((size_t)buf_area));

	mov	rcx, QWORD PTR buf_area$[rsp]
	call	v2p
	mov	QWORD PTR tv76[rsp], rax
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	rcx, QWORD PTR tv76[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 128  : 	unsigned char *buf = (unsigned char*)buf_area;

	mov	rax, QWORD PTR buf_area$[rsp]
	mov	QWORD PTR buf$[rsp], rax

; 129  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 130  : 	AuPmmngrFree((void*)v2p((size_t)buf_area));

	mov	rcx, QWORD PTR buf_area$[rsp]
	call	v2p
	mov	rcx, rax
	call	AuPmmngrFree

; 131  : 	return value & 0x0FFFFFFF;

	mov	eax, DWORD PTR value$[rsp]
	and	eax, 268435455				; 0fffffffH

; 132  : }

	add	rsp, 88					; 00000058H
	ret	0
?fat32_read_fat@@YAII@Z ENDP				; fat32_read_fat
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
cluster$ = 8
?cluster_to_sector32@@YA_K_K@Z PROC			; cluster_to_sector32

; 62   : uint64_t  cluster_to_sector32 (uint64_t cluster){

	mov	QWORD PTR [rsp+8], rcx

; 63   : 	return cluster_begin_lba + (cluster - 2) * sectors_per_cluster ;

	mov	eax, DWORD PTR ?cluster_begin_lba@@3KA	; cluster_begin_lba
	mov	rcx, QWORD PTR cluster$[rsp]
	sub	rcx, 2
	movzx	edx, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	imul	rcx, rdx
	add	rax, rcx

; 64   : }

	ret	0
?cluster_to_sector32@@YA_K_K@Z ENDP			; cluster_to_sector32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
?fat32_get_sector_per_cluster@@YA_KXZ PROC		; fat32_get_sector_per_cluster

; 460  : 	return sectors_per_cluster;

	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster

; 461  : }

	ret	0
?fat32_get_sector_per_cluster@@YA_KXZ ENDP		; fat32_get_sector_per_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
?fat32_get_root_cluster@@YAIXZ PROC			; fat32_get_root_cluster

; 453  : 	return root_dir_first_cluster;

	mov	eax, DWORD PTR ?root_dir_first_cluster@@3IA ; root_dir_first_cluster

; 454  : }

	ret	0
?fat32_get_root_cluster@@YAIXZ ENDP			; fat32_get_root_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
?fat32_get_root_sector@@YA_KXZ PROC			; fat32_get_root_sector

; 446  : 	return root_sector;

	mov	eax, DWORD PTR ?root_sector@@3KA	; root_sector

; 447  : }

	ret	0
?fat32_get_root_sector@@YA_KXZ ENDP			; fat32_get_root_sector
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
value2$ = 40
buffer$ = 48
ent_offset$ = 56
buf$ = 64
fat_sector$ = 72
position$ = 96
n_value$ = 104
?fat32_alloc_cluster@@YAXHI@Z PROC			; fat32_alloc_cluster

; 165  : void fat32_alloc_cluster (int position, uint32_t n_value) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 166  : 	auto fat_offset = position * 4;

	mov	eax, DWORD PTR position$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 167  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	mov	eax, DWORD PTR fat_offset$[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 168  : 	size_t ent_offset = fat_offset  % 512;

	mov	eax, DWORD PTR fat_offset$[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	and	eax, 511				; 000001ffH
	sub	eax, edx
	cdqe
	mov	QWORD PTR ent_offset$[rsp], rax

; 169  : 	uint64_t *buffer = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buffer$[rsp], rax

; 170  : 	memset(buffer,0,4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 171  : 	ahci_disk_read(ahci_disk_get_port(),fat_sector,1,buffer);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buffer$[rsp]
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 172  : 
; 173  : 	uint8_t* buf = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR buf$[rsp], rax

; 174  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 175  : 	*(uint32_t*)&buf[ent_offset] = n_value & 0x0FFFFFFF;

	mov	eax, DWORD PTR n_value$[rsp]
	and	eax, 268435455				; 0fffffffH
	mov	rcx, QWORD PTR ent_offset$[rsp]
	mov	rdx, QWORD PTR buf$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	DWORD PTR [rcx], eax

; 176  : 
; 177  : 	uint32_t value2 = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value2$[rsp], eax

; 178  : 	ahci_disk_write(ahci_disk_get_port(),fat_sector,1,buffer);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buffer$[rsp]
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, rax
	call	?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_write

; 179  : 	AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$[rsp]
	call	AuPmmngrFree

; 180  : }

	add	rsp, 88					; 00000058H
	ret	0
?fat32_alloc_cluster@@YAXHI@Z ENDP			; fat32_alloc_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
fat_offset$2 = 36
value$3 = 40
buffer$4 = 48
fat_sector$5 = 56
ent_offset$6 = 64
buf$7 = 72
?fat32_find_free_cluster@@YAIXZ PROC			; fat32_find_free_cluster

; 139  : uint32_t fat32_find_free_cluster () {

$LN7:
	sub	rsp, 88					; 00000058H

; 140  : 	//!iterate through every sectors in fat32 table
; 141  : 	for (int i = 2; i < total_clusters; i++) {

	mov	DWORD PTR i$1[rsp], 2
	jmp	SHORT $LN4@fat32_find
$LN3@fat32_find:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@fat32_find:
	mov	eax, DWORD PTR ?total_clusters@@3IA	; total_clusters
	cmp	DWORD PTR i$1[rsp], eax
	jae	$LN2@fat32_find

; 142  : 		auto fat_offset = i * 4;

	mov	eax, DWORD PTR i$1[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$2[rsp], eax

; 143  : 		uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	mov	eax, DWORD PTR fat_offset$2[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$5[rsp], rax

; 144  : 		size_t ent_offset = fat_offset  % 512;

	mov	eax, DWORD PTR fat_offset$2[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	and	eax, 511				; 000001ffH
	sub	eax, edx
	cdqe
	mov	QWORD PTR ent_offset$6[rsp], rax

; 145  : 		uint64_t *buffer = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buffer$4[rsp], rax

; 146  : 		memset(buffer,0,4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$4[rsp]
	call	memset

; 147  : 		ahci_disk_read(ahci_disk_get_port(),fat_sector,1,buffer);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buffer$4[rsp]
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$5[rsp]
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 148  : 		uint8_t* buf = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$4[rsp]
	mov	QWORD PTR buf$7[rsp], rax

; 149  : 		uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$6[rsp]
	mov	rcx, QWORD PTR buf$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$3[rsp], eax

; 150  : 
; 151  : 		AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$4[rsp]
	call	AuPmmngrFree

; 152  : 		//! Found a free cluster return the value
; 153  : 		if (value == 0x00) {

	cmp	DWORD PTR value$3[rsp], 0
	jne	SHORT $LN1@fat32_find

; 154  : 			return i;

	mov	eax, DWORD PTR i$1[rsp]
	jmp	SHORT $LN5@fat32_find
$LN1@fat32_find:

; 155  : 		}
; 156  : 	}

	jmp	$LN3@fat32_find
$LN2@fat32_find:

; 157  : 	return 0;

	xor	eax, eax
$LN5@fat32_find:

; 158  : }

	add	rsp, 88					; 00000058H
	ret	0
?fat32_find_free_cluster@@YAIXZ ENDP			; fat32_find_free_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
fsys$ = 32
?fat32_self_register@@YAXXZ PROC			; fat32_self_register

; 481  : void fat32_self_register () {

$LN3:
	sub	rsp, 56					; 00000038H

; 482  : 	vfs_node_t *fsys = (vfs_node_t*)malloc(sizeof(vfs_node_t));

	mov	ecx, 104				; 00000068H
	call	malloc
	mov	QWORD PTR fsys$[rsp], rax

; 483  : 	strcpy (fsys->filename, "/");

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rdx, OFFSET FLAT:$SG3927
	mov	rcx, rax
	call	strcpy

; 484  : 	fsys->size = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+32], 0

; 485  : 	fsys->eof = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	BYTE PTR [rax+36], 0

; 486  : 	fsys->pos = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+40], 0

; 487  : 	fsys->current = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+44], 0

; 488  : 	fsys->flags = FS_FLAG_GENERAL;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	BYTE PTR [rax+48], 2

; 489  : 	fsys->status = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	BYTE PTR [rax+49], 0

; 490  : 	fsys->open = fat32_open;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z ; fat32_open
	mov	QWORD PTR [rax+64], rcx

; 491  : 	fsys->read = fat32_read_file;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z ; fat32_read_file
	mov	QWORD PTR [rax+72], rcx

; 492  : 	fsys->write = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+80], 0

; 493  : 	fsys->read_blk = fat32_read;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z ; fat32_read
	mov	QWORD PTR [rax+88], rcx

; 494  : 	fsys->ioquery = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+96], 0

; 495  : 	vfs_mount ("/", fsys, 0);

	xor	r8d, r8d
	mov	rdx, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:$SG3928
	call	vfs_mount

; 496  : 	printf ("File System registered\n");

	lea	rcx, OFFSET FLAT:$SG3929
	call	printf

; 497  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_self_register@@YAXXZ ENDP			; fat32_self_register
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
sector$1 = 32
i$2 = 36
dirent$ = 40
buf$ = 48
name$3 = 56
tv76 = 72
tv81 = 80
aligned_buf$4 = 88
dos_file_name$ = 96
file$ = 112
$T5 = 256
dir$ = 264
?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z PROC		; fat32_locate_dir

; 246  : vfs_node_t fat32_locate_dir (const char* dir) {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 232				; 000000e8H

; 247  : 	vfs_node_t file;
; 248  : 	uint64_t* buf;
; 249  : 	fat32_dir *dirent;
; 250  : 	char dos_file_name[11];
; 251  : 	fat32_to_dos_file_name (dir, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	?fat32_to_dos_file_name@@YAXPEBDPEADI@Z	; fat32_to_dos_file_name

; 252  : 
; 253  : 	buf = (uint64_t*)p2v((uint64_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	p2v
	mov	QWORD PTR buf$[rsp], rax

; 254  : 	for (unsigned int sector = 0; sector < sectors_per_cluster; sector++) {

	mov	DWORD PTR sector$1[rsp], 0
	jmp	SHORT $LN9@fat32_loca
$LN8@fat32_loca:
	mov	eax, DWORD PTR sector$1[rsp]
	inc	eax
	mov	DWORD PTR sector$1[rsp], eax
$LN9@fat32_loca:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR sector$1[rsp], eax
	jae	$LN7@fat32_loca

; 255  : 
; 256  : 		memset (buf, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rsp]
	call	memset

; 257  : 		//ata_read_28 (root_sector + sector,1, buf);
; 258  : 		ahci_disk_read(ahci_disk_get_port(),root_sector + sector,1,(uint64_t*)v2p((uint64_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	v2p
	mov	QWORD PTR tv76[rsp], rax
	mov	ecx, DWORD PTR sector$1[rsp]
	mov	edx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	edx, ecx
	mov	ecx, edx
	mov	ecx, ecx
	mov	QWORD PTR tv81[rsp], rcx
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	rcx, QWORD PTR tv76[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rcx, QWORD PTR tv81[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 259  : 
; 260  : 		uint8_t* aligned_buf = (uint8_t*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR aligned_buf$4[rsp], rax

; 261  : 		dirent = (fat32_dir*)aligned_buf;

	mov	rax, QWORD PTR aligned_buf$4[rsp]
	mov	QWORD PTR dirent$[rsp], rax

; 262  : 
; 263  : 		for (int i=0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN6@fat32_loca
$LN5@fat32_loca:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN6@fat32_loca:
	cmp	DWORD PTR i$2[rsp], 16
	jge	$LN4@fat32_loca

; 264  : 			char name[11];
; 265  : 			memcpy (name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rsp]
	call	memcpy

; 266  : 			name[11] = 0;

	mov	eax, 1
	imul	rax, 11
	mov	BYTE PTR name$3[rsp+rax], 0

; 267  : 		
; 268  : 			if (strcmp (dos_file_name, name) == 0) {

	lea	rdx, QWORD PTR name$3[rsp]
	lea	rcx, QWORD PTR dos_file_name$[rsp]
	call	strcmp
	test	eax, eax
	jne	$LN3@fat32_loca

; 269  : 				
; 270  : 				strcpy (file.filename, dir);

	mov	rdx, QWORD PTR dir$[rsp]
	lea	rcx, QWORD PTR file$[rsp]
	call	strcpy

; 271  : 				file.current = dirent->first_cluster;

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	DWORD PTR file$[rsp+44], eax

; 272  : 				file.size = dirent->file_size;

	mov	rax, QWORD PTR dirent$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR file$[rsp+32], eax

; 273  : 				file.eof = 0;

	mov	BYTE PTR file$[rsp+36], 0

; 274  : 				file.status = FS_STATUS_FOUND;

	mov	BYTE PTR file$[rsp+49], 4

; 275  : 
; 276  : 				if (dirent->attrib == 0x10)

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	eax, 16
	jne	SHORT $LN2@fat32_loca

; 277  : 					file.flags = FS_FLAG_DIRECTORY;

	mov	BYTE PTR file$[rsp+48], 1

; 278  : 				else

	jmp	SHORT $LN1@fat32_loca
$LN2@fat32_loca:

; 279  : 					file.flags = FS_FLAG_GENERAL;

	mov	BYTE PTR file$[rsp+48], 2
$LN1@fat32_loca:

; 280  : 				
; 281  : 				//AuPmmngrFree((void*)v2p((size_t)buf));
; 282  : 				return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T5[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T5[rsp]
	jmp	SHORT $LN10@fat32_loca
$LN3@fat32_loca:

; 283  : 			}
; 284  : 			dirent++;

	mov	rax, QWORD PTR dirent$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$[rsp], rax

; 285  : 		}

	jmp	$LN5@fat32_loca
$LN4@fat32_loca:

; 286  : 	}

	jmp	$LN8@fat32_loca
$LN7@fat32_loca:

; 287  : 
; 288  : 	file.status = FS_FLAG_INVALID;

	mov	BYTE PTR file$[rsp+49], 3

; 289  : 	file.size = 0;

	mov	DWORD PTR file$[rsp+32], 0

; 290  : 	file.eof = 0;

	mov	BYTE PTR file$[rsp+36], 0

; 291  : 	return file;

	lea	rax, QWORD PTR file$[rsp]
	mov	rdi, QWORD PTR $T5[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T5[rsp]
$LN10@fat32_loca:

; 292  : }

	add	rsp, 232				; 000000e8H
	pop	rdi
	pop	rsi
	ret	0
?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z ENDP		; fat32_locate_dir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
value$ = 32
lba$ = 40
file$ = 64
buf$ = 72
?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z PROC		; fat32_read

; 200  : void fat32_read (vfs_node_t *file, uint64_t* buf) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 201  : 
; 202  : 	auto lba = cluster_to_sector32 (file->current); 

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+44]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	QWORD PTR lba$[rsp], rax

; 203  : 
; 204  : 	ahci_disk_read(ahci_disk_get_port(), lba, 8,buf);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buf$[rsp]
	mov	r8d, 8
	mov	rdx, QWORD PTR lba$[rsp]
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 205  : 
; 206  : 	uint32_t value = fat32_read_fat (file->current);

	mov	rax, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR [rax+44]
	call	?fat32_read_fat@@YAII@Z			; fat32_read_fat
	mov	DWORD PTR value$[rsp], eax

; 207  : 
; 208  : 	if (value  >= 0x0FFFFFF8) {

	cmp	DWORD PTR value$[rsp], 268435448	; 0ffffff8H
	jb	SHORT $LN2@fat32_read

; 209  : 	    file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 1

; 210  : 		return;

	jmp	SHORT $LN3@fat32_read
$LN2@fat32_read:

; 211  : 	}
; 212  : 
; 213  : 	if (value  == 0x0FFFFFF7) {

	cmp	DWORD PTR value$[rsp], 268435447	; 0ffffff7H
	jne	SHORT $LN1@fat32_read

; 214  : 	    file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 1

; 215  : 		return;

	jmp	SHORT $LN3@fat32_read
$LN1@fat32_read:

; 216  : 	}
; 217  : 	
; 218  : 	file->current = value;

	mov	rax, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+44], ecx
$LN3@fat32_read:

; 219  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z ENDP		; fat32_read
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
file$ = 64
buffer$ = 72
count$ = 80
?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z PROC	; fat32_read_file

; 229  : void fat32_read_file (vfs_node_t *file, uint64_t* buffer, uint32_t count) {

$LN7:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 230  : 	/*while(file->eof != 1) {
; 231  : 		fat32_read (file,buffer);
; 232  : 		buffer += 4096;
; 233  : 	}*/
; 234  : 	for (int i=0; i < count; i+= 8) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@fat32_read
$LN3@fat32_read:
	mov	eax, DWORD PTR i$1[rsp]
	add	eax, 8
	mov	DWORD PTR i$1[rsp], eax
$LN4@fat32_read:
	mov	eax, DWORD PTR count$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@fat32_read

; 235  : 		fat32_read (file, buffer);

	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	call	?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z	; fat32_read

; 236  : 		if (file->eof) 

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	je	SHORT $LN1@fat32_read

; 237  : 			break;

	jmp	SHORT $LN2@fat32_read
$LN1@fat32_read:

; 238  : 		buffer += 4096;

	mov	rax, QWORD PTR buffer$[rsp]
	add	rax, 32768				; 00008000H
	mov	QWORD PTR buffer$[rsp], rax

; 239  : 	}

	jmp	SHORT $LN3@fat32_read
$LN2@fat32_read:

; 240  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z ENDP	; fat32_read_file
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
root_dir$ = 32
i$1 = 36
p$ = 40
path$ = 48
pathname$2 = 56
cur_dir$ = 80
ret$ = 192
ret$3 = 304
$T4 = 416
$T5 = 528
$T6 = 632
$T7 = 736
$T8 = 840
$T9 = 944
$T10 = 1048
$T11 = 1184
node$ = 1192
filename$ = 1200
?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z PROC		; fat32_open

; 365  : vfs_node_t fat32_open (vfs_node_t * node, char* filename) {

$LN17:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 1160				; 00000488H

; 366  : 	vfs_node_t cur_dir;
; 367  : 	char* p = 0;

	mov	QWORD PTR p$[rsp], 0

; 368  : 	bool  root_dir = true;

	mov	BYTE PTR root_dir$[rsp], 1

; 369  : 	char* path = (char*) filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR path$[rsp], rax

; 370  : 
; 371  : 	//! any '\'s in path ?
; 372  : 	p = strchr (path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 373  : 	if (!p) {

	cmp	QWORD PTR p$[rsp], 0
	jne	$LN14@fat32_open

; 374  : 		//! nope, must be in root directory, search it
; 375  : 		cur_dir = fat32_locate_dir (path);

	mov	rdx, QWORD PTR path$[rsp]
	lea	rcx, QWORD PTR $T8[rsp]
	call	?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z ; fat32_locate_dir
	lea	rcx, QWORD PTR $T6[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	lea	rax, QWORD PTR cur_dir$[rsp]
	lea	rcx, QWORD PTR $T6[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 104				; 00000068H
	rep movsb

; 376  : 
; 377  : 		//! found file ?
; 378  : 		if (cur_dir.flags == FS_FLAG_GENERAL) {

	movzx	eax, BYTE PTR cur_dir$[rsp+48]
	cmp	eax, 2
	jne	SHORT $LN13@fat32_open

; 379  : 			return cur_dir;

	lea	rax, QWORD PTR cur_dir$[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN15@fat32_open
$LN13@fat32_open:

; 380  : 		}
; 381  : 
; 382  : 		//! unable to find
; 383  : 		vfs_node_t ret;
; 384  : 		ret.flags = FS_FLAG_INVALID;

	mov	BYTE PTR ret$3[rsp+48], 3

; 385  : 		ret.size = 0;

	mov	DWORD PTR ret$3[rsp+32], 0

; 386  : 		return ret;

	lea	rax, QWORD PTR ret$3[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
	jmp	$LN15@fat32_open
$LN14@fat32_open:

; 387  : 	}
; 388  : 
; 389  : 	//! go to next character after first '\'
; 390  : 	p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN12@fat32_open:

; 391  : 
; 392  : 	while (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	$LN11@fat32_open

; 393  : 
; 394  : 		//! get pathname
; 395  : 		char pathname[16];
; 396  : 		int i=0;

	mov	DWORD PTR i$1[rsp], 0

; 397  : 		for (i=0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN10@fat32_open
$LN9@fat32_open:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN10@fat32_open:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN8@fat32_open

; 398  : 
; 399  : 			//! if another '\' or end of line is reached, we are done
; 400  : 			if (p[i] == '/' || p[i]=='\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN6@fat32_open
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN7@fat32_open
$LN6@fat32_open:

; 401  : 				break;

	jmp	SHORT $LN8@fat32_open
$LN7@fat32_open:

; 402  : 
; 403  : 			//! copy character
; 404  : 			pathname[i]=p[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$2[rsp+rcx], al

; 405  : 		}

	jmp	SHORT $LN9@fat32_open
$LN8@fat32_open:

; 406  : 		pathname[i]=0; //null terminate

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$2[rsp+rax], 0

; 407  : 
; 408  : 		//! open subdirectory or file
; 409  : 		if (root_dir) {

	movzx	eax, BYTE PTR root_dir$[rsp]
	test	eax, eax
	je	SHORT $LN5@fat32_open

; 410  : 			//! search root dir -- open pathname
; 411  : 			cur_dir = fat32_locate_dir (pathname);

	lea	rdx, QWORD PTR pathname$2[rsp]
	lea	rcx, QWORD PTR $T9[rsp]
	call	?fat32_locate_dir@@YA?AU_vfs_node_@@PEBD@Z ; fat32_locate_dir
	lea	rcx, QWORD PTR $T7[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	lea	rax, QWORD PTR cur_dir$[rsp]
	lea	rcx, QWORD PTR $T7[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 104				; 00000068H
	rep movsb

; 412  : 			root_dir = false;

	mov	BYTE PTR root_dir$[rsp], 0

; 413  : 		}
; 414  : 		else {

	jmp	SHORT $LN4@fat32_open
$LN5@fat32_open:

; 415  : 			//! search a sub directory instead for pathname
; 416  : 			cur_dir = fat32_locate_subdir (cur_dir, pathname);

	lea	rax, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR cur_dir$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 104				; 00000068H
	rep movsb
	lea	r8, QWORD PTR pathname$2[rsp]
	lea	rdx, QWORD PTR $T4[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	call	?fat32_locate_subdir@@YA?AU_vfs_node_@@U1@PEBD@Z ; fat32_locate_subdir
	lea	rcx, QWORD PTR $T5[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	lea	rax, QWORD PTR cur_dir$[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 104				; 00000068H
	rep movsb
$LN4@fat32_open:

; 417  : 		}
; 418  : 
; 419  : 		//! found directory or file?
; 420  : 		if (cur_dir.flags == FS_FLAG_INVALID)

	movzx	eax, BYTE PTR cur_dir$[rsp+48]
	cmp	eax, 3
	jne	SHORT $LN3@fat32_open

; 421  : 			break;

	jmp	SHORT $LN11@fat32_open
$LN3@fat32_open:

; 422  : 
; 423  : 		//! found file?
; 424  : 		if (cur_dir.flags == FS_FLAG_GENERAL){

	movzx	eax, BYTE PTR cur_dir$[rsp+48]
	cmp	eax, 2
	jne	SHORT $LN2@fat32_open

; 425  : 			return cur_dir;

	lea	rax, QWORD PTR cur_dir$[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
	jmp	SHORT $LN15@fat32_open
$LN2@fat32_open:

; 426  : 		}
; 427  : 
; 428  : 		//! find next '\'
; 429  : 		p=strchr(p+1, '/');

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 430  : 		if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN1@fat32_open

; 431  : 			p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN1@fat32_open:

; 432  : 	}

	jmp	$LN12@fat32_open
$LN11@fat32_open:

; 433  : 
; 434  : 	//! unable to find
; 435  : 	vfs_node_t ret;
; 436  : 	ret.flags = FS_FLAG_INVALID;

	mov	BYTE PTR ret$[rsp+48], 3

; 437  : 	ret.size = 0;

	mov	DWORD PTR ret$[rsp+32], 0

; 438  : 	return ret;

	lea	rax, QWORD PTR ret$[rsp]
	mov	rdi, QWORD PTR $T11[rsp]
	mov	rsi, rax
	mov	ecx, 104				; 00000068H
	rep movsb
	mov	rax, QWORD PTR $T11[rsp]
$LN15@fat32_open:

; 439  : }

	add	rsp, 1160				; 00000488H
	pop	rdi
	pop	rsi
	ret	0
?fat32_open@@YA?AU_vfs_node_@@PEAU1@PEAD@Z ENDP		; fat32_open
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
tv178 = 40
fat32_data$ = 48
buf$ = 56
?initialize_fat32@@YAXXZ PROC				; initialize_fat32

; 70   : void initialize_fat32 () {

$LN9:
	sub	rsp, 72					; 00000048H

; 71   : 
; 72   : 	uint64_t *buf = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buf$[rsp], rax

; 73   : 	//ata_read_28 (2048,1,buf); //partition_begin_lba = 2048
; 74   : 	ahci_disk_read (ahci_disk_get_port(),2048,1,buf);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buf$[rsp]
	mov	r8d, 1
	mov	edx, 2048				; 00000800H
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 75   : 
; 76   : 
; 77   : 	BPB *fat32_data = (BPB*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR fat32_data$[rsp], rax

; 78   : 
; 79   : 	part_lba = 2048;

	mov	DWORD PTR ?part_lba@@3IA, 2048		; part_lba, 00000800H

; 80   : 
; 81   : #ifdef _DEBUG_ON_
; 82   : 	_debug_print_ ("FAT32 BOOT PARAMETER BLOCK \r\n");

	lea	rcx, OFFSET FLAT:$SG3721
	call	_debug_print_

; 83   : 	_debug_print_ ("Bytes/Sector -> %d \r\n", fat32_data->bytes_per_sector);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+11]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3722
	call	_debug_print_

; 84   : 	_debug_print_ ("Sectors/Cluster -> %d \r\n", fat32_data->sectors_per_cluster);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, BYTE PTR [rax+13]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3723
	call	_debug_print_

; 85   : 	_debug_print_ ("Reserved Sectors -> %d \r\n", fat32_data->reserved_sectors);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3724
	call	_debug_print_

; 86   : 	_debug_print_ ("Number Of FATs -> %d \r\n", fat32_data->num_fats);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3725
	call	_debug_print_

; 87   : 	_debug_print_ ("Root Base Cluster -> %d \r\n", fat32_data->info.FAT32.root_dir_cluster);

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	edx, DWORD PTR [rax+44]
	lea	rcx, OFFSET FLAT:$SG3726
	call	_debug_print_

; 88   : 	_debug_print_ ("Sector/FAT32 -> %d \r\n", fat32_data->info.FAT32.sect_per_fat32);

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	edx, DWORD PTR [rax+36]
	lea	rcx, OFFSET FLAT:$SG3727
	call	_debug_print_

; 89   : 
; 90   : 
; 91   : 	for (int i=0; i <12; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@initialize
$LN5@initialize:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@initialize:
	cmp	DWORD PTR i$1[rsp], 12
	jge	SHORT $LN4@initialize

; 92   : 		_debug_print_("%c",fat32_data->info.FAT32.vol_label[i]);

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+71]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3732
	call	_debug_print_

; 93   : 	}

	jmp	SHORT $LN5@initialize
$LN4@initialize:

; 94   : 
; 95   : 	_debug_print_ ("\r\n");

	lea	rcx, OFFSET FLAT:$SG3733
	call	_debug_print_

; 96   : 
; 97   : 	for (int i=0; i <9; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@initialize
$LN2@initialize:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@initialize:
	cmp	DWORD PTR i$2[rsp], 9
	jge	SHORT $LN1@initialize

; 98   : 		_debug_print_("%c",fat32_data->info.FAT32.sys_id[i]);

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+82]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3738
	call	_debug_print_

; 99   : 	}

	jmp	SHORT $LN2@initialize
$LN1@initialize:

; 100  : 
; 101  : 	_debug_print_ ("\r\n");

	lea	rcx, OFFSET FLAT:$SG3739
	call	_debug_print_

; 102  : #endif
; 103  : 	fat_begin_lba = part_lba + fat32_data->reserved_sectors;

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	ecx, DWORD PTR ?part_lba@@3IA		; part_lba
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ?fat_begin_lba@@3KA, eax	; fat_begin_lba

; 104  : 	cluster_begin_lba = part_lba + fat32_data->reserved_sectors + (fat32_data->num_fats * fat32_data->info.FAT32.sect_per_fat32);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	ecx, DWORD PTR ?part_lba@@3IA		; part_lba
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movzx	ecx, BYTE PTR [rcx+16]
	mov	rdx, QWORD PTR fat32_data$[rsp]
	imul	ecx, DWORD PTR [rdx+36]
	add	eax, ecx
	mov	DWORD PTR ?cluster_begin_lba@@3KA, eax	; cluster_begin_lba

; 105  : 	sectors_per_cluster = fat32_data->sectors_per_cluster;

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, BYTE PTR [rax+13]
	mov	BYTE PTR ?sectors_per_cluster@@3EA, al	; sectors_per_cluster

; 106  : 	root_dir_first_cluster = fat32_data->info.FAT32.root_dir_cluster;

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rax+44]
	mov	DWORD PTR ?root_dir_first_cluster@@3IA, eax ; root_dir_first_cluster

; 107  : 	root_sector = cluster_to_sector32 (root_dir_first_cluster);

	mov	eax, DWORD PTR ?root_dir_first_cluster@@3IA ; root_dir_first_cluster
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR ?root_sector@@3KA, eax	; root_sector

; 108  : 	sectors_per_fat32 = fat32_data->info.FAT32.sect_per_fat32;

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR ?sectors_per_fat32@@3IA, eax	; sectors_per_fat32

; 109  : 
; 110  : 	total_clusters = fat32_data->large_sector_count / sectors_per_cluster;

	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	mov	DWORD PTR tv178[rsp], eax
	xor	edx, edx
	mov	rcx, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rcx+32]
	mov	ecx, DWORD PTR tv178[rsp]
	div	ecx
	mov	DWORD PTR ?total_clusters@@3IA, eax	; total_clusters

; 111  : 	_debug_print_ ("FAT32 Total clusters -> %d \r\n", total_clusters);

	mov	edx, DWORD PTR ?total_clusters@@3IA	; total_clusters
	lea	rcx, OFFSET FLAT:$SG3740
	call	_debug_print_

; 112  : 
; 113  : 
; 114  : }

	add	rsp, 72					; 00000048H
	ret	0
?initialize_fat32@@YAXXZ ENDP				; initialize_fat32
_TEXT	ENDS
END
