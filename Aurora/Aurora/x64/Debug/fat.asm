; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?part_lba@@3IA					; part_lba
PUBLIC	?fat_begin_lba@@3KA				; fat_begin_lba
PUBLIC	?cluster_begin_lba@@3KA				; cluster_begin_lba
PUBLIC	?sectors_per_cluster@@3EA			; sectors_per_cluster
PUBLIC	?root_dir_first_cluster@@3IA			; root_dir_first_cluster
PUBLIC	?root_sector@@3KA				; root_sector
PUBLIC	?sectors_per_fat32@@3IA				; sectors_per_fat32
PUBLIC	?alloc_counter@@3HA				; alloc_counter
PUBLIC	?total_clusters@@3IA				; total_clusters
PUBLIC	?root_dir_cache@@3PEAEEA			; root_dir_cache
_BSS	SEGMENT
?part_lba@@3IA DD 01H DUP (?)				; part_lba
?fat_begin_lba@@3KA DD 01H DUP (?)			; fat_begin_lba
?cluster_begin_lba@@3KA DD 01H DUP (?)			; cluster_begin_lba
?sectors_per_cluster@@3EA DB 01H DUP (?)		; sectors_per_cluster
	ALIGN	4

?root_dir_first_cluster@@3IA DD 01H DUP (?)		; root_dir_first_cluster
?root_sector@@3KA DD 01H DUP (?)			; root_sector
?sectors_per_fat32@@3IA DD 01H DUP (?)			; sectors_per_fat32
?alloc_counter@@3HA DD 01H DUP (?)			; alloc_counter
?total_clusters@@3IA DD 01H DUP (?)			; total_clusters
	ALIGN	8

?root_dir_cache@@3PEAEEA DQ 01H DUP (?)			; root_dir_cache
_BSS	ENDS
CONST	SEGMENT
$SG3725	DB	'FAT32 BOOT PARAMETER BLOCK ', 0dH, 0aH, 00H
	ORG $+2
$SG3726	DB	'Bytes/Sector -> %d ', 0dH, 0aH, 00H
	ORG $+2
$SG3727	DB	'Sectors/Cluster -> %d ', 0dH, 0aH, 00H
	ORG $+3
$SG3736	DB	'%c', 00H
	ORG $+1
$SG3728	DB	'Reserved Sectors -> %d ', 0dH, 0aH, 00H
	ORG $+2
$SG3737	DB	0dH, 0aH, 00H
	ORG $+1
$SG3729	DB	'Number Of FATs -> %d ', 0dH, 0aH, 00H
$SG3730	DB	'Root Base Cluster -> %d ', 0dH, 0aH, 00H
	ORG $+1
$SG3742	DB	'%c', 00H
	ORG $+1
$SG3731	DB	'Sector/FAT32 -> %d ', 0dH, 0aH, 00H
	ORG $+2
$SG3743	DB	0dH, 0aH, 00H
	ORG $+1
$SG3930	DB	'/', 00H
	ORG $+2
$SG3744	DB	'FAT32 Total clusters -> %d ', 0dH, 0aH, 00H
	ORG $+2
$SG3931	DB	'/', 00H
	ORG $+6
$SG3932	DB	'File System registered', 0aH, 00H
CONST	ENDS
PUBLIC	?initialize_fat32@@YAXXZ			; initialize_fat32
PUBLIC	?fat32_open@@YAPEAU_vfs_node_@@PEAU1@PEAD@Z	; fat32_open
PUBLIC	?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z	; fat32_read_file
PUBLIC	?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z		; fat32_read
PUBLIC	?fat32_locate_dir@@YAPEAU_vfs_node_@@PEBD@Z	; fat32_locate_dir
PUBLIC	?fat32_self_register@@YAXXZ			; fat32_self_register
PUBLIC	?fat32_find_free_cluster@@YAIXZ			; fat32_find_free_cluster
PUBLIC	?fat32_alloc_cluster@@YAXHI@Z			; fat32_alloc_cluster
PUBLIC	?fat32_get_root_sector@@YA_KXZ			; fat32_get_root_sector
PUBLIC	?fat32_get_root_cluster@@YAIXZ			; fat32_get_root_cluster
PUBLIC	?fat32_get_sector_per_cluster@@YA_KXZ		; fat32_get_sector_per_cluster
PUBLIC	?cluster_to_sector32@@YA_K_K@Z			; cluster_to_sector32
PUBLIC	?fat32_read_fat@@YAII@Z				; fat32_read_fat
PUBLIC	?fat32_clear_cluster@@YAXI@Z			; fat32_clear_cluster
PUBLIC	?fat32_locate_subdir@@YAPEAU_vfs_node_@@PEAU1@PEBD@Z ; fat32_locate_subdir
PUBLIC	?fat32_format_date@@YAGXZ			; fat32_format_date
PUBLIC	?fat32_format_time@@YAGXZ			; fat32_format_time
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strchr:PROC
EXTRN	memset:PROC
EXTRN	memcpy:PROC
EXTRN	vfs_mount:PROC
EXTRN	?fat32_to_dos_file_name@@YAXPEBDPEADI@Z:PROC	; fat32_to_dos_file_name
EXTRN	printf:PROC
EXTRN	AuPmmngrAlloc:PROC
EXTRN	AuPmmngrFree:PROC
EXTRN	p2v:PROC
EXTRN	v2p:PROC
EXTRN	malloc:PROC
EXTRN	free:PROC
EXTRN	?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z:PROC ; ahci_disk_write
EXTRN	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z:PROC ; ahci_disk_read
EXTRN	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ:PROC	; ahci_disk_get_port
EXTRN	_debug_print_:PROC
EXTRN	AuGetYear:PROC
EXTRN	AuGetSecond:PROC
EXTRN	AuGetDay:PROC
EXTRN	AuGetHour:PROC
EXTRN	AuGetMinutes:PROC
EXTRN	AuGetMonth:PROC
pdata	SEGMENT
$pdata$?initialize_fat32@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+535
	DD	imagerel $unwind$?initialize_fat32@@YAXXZ
$pdata$?fat32_open@@YAPEAU_vfs_node_@@PEAU1@PEAD@Z DD imagerel $LN17
	DD	imagerel $LN17+413
	DD	imagerel $unwind$?fat32_open@@YAPEAU_vfs_node_@@PEAU1@PEAD@Z
$pdata$?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z DD imagerel $LN7
	DD	imagerel $LN7+103
	DD	imagerel $unwind$?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z
$pdata$?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z DD imagerel $LN5
	DD	imagerel $LN5+139
	DD	imagerel $unwind$?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z
$pdata$?fat32_locate_dir@@YAPEAU_vfs_node_@@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+498
	DD	imagerel $unwind$?fat32_locate_dir@@YAPEAU_vfs_node_@@PEBD@Z
$pdata$?fat32_self_register@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+213
	DD	imagerel $unwind$?fat32_self_register@@YAXXZ
$pdata$?fat32_find_free_cluster@@YAIXZ DD imagerel $LN7
	DD	imagerel $LN7+235
	DD	imagerel $unwind$?fat32_find_free_cluster@@YAIXZ
$pdata$?fat32_alloc_cluster@@YAXHI@Z DD imagerel $LN3
	DD	imagerel $LN3+265
	DD	imagerel $unwind$?fat32_alloc_cluster@@YAXHI@Z
$pdata$?fat32_read_fat@@YAII@Z DD imagerel $LN3
	DD	imagerel $LN3+218
	DD	imagerel $unwind$?fat32_read_fat@@YAII@Z
$pdata$?fat32_clear_cluster@@YAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+119
	DD	imagerel $unwind$?fat32_clear_cluster@@YAXI@Z
$pdata$?fat32_locate_subdir@@YAPEAU_vfs_node_@@PEAU1@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+423
	DD	imagerel $unwind$?fat32_locate_subdir@@YAPEAU_vfs_node_@@PEAU1@PEBD@Z
$pdata$?fat32_format_date@@YAGXZ DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$?fat32_format_date@@YAGXZ
$pdata$?fat32_format_time@@YAGXZ DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?fat32_format_time@@YAGXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?initialize_fat32@@YAXXZ DD 010401H
	DD	08204H
$unwind$?fat32_open@@YAPEAU_vfs_node_@@PEAU1@PEAD@Z DD 010e01H
	DD	0a20eH
$unwind$?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z DD 011301H
	DD	06213H
$unwind$?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z DD 010e01H
	DD	0620eH
$unwind$?fat32_locate_dir@@YAPEAU_vfs_node_@@PEBD@Z DD 010901H
	DD	0e209H
$unwind$?fat32_self_register@@YAXXZ DD 010401H
	DD	06204H
$unwind$?fat32_find_free_cluster@@YAIXZ DD 010401H
	DD	0a204H
$unwind$?fat32_alloc_cluster@@YAXHI@Z DD 010c01H
	DD	0a20cH
$unwind$?fat32_read_fat@@YAII@Z DD 010801H
	DD	0a208H
$unwind$?fat32_clear_cluster@@YAXI@Z DD 010801H
	DD	08208H
$unwind$?fat32_locate_subdir@@YAPEAU_vfs_node_@@PEAU1@PEBD@Z DD 010e01H
	DD	0c20eH
$unwind$?fat32_format_date@@YAGXZ DD 010401H
	DD	06204H
$unwind$?fat32_format_time@@YAGXZ DD 010401H
	DD	06204H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
tv66 = 32
tv70 = 36
?fat32_format_time@@YAGXZ PROC				; fat32_format_time

; 472  : uint16_t fat32_format_time () {

$LN3:
	sub	rsp, 56					; 00000038H

; 473  : 	return (uint16_t)AuGetHour() << 11 | (uint16_t)AuGetMinutes() << 5 | (uint16_t)AuGetSecond()/2;

	call	AuGetHour
	movzx	eax, al
	shl	eax, 11
	mov	DWORD PTR tv66[rsp], eax
	call	AuGetMinutes
	movzx	eax, al
	shl	eax, 5
	mov	ecx, DWORD PTR tv66[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv70[rsp], eax
	call	AuGetSecond
	movzx	eax, al
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR tv70[rsp]
	or	ecx, eax
	mov	eax, ecx

; 474  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_format_time@@YAGXZ ENDP				; fat32_format_time
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
tv70 = 32
tv74 = 36
?fat32_format_date@@YAGXZ PROC				; fat32_format_date

; 464  : uint16_t fat32_format_date () {

$LN3:
	sub	rsp, 56					; 00000038H

; 465  : 	return (uint16_t)(2000 + AuGetYear()-1980)<<9 | (uint16_t)AuGetMonth() << 5 | (uint16_t)AuGetDay();

	call	AuGetYear
	movzx	eax, al
	add	eax, 20
	movzx	eax, ax
	shl	eax, 9
	mov	DWORD PTR tv70[rsp], eax
	call	AuGetMonth
	movzx	eax, al
	shl	eax, 5
	mov	ecx, DWORD PTR tv70[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR tv74[rsp], eax
	call	AuGetDay
	movzx	eax, al
	mov	ecx, DWORD PTR tv74[rsp]
	or	ecx, eax
	mov	eax, ecx

; 466  : 	//return (uint16_t)(2022-1980) <<9 | (uint16_t)3 << 5 | (uint16_t)6;
; 467  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_format_date@@YAGXZ ENDP				; fat32_format_date
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
file$ = 40
pkDir$2 = 48
buf$ = 56
dos_file_name$ = 64
name$3 = 80
kfile$ = 112
filename$ = 120
?fat32_locate_subdir@@YAPEAU_vfs_node_@@PEAU1@PEBD@Z PROC ; fat32_locate_subdir

; 299  : vfs_node_t *fat32_locate_subdir (vfs_node_t *kfile, const char* filename) {

$LN12:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 300  : 
; 301  : 	vfs_node_t *file = (vfs_node_t*)malloc(sizeof(vfs_node_t));

	mov	ecx, 104				; 00000068H
	call	malloc
	mov	QWORD PTR file$[rsp], rax

; 302  : 
; 303  : 	char dos_file_name[11];
; 304  : 	fat32_to_dos_file_name (filename, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR filename$[rsp]
	call	?fat32_to_dos_file_name@@YAXPEBDPEADI@Z	; fat32_to_dos_file_name

; 305  : 	//dos_file_name[11] = 0;
; 306  : 	uint64_t* buf = (uint64_t*)p2v((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	p2v
	mov	QWORD PTR buf$[rsp], rax

; 307  : 	if (kfile->flags != FS_FLAG_INVALID) {

	mov	rax, QWORD PTR kfile$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 3
	je	$LN9@fat32_loca
$LN8@fat32_loca:

; 308  : 		
; 309  : 		//! read the directory
; 310  : 		while (!kfile->eof) {

	mov	rax, QWORD PTR kfile$[rsp]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	jne	$LN7@fat32_loca

; 311  : 
; 312  : 			//! read 
; 313  : 		
; 314  : 			fat32_read (kfile, (uint64_t*)v2p((uint64_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	v2p
	mov	rdx, rax
	mov	rcx, QWORD PTR kfile$[rsp]
	call	?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z	; fat32_read

; 315  : 			//! set directory
; 316  : 			fat32_dir* pkDir = (fat32_dir*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR pkDir$2[rsp], rax

; 317  : 
; 318  : 			//! 16 entries
; 319  : 			for (unsigned int i = 0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@fat32_loca
$LN5@fat32_loca:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@fat32_loca:
	cmp	DWORD PTR i$1[rsp], 16
	jae	$LN4@fat32_loca

; 320  : 
; 321  : 				//! get current filename;
; 322  : 				char name[11];
; 323  : 				memcpy (name, pkDir->filename, 11);

	mov	rax, QWORD PTR pkDir$2[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rsp]
	call	memcpy

; 324  : 				//name[11] = 0;
; 325  : 
; 326  : 				if (strcmp (name, dos_file_name) == 0) {

	lea	rdx, QWORD PTR dos_file_name$[rsp]
	lea	rcx, QWORD PTR name$3[rsp]
	call	strcmp
	test	eax, eax
	jne	$LN3@fat32_loca

; 327  : 
; 328  : 					//! found file
; 329  : 					strcpy (file->filename, filename);

	mov	rax, QWORD PTR file$[rsp]
	mov	rdx, QWORD PTR filename$[rsp]
	mov	rcx, rax
	call	strcpy

; 330  : 					file->current = pkDir->first_cluster;

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	rcx, QWORD PTR file$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 331  : 					file->size = pkDir->file_size;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR pkDir$2[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+32], ecx

; 332  : 					file->eof = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 0

; 333  : 					file->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+49], 4

; 334  : 					//! set file type
; 335  : 					if (pkDir->attrib == 0x10)

	mov	rax, QWORD PTR pkDir$2[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	eax, 16
	jne	SHORT $LN2@fat32_loca

; 336  : 						file->flags = FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+48], 2

; 337  : 					else

	jmp	SHORT $LN1@fat32_loca
$LN2@fat32_loca:

; 338  : 						file->flags = FS_FLAG_GENERAL;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+48], 4
$LN1@fat32_loca:

; 339  : 
; 340  : 					AuPmmngrFree((void*)v2p((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	v2p
	mov	rcx, rax
	call	AuPmmngrFree

; 341  : 					free(kfile);

	mov	rcx, QWORD PTR kfile$[rsp]
	call	free

; 342  : 					//!return file
; 343  : 					return file;

	mov	rax, QWORD PTR file$[rsp]
	jmp	SHORT $LN10@fat32_loca
$LN3@fat32_loca:

; 344  : 				}
; 345  : 
; 346  : 				//! go to next entry
; 347  : 				pkDir++;

	mov	rax, QWORD PTR pkDir$2[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR pkDir$2[rsp], rax

; 348  : 			}

	jmp	$LN5@fat32_loca
$LN4@fat32_loca:

; 349  : 
; 350  : 			//pmmngr_free (buf);
; 351  : 		}

	jmp	$LN8@fat32_loca
$LN7@fat32_loca:
$LN9@fat32_loca:

; 352  : 	}
; 353  : 
; 354  : 	AuPmmngrFree((void*)v2p((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	v2p
	mov	rcx, rax
	call	AuPmmngrFree

; 355  : 	file->flags = FS_FLAG_INVALID;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+48], 3

; 356  : 	free(kfile);

	mov	rcx, QWORD PTR kfile$[rsp]
	call	free

; 357  : 	return file;

	mov	rax, QWORD PTR file$[rsp]
$LN10@fat32_loca:

; 358  : }

	add	rsp, 104				; 00000068H
	ret	0
?fat32_locate_subdir@@YAPEAU_vfs_node_@@PEAU1@PEBD@Z ENDP ; fat32_locate_subdir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
sector$ = 32
tv73 = 36
buffer$ = 40
tv75 = 48
cluster$ = 80
?fat32_clear_cluster@@YAXI@Z PROC			; fat32_clear_cluster

; 186  : void fat32_clear_cluster (uint32_t cluster) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 72					; 00000048H

; 187  : 	uint64_t *buffer = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buffer$[rsp], rax

; 188  : 	memset (buffer, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 189  : 	//update_cluster (buffer,cluster);
; 190  : 	uint32_t sector = cluster_to_sector32 (cluster);

	mov	eax, DWORD PTR cluster$[rsp]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR sector$[rsp], eax

; 191  : 	ahci_disk_write (ahci_disk_get_port(),sector,sectors_per_cluster,buffer);

	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	mov	DWORD PTR tv73[rsp], eax
	mov	ecx, DWORD PTR sector$[rsp]
	mov	QWORD PTR tv75[rsp], rcx
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buffer$[rsp]
	mov	ecx, DWORD PTR tv73[rsp]
	mov	r8d, ecx
	mov	rcx, QWORD PTR tv75[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_write

; 192  : 	AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$[rsp]
	call	AuPmmngrFree

; 193  : }

	add	rsp, 72					; 00000048H
	ret	0
?fat32_clear_cluster@@YAXI@Z ENDP			; fat32_clear_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
buf_area$ = 40
tv76 = 48
fat_sector$ = 56
ent_offset$ = 64
buf$ = 72
cluster_index$ = 96
?fat32_read_fat@@YAII@Z PROC				; fat32_read_fat

; 120  : uint32_t fat32_read_fat (uint32_t cluster_index) {

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 121  : 	auto fat_offset = cluster_index * 4;

	mov	eax, DWORD PTR cluster_index$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 122  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 123  : 	size_t ent_offset = fat_offset  % 512;

	xor	edx, edx
	mov	eax, DWORD PTR fat_offset$[rsp]
	mov	ecx, 512				; 00000200H
	div	ecx
	mov	eax, edx
	mov	eax, eax
	mov	QWORD PTR ent_offset$[rsp], rax

; 124  : 	uint64_t *buf_area = (uint64_t*)p2v((size_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	p2v
	mov	QWORD PTR buf_area$[rsp], rax

; 125  : 	memset(buf_area,0,4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf_area$[rsp]
	call	memset

; 126  : 	//ata_read_28 (fat_sector,1,buf);
; 127  : 	ahci_disk_read (ahci_disk_get_port(),fat_sector,1,(uint64_t*)v2p((size_t)buf_area));

	mov	rcx, QWORD PTR buf_area$[rsp]
	call	v2p
	mov	QWORD PTR tv76[rsp], rax
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	rcx, QWORD PTR tv76[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 128  : 	unsigned char *buf = (unsigned char*)buf_area;

	mov	rax, QWORD PTR buf_area$[rsp]
	mov	QWORD PTR buf$[rsp], rax

; 129  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 130  : 	AuPmmngrFree((void*)v2p((size_t)buf_area));

	mov	rcx, QWORD PTR buf_area$[rsp]
	call	v2p
	mov	rcx, rax
	call	AuPmmngrFree

; 131  : 	return value & 0x0FFFFFFF;

	mov	eax, DWORD PTR value$[rsp]
	and	eax, 268435455				; 0fffffffH

; 132  : }

	add	rsp, 88					; 00000058H
	ret	0
?fat32_read_fat@@YAII@Z ENDP				; fat32_read_fat
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
cluster$ = 8
?cluster_to_sector32@@YA_K_K@Z PROC			; cluster_to_sector32

; 62   : uint64_t  cluster_to_sector32 (uint64_t cluster){

	mov	QWORD PTR [rsp+8], rcx

; 63   : 	return cluster_begin_lba + (cluster - 2) * sectors_per_cluster ;

	mov	eax, DWORD PTR ?cluster_begin_lba@@3KA	; cluster_begin_lba
	mov	rcx, QWORD PTR cluster$[rsp]
	sub	rcx, 2
	movzx	edx, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	imul	rcx, rdx
	add	rax, rcx

; 64   : }

	ret	0
?cluster_to_sector32@@YA_K_K@Z ENDP			; cluster_to_sector32
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
?fat32_get_sector_per_cluster@@YA_KXZ PROC		; fat32_get_sector_per_cluster

; 458  : 	return sectors_per_cluster;

	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster

; 459  : }

	ret	0
?fat32_get_sector_per_cluster@@YA_KXZ ENDP		; fat32_get_sector_per_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
?fat32_get_root_cluster@@YAIXZ PROC			; fat32_get_root_cluster

; 451  : 	return root_dir_first_cluster;

	mov	eax, DWORD PTR ?root_dir_first_cluster@@3IA ; root_dir_first_cluster

; 452  : }

	ret	0
?fat32_get_root_cluster@@YAIXZ ENDP			; fat32_get_root_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
?fat32_get_root_sector@@YA_KXZ PROC			; fat32_get_root_sector

; 444  : 	return root_sector;

	mov	eax, DWORD PTR ?root_sector@@3KA	; root_sector

; 445  : }

	ret	0
?fat32_get_root_sector@@YA_KXZ ENDP			; fat32_get_root_sector
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
fat_offset$ = 32
value$ = 36
value2$ = 40
buffer$ = 48
ent_offset$ = 56
buf$ = 64
fat_sector$ = 72
position$ = 96
n_value$ = 104
?fat32_alloc_cluster@@YAXHI@Z PROC			; fat32_alloc_cluster

; 165  : void fat32_alloc_cluster (int position, uint32_t n_value) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 166  : 	auto fat_offset = position * 4;

	mov	eax, DWORD PTR position$[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$[rsp], eax

; 167  : 	uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	mov	eax, DWORD PTR fat_offset$[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$[rsp], rax

; 168  : 	size_t ent_offset = fat_offset  % 512;

	mov	eax, DWORD PTR fat_offset$[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	and	eax, 511				; 000001ffH
	sub	eax, edx
	cdqe
	mov	QWORD PTR ent_offset$[rsp], rax

; 169  : 	uint64_t *buffer = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buffer$[rsp], rax

; 170  : 	memset(buffer,0,4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$[rsp]
	call	memset

; 171  : 	ahci_disk_read(ahci_disk_get_port(),fat_sector,1,buffer);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buffer$[rsp]
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 172  : 
; 173  : 	uint8_t* buf = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR buf$[rsp], rax

; 174  : 	uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$[rsp], eax

; 175  : 	*(uint32_t*)&buf[ent_offset] = n_value & 0x0FFFFFFF;

	mov	eax, DWORD PTR n_value$[rsp]
	and	eax, 268435455				; 0fffffffH
	mov	rcx, QWORD PTR ent_offset$[rsp]
	mov	rdx, QWORD PTR buf$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	mov	DWORD PTR [rcx], eax

; 176  : 
; 177  : 	uint32_t value2 = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$[rsp]
	mov	rcx, QWORD PTR buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value2$[rsp], eax

; 178  : 	ahci_disk_write(ahci_disk_get_port(),fat_sector,1,buffer);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buffer$[rsp]
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$[rsp]
	mov	rcx, rax
	call	?ahci_disk_write@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_write

; 179  : 	AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$[rsp]
	call	AuPmmngrFree

; 180  : }

	add	rsp, 88					; 00000058H
	ret	0
?fat32_alloc_cluster@@YAXHI@Z ENDP			; fat32_alloc_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
fat_offset$2 = 36
value$3 = 40
buffer$4 = 48
fat_sector$5 = 56
ent_offset$6 = 64
buf$7 = 72
?fat32_find_free_cluster@@YAIXZ PROC			; fat32_find_free_cluster

; 139  : uint32_t fat32_find_free_cluster () {

$LN7:
	sub	rsp, 88					; 00000058H

; 140  : 	//!iterate through every sectors in fat32 table
; 141  : 	for (int i = 2; i < total_clusters; i++) {

	mov	DWORD PTR i$1[rsp], 2
	jmp	SHORT $LN4@fat32_find
$LN3@fat32_find:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@fat32_find:
	mov	eax, DWORD PTR ?total_clusters@@3IA	; total_clusters
	cmp	DWORD PTR i$1[rsp], eax
	jae	$LN2@fat32_find

; 142  : 		auto fat_offset = i * 4;

	mov	eax, DWORD PTR i$1[rsp]
	shl	eax, 2
	mov	DWORD PTR fat_offset$2[rsp], eax

; 143  : 		uint64_t fat_sector = fat_begin_lba + (fat_offset / 512);

	mov	eax, DWORD PTR fat_offset$2[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	sar	eax, 9
	mov	ecx, DWORD PTR ?fat_begin_lba@@3KA	; fat_begin_lba
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	QWORD PTR fat_sector$5[rsp], rax

; 144  : 		size_t ent_offset = fat_offset  % 512;

	mov	eax, DWORD PTR fat_offset$2[rsp]
	cdq
	and	edx, 511				; 000001ffH
	add	eax, edx
	and	eax, 511				; 000001ffH
	sub	eax, edx
	cdqe
	mov	QWORD PTR ent_offset$6[rsp], rax

; 145  : 		uint64_t *buffer = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buffer$4[rsp], rax

; 146  : 		memset(buffer,0,4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buffer$4[rsp]
	call	memset

; 147  : 		ahci_disk_read(ahci_disk_get_port(),fat_sector,1,buffer);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buffer$4[rsp]
	mov	r8d, 1
	mov	rdx, QWORD PTR fat_sector$5[rsp]
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 148  : 		uint8_t* buf = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$4[rsp]
	mov	QWORD PTR buf$7[rsp], rax

; 149  : 		uint32_t value = *(uint32_t*)&buf[ent_offset];

	mov	rax, QWORD PTR ent_offset$6[rsp]
	mov	rcx, QWORD PTR buf$7[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR value$3[rsp], eax

; 150  : 
; 151  : 		AuPmmngrFree(buffer);

	mov	rcx, QWORD PTR buffer$4[rsp]
	call	AuPmmngrFree

; 152  : 		//! Found a free cluster return the value
; 153  : 		if (value == 0x00) {

	cmp	DWORD PTR value$3[rsp], 0
	jne	SHORT $LN1@fat32_find

; 154  : 			return i;

	mov	eax, DWORD PTR i$1[rsp]
	jmp	SHORT $LN5@fat32_find
$LN1@fat32_find:

; 155  : 		}
; 156  : 	}

	jmp	$LN3@fat32_find
$LN2@fat32_find:

; 157  : 	return 0;

	xor	eax, eax
$LN5@fat32_find:

; 158  : }

	add	rsp, 88					; 00000058H
	ret	0
?fat32_find_free_cluster@@YAIXZ ENDP			; fat32_find_free_cluster
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
fsys$ = 32
?fat32_self_register@@YAXXZ PROC			; fat32_self_register

; 479  : void fat32_self_register () {

$LN3:
	sub	rsp, 56					; 00000038H

; 480  : 	vfs_node_t *fsys = (vfs_node_t*)malloc(sizeof(vfs_node_t));

	mov	ecx, 104				; 00000068H
	call	malloc
	mov	QWORD PTR fsys$[rsp], rax

; 481  : 	strcpy (fsys->filename, "/");

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rdx, OFFSET FLAT:$SG3930
	mov	rcx, rax
	call	strcpy

; 482  : 	fsys->size = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+32], 0

; 483  : 	fsys->eof = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	BYTE PTR [rax+36], 0

; 484  : 	fsys->pos = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+40], 0

; 485  : 	fsys->current = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	DWORD PTR [rax+44], 0

; 486  : 	fsys->flags = FS_FLAG_GENERAL;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	BYTE PTR [rax+48], 4

; 487  : 	fsys->status = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	BYTE PTR [rax+49], 0

; 488  : 	fsys->open = fat32_open;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?fat32_open@@YAPEAU_vfs_node_@@PEAU1@PEAD@Z ; fat32_open
	mov	QWORD PTR [rax+64], rcx

; 489  : 	fsys->read = fat32_read_file;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z ; fat32_read_file
	mov	QWORD PTR [rax+72], rcx

; 490  : 	fsys->write = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+80], 0

; 491  : 	fsys->read_blk = fat32_read;

	mov	rax, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z ; fat32_read
	mov	QWORD PTR [rax+88], rcx

; 492  : 	fsys->ioquery = 0;

	mov	rax, QWORD PTR fsys$[rsp]
	mov	QWORD PTR [rax+96], 0

; 493  : 	vfs_mount ("/", fsys, 0);

	xor	r8d, r8d
	mov	rdx, QWORD PTR fsys$[rsp]
	lea	rcx, OFFSET FLAT:$SG3931
	call	vfs_mount

; 494  : 	printf ("File System registered\n");

	lea	rcx, OFFSET FLAT:$SG3932
	call	printf

; 495  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_self_register@@YAXXZ ENDP			; fat32_self_register
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
file$ = 32
sector$1 = 40
i$2 = 44
dirent$ = 48
buf$ = 56
dos_file_name$ = 64
name$3 = 80
tv85 = 96
tv80 = 104
dir$ = 128
?fat32_locate_dir@@YAPEAU_vfs_node_@@PEBD@Z PROC	; fat32_locate_dir

; 246  : vfs_node_t *fat32_locate_dir (const char* dir) {

$LN12:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 247  : 	vfs_node_t *file = (vfs_node_t*)malloc(sizeof(vfs_node_t));

	mov	ecx, 104				; 00000068H
	call	malloc
	mov	QWORD PTR file$[rsp], rax

; 248  : 
; 249  : 	uint64_t* buf;
; 250  : 	fat32_dir *dirent;
; 251  : 	char dos_file_name[11];
; 252  : 	fat32_to_dos_file_name (dir, dos_file_name, 11);

	mov	r8d, 11
	lea	rdx, QWORD PTR dos_file_name$[rsp]
	mov	rcx, QWORD PTR dir$[rsp]
	call	?fat32_to_dos_file_name@@YAXPEBDPEADI@Z	; fat32_to_dos_file_name

; 253  : 	dos_file_name[11] = 0;

	mov	eax, 1
	imul	rax, 11
	mov	BYTE PTR dos_file_name$[rsp+rax], 0

; 254  : 	
; 255  : 	buf = (uint64_t*)p2v((uint64_t)AuPmmngrAlloc());

	call	AuPmmngrAlloc
	mov	rcx, rax
	call	p2v
	mov	QWORD PTR buf$[rsp], rax

; 256  : 	for (unsigned int sector = 0; sector < sectors_per_cluster; sector++) {

	mov	DWORD PTR sector$1[rsp], 0
	jmp	SHORT $LN9@fat32_loca
$LN8@fat32_loca:
	mov	eax, DWORD PTR sector$1[rsp]
	inc	eax
	mov	DWORD PTR sector$1[rsp], eax
$LN9@fat32_loca:
	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	cmp	DWORD PTR sector$1[rsp], eax
	jae	$LN7@fat32_loca

; 257  : 
; 258  : 		memset (buf, 0, 4096);

	mov	r8d, 4096				; 00001000H
	xor	edx, edx
	mov	rcx, QWORD PTR buf$[rsp]
	call	memset

; 259  : 		//ata_read_28 (root_sector + sector,1, buf);
; 260  : 		ahci_disk_read(ahci_disk_get_port(),root_sector + sector,1,(uint64_t*)v2p((uint64_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	v2p
	mov	QWORD PTR tv80[rsp], rax
	mov	ecx, DWORD PTR sector$1[rsp]
	mov	edx, DWORD PTR ?root_sector@@3KA	; root_sector
	add	edx, ecx
	mov	ecx, edx
	mov	ecx, ecx
	mov	QWORD PTR tv85[rsp], rcx
	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	rcx, QWORD PTR tv80[rsp]
	mov	r9, rcx
	mov	r8d, 1
	mov	rcx, QWORD PTR tv85[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 261  : 
; 262  : 		dirent = (fat32_dir*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR dirent$[rsp], rax

; 263  : 
; 264  : 		for (int i=0; i < 16; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN6@fat32_loca
$LN5@fat32_loca:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN6@fat32_loca:
	cmp	DWORD PTR i$2[rsp], 16
	jge	$LN4@fat32_loca

; 265  : 			char name[11];
; 266  : 			memcpy (name, dirent->filename, 11);

	mov	rax, QWORD PTR dirent$[rsp]
	mov	r8d, 11
	mov	rdx, rax
	lea	rcx, QWORD PTR name$3[rsp]
	call	memcpy

; 267  : 			name[11] = 0;

	mov	eax, 1
	imul	rax, 11
	mov	BYTE PTR name$3[rsp+rax], 0

; 268  : 			if (strcmp (dos_file_name, name) == 0) {

	lea	rdx, QWORD PTR name$3[rsp]
	lea	rcx, QWORD PTR dos_file_name$[rsp]
	call	strcmp
	test	eax, eax
	jne	$LN3@fat32_loca

; 269  : 				
; 270  : 				strcpy (file->filename, dir);

	mov	rax, QWORD PTR file$[rsp]
	mov	rdx, QWORD PTR dir$[rsp]
	mov	rcx, rax
	call	strcpy

; 271  : 				file->current = dirent->first_cluster;

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, WORD PTR [rax+26]
	mov	rcx, QWORD PTR file$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 272  : 				file->size = dirent->file_size;

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR dirent$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	mov	DWORD PTR [rax+32], ecx

; 273  : 				file->eof = 0;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 0

; 274  : 				file->status = FS_STATUS_FOUND;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+49], 4

; 275  : 
; 276  : 				if (dirent->attrib == 0x10)

	mov	rax, QWORD PTR dirent$[rsp]
	movzx	eax, BYTE PTR [rax+11]
	cmp	eax, 16
	jne	SHORT $LN2@fat32_loca

; 277  : 					file->flags = FS_FLAG_DIRECTORY;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+48], 2

; 278  : 				else

	jmp	SHORT $LN1@fat32_loca
$LN2@fat32_loca:

; 279  : 					file->flags = FS_FLAG_GENERAL;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+48], 4
$LN1@fat32_loca:

; 280  : 				
; 281  : 				AuPmmngrFree((void*)v2p((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	v2p
	mov	rcx, rax
	call	AuPmmngrFree

; 282  : 				return file;

	mov	rax, QWORD PTR file$[rsp]
	jmp	SHORT $LN10@fat32_loca
$LN3@fat32_loca:

; 283  : 			}
; 284  : 			dirent++;

	mov	rax, QWORD PTR dirent$[rsp]
	add	rax, 32					; 00000020H
	mov	QWORD PTR dirent$[rsp], rax

; 285  : 		}

	jmp	$LN5@fat32_loca
$LN4@fat32_loca:

; 286  : 	}

	jmp	$LN8@fat32_loca
$LN7@fat32_loca:

; 287  : 
; 288  : 	AuPmmngrFree((void*)v2p((size_t)buf));

	mov	rcx, QWORD PTR buf$[rsp]
	call	v2p
	mov	rcx, rax
	call	AuPmmngrFree

; 289  : 	free(file);

	mov	rcx, QWORD PTR file$[rsp]
	call	free

; 290  : 	return NULL;

	xor	eax, eax
$LN10@fat32_loca:

; 291  : }

	add	rsp, 120				; 00000078H
	ret	0
?fat32_locate_dir@@YAPEAU_vfs_node_@@PEBD@Z ENDP	; fat32_locate_dir
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
value$ = 32
lba$ = 40
file$ = 64
buf$ = 72
?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z PROC		; fat32_read

; 200  : void fat32_read (vfs_node_t *file, uint64_t* buf) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 201  : 
; 202  : 	auto lba = cluster_to_sector32 (file->current); 

	mov	rax, QWORD PTR file$[rsp]
	mov	eax, DWORD PTR [rax+44]
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	QWORD PTR lba$[rsp], rax

; 203  : 
; 204  : 	ahci_disk_read(ahci_disk_get_port(), lba, 8,buf);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buf$[rsp]
	mov	r8d, 8
	mov	rdx, QWORD PTR lba$[rsp]
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 205  : 
; 206  : 	uint32_t value = fat32_read_fat (file->current);

	mov	rax, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR [rax+44]
	call	?fat32_read_fat@@YAII@Z			; fat32_read_fat
	mov	DWORD PTR value$[rsp], eax

; 207  : 
; 208  : 	if (value  >= 0x0FFFFFF8) {

	cmp	DWORD PTR value$[rsp], 268435448	; 0ffffff8H
	jb	SHORT $LN2@fat32_read

; 209  : 	    file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 1

; 210  : 		return;

	jmp	SHORT $LN3@fat32_read
$LN2@fat32_read:

; 211  : 	}
; 212  : 
; 213  : 	if (value  == 0x0FFFFFF7) {

	cmp	DWORD PTR value$[rsp], 268435447	; 0ffffff7H
	jne	SHORT $LN1@fat32_read

; 214  : 	    file->eof = 1;

	mov	rax, QWORD PTR file$[rsp]
	mov	BYTE PTR [rax+36], 1

; 215  : 		return;

	jmp	SHORT $LN3@fat32_read
$LN1@fat32_read:

; 216  : 	}
; 217  : 	
; 218  : 	file->current = value;

	mov	rax, QWORD PTR file$[rsp]
	mov	ecx, DWORD PTR value$[rsp]
	mov	DWORD PTR [rax+44], ecx
$LN3@fat32_read:

; 219  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z ENDP		; fat32_read
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
file$ = 64
buffer$ = 72
count$ = 80
?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z PROC	; fat32_read_file

; 229  : void fat32_read_file (vfs_node_t *file, uint64_t* buffer, uint32_t count) {

$LN7:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 230  : 	/*while(file->eof != 1) {
; 231  : 		fat32_read (file,buffer);
; 232  : 		buffer += 4096;
; 233  : 	}*/
; 234  : 	for (int i=0; i < count; i+= 8) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@fat32_read
$LN3@fat32_read:
	mov	eax, DWORD PTR i$1[rsp]
	add	eax, 8
	mov	DWORD PTR i$1[rsp], eax
$LN4@fat32_read:
	mov	eax, DWORD PTR count$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN2@fat32_read

; 235  : 		fat32_read (file, buffer);

	mov	rdx, QWORD PTR buffer$[rsp]
	mov	rcx, QWORD PTR file$[rsp]
	call	?fat32_read@@YAXPEAU_vfs_node_@@PEA_K@Z	; fat32_read

; 236  : 		if (file->eof) 

	mov	rax, QWORD PTR file$[rsp]
	movzx	eax, BYTE PTR [rax+36]
	test	eax, eax
	je	SHORT $LN1@fat32_read

; 237  : 			break;

	jmp	SHORT $LN2@fat32_read
$LN1@fat32_read:

; 238  : 		buffer += 4096;

	mov	rax, QWORD PTR buffer$[rsp]
	add	rax, 32768				; 00008000H
	mov	QWORD PTR buffer$[rsp], rax

; 239  : 	}

	jmp	SHORT $LN3@fat32_read
$LN2@fat32_read:

; 240  : }

	add	rsp, 56					; 00000038H
	ret	0
?fat32_read_file@@YAXPEAU_vfs_node_@@PEA_KI@Z ENDP	; fat32_read_file
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
root_dir$ = 32
i$1 = 36
p$ = 40
cur_dir$ = 48
path$ = 56
pathname$2 = 64
node$ = 96
filename$ = 104
?fat32_open@@YAPEAU_vfs_node_@@PEAU1@PEAD@Z PROC	; fat32_open

; 365  : vfs_node_t * fat32_open (vfs_node_t * node, char* filename) {

$LN17:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 366  : 	vfs_node_t *cur_dir;
; 367  : 	char* p = 0;

	mov	QWORD PTR p$[rsp], 0

; 368  : 	bool  root_dir = true;

	mov	BYTE PTR root_dir$[rsp], 1

; 369  : 	char* path = (char*) filename;

	mov	rax, QWORD PTR filename$[rsp]
	mov	QWORD PTR path$[rsp], rax

; 370  : 
; 371  : 	//! any '\'s in path ?
; 372  : 	p = strchr (path, '/');

	mov	edx, 47					; 0000002fH
	mov	rcx, QWORD PTR path$[rsp]
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 373  : 	if (!p) {

	cmp	QWORD PTR p$[rsp], 0
	jne	SHORT $LN14@fat32_open

; 374  : 		//! nope, must be in root directory, search it
; 375  : 		cur_dir = fat32_locate_dir (path);

	mov	rcx, QWORD PTR path$[rsp]
	call	?fat32_locate_dir@@YAPEAU_vfs_node_@@PEBD@Z ; fat32_locate_dir
	mov	QWORD PTR cur_dir$[rsp], rax

; 376  : 
; 377  : 		//! found file ?
; 378  : 		if (cur_dir != NULL && cur_dir->flags == FS_FLAG_GENERAL) {

	cmp	QWORD PTR cur_dir$[rsp], 0
	je	SHORT $LN13@fat32_open
	mov	rax, QWORD PTR cur_dir$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 4
	jne	SHORT $LN13@fat32_open

; 379  : 			return cur_dir;

	mov	rax, QWORD PTR cur_dir$[rsp]
	jmp	$LN15@fat32_open
$LN13@fat32_open:

; 380  : 		}
; 381  : 
; 382  : 		//! unable to find
; 383  : 		return NULL;

	xor	eax, eax
	jmp	$LN15@fat32_open
$LN14@fat32_open:

; 384  : 	}
; 385  : 
; 386  : 	//! go to next character after first '\'
; 387  : 	p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN12@fat32_open:

; 388  : 
; 389  : 	while (p) {

	cmp	QWORD PTR p$[rsp], 0
	je	$LN11@fat32_open

; 390  : 
; 391  : 		//! get pathname
; 392  : 		char pathname[16];
; 393  : 		int i=0;

	mov	DWORD PTR i$1[rsp], 0

; 394  : 		for (i=0; i < 16; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN10@fat32_open
$LN9@fat32_open:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN10@fat32_open:
	cmp	DWORD PTR i$1[rsp], 16
	jge	SHORT $LN8@fat32_open

; 395  : 
; 396  : 			//! if another '\' or end of line is reached, we are done
; 397  : 			if (p[i] == '/' || p[i]=='\0')

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN6@fat32_open
	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN7@fat32_open
$LN6@fat32_open:

; 398  : 				break;

	jmp	SHORT $LN8@fat32_open
$LN7@fat32_open:

; 399  : 
; 400  : 			//! copy character
; 401  : 			pathname[i]=p[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR p$[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR pathname$2[rsp+rcx], al

; 402  : 		}

	jmp	SHORT $LN9@fat32_open
$LN8@fat32_open:

; 403  : 		pathname[i]=0; //null terminate

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	BYTE PTR pathname$2[rsp+rax], 0

; 404  : 
; 405  : 		//! open subdirectory or file
; 406  : 		if (root_dir) {

	movzx	eax, BYTE PTR root_dir$[rsp]
	test	eax, eax
	je	SHORT $LN5@fat32_open

; 407  : 			//! search root dir -- open pathname
; 408  : 			cur_dir = fat32_locate_dir (pathname);

	lea	rcx, QWORD PTR pathname$2[rsp]
	call	?fat32_locate_dir@@YAPEAU_vfs_node_@@PEBD@Z ; fat32_locate_dir
	mov	QWORD PTR cur_dir$[rsp], rax

; 409  : 			root_dir = false;

	mov	BYTE PTR root_dir$[rsp], 0

; 410  : 		}
; 411  : 		else {

	jmp	SHORT $LN4@fat32_open
$LN5@fat32_open:

; 412  : 			//! search a sub directory instead for pathname
; 413  : 			cur_dir = fat32_locate_subdir (cur_dir, pathname);

	lea	rdx, QWORD PTR pathname$2[rsp]
	mov	rcx, QWORD PTR cur_dir$[rsp]
	call	?fat32_locate_subdir@@YAPEAU_vfs_node_@@PEAU1@PEBD@Z ; fat32_locate_subdir
	mov	QWORD PTR cur_dir$[rsp], rax
$LN4@fat32_open:

; 414  : 		}
; 415  : 
; 416  : 		//! found directory or file?
; 417  : 		if (cur_dir == NULL)

	cmp	QWORD PTR cur_dir$[rsp], 0
	jne	SHORT $LN3@fat32_open

; 418  : 			break;

	jmp	SHORT $LN11@fat32_open
$LN3@fat32_open:

; 419  : 
; 420  : 		//! found file?
; 421  : 		if (cur_dir != NULL && cur_dir->flags == FS_FLAG_GENERAL){

	cmp	QWORD PTR cur_dir$[rsp], 0
	je	SHORT $LN2@fat32_open
	mov	rax, QWORD PTR cur_dir$[rsp]
	movzx	eax, BYTE PTR [rax+48]
	cmp	eax, 4
	jne	SHORT $LN2@fat32_open

; 422  : 			return cur_dir;

	mov	rax, QWORD PTR cur_dir$[rsp]
	jmp	SHORT $LN15@fat32_open
$LN2@fat32_open:

; 423  : 		}
; 424  : 
; 425  : 		//! find next '\'
; 426  : 		p=strchr(p+1, '/');

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	edx, 47					; 0000002fH
	mov	rcx, rax
	call	strchr
	mov	QWORD PTR p$[rsp], rax

; 427  : 		if (p)

	cmp	QWORD PTR p$[rsp], 0
	je	SHORT $LN1@fat32_open

; 428  : 			p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax
$LN1@fat32_open:

; 429  : 	}

	jmp	$LN12@fat32_open
$LN11@fat32_open:

; 430  : 
; 431  : 	//! unable to find
; 432  : 	/*vfs_node_t ret;
; 433  : 	ret.flags = FS_FLAG_INVALID;
; 434  : 	ret.size = 0;*/
; 435  : 	free(cur_dir);

	mov	rcx, QWORD PTR cur_dir$[rsp]
	call	free

; 436  : 	return NULL;

	xor	eax, eax
$LN15@fat32_open:

; 437  : }

	add	rsp, 88					; 00000058H
	ret	0
?fat32_open@@YAPEAU_vfs_node_@@PEAU1@PEAD@Z ENDP	; fat32_open
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\fs\fat\fat.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
tv178 = 40
fat32_data$ = 48
buf$ = 56
?initialize_fat32@@YAXXZ PROC				; initialize_fat32

; 70   : void initialize_fat32 () {

$LN9:
	sub	rsp, 72					; 00000048H

; 71   : 
; 72   : 	uint64_t *buf = (uint64_t*)AuPmmngrAlloc();

	call	AuPmmngrAlloc
	mov	QWORD PTR buf$[rsp], rax

; 73   : 	//ata_read_28 (2048,1,buf); //partition_begin_lba = 2048
; 74   : 	ahci_disk_read (ahci_disk_get_port(),2048,1,buf);

	call	?ahci_disk_get_port@@YAPEAU_hba_port_@@XZ ; ahci_disk_get_port
	mov	r9, QWORD PTR buf$[rsp]
	mov	r8d, 1
	mov	edx, 2048				; 00000800H
	mov	rcx, rax
	call	?ahci_disk_read@@YAXPEAU_hba_port_@@_KIPEA_K@Z ; ahci_disk_read

; 75   : 
; 76   : 
; 77   : 	BPB *fat32_data = (BPB*)buf;

	mov	rax, QWORD PTR buf$[rsp]
	mov	QWORD PTR fat32_data$[rsp], rax

; 78   : 
; 79   : 	part_lba = 2048;

	mov	DWORD PTR ?part_lba@@3IA, 2048		; part_lba, 00000800H

; 80   : 
; 81   : #ifdef _DEBUG_ON_
; 82   : 	_debug_print_ ("FAT32 BOOT PARAMETER BLOCK \r\n");

	lea	rcx, OFFSET FLAT:$SG3725
	call	_debug_print_

; 83   : 	_debug_print_ ("Bytes/Sector -> %d \r\n", fat32_data->bytes_per_sector);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+11]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3726
	call	_debug_print_

; 84   : 	_debug_print_ ("Sectors/Cluster -> %d \r\n", fat32_data->sectors_per_cluster);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, BYTE PTR [rax+13]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3727
	call	_debug_print_

; 85   : 	_debug_print_ ("Reserved Sectors -> %d \r\n", fat32_data->reserved_sectors);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3728
	call	_debug_print_

; 86   : 	_debug_print_ ("Number Of FATs -> %d \r\n", fat32_data->num_fats);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, BYTE PTR [rax+16]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3729
	call	_debug_print_

; 87   : 	_debug_print_ ("Root Base Cluster -> %d \r\n", fat32_data->info.FAT32.root_dir_cluster);

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	edx, DWORD PTR [rax+44]
	lea	rcx, OFFSET FLAT:$SG3730
	call	_debug_print_

; 88   : 	_debug_print_ ("Sector/FAT32 -> %d \r\n", fat32_data->info.FAT32.sect_per_fat32);

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	edx, DWORD PTR [rax+36]
	lea	rcx, OFFSET FLAT:$SG3731
	call	_debug_print_

; 89   : 
; 90   : 
; 91   : 	for (int i=0; i <12; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@initialize
$LN5@initialize:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@initialize:
	cmp	DWORD PTR i$1[rsp], 12
	jge	SHORT $LN4@initialize

; 92   : 		_debug_print_("%c",fat32_data->info.FAT32.vol_label[i]);

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+71]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3736
	call	_debug_print_

; 93   : 	}

	jmp	SHORT $LN5@initialize
$LN4@initialize:

; 94   : 
; 95   : 	_debug_print_ ("\r\n");

	lea	rcx, OFFSET FLAT:$SG3737
	call	_debug_print_

; 96   : 
; 97   : 	for (int i=0; i <9; i++) {

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@initialize
$LN2@initialize:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@initialize:
	cmp	DWORD PTR i$2[rsp], 9
	jge	SHORT $LN1@initialize

; 98   : 		_debug_print_("%c",fat32_data->info.FAT32.sys_id[i]);

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movsx	eax, BYTE PTR [rcx+rax+82]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG3742
	call	_debug_print_

; 99   : 	}

	jmp	SHORT $LN2@initialize
$LN1@initialize:

; 100  : 
; 101  : 	_debug_print_ ("\r\n");

	lea	rcx, OFFSET FLAT:$SG3743
	call	_debug_print_

; 102  : #endif
; 103  : 	fat_begin_lba = part_lba + fat32_data->reserved_sectors;

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	ecx, DWORD PTR ?part_lba@@3IA		; part_lba
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ?fat_begin_lba@@3KA, eax	; fat_begin_lba

; 104  : 	cluster_begin_lba = part_lba + fat32_data->reserved_sectors + (fat32_data->num_fats * fat32_data->info.FAT32.sect_per_fat32);

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, WORD PTR [rax+14]
	mov	ecx, DWORD PTR ?part_lba@@3IA		; part_lba
	add	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR fat32_data$[rsp]
	movzx	ecx, BYTE PTR [rcx+16]
	mov	rdx, QWORD PTR fat32_data$[rsp]
	imul	ecx, DWORD PTR [rdx+36]
	add	eax, ecx
	mov	DWORD PTR ?cluster_begin_lba@@3KA, eax	; cluster_begin_lba

; 105  : 	sectors_per_cluster = fat32_data->sectors_per_cluster;

	mov	rax, QWORD PTR fat32_data$[rsp]
	movzx	eax, BYTE PTR [rax+13]
	mov	BYTE PTR ?sectors_per_cluster@@3EA, al	; sectors_per_cluster

; 106  : 	root_dir_first_cluster = fat32_data->info.FAT32.root_dir_cluster;

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rax+44]
	mov	DWORD PTR ?root_dir_first_cluster@@3IA, eax ; root_dir_first_cluster

; 107  : 	root_sector = cluster_to_sector32 (root_dir_first_cluster);

	mov	eax, DWORD PTR ?root_dir_first_cluster@@3IA ; root_dir_first_cluster
	mov	ecx, eax
	call	?cluster_to_sector32@@YA_K_K@Z		; cluster_to_sector32
	mov	DWORD PTR ?root_sector@@3KA, eax	; root_sector

; 108  : 	sectors_per_fat32 = fat32_data->info.FAT32.sect_per_fat32;

	mov	rax, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rax+36]
	mov	DWORD PTR ?sectors_per_fat32@@3IA, eax	; sectors_per_fat32

; 109  : 
; 110  : 	total_clusters = fat32_data->large_sector_count / sectors_per_cluster;

	movzx	eax, BYTE PTR ?sectors_per_cluster@@3EA	; sectors_per_cluster
	mov	DWORD PTR tv178[rsp], eax
	xor	edx, edx
	mov	rcx, QWORD PTR fat32_data$[rsp]
	mov	eax, DWORD PTR [rcx+32]
	mov	ecx, DWORD PTR tv178[rsp]
	div	ecx
	mov	DWORD PTR ?total_clusters@@3IA, eax	; total_clusters

; 111  : 	_debug_print_ ("FAT32 Total clusters -> %d \r\n", total_clusters);

	mov	edx, DWORD PTR ?total_clusters@@3IA	; total_clusters
	lea	rcx, OFFSET FLAT:$SG3744
	call	_debug_print_

; 112  : 
; 113  : 
; 114  : }

	add	rsp, 72					; 00000048H
	ret	0
?initialize_fat32@@YAXXZ ENDP				; initialize_fat32
_TEXT	ENDS
END
