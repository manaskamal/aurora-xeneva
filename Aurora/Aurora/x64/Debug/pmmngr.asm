; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?free_memory@@3_KA				; free_memory
PUBLIC	?reserved_memory@@3_KA				; reserved_memory
PUBLIC	?used_memory@@3_KA				; used_memory
PUBLIC	?ram_bitmap_index@@3_KA				; ram_bitmap_index
PUBLIC	?total_ram@@3_KA				; total_ram
PUBLIC	?ram_bitmap@@3VBitmap@@A			; ram_bitmap
_BSS	SEGMENT
?free_memory@@3_KA DQ 01H DUP (?)			; free_memory
?reserved_memory@@3_KA DQ 01H DUP (?)			; reserved_memory
?used_memory@@3_KA DQ 01H DUP (?)			; used_memory
?ram_bitmap_index@@3_KA DQ 01H DUP (?)			; ram_bitmap_index
?total_ram@@3_KA DQ 01H DUP (?)				; total_ram
?ram_bitmap@@3VBitmap@@A DB 010H DUP (?)		; ram_bitmap
_BSS	ENDS
CONST	SEGMENT
$SG2967	DB	'Used RAM -> %d MB, Free RAM -> %d MB', 0aH, 00H
	ORG $+2
$SG2968	DB	'No more available pages', 0aH, 00H
CONST	ENDS
PUBLIC	?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z	; pmmngr_init
PUBLIC	?pmmngr_alloc@@YAPEAXXZ				; pmmngr_alloc
PUBLIC	?pmmngr_alloc_blocks@@YAPEAXH@Z			; pmmngr_alloc_blocks
PUBLIC	?pmmngr_lock_pages@@YAXPEAX_K@Z			; pmmngr_lock_pages
PUBLIC	?pmmngr_free@@YAXPEAX@Z				; pmmngr_free
PUBLIC	?pmmngr_get_free_ram@@YA_KXZ			; pmmngr_get_free_ram
PUBLIC	?pmmngr_get_used_ram@@YA_KXZ			; pmmngr_get_used_ram
PUBLIC	?pmmngr_get_total_ram@@YA_KXZ			; pmmngr_get_total_ram
PUBLIC	??ABitmap@@QEAA_N_K@Z				; Bitmap::operator[]
PUBLIC	?Set@Bitmap@@QEAA_N_K_N@Z			; Bitmap::Set
PUBLIC	?pmmngr_init_bitmap@@YAX_KPEAX@Z		; pmmngr_init_bitmap
PUBLIC	?pmmngr_lock_page@@YAXPEAX@Z			; pmmngr_lock_page
PUBLIC	?pmmngr_unreserve_page@@YAXPEAX@Z		; pmmngr_unreserve_page
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
EXTRN	x64_cli:PROC
EXTRN	x64_hlt:PROC
pdata	SEGMENT
$pdata$?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+350
	DD	imagerel $unwind$?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z
$pdata$?pmmngr_alloc@@YAPEAXXZ DD imagerel $LN13
	DD	imagerel $LN13+378
	DD	imagerel $unwind$?pmmngr_alloc@@YAPEAXXZ
$pdata$?pmmngr_alloc_blocks@@YAPEAXH@Z DD imagerel $LN6
	DD	imagerel $LN6+77
	DD	imagerel $unwind$?pmmngr_alloc_blocks@@YAPEAXH@Z
$pdata$?pmmngr_lock_pages@@YAXPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+84
	DD	imagerel $unwind$?pmmngr_lock_pages@@YAXPEAX_K@Z
$pdata$?pmmngr_free@@YAXPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?pmmngr_free@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??ABitmap@@QEAA_N_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$??ABitmap@@QEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Set@Bitmap@@QEAA_N_K_N@Z DD imagerel $LN5
	DD	imagerel $LN5+213
	DD	imagerel $unwind$?Set@Bitmap@@QEAA_N_K_N@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?pmmngr_init_bitmap@@YAX_KPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+88
	DD	imagerel $unwind$?pmmngr_init_bitmap@@YAX_KPEAX@Z
$pdata$?pmmngr_lock_page@@YAXPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+128
	DD	imagerel $unwind$?pmmngr_lock_page@@YAXPEAX@Z
$pdata$?pmmngr_unreserve_page@@YAXPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?pmmngr_unreserve_page@@YAXPEAX@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Set@Bitmap@@QEAA_N_K_N@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??ABitmap@@QEAA_N_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
xdata	SEGMENT
$unwind$?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD 010901H
	DD	0a209H
$unwind$?pmmngr_alloc@@YAPEAXXZ DD 010401H
	DD	06204H
$unwind$?pmmngr_alloc_blocks@@YAPEAXH@Z DD 010801H
	DD	06208H
$unwind$?pmmngr_lock_pages@@YAXPEAX_K@Z DD 010e01H
	DD	0620eH
$unwind$?pmmngr_free@@YAXPEAX@Z DD 010901H
	DD	06209H
$unwind$?pmmngr_init_bitmap@@YAX_KPEAX@Z DD 010e01H
	DD	0220eH
$unwind$?pmmngr_lock_page@@YAXPEAX@Z DD 010901H
	DD	06209H
$unwind$?pmmngr_unreserve_page@@YAXPEAX@Z DD 010901H
	DD	06209H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
index$ = 32
addr$ = 64
?pmmngr_unreserve_page@@YAXPEAX@Z PROC			; pmmngr_unreserve_page

; 95   : void pmmngr_unreserve_page (void* addr) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 96   : 
; 97   : 	uint64_t index = (uint64_t)addr / 4096;

	xor	edx, edx
	mov	rax, QWORD PTR addr$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR index$[rsp], rax

; 98   : 	if (ram_bitmap[index] == false) return;

	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@pmmngr_unr
	jmp	SHORT $LN4@pmmngr_unr
$LN3@pmmngr_unr:

; 99   : 	if (ram_bitmap.Set(index, false)) {

	xor	r8d, r8d
	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	?Set@Bitmap@@QEAA_N_K_N@Z		; Bitmap::Set
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@pmmngr_unr

; 100  : 		free_memory += 4096;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 101  : 		reserved_memory -= 4096;

	mov	rax, QWORD PTR ?reserved_memory@@3_KA	; reserved_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?reserved_memory@@3_KA, rax	; reserved_memory

; 102  : 		if (ram_bitmap_index > index) ram_bitmap_index = index;

	mov	rax, QWORD PTR index$[rsp]
	cmp	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
	jbe	SHORT $LN1@pmmngr_unr
	mov	rax, QWORD PTR index$[rsp]
	mov	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
$LN1@pmmngr_unr:
$LN2@pmmngr_unr:
$LN4@pmmngr_unr:

; 103  : 	}
; 104  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_unreserve_page@@YAXPEAX@Z ENDP			; pmmngr_unreserve_page
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
index$ = 32
addr$ = 64
?pmmngr_lock_page@@YAXPEAX@Z PROC			; pmmngr_lock_page

; 78   : void pmmngr_lock_page ( void* addr) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 79   : 
; 80   : 	uint64_t index = (uint64_t)addr / 4096;

	xor	edx, edx
	mov	rax, QWORD PTR addr$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR index$[rsp], rax

; 81   : 	if (ram_bitmap[index] == true) return;

	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN2@pmmngr_loc
	jmp	SHORT $LN3@pmmngr_loc
$LN2@pmmngr_loc:

; 82   : 	if (ram_bitmap.Set (index, true)) {

	mov	r8b, 1
	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	?Set@Bitmap@@QEAA_N_K_N@Z		; Bitmap::Set
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@pmmngr_loc

; 83   : 		free_memory -= 4096;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 84   : 		reserved_memory += 4096;

	mov	rax, QWORD PTR ?reserved_memory@@3_KA	; reserved_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?reserved_memory@@3_KA, rax	; reserved_memory
$LN1@pmmngr_loc:
$LN3@pmmngr_loc:

; 85   : 	}
; 86   : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_lock_page@@YAXPEAX@Z ENDP			; pmmngr_lock_page
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 0
bitmap_size$ = 32
buffer$ = 40
?pmmngr_init_bitmap@@YAX_KPEAX@Z PROC			; pmmngr_init_bitmap

; 67   : void pmmngr_init_bitmap (size_t bitmap_size, void* buffer) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 68   : 
; 69   : 	ram_bitmap.Size = bitmap_size;

	mov	rax, QWORD PTR bitmap_size$[rsp]
	mov	QWORD PTR ?ram_bitmap@@3VBitmap@@A, rax

; 70   : 	ram_bitmap.Buffer = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR ?ram_bitmap@@3VBitmap@@A+8, rax

; 71   : 
; 72   : 	for (int i = 0; i < bitmap_size ; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@pmmngr_ini
$LN2@pmmngr_ini:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@pmmngr_ini:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR bitmap_size$[rsp]
	jae	SHORT $LN1@pmmngr_ini

; 73   : 		*(uint8_t*)(ram_bitmap.Buffer + i) = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR ?ram_bitmap@@3VBitmap@@A+8
	mov	BYTE PTR [rcx+rax], 0

; 74   : 	}

	jmp	SHORT $LN2@pmmngr_ini
$LN1@pmmngr_ini:

; 75   : }

	add	rsp, 24
	ret	0
?pmmngr_init_bitmap@@YAX_KPEAX@Z ENDP			; pmmngr_init_bitmap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
;	COMDAT ?Set@Bitmap@@QEAA_N_K_N@Z
_TEXT	SEGMENT
bitIndexer$ = 0
bitIndex$ = 1
tv145 = 4
byteIndex$ = 8
this$ = 32
index$ = 40
value$ = 48
?Set@Bitmap@@QEAA_N_K_N@Z PROC				; Bitmap::Set, COMDAT

; 47   : 	bool Set(uint64_t index, bool value) {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 48   : 		
; 49   : 		if (index > Size * 8) return false;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	shl	rax, 3
	cmp	QWORD PTR index$[rsp], rax
	jbe	SHORT $LN2@Set
	xor	al, al
	jmp	$LN3@Set
$LN2@Set:

; 50   : 
; 51   : 		uint64_t byteIndex = index / 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 8
	div	rcx
	mov	QWORD PTR byteIndex$[rsp], rax

; 52   : 		uint8_t  bitIndex = index % 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 8
	div	rcx
	mov	rax, rdx
	mov	BYTE PTR bitIndex$[rsp], al

; 53   : 		uint8_t  bitIndexer = 0x80 >> bitIndex;

	movzx	eax, BYTE PTR bitIndex$[rsp]
	mov	ecx, 128				; 00000080H
	mov	DWORD PTR tv145[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv145[rsp]
	sar	eax, cl
	mov	BYTE PTR bitIndexer$[rsp], al

; 54   : 	
; 55   : 		Buffer[byteIndex] &= ~bitIndexer;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	ecx, BYTE PTR bitIndexer$[rsp]
	not	ecx
	mov	rdx, QWORD PTR byteIndex$[rsp]
	movzx	eax, BYTE PTR [rax+rdx]
	and	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR byteIndex$[rsp]
	mov	BYTE PTR [rcx+rdx], al

; 56   : 		if (value) {

	movzx	eax, BYTE PTR value$[rsp]
	test	eax, eax
	je	SHORT $LN1@Set

; 57   : 			Buffer[byteIndex] |= bitIndexer;	

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	ecx, BYTE PTR bitIndexer$[rsp]
	mov	rdx, QWORD PTR byteIndex$[rsp]
	movzx	eax, BYTE PTR [rax+rdx]
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR byteIndex$[rsp]
	mov	BYTE PTR [rcx+rdx], al
$LN1@Set:

; 58   : 		}
; 59   : 
; 60   : 		return true;

	mov	al, 1
$LN3@Set:

; 61   : 	}

	add	rsp, 24
	ret	0
?Set@Bitmap@@QEAA_N_K_N@Z ENDP				; Bitmap::Set
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
;	COMDAT ??ABitmap@@QEAA_N_K@Z
_TEXT	SEGMENT
bitIndex$ = 0
bitIndexer$ = 1
tv94 = 4
byteIndex$ = 8
this$ = 32
index$ = 40
??ABitmap@@QEAA_N_K@Z PROC				; Bitmap::operator[], COMDAT

; 33   : 	bool operator[](uint64_t index) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 34   : 		
; 35   : 		if (index > Size * 8) return false;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	shl	rax, 3
	cmp	QWORD PTR index$[rsp], rax
	jbe	SHORT $LN2@operator
	xor	al, al
	jmp	SHORT $LN3@operator
$LN2@operator:

; 36   : 		uint64_t byteIndex = index / 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 8
	div	rcx
	mov	QWORD PTR byteIndex$[rsp], rax

; 37   : 		uint8_t  bitIndex = index % 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 8
	div	rcx
	mov	rax, rdx
	mov	BYTE PTR bitIndex$[rsp], al

; 38   : 		uint8_t  bitIndexer = 0x80 >> bitIndex;

	movzx	eax, BYTE PTR bitIndex$[rsp]
	mov	ecx, 128				; 00000080H
	mov	DWORD PTR tv94[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv94[rsp]
	sar	eax, cl
	mov	BYTE PTR bitIndexer$[rsp], al

; 39   : 
; 40   : 		if ((Buffer[byteIndex] & bitIndexer) > 0) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR byteIndex$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	movzx	ecx, BYTE PTR bitIndexer$[rsp]
	and	eax, ecx
	test	eax, eax
	jle	SHORT $LN1@operator

; 41   : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@operator
$LN1@operator:

; 42   : 		}
; 43   : 		return false;

	xor	al, al
$LN3@operator:

; 44   : 	}

	add	rsp, 24
	ret	0
??ABitmap@@QEAA_N_K@Z ENDP				; Bitmap::operator[]
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
?pmmngr_get_total_ram@@YA_KXZ PROC			; pmmngr_get_total_ram

; 217  : 	return total_ram;

	mov	rax, QWORD PTR ?total_ram@@3_KA		; total_ram

; 218  : }

	ret	0
?pmmngr_get_total_ram@@YA_KXZ ENDP			; pmmngr_get_total_ram
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
?pmmngr_get_used_ram@@YA_KXZ PROC			; pmmngr_get_used_ram

; 212  : 	return used_memory;

	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory

; 213  : }

	ret	0
?pmmngr_get_used_ram@@YA_KXZ ENDP			; pmmngr_get_used_ram
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
?pmmngr_get_free_ram@@YA_KXZ PROC			; pmmngr_get_free_ram

; 207  : 	return free_memory;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory

; 208  : }

	ret	0
?pmmngr_get_free_ram@@YA_KXZ ENDP			; pmmngr_get_free_ram
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
index$ = 32
addr$ = 64
?pmmngr_free@@YAXPEAX@Z PROC				; pmmngr_free

; 193  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 194  : 	uint64_t index = (uint64_t)addr / 4096;

	xor	edx, edx
	mov	rax, QWORD PTR addr$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR index$[rsp], rax

; 195  : 	if (ram_bitmap[index] == false) return;

	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@pmmngr_fre
	jmp	SHORT $LN4@pmmngr_fre
$LN3@pmmngr_fre:

; 196  : 	if (ram_bitmap.Set (index, false)) {

	xor	r8d, r8d
	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	?Set@Bitmap@@QEAA_N_K_N@Z		; Bitmap::Set
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@pmmngr_fre

; 197  : 		free_memory += 4096;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 198  : 		used_memory -= 4096;	

	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?used_memory@@3_KA, rax	; used_memory

; 199  : 		if (ram_bitmap_index > index) {

	mov	rax, QWORD PTR index$[rsp]
	cmp	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
	jbe	SHORT $LN1@pmmngr_fre

; 200  : 			ram_bitmap_index = index;

	mov	rax, QWORD PTR index$[rsp]
	mov	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
$LN1@pmmngr_fre:
$LN2@pmmngr_fre:
$LN4@pmmngr_fre:

; 201  : 		}
; 202  : 	}
; 203  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_free@@YAXPEAX@Z ENDP				; pmmngr_free
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
addr$ = 64
size$ = 72
?pmmngr_lock_pages@@YAXPEAX_K@Z PROC			; pmmngr_lock_pages

; 89   : void pmmngr_lock_pages (void *addr, size_t size) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 90   : 	for (int i = 0; i < size; i++) 

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@pmmngr_loc
$LN2@pmmngr_loc:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@pmmngr_loc:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR size$[rsp]
	jae	SHORT $LN1@pmmngr_loc

; 91   : 		pmmngr_lock_page ((void*)((size_t)addr + i * 4096));

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?pmmngr_lock_page@@YAXPEAX@Z		; pmmngr_lock_page
	jmp	SHORT $LN2@pmmngr_loc
$LN1@pmmngr_loc:

; 92   : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_lock_pages@@YAXPEAX_K@Z ENDP			; pmmngr_lock_pages
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
first$ = 40
size$ = 64
?pmmngr_alloc_blocks@@YAPEAXH@Z PROC			; pmmngr_alloc_blocks

; 179  : void* pmmngr_alloc_blocks (int size) {

$LN6:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 180  : 	void *first = pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR first$[rsp], rax

; 181  : 	for (int i = 0; i < size / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@pmmngr_all
$LN2@pmmngr_all:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@pmmngr_all:
	mov	eax, DWORD PTR size$[rsp]
	cdq
	and	edx, 4095				; 00000fffH
	add	eax, edx
	sar	eax, 12
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN1@pmmngr_all

; 182  : 		pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc

; 183  : 	}

	jmp	SHORT $LN2@pmmngr_all
$LN1@pmmngr_all:

; 184  : 
; 185  : 	return first; //here we need to swap page to file

	mov	rax, QWORD PTR first$[rsp]

; 186  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_alloc_blocks@@YAPEAXH@Z ENDP			; pmmngr_alloc_blocks
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
index$1 = 32
tv93 = 40
?pmmngr_alloc@@YAPEAXXZ PROC				; pmmngr_alloc

; 155  : {

$LN13:
	sub	rsp, 56					; 00000038H

; 156  : 	
; 157  : 	for (; ram_bitmap_index < ram_bitmap.Size * 8; ram_bitmap_index++) {

	jmp	SHORT $LN10@pmmngr_all
$LN9@pmmngr_all:
	mov	rax, QWORD PTR ?ram_bitmap_index@@3_KA	; ram_bitmap_index
	inc	rax
	mov	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
$LN10@pmmngr_all:
	mov	rax, QWORD PTR ?ram_bitmap@@3VBitmap@@A
	shl	rax, 3
	cmp	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
	jae	SHORT $LN8@pmmngr_all

; 158  : 		if (ram_bitmap[ram_bitmap_index] == true) continue;

	mov	rdx, QWORD PTR ?ram_bitmap_index@@3_KA	; ram_bitmap_index
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN7@pmmngr_all
	jmp	SHORT $LN9@pmmngr_all
$LN7@pmmngr_all:

; 159  : 		pmmngr_lock_page ((void*)(ram_bitmap_index * 4096));

	mov	rax, QWORD PTR ?ram_bitmap_index@@3_KA	; ram_bitmap_index
	imul	rax, 4096				; 00001000H
	mov	rcx, rax
	call	?pmmngr_lock_page@@YAXPEAX@Z		; pmmngr_lock_page

; 160  : 		used_memory += 4096 * 1;

	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?used_memory@@3_KA, rax	; used_memory

; 161  : 		return (void*)(ram_bitmap_index * 4096);

	mov	rax, QWORD PTR ?ram_bitmap_index@@3_KA	; ram_bitmap_index
	imul	rax, 4096				; 00001000H
	jmp	$LN11@pmmngr_all

; 162  : 	}

	jmp	$LN9@pmmngr_all
$LN8@pmmngr_all:

; 163  : 
; 164  : 	for (int index = 0; index  < ram_bitmap.Size * 8; index++) {

	mov	DWORD PTR index$1[rsp], 0
	jmp	SHORT $LN6@pmmngr_all
$LN5@pmmngr_all:
	mov	eax, DWORD PTR index$1[rsp]
	inc	eax
	mov	DWORD PTR index$1[rsp], eax
$LN6@pmmngr_all:
	movsxd	rax, DWORD PTR index$1[rsp]
	mov	rcx, QWORD PTR ?ram_bitmap@@3VBitmap@@A
	shl	rcx, 3
	cmp	rax, rcx
	jae	SHORT $LN4@pmmngr_all

; 165  : 		if (ram_bitmap[index] == true) continue;

	movsxd	rax, DWORD PTR index$1[rsp]
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN3@pmmngr_all
	jmp	SHORT $LN5@pmmngr_all
$LN3@pmmngr_all:

; 166  : 		pmmngr_lock_page ((void*)(index * 4096));

	mov	eax, DWORD PTR index$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, rax
	call	?pmmngr_lock_page@@YAXPEAX@Z		; pmmngr_lock_page

; 167  : 		used_memory += 4096 * 1;

	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?used_memory@@3_KA, rax	; used_memory

; 168  : 		return (void*)(index * 4096);

	mov	eax, DWORD PTR index$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	jmp	SHORT $LN11@pmmngr_all

; 169  : 	}

	jmp	SHORT $LN5@pmmngr_all
$LN4@pmmngr_all:

; 170  : 	x64_cli();

	call	x64_cli

; 171  : 	printf ("Used RAM -> %d MB, Free RAM -> %d MB\n", used_memory /1024 / 1024, free_memory / 1024 / 1024);

	xor	edx, edx
	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	mov	ecx, 1024				; 00000400H
	div	rcx
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	rcx
	mov	QWORD PTR tv93[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory
	mov	ecx, 1024				; 00000400H
	div	rcx
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	rcx
	mov	rcx, QWORD PTR tv93[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG2967
	call	?printf@@YAXPEBDZZ			; printf

; 172  : 	printf ("No more available pages\n");

	lea	rcx, OFFSET FLAT:$SG2968
	call	?printf@@YAXPEBDZZ			; printf

; 173  : 	x64_hlt();

	call	x64_hlt
$LN2@pmmngr_all:

; 174  : 	for(;;);

	jmp	SHORT $LN2@pmmngr_all

; 175  : 	return NULL; //here we need to swap page to file

	xor	eax, eax
$LN11@pmmngr_all:

; 176  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_alloc@@YAPEAXXZ ENDP				; pmmngr_alloc
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
efi_mem$2 = 40
memory_size$ = 48
bitmap_size$ = 56
memmap_entries$ = 64
unusable$ = 72
_info$ = 96
?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z PROC	; pmmngr_init

; 115  : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 116  : 	//! scan for memory above 1MB and set up the current pointer
; 117  : 
; 118  : 	uint64_t memory_size = _info->ram_size;

	mov	rax, QWORD PTR _info$[rsp]
	mov	rax, QWORD PTR [rax+20]
	mov	QWORD PTR memory_size$[rsp], rax

; 119  : 	free_memory = memory_size;

	mov	rax, QWORD PTR memory_size$[rsp]
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 120  : 	uint64_t bitmap_size = memory_size / 4096 / 8 + 1;

	xor	edx, edx
	mov	rax, QWORD PTR memory_size$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	xor	edx, edx
	mov	ecx, 8
	div	rcx
	inc	rax
	mov	QWORD PTR bitmap_size$[rsp], rax

; 121  : 	ram_bitmap_index = 0;

	mov	QWORD PTR ?ram_bitmap_index@@3_KA, 0	; ram_bitmap_index

; 122  : 	total_ram = 0;

	mov	QWORD PTR ?total_ram@@3_KA, 0		; total_ram

; 123  : 
; 124  : 	pmmngr_init_bitmap (bitmap_size, (void*) _info->phys_start); 

	mov	rax, QWORD PTR _info$[rsp]
	mov	rdx, QWORD PTR [rax+4]
	mov	rcx, QWORD PTR bitmap_size$[rsp]
	call	?pmmngr_init_bitmap@@YAX_KPEAX@Z	; pmmngr_init_bitmap

; 125  : 
; 126  : 	pmmngr_lock_pages ((void*)_info->phys_start,bitmap_size);

	mov	rdx, QWORD PTR bitmap_size$[rsp]
	mov	rax, QWORD PTR _info$[rsp]
	mov	rcx, QWORD PTR [rax+4]
	call	?pmmngr_lock_pages@@YAXPEAX_K@Z		; pmmngr_lock_pages

; 127  : 
; 128  : 	//Lock every EFI-Reserved memories here
; 129  : 	uint64_t memmap_entries = _info->mem_map_size / _info->descriptor_size;

	xor	edx, edx
	mov	rax, QWORD PTR _info$[rsp]
	mov	rax, QWORD PTR [rax+44]
	mov	rcx, QWORD PTR _info$[rsp]
	div	QWORD PTR [rcx+36]
	mov	QWORD PTR memmap_entries$[rsp], rax

; 130  : 
; 131  : 	//! Currently uses EFI-Memory Maps to check reserved regions
; 132  : 	for (int i = 0; i < memmap_entries; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@pmmngr_ini
$LN3@pmmngr_ini:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@pmmngr_ini:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR memmap_entries$[rsp]
	jae	SHORT $LN2@pmmngr_ini

; 133  : 		EFI_MEMORY_DESCRIPTOR *efi_mem = (EFI_MEMORY_DESCRIPTOR*)((uint64_t)_info->map + i * _info->descriptor_size);

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR _info$[rsp]
	imul	rax, QWORD PTR [rcx+36]
	mov	rcx, QWORD PTR _info$[rsp]
	add	rax, QWORD PTR [rcx+28]
	mov	QWORD PTR efi_mem$2[rsp], rax

; 134  : 		total_ram += efi_mem->num_pages * 4096;

	mov	rax, QWORD PTR efi_mem$2[rsp]
	mov	rax, QWORD PTR [rax+24]
	imul	rax, 4096				; 00001000H
	mov	rcx, QWORD PTR ?total_ram@@3_KA		; total_ram
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?total_ram@@3_KA, rax		; total_ram

; 135  : 		if (efi_mem->type != 7) {

	mov	rax, QWORD PTR efi_mem$2[rsp]
	cmp	DWORD PTR [rax], 7
	je	SHORT $LN1@pmmngr_ini

; 136  : 			//! lock every pages
; 137  : 			free_memory -= 4096;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 138  : 			pmmngr_lock_pages ((void*)efi_mem->phys_start,efi_mem->num_pages);

	mov	rax, QWORD PTR efi_mem$2[rsp]
	mov	rdx, QWORD PTR [rax+24]
	mov	rax, QWORD PTR efi_mem$2[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?pmmngr_lock_pages@@YAXPEAX_K@Z		; pmmngr_lock_pages
$LN1@pmmngr_ini:

; 139  : 		}
; 140  : 	}

	jmp	$LN3@pmmngr_ini
$LN2@pmmngr_ini:

; 141  : 
; 142  : 	total_ram -= reserved_memory;

	mov	rax, QWORD PTR ?reserved_memory@@3_KA	; reserved_memory
	mov	rcx, QWORD PTR ?total_ram@@3_KA		; total_ram
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?total_ram@@3_KA, rax		; total_ram

; 143  : 
; 144  : 	void *unusable = pmmngr_alloc(); //0 is avoided

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR unusable$[rsp], rax

; 145  : }

	add	rsp, 88					; 00000058H
	ret	0
?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ENDP	; pmmngr_init
_TEXT	ENDS
END
