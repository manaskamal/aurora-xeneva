; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?free_memory@@3_KA				; free_memory
PUBLIC	?reserved_memory@@3_KA				; reserved_memory
PUBLIC	?used_memory@@3_KA				; used_memory
PUBLIC	?ram_bitmap_index@@3_KA				; ram_bitmap_index
PUBLIC	?total_ram@@3_KA				; total_ram
PUBLIC	?ram_bitmap@@3VBitmap@@A			; ram_bitmap
_BSS	SEGMENT
?free_memory@@3_KA DQ 01H DUP (?)			; free_memory
?reserved_memory@@3_KA DQ 01H DUP (?)			; reserved_memory
?used_memory@@3_KA DQ 01H DUP (?)			; used_memory
?ram_bitmap_index@@3_KA DQ 01H DUP (?)			; ram_bitmap_index
?total_ram@@3_KA DQ 01H DUP (?)				; total_ram
?ram_bitmap@@3VBitmap@@A DB 010H DUP (?)		; ram_bitmap
_BSS	ENDS
CONST	SEGMENT
$SG2984	DB	'Used RAM -> %d MB, Free RAM -> %d MB', 0aH, 00H
	ORG $+2
$SG2985	DB	'No more available pages', 0aH, 00H
CONST	ENDS
PUBLIC	?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z	; pmmngr_init
PUBLIC	?pmmngr_alloc@@YAPEAXXZ				; pmmngr_alloc
PUBLIC	?pmmngr_alloc_blocks@@YAPEAXH@Z			; pmmngr_alloc_blocks
PUBLIC	?pmmngr_lock_pages@@YAXPEAX_K@Z			; pmmngr_lock_pages
PUBLIC	?pmmngr_lock_page@@YAXPEAX@Z			; pmmngr_lock_page
PUBLIC	?pmmngr_free@@YAXPEAX@Z				; pmmngr_free
PUBLIC	?pmmngr_free_blocks@@YAXPEAXH@Z			; pmmngr_free_blocks
PUBLIC	?pmmngr_get_free_ram@@YA_KXZ			; pmmngr_get_free_ram
PUBLIC	?pmmngr_get_used_ram@@YA_KXZ			; pmmngr_get_used_ram
PUBLIC	?pmmngr_get_total_ram@@YA_KXZ			; pmmngr_get_total_ram
PUBLIC	??ABitmap@@QEAA_N_K@Z				; Bitmap::operator[]
PUBLIC	?Set@Bitmap@@QEAA_N_K_N@Z			; Bitmap::Set
PUBLIC	?pmmngr_init_bitmap@@YAX_KPEAX@Z		; pmmngr_init_bitmap
PUBLIC	?pmmngr_unreserve_page@@YAXPEAX@Z		; pmmngr_unreserve_page
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
EXTRN	x64_cli:PROC
EXTRN	x64_hlt:PROC
pdata	SEGMENT
$pdata$?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD imagerel $LN10
	DD	imagerel $LN10+455
	DD	imagerel $unwind$?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z
$pdata$?pmmngr_alloc@@YAPEAXXZ DD imagerel $LN9
	DD	imagerel $LN9+245
	DD	imagerel $unwind$?pmmngr_alloc@@YAPEAXXZ
$pdata$?pmmngr_alloc_blocks@@YAPEAXH@Z DD imagerel $LN6
	DD	imagerel $LN6+77
	DD	imagerel $unwind$?pmmngr_alloc_blocks@@YAPEAXH@Z
$pdata$?pmmngr_lock_pages@@YAXPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+84
	DD	imagerel $unwind$?pmmngr_lock_pages@@YAXPEAX_K@Z
$pdata$?pmmngr_lock_page@@YAXPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+128
	DD	imagerel $unwind$?pmmngr_lock_page@@YAXPEAX@Z
$pdata$?pmmngr_free@@YAXPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?pmmngr_free@@YAXPEAX@Z
$pdata$?pmmngr_free_blocks@@YAXPEAXH@Z DD imagerel $LN6
	DD	imagerel $LN6+86
	DD	imagerel $unwind$?pmmngr_free_blocks@@YAXPEAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??ABitmap@@QEAA_N_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$??ABitmap@@QEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Set@Bitmap@@QEAA_N_K_N@Z DD imagerel $LN5
	DD	imagerel $LN5+213
	DD	imagerel $unwind$?Set@Bitmap@@QEAA_N_K_N@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?pmmngr_init_bitmap@@YAX_KPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+88
	DD	imagerel $unwind$?pmmngr_init_bitmap@@YAX_KPEAX@Z
$pdata$?pmmngr_unreserve_page@@YAXPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?pmmngr_unreserve_page@@YAXPEAX@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Set@Bitmap@@QEAA_N_K_N@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??ABitmap@@QEAA_N_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
xdata	SEGMENT
$unwind$?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD 010901H
	DD	0c209H
$unwind$?pmmngr_alloc@@YAPEAXXZ DD 010401H
	DD	06204H
$unwind$?pmmngr_alloc_blocks@@YAPEAXH@Z DD 010801H
	DD	06208H
$unwind$?pmmngr_lock_pages@@YAXPEAX_K@Z DD 010e01H
	DD	0620eH
$unwind$?pmmngr_lock_page@@YAXPEAX@Z DD 010901H
	DD	06209H
$unwind$?pmmngr_free@@YAXPEAX@Z DD 010901H
	DD	06209H
$unwind$?pmmngr_free_blocks@@YAXPEAXH@Z DD 010d01H
	DD	0620dH
$unwind$?pmmngr_init_bitmap@@YAX_KPEAX@Z DD 010e01H
	DD	0220eH
$unwind$?pmmngr_unreserve_page@@YAXPEAX@Z DD 010901H
	DD	06209H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
index$ = 32
addr$ = 64
?pmmngr_unreserve_page@@YAXPEAX@Z PROC			; pmmngr_unreserve_page

; 96   : void pmmngr_unreserve_page (void* addr) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 97   : 
; 98   : 	uint64_t index = (uint64_t)addr / 4096;

	xor	edx, edx
	mov	rax, QWORD PTR addr$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR index$[rsp], rax

; 99   : 	if (ram_bitmap[index] == false) return;

	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@pmmngr_unr
	jmp	SHORT $LN4@pmmngr_unr
$LN3@pmmngr_unr:

; 100  : 	if (ram_bitmap.Set(index, false)) {

	xor	r8d, r8d
	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	?Set@Bitmap@@QEAA_N_K_N@Z		; Bitmap::Set
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@pmmngr_unr

; 101  : 		free_memory += 4096;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 102  : 		reserved_memory -= 4096;

	mov	rax, QWORD PTR ?reserved_memory@@3_KA	; reserved_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?reserved_memory@@3_KA, rax	; reserved_memory

; 103  : 		if (ram_bitmap_index > index) ram_bitmap_index = index;

	mov	rax, QWORD PTR index$[rsp]
	cmp	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
	jbe	SHORT $LN1@pmmngr_unr
	mov	rax, QWORD PTR index$[rsp]
	mov	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
$LN1@pmmngr_unr:
$LN2@pmmngr_unr:
$LN4@pmmngr_unr:

; 104  : 	}
; 105  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_unreserve_page@@YAXPEAX@Z ENDP			; pmmngr_unreserve_page
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 0
bitmap_size$ = 32
buffer$ = 40
?pmmngr_init_bitmap@@YAX_KPEAX@Z PROC			; pmmngr_init_bitmap

; 68   : void pmmngr_init_bitmap (size_t bitmap_size, void* buffer) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 69   : 
; 70   : 	ram_bitmap.Size = bitmap_size;

	mov	rax, QWORD PTR bitmap_size$[rsp]
	mov	QWORD PTR ?ram_bitmap@@3VBitmap@@A, rax

; 71   : 	ram_bitmap.Buffer = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR ?ram_bitmap@@3VBitmap@@A+8, rax

; 72   : 
; 73   : 	for (int i = 0; i < bitmap_size ; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@pmmngr_ini
$LN2@pmmngr_ini:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@pmmngr_ini:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR bitmap_size$[rsp]
	jae	SHORT $LN1@pmmngr_ini

; 74   : 		*(uint8_t*)(ram_bitmap.Buffer + i) = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR ?ram_bitmap@@3VBitmap@@A+8
	mov	BYTE PTR [rcx+rax], 0

; 75   : 	}

	jmp	SHORT $LN2@pmmngr_ini
$LN1@pmmngr_ini:

; 76   : }

	add	rsp, 24
	ret	0
?pmmngr_init_bitmap@@YAX_KPEAX@Z ENDP			; pmmngr_init_bitmap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
;	COMDAT ?Set@Bitmap@@QEAA_N_K_N@Z
_TEXT	SEGMENT
bitIndexer$ = 0
bitIndex$ = 1
tv145 = 4
byteIndex$ = 8
this$ = 32
index$ = 40
value$ = 48
?Set@Bitmap@@QEAA_N_K_N@Z PROC				; Bitmap::Set, COMDAT

; 48   : 	bool Set(uint64_t index, bool value) {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 49   : 		
; 50   : 		if (index > Size * 8) return false;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	shl	rax, 3
	cmp	QWORD PTR index$[rsp], rax
	jbe	SHORT $LN2@Set
	xor	al, al
	jmp	$LN3@Set
$LN2@Set:

; 51   : 
; 52   : 		uint64_t byteIndex = index / 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 8
	div	rcx
	mov	QWORD PTR byteIndex$[rsp], rax

; 53   : 		uint8_t  bitIndex = index % 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 8
	div	rcx
	mov	rax, rdx
	mov	BYTE PTR bitIndex$[rsp], al

; 54   : 		uint8_t  bitIndexer = 0x80 >> bitIndex;

	movzx	eax, BYTE PTR bitIndex$[rsp]
	mov	ecx, 128				; 00000080H
	mov	DWORD PTR tv145[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv145[rsp]
	sar	eax, cl
	mov	BYTE PTR bitIndexer$[rsp], al

; 55   : 	
; 56   : 		Buffer[byteIndex] &= ~bitIndexer;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	ecx, BYTE PTR bitIndexer$[rsp]
	not	ecx
	mov	rdx, QWORD PTR byteIndex$[rsp]
	movzx	eax, BYTE PTR [rax+rdx]
	and	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR byteIndex$[rsp]
	mov	BYTE PTR [rcx+rdx], al

; 57   : 		if (value) {

	movzx	eax, BYTE PTR value$[rsp]
	test	eax, eax
	je	SHORT $LN1@Set

; 58   : 			Buffer[byteIndex] |= bitIndexer;	

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	ecx, BYTE PTR bitIndexer$[rsp]
	mov	rdx, QWORD PTR byteIndex$[rsp]
	movzx	eax, BYTE PTR [rax+rdx]
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR byteIndex$[rsp]
	mov	BYTE PTR [rcx+rdx], al
$LN1@Set:

; 59   : 		}
; 60   : 
; 61   : 		return true;

	mov	al, 1
$LN3@Set:

; 62   : 	}

	add	rsp, 24
	ret	0
?Set@Bitmap@@QEAA_N_K_N@Z ENDP				; Bitmap::Set
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
;	COMDAT ??ABitmap@@QEAA_N_K@Z
_TEXT	SEGMENT
bitIndex$ = 0
bitIndexer$ = 1
tv94 = 4
byteIndex$ = 8
this$ = 32
index$ = 40
??ABitmap@@QEAA_N_K@Z PROC				; Bitmap::operator[], COMDAT

; 34   : 	bool operator[](uint64_t index) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 35   : 		
; 36   : 		if (index > Size * 8) return false;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	shl	rax, 3
	cmp	QWORD PTR index$[rsp], rax
	jbe	SHORT $LN2@operator
	xor	al, al
	jmp	SHORT $LN3@operator
$LN2@operator:

; 37   : 		uint64_t byteIndex = index / 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 8
	div	rcx
	mov	QWORD PTR byteIndex$[rsp], rax

; 38   : 		uint8_t  bitIndex = index % 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 8
	div	rcx
	mov	rax, rdx
	mov	BYTE PTR bitIndex$[rsp], al

; 39   : 		uint8_t  bitIndexer = 0x80 >> bitIndex;

	movzx	eax, BYTE PTR bitIndex$[rsp]
	mov	ecx, 128				; 00000080H
	mov	DWORD PTR tv94[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv94[rsp]
	sar	eax, cl
	mov	BYTE PTR bitIndexer$[rsp], al

; 40   : 
; 41   : 		if ((Buffer[byteIndex] & bitIndexer) > 0) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR byteIndex$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	movzx	ecx, BYTE PTR bitIndexer$[rsp]
	and	eax, ecx
	test	eax, eax
	jle	SHORT $LN1@operator

; 42   : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@operator
$LN1@operator:

; 43   : 		}
; 44   : 		return false;

	xor	al, al
$LN3@operator:

; 45   : 	}

	add	rsp, 24
	ret	0
??ABitmap@@QEAA_N_K@Z ENDP				; Bitmap::operator[]
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
?pmmngr_get_total_ram@@YA_KXZ PROC			; pmmngr_get_total_ram

; 238  : 	return total_ram;

	mov	rax, QWORD PTR ?total_ram@@3_KA		; total_ram

; 239  : }

	ret	0
?pmmngr_get_total_ram@@YA_KXZ ENDP			; pmmngr_get_total_ram
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
?pmmngr_get_used_ram@@YA_KXZ PROC			; pmmngr_get_used_ram

; 233  : 	return used_memory;

	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory

; 234  : }

	ret	0
?pmmngr_get_used_ram@@YA_KXZ ENDP			; pmmngr_get_used_ram
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
?pmmngr_get_free_ram@@YA_KXZ PROC			; pmmngr_get_free_ram

; 228  : 	return free_memory;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory

; 229  : }

	ret	0
?pmmngr_get_free_ram@@YA_KXZ ENDP			; pmmngr_get_free_ram
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
address$ = 40
addr$ = 64
count$ = 72
?pmmngr_free_blocks@@YAXPEAXH@Z PROC			; pmmngr_free_blocks

; 218  : void pmmngr_free_blocks (void* addr, int count) {

$LN6:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 219  : 	uint64_t * address = (uint64_t*)addr;

	mov	rax, QWORD PTR addr$[rsp]
	mov	QWORD PTR address$[rsp], rax

; 220  : 	for (uint32_t i = 0; i < count; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@pmmngr_fre
$LN2@pmmngr_fre:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@pmmngr_fre:
	mov	eax, DWORD PTR count$[rsp]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN1@pmmngr_fre

; 221  : 		pmmngr_free (address);

	mov	rcx, QWORD PTR address$[rsp]
	call	?pmmngr_free@@YAXPEAX@Z			; pmmngr_free

; 222  : 		address += 0x1000;

	mov	rax, QWORD PTR address$[rsp]
	add	rax, 32768				; 00008000H
	mov	QWORD PTR address$[rsp], rax

; 223  : 	}

	jmp	SHORT $LN2@pmmngr_fre
$LN1@pmmngr_fre:

; 224  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_free_blocks@@YAXPEAXH@Z ENDP			; pmmngr_free_blocks
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
index$ = 32
addr$ = 64
?pmmngr_free@@YAXPEAX@Z PROC				; pmmngr_free

; 203  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 204  : 	uint64_t index = (uint64_t)addr / 4096;

	xor	edx, edx
	mov	rax, QWORD PTR addr$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR index$[rsp], rax

; 205  : 	if (ram_bitmap[index] == false) return;

	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@pmmngr_fre
	jmp	SHORT $LN4@pmmngr_fre
$LN3@pmmngr_fre:

; 206  : 	if (ram_bitmap.Set (index, false)) {

	xor	r8d, r8d
	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	?Set@Bitmap@@QEAA_N_K_N@Z		; Bitmap::Set
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@pmmngr_fre

; 207  : 		free_memory += 4096;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 208  : 		used_memory -= 4096;	

	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?used_memory@@3_KA, rax	; used_memory

; 209  : 		if (ram_bitmap_index > index) {

	mov	rax, QWORD PTR index$[rsp]
	cmp	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
	jbe	SHORT $LN1@pmmngr_fre

; 210  : 			ram_bitmap_index = index;

	mov	rax, QWORD PTR index$[rsp]
	mov	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
$LN1@pmmngr_fre:
$LN2@pmmngr_fre:
$LN4@pmmngr_fre:

; 211  : 		}
; 212  : 	}
; 213  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_free@@YAXPEAX@Z ENDP				; pmmngr_free
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
index$ = 32
addr$ = 64
?pmmngr_lock_page@@YAXPEAX@Z PROC			; pmmngr_lock_page

; 79   : void pmmngr_lock_page ( void* addr) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 80   : 
; 81   : 	uint64_t index = (uint64_t)addr / 4096;

	xor	edx, edx
	mov	rax, QWORD PTR addr$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR index$[rsp], rax

; 82   : 	if (ram_bitmap[index] == true) return;

	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN2@pmmngr_loc
	jmp	SHORT $LN3@pmmngr_loc
$LN2@pmmngr_loc:

; 83   : 	if (ram_bitmap.Set (index, true)) {

	mov	r8b, 1
	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	?Set@Bitmap@@QEAA_N_K_N@Z		; Bitmap::Set
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@pmmngr_loc

; 84   : 		free_memory -= 4096;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 85   : 		reserved_memory += 4096;

	mov	rax, QWORD PTR ?reserved_memory@@3_KA	; reserved_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?reserved_memory@@3_KA, rax	; reserved_memory
$LN1@pmmngr_loc:
$LN3@pmmngr_loc:

; 86   : 	}
; 87   : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_lock_page@@YAXPEAX@Z ENDP			; pmmngr_lock_page
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
addr$ = 64
size$ = 72
?pmmngr_lock_pages@@YAXPEAX_K@Z PROC			; pmmngr_lock_pages

; 90   : void pmmngr_lock_pages (void *addr, size_t size) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 91   : 	for (int i = 0; i < size; i++) 

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@pmmngr_loc
$LN2@pmmngr_loc:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@pmmngr_loc:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR size$[rsp]
	jae	SHORT $LN1@pmmngr_loc

; 92   : 		pmmngr_lock_page ((void*)((size_t)addr + i * 4096));

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?pmmngr_lock_page@@YAXPEAX@Z		; pmmngr_lock_page
	jmp	SHORT $LN2@pmmngr_loc
$LN1@pmmngr_loc:

; 93   : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_lock_pages@@YAXPEAX_K@Z ENDP			; pmmngr_lock_pages
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
first$ = 40
size$ = 64
?pmmngr_alloc_blocks@@YAPEAXH@Z PROC			; pmmngr_alloc_blocks

; 189  : void* pmmngr_alloc_blocks (int size) {

$LN6:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 190  : 	void *first = pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR first$[rsp], rax

; 191  : 	for (int i = 0; i < size / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@pmmngr_all
$LN2@pmmngr_all:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@pmmngr_all:
	mov	eax, DWORD PTR size$[rsp]
	cdq
	and	edx, 4095				; 00000fffH
	add	eax, edx
	sar	eax, 12
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN1@pmmngr_all

; 192  : 		pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc

; 193  : 	}

	jmp	SHORT $LN2@pmmngr_all
$LN1@pmmngr_all:

; 194  : 
; 195  : 	return first; //here we need to swap page to file

	mov	rax, QWORD PTR first$[rsp]

; 196  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_alloc_blocks@@YAPEAXH@Z ENDP			; pmmngr_alloc_blocks
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
tv77 = 32
?pmmngr_alloc@@YAPEAXXZ PROC				; pmmngr_alloc

; 163  : {

$LN9:
	sub	rsp, 56					; 00000038H

; 164  : 	
; 165  : 	for (; ram_bitmap_index < ram_bitmap.Size * 8; ram_bitmap_index++) {

	jmp	SHORT $LN6@pmmngr_all
$LN5@pmmngr_all:
	mov	rax, QWORD PTR ?ram_bitmap_index@@3_KA	; ram_bitmap_index
	inc	rax
	mov	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
$LN6@pmmngr_all:
	mov	rax, QWORD PTR ?ram_bitmap@@3VBitmap@@A
	shl	rax, 3
	cmp	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
	jae	SHORT $LN4@pmmngr_all

; 166  : 		if (ram_bitmap[ram_bitmap_index] == true) continue;

	mov	rdx, QWORD PTR ?ram_bitmap_index@@3_KA	; ram_bitmap_index
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN3@pmmngr_all
	jmp	SHORT $LN5@pmmngr_all
$LN3@pmmngr_all:

; 167  : 		pmmngr_lock_page ((void*)(ram_bitmap_index * 4096));

	mov	rax, QWORD PTR ?ram_bitmap_index@@3_KA	; ram_bitmap_index
	imul	rax, 4096				; 00001000H
	mov	rcx, rax
	call	?pmmngr_lock_page@@YAXPEAX@Z		; pmmngr_lock_page

; 168  : 		used_memory += 4096 * 1;

	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?used_memory@@3_KA, rax	; used_memory

; 169  : 	/*	if (is_serial_initialized())
; 170  : 			_debug_print_("Pmmngr Allocated ->%x \r\n",ram_bitmap_index * 4096);*/
; 171  : 		return (void*)(ram_bitmap_index * 4096);

	mov	rax, QWORD PTR ?ram_bitmap_index@@3_KA	; ram_bitmap_index
	imul	rax, 4096				; 00001000H
	jmp	SHORT $LN7@pmmngr_all

; 172  : 	}

	jmp	SHORT $LN5@pmmngr_all
$LN4@pmmngr_all:

; 173  : 
; 174  : 	/*for (int index = 0; index  < ram_bitmap.Size * 8; index++) {
; 175  : 		if (ram_bitmap[index] == true) continue;
; 176  : 		pmmngr_lock_page ((void*)(index * 4096));
; 177  : 		used_memory += 4096 * 1;
; 178  : 		return (void*)(index * 4096);
; 179  : 	}*/
; 180  : 	x64_cli();

	call	x64_cli

; 181  : 	printf ("Used RAM -> %d MB, Free RAM -> %d MB\n", used_memory /1024 / 1024, free_memory / 1024 / 1024);

	xor	edx, edx
	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	mov	ecx, 1024				; 00000400H
	div	rcx
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	rcx
	mov	QWORD PTR tv77[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory
	mov	ecx, 1024				; 00000400H
	div	rcx
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	rcx
	mov	rcx, QWORD PTR tv77[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG2984
	call	?printf@@YAXPEBDZZ			; printf

; 182  : 	printf ("No more available pages\n");

	lea	rcx, OFFSET FLAT:$SG2985
	call	?printf@@YAXPEBDZZ			; printf

; 183  : 	x64_hlt();

	call	x64_hlt
$LN2@pmmngr_all:

; 184  : 	for(;;);

	jmp	SHORT $LN2@pmmngr_all

; 185  : 	return NULL; //here we need to swap page to file

	xor	eax, eax
$LN7@pmmngr_all:

; 186  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_alloc@@YAPEAXXZ ENDP				; pmmngr_alloc
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
efi_mem$3 = 40
memory_size$ = 48
bitmap_size$ = 56
memmap_entries$ = 64
pos$ = 72
unusable$ = 80
_info$ = 112
?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z PROC	; pmmngr_init

; 116  : {

$LN10:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 117  : 	//! scan for memory above 1MB and set up the current pointer
; 118  : 
; 119  : 	uint64_t memory_size = _info->ram_size;

	mov	rax, QWORD PTR _info$[rsp]
	mov	rax, QWORD PTR [rax+20]
	mov	QWORD PTR memory_size$[rsp], rax

; 120  : 	free_memory = memory_size;

	mov	rax, QWORD PTR memory_size$[rsp]
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 121  : 	uint64_t bitmap_size = memory_size / 4096 / 8 + 1;

	xor	edx, edx
	mov	rax, QWORD PTR memory_size$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	xor	edx, edx
	mov	ecx, 8
	div	rcx
	inc	rax
	mov	QWORD PTR bitmap_size$[rsp], rax

; 122  : 	ram_bitmap_index = 0;

	mov	QWORD PTR ?ram_bitmap_index@@3_KA, 0	; ram_bitmap_index

; 123  : 	total_ram = 0;

	mov	QWORD PTR ?total_ram@@3_KA, 0		; total_ram

; 124  : 
; 125  : 	pmmngr_init_bitmap (bitmap_size, (void*) _info->phys_start); 

	mov	rax, QWORD PTR _info$[rsp]
	mov	rdx, QWORD PTR [rax+4]
	mov	rcx, QWORD PTR bitmap_size$[rsp]
	call	?pmmngr_init_bitmap@@YAX_KPEAX@Z	; pmmngr_init_bitmap

; 126  : 
; 127  : 	pmmngr_lock_pages ((void*)_info->phys_start,bitmap_size);

	mov	rdx, QWORD PTR bitmap_size$[rsp]
	mov	rax, QWORD PTR _info$[rsp]
	mov	rcx, QWORD PTR [rax+4]
	call	?pmmngr_lock_pages@@YAXPEAX_K@Z		; pmmngr_lock_pages

; 128  : 
; 129  : 	//Lock every EFI-Reserved memories here
; 130  : 	uint64_t memmap_entries = _info->mem_map_size / _info->descriptor_size;

	xor	edx, edx
	mov	rax, QWORD PTR _info$[rsp]
	mov	rax, QWORD PTR [rax+44]
	mov	rcx, QWORD PTR _info$[rsp]
	div	QWORD PTR [rcx+36]
	mov	QWORD PTR memmap_entries$[rsp], rax

; 131  : 
; 132  : 	//! Currently uses EFI-Memory Maps to check reserved regions
; 133  : 	for (int i = 0; i < memmap_entries; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN7@pmmngr_ini
$LN6@pmmngr_ini:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN7@pmmngr_ini:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR memmap_entries$[rsp]
	jae	SHORT $LN5@pmmngr_ini

; 134  : 		EFI_MEMORY_DESCRIPTOR *efi_mem = (EFI_MEMORY_DESCRIPTOR*)((uint64_t)_info->map + i * _info->descriptor_size);

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR _info$[rsp]
	imul	rax, QWORD PTR [rcx+36]
	mov	rcx, QWORD PTR _info$[rsp]
	add	rax, QWORD PTR [rcx+28]
	mov	QWORD PTR efi_mem$3[rsp], rax

; 135  : 		total_ram += efi_mem->num_pages * 4096;

	mov	rax, QWORD PTR efi_mem$3[rsp]
	mov	rax, QWORD PTR [rax+24]
	imul	rax, 4096				; 00001000H
	mov	rcx, QWORD PTR ?total_ram@@3_KA		; total_ram
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?total_ram@@3_KA, rax		; total_ram

; 136  : 		if (efi_mem->type != 7) {

	mov	rax, QWORD PTR efi_mem$3[rsp]
	cmp	DWORD PTR [rax], 7
	je	SHORT $LN4@pmmngr_ini

; 137  : 			//! lock every pages
; 138  : 			free_memory -= 4096;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 139  : 			pmmngr_lock_pages ((void*)efi_mem->phys_start,efi_mem->num_pages);

	mov	rax, QWORD PTR efi_mem$3[rsp]
	mov	rdx, QWORD PTR [rax+24]
	mov	rax, QWORD PTR efi_mem$3[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?pmmngr_lock_pages@@YAXPEAX_K@Z		; pmmngr_lock_pages
$LN4@pmmngr_ini:

; 140  : 		}
; 141  : 	}

	jmp	$LN6@pmmngr_ini
$LN5@pmmngr_ini:

; 142  : 
; 143  : 
; 144  : 	pmmngr_lock_pages(_info->graphics_framebuffer,_info->fb_size / 4096);

	xor	edx, edx
	mov	rax, QWORD PTR _info$[rsp]
	mov	rax, QWORD PTR [rax+60]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	rdx, rax
	mov	rax, QWORD PTR _info$[rsp]
	mov	rcx, QWORD PTR [rax+52]
	call	?pmmngr_lock_pages@@YAXPEAX_K@Z		; pmmngr_lock_pages

; 145  : 
; 146  : 	uint64_t pos = 0x1005D000;

	mov	QWORD PTR pos$[rsp], 268816384		; 1005d000H

; 147  : 	for (int i = 0; i < 12*1024 / 4096; i++)

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN3@pmmngr_ini
$LN2@pmmngr_ini:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN3@pmmngr_ini:
	cmp	DWORD PTR i$2[rsp], 3
	jge	SHORT $LN1@pmmngr_ini

; 148  : 		pmmngr_lock_page((void*)(pos + i * 4096));

	mov	eax, DWORD PTR i$2[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR pos$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?pmmngr_lock_page@@YAXPEAX@Z		; pmmngr_lock_page
	jmp	SHORT $LN2@pmmngr_ini
$LN1@pmmngr_ini:

; 149  : 
; 150  : 	total_ram -= reserved_memory;

	mov	rax, QWORD PTR ?reserved_memory@@3_KA	; reserved_memory
	mov	rcx, QWORD PTR ?total_ram@@3_KA		; total_ram
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?total_ram@@3_KA, rax		; total_ram

; 151  : 
; 152  : 	void *unusable = pmmngr_alloc(); //0 is avoided

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR unusable$[rsp], rax

; 153  : }

	add	rsp, 104				; 00000068H
	ret	0
?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ENDP	; pmmngr_init
_TEXT	ENDS
END
