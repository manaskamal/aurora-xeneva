; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?free_memory@@3_KA				; free_memory
PUBLIC	?reserved_memory@@3_KA				; reserved_memory
PUBLIC	?used_memory@@3_KA				; used_memory
PUBLIC	?ram_bitmap_index@@3_KA				; ram_bitmap_index
PUBLIC	?total_ram@@3_KA				; total_ram
PUBLIC	?ram_bitmap@@3VBitmap@@A			; ram_bitmap
_BSS	SEGMENT
?free_memory@@3_KA DQ 01H DUP (?)			; free_memory
?reserved_memory@@3_KA DQ 01H DUP (?)			; reserved_memory
?used_memory@@3_KA DQ 01H DUP (?)			; used_memory
?ram_bitmap_index@@3_KA DQ 01H DUP (?)			; ram_bitmap_index
?total_ram@@3_KA DQ 01H DUP (?)				; total_ram
?ram_bitmap@@3VBitmap@@A DB 010H DUP (?)		; ram_bitmap
_BSS	ENDS
CONST	SEGMENT
$SG2801	DB	'Used RAM -> %d MB, Free RAM -> %d MB', 0aH, 00H
	ORG $+2
$SG2802	DB	'No more available pages', 0aH, 00H
CONST	ENDS
PUBLIC	?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z	; pmmngr_init
PUBLIC	?pmmngr_alloc@@YAPEAXXZ				; pmmngr_alloc
PUBLIC	?pmmngr_alloc_blocks@@YAPEAXH@Z			; pmmngr_alloc_blocks
PUBLIC	?pmmngr_lock_pages@@YAXPEAX_K@Z			; pmmngr_lock_pages
PUBLIC	?pmmngr_free@@YAXPEAX@Z				; pmmngr_free
PUBLIC	?pmmngr_get_free_ram@@YA_KXZ			; pmmngr_get_free_ram
PUBLIC	?pmmngr_get_used_ram@@YA_KXZ			; pmmngr_get_used_ram
PUBLIC	?pmmngr_get_total_ram@@YA_KXZ			; pmmngr_get_total_ram
PUBLIC	??ABitmap@@QEAA_N_K@Z				; Bitmap::operator[]
PUBLIC	?Set@Bitmap@@QEAA_N_K_N@Z			; Bitmap::Set
PUBLIC	?pmmngr_init_bitmap@@YAX_KPEAX@Z		; pmmngr_init_bitmap
PUBLIC	?pmmngr_lock_page@@YAXPEAX@Z			; pmmngr_lock_page
PUBLIC	?pmmngr_unreserve_page@@YAXPEAX@Z		; pmmngr_unreserve_page
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
pdata	SEGMENT
$pdata$?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD imagerel $LN7
	DD	imagerel $LN7+323
	DD	imagerel $unwind$?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z
$pdata$?pmmngr_alloc@@YAPEAXXZ DD imagerel $LN9
	DD	imagerel $LN9+255
	DD	imagerel $unwind$?pmmngr_alloc@@YAPEAXXZ
$pdata$?pmmngr_alloc_blocks@@YAPEAXH@Z DD imagerel $LN6
	DD	imagerel $LN6+77
	DD	imagerel $unwind$?pmmngr_alloc_blocks@@YAPEAXH@Z
$pdata$?pmmngr_lock_pages@@YAXPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+84
	DD	imagerel $unwind$?pmmngr_lock_pages@@YAXPEAX_K@Z
$pdata$?pmmngr_free@@YAXPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?pmmngr_free@@YAXPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??ABitmap@@QEAA_N_K@Z DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$??ABitmap@@QEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Set@Bitmap@@QEAA_N_K_N@Z DD imagerel $LN5
	DD	imagerel $LN5+213
	DD	imagerel $unwind$?Set@Bitmap@@QEAA_N_K_N@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?pmmngr_init_bitmap@@YAX_KPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+88
	DD	imagerel $unwind$?pmmngr_init_bitmap@@YAX_KPEAX@Z
$pdata$?pmmngr_lock_page@@YAXPEAX@Z DD imagerel $LN5
	DD	imagerel $LN5+128
	DD	imagerel $unwind$?pmmngr_lock_page@@YAXPEAX@Z
$pdata$?pmmngr_unreserve_page@@YAXPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$?pmmngr_unreserve_page@@YAXPEAX@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Set@Bitmap@@QEAA_N_K_N@Z DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??ABitmap@@QEAA_N_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
xdata	SEGMENT
$unwind$?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z DD 010901H
	DD	0a209H
$unwind$?pmmngr_alloc@@YAPEAXXZ DD 010401H
	DD	06204H
$unwind$?pmmngr_alloc_blocks@@YAPEAXH@Z DD 010801H
	DD	06208H
$unwind$?pmmngr_lock_pages@@YAXPEAX_K@Z DD 010e01H
	DD	0620eH
$unwind$?pmmngr_free@@YAXPEAX@Z DD 010901H
	DD	06209H
$unwind$?pmmngr_init_bitmap@@YAX_KPEAX@Z DD 010e01H
	DD	0220eH
$unwind$?pmmngr_lock_page@@YAXPEAX@Z DD 010901H
	DD	06209H
$unwind$?pmmngr_unreserve_page@@YAXPEAX@Z DD 010901H
	DD	06209H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
index$ = 32
addr$ = 64
?pmmngr_unreserve_page@@YAXPEAX@Z PROC			; pmmngr_unreserve_page

; 94   : void pmmngr_unreserve_page (void* addr) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 95   : 
; 96   : 	uint64_t index = (uint64_t)addr / 4096;

	xor	edx, edx
	mov	rax, QWORD PTR addr$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR index$[rsp], rax

; 97   : 	if (ram_bitmap[index] == false) return;

	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@pmmngr_unr
	jmp	SHORT $LN4@pmmngr_unr
$LN3@pmmngr_unr:

; 98   : 	if (ram_bitmap.Set(index, false)) {

	xor	r8d, r8d
	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	?Set@Bitmap@@QEAA_N_K_N@Z		; Bitmap::Set
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@pmmngr_unr

; 99   : 		free_memory += 4096;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 100  : 		reserved_memory -= 4096;

	mov	rax, QWORD PTR ?reserved_memory@@3_KA	; reserved_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?reserved_memory@@3_KA, rax	; reserved_memory

; 101  : 		if (ram_bitmap_index > index) ram_bitmap_index = index;

	mov	rax, QWORD PTR index$[rsp]
	cmp	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
	jbe	SHORT $LN1@pmmngr_unr
	mov	rax, QWORD PTR index$[rsp]
	mov	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
$LN1@pmmngr_unr:
$LN2@pmmngr_unr:
$LN4@pmmngr_unr:

; 102  : 	}
; 103  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_unreserve_page@@YAXPEAX@Z ENDP			; pmmngr_unreserve_page
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
index$ = 32
addr$ = 64
?pmmngr_lock_page@@YAXPEAX@Z PROC			; pmmngr_lock_page

; 77   : void pmmngr_lock_page ( void* addr) {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 78   : 
; 79   : 	uint64_t index = (uint64_t)addr / 4096;

	xor	edx, edx
	mov	rax, QWORD PTR addr$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR index$[rsp], rax

; 80   : 	if (ram_bitmap[index] == true) return;

	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN2@pmmngr_loc
	jmp	SHORT $LN3@pmmngr_loc
$LN2@pmmngr_loc:

; 81   : 	if (ram_bitmap.Set (index, true)) {

	mov	r8b, 1
	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	?Set@Bitmap@@QEAA_N_K_N@Z		; Bitmap::Set
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@pmmngr_loc

; 82   : 		free_memory -= 4096;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 83   : 		used_memory += 4096;

	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?used_memory@@3_KA, rax	; used_memory
$LN1@pmmngr_loc:
$LN3@pmmngr_loc:

; 84   : 	}
; 85   : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_lock_page@@YAXPEAX@Z ENDP			; pmmngr_lock_page
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 0
bitmap_size$ = 32
buffer$ = 40
?pmmngr_init_bitmap@@YAX_KPEAX@Z PROC			; pmmngr_init_bitmap

; 66   : void pmmngr_init_bitmap (size_t bitmap_size, void* buffer) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 67   : 
; 68   : 	ram_bitmap.Size = bitmap_size;

	mov	rax, QWORD PTR bitmap_size$[rsp]
	mov	QWORD PTR ?ram_bitmap@@3VBitmap@@A, rax

; 69   : 	ram_bitmap.Buffer = (uint8_t*)buffer;

	mov	rax, QWORD PTR buffer$[rsp]
	mov	QWORD PTR ?ram_bitmap@@3VBitmap@@A+8, rax

; 70   : 
; 71   : 	for (int i = 0; i < bitmap_size ; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@pmmngr_ini
$LN2@pmmngr_ini:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@pmmngr_ini:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR bitmap_size$[rsp]
	jae	SHORT $LN1@pmmngr_ini

; 72   : 		*(uint8_t*)(ram_bitmap.Buffer + i) = 0;

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR ?ram_bitmap@@3VBitmap@@A+8
	mov	BYTE PTR [rcx+rax], 0

; 73   : 	}

	jmp	SHORT $LN2@pmmngr_ini
$LN1@pmmngr_ini:

; 74   : }

	add	rsp, 24
	ret	0
?pmmngr_init_bitmap@@YAX_KPEAX@Z ENDP			; pmmngr_init_bitmap
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
;	COMDAT ?Set@Bitmap@@QEAA_N_K_N@Z
_TEXT	SEGMENT
bitIndexer$ = 0
bitIndex$ = 1
tv145 = 4
byteIndex$ = 8
this$ = 32
index$ = 40
value$ = 48
?Set@Bitmap@@QEAA_N_K_N@Z PROC				; Bitmap::Set, COMDAT

; 46   : 	bool Set(uint64_t index, bool value) {

$LN5:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 47   : 		
; 48   : 		if (index > Size * 8) return false;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	shl	rax, 3
	cmp	QWORD PTR index$[rsp], rax
	jbe	SHORT $LN2@Set
	xor	al, al
	jmp	$LN3@Set
$LN2@Set:

; 49   : 
; 50   : 		uint64_t byteIndex = index / 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 8
	div	rcx
	mov	QWORD PTR byteIndex$[rsp], rax

; 51   : 		uint8_t  bitIndex = index % 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 8
	div	rcx
	mov	rax, rdx
	mov	BYTE PTR bitIndex$[rsp], al

; 52   : 		uint8_t  bitIndexer = 0x80 >> bitIndex;

	movzx	eax, BYTE PTR bitIndex$[rsp]
	mov	ecx, 128				; 00000080H
	mov	DWORD PTR tv145[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv145[rsp]
	sar	eax, cl
	mov	BYTE PTR bitIndexer$[rsp], al

; 53   : 
; 54   : 		Buffer[byteIndex] &= ~bitIndexer;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	ecx, BYTE PTR bitIndexer$[rsp]
	not	ecx
	mov	rdx, QWORD PTR byteIndex$[rsp]
	movzx	eax, BYTE PTR [rax+rdx]
	and	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR byteIndex$[rsp]
	mov	BYTE PTR [rcx+rdx], al

; 55   : 		if (value) {

	movzx	eax, BYTE PTR value$[rsp]
	test	eax, eax
	je	SHORT $LN1@Set

; 56   : 			Buffer[byteIndex] |= bitIndexer;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	ecx, BYTE PTR bitIndexer$[rsp]
	mov	rdx, QWORD PTR byteIndex$[rsp]
	movzx	eax, BYTE PTR [rax+rdx]
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rdx, QWORD PTR byteIndex$[rsp]
	mov	BYTE PTR [rcx+rdx], al
$LN1@Set:

; 57   : 		}
; 58   : 
; 59   : 		return false;

	xor	al, al
$LN3@Set:

; 60   : 	}

	add	rsp, 24
	ret	0
?Set@Bitmap@@QEAA_N_K_N@Z ENDP				; Bitmap::Set
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
;	COMDAT ??ABitmap@@QEAA_N_K@Z
_TEXT	SEGMENT
bitIndex$ = 0
bitIndexer$ = 1
tv94 = 4
byteIndex$ = 8
this$ = 32
index$ = 40
??ABitmap@@QEAA_N_K@Z PROC				; Bitmap::operator[], COMDAT

; 32   : 	bool operator[](uint64_t index) {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 33   : 		
; 34   : 		if (index > Size * 8) return false;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	shl	rax, 3
	cmp	QWORD PTR index$[rsp], rax
	jbe	SHORT $LN2@operator
	xor	al, al
	jmp	SHORT $LN3@operator
$LN2@operator:

; 35   : 		uint64_t byteIndex = index / 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 8
	div	rcx
	mov	QWORD PTR byteIndex$[rsp], rax

; 36   : 		uint8_t  bitIndex = index % 8;

	xor	edx, edx
	mov	rax, QWORD PTR index$[rsp]
	mov	ecx, 8
	div	rcx
	mov	rax, rdx
	mov	BYTE PTR bitIndex$[rsp], al

; 37   : 		uint8_t  bitIndexer = 0x80 >> bitIndex;

	movzx	eax, BYTE PTR bitIndex$[rsp]
	mov	ecx, 128				; 00000080H
	mov	DWORD PTR tv94[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv94[rsp]
	sar	eax, cl
	mov	BYTE PTR bitIndexer$[rsp], al

; 38   : 
; 39   : 		if ((Buffer[byteIndex] & bitIndexer) > 0) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR byteIndex$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	movzx	ecx, BYTE PTR bitIndexer$[rsp]
	and	eax, ecx
	test	eax, eax
	jle	SHORT $LN1@operator

; 40   : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@operator
$LN1@operator:

; 41   : 		}
; 42   : 		return false;

	xor	al, al
$LN3@operator:

; 43   : 	}

	add	rsp, 24
	ret	0
??ABitmap@@QEAA_N_K@Z ENDP				; Bitmap::operator[]
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
?pmmngr_get_total_ram@@YA_KXZ PROC			; pmmngr_get_total_ram

; 205  : 	return total_ram;

	mov	rax, QWORD PTR ?total_ram@@3_KA		; total_ram

; 206  : }

	ret	0
?pmmngr_get_total_ram@@YA_KXZ ENDP			; pmmngr_get_total_ram
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
?pmmngr_get_used_ram@@YA_KXZ PROC			; pmmngr_get_used_ram

; 200  : 	return used_memory;

	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory

; 201  : }

	ret	0
?pmmngr_get_used_ram@@YA_KXZ ENDP			; pmmngr_get_used_ram
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
?pmmngr_get_free_ram@@YA_KXZ PROC			; pmmngr_get_free_ram

; 195  : 	return free_memory;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory

; 196  : }

	ret	0
?pmmngr_get_free_ram@@YA_KXZ ENDP			; pmmngr_get_free_ram
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
index$ = 32
addr$ = 64
?pmmngr_free@@YAXPEAX@Z PROC				; pmmngr_free

; 183  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 184  : 	uint64_t index = (uint64_t)addr / 4096;

	xor	edx, edx
	mov	rax, QWORD PTR addr$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	mov	QWORD PTR index$[rsp], rax

; 185  : 	if (ram_bitmap[index] == false) return;

	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@pmmngr_fre
	jmp	SHORT $LN4@pmmngr_fre
$LN3@pmmngr_fre:

; 186  : 	if (ram_bitmap.Set (index, false)) {

	xor	r8d, r8d
	mov	rdx, QWORD PTR index$[rsp]
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	?Set@Bitmap@@QEAA_N_K_N@Z		; Bitmap::Set
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@pmmngr_fre

; 187  : 		free_memory += 4096;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 188  : 		used_memory -= 4096;

	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?used_memory@@3_KA, rax	; used_memory

; 189  : 		if (ram_bitmap_index > index) ram_bitmap_index = index;

	mov	rax, QWORD PTR index$[rsp]
	cmp	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
	jbe	SHORT $LN1@pmmngr_fre
	mov	rax, QWORD PTR index$[rsp]
	mov	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
$LN1@pmmngr_fre:
$LN2@pmmngr_fre:
$LN4@pmmngr_fre:

; 190  : 	}
; 191  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_free@@YAXPEAX@Z ENDP				; pmmngr_free
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
addr$ = 64
size$ = 72
?pmmngr_lock_pages@@YAXPEAX_K@Z PROC			; pmmngr_lock_pages

; 88   : void pmmngr_lock_pages (void *addr, size_t size) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 89   : 	for (int i = 0; i < size; i++) 

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@pmmngr_loc
$LN2@pmmngr_loc:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@pmmngr_loc:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR size$[rsp]
	jae	SHORT $LN1@pmmngr_loc

; 90   : 		pmmngr_lock_page ((void*)((size_t)addr + i * 4096));

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	cdqe
	mov	rcx, QWORD PTR addr$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	?pmmngr_lock_page@@YAXPEAX@Z		; pmmngr_lock_page
	jmp	SHORT $LN2@pmmngr_loc
$LN1@pmmngr_loc:

; 91   : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_lock_pages@@YAXPEAX_K@Z ENDP			; pmmngr_lock_pages
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
first$ = 40
size$ = 64
?pmmngr_alloc_blocks@@YAPEAXH@Z PROC			; pmmngr_alloc_blocks

; 169  : void* pmmngr_alloc_blocks (int size) {

$LN6:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 170  : 	void *first = pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR first$[rsp], rax

; 171  : 	for (int i = 0; i < size / 4096; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN3@pmmngr_all
$LN2@pmmngr_all:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN3@pmmngr_all:
	mov	eax, DWORD PTR size$[rsp]
	cdq
	and	edx, 4095				; 00000fffH
	add	eax, edx
	sar	eax, 12
	cmp	DWORD PTR i$1[rsp], eax
	jge	SHORT $LN1@pmmngr_all

; 172  : 		pmmngr_alloc();

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc

; 173  : 	}

	jmp	SHORT $LN2@pmmngr_all
$LN1@pmmngr_all:

; 174  : 
; 175  : 	return first; //here we need to swap page to file

	mov	rax, QWORD PTR first$[rsp]

; 176  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_alloc_blocks@@YAPEAXH@Z ENDP			; pmmngr_alloc_blocks
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
tv78 = 32
?pmmngr_alloc@@YAPEAXXZ PROC				; pmmngr_alloc

; 152  : {

$LN9:
	sub	rsp, 56					; 00000038H

; 153  : 	free_memory -= 4096 * 1;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 154  : 	used_memory += 4096 * 1;

	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory
	add	rax, 4096				; 00001000H
	mov	QWORD PTR ?used_memory@@3_KA, rax	; used_memory

; 155  : 	for (; ram_bitmap_index < ram_bitmap.Size * 8; ram_bitmap_index++) {

	jmp	SHORT $LN6@pmmngr_all
$LN5@pmmngr_all:
	mov	rax, QWORD PTR ?ram_bitmap_index@@3_KA	; ram_bitmap_index
	inc	rax
	mov	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
$LN6@pmmngr_all:
	mov	rax, QWORD PTR ?ram_bitmap@@3VBitmap@@A
	shl	rax, 3
	cmp	QWORD PTR ?ram_bitmap_index@@3_KA, rax	; ram_bitmap_index
	jae	SHORT $LN4@pmmngr_all

; 156  : 		if (ram_bitmap[ram_bitmap_index] == true) continue;

	mov	rdx, QWORD PTR ?ram_bitmap_index@@3_KA	; ram_bitmap_index
	lea	rcx, OFFSET FLAT:?ram_bitmap@@3VBitmap@@A ; ram_bitmap
	call	??ABitmap@@QEAA_N_K@Z			; Bitmap::operator[]
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN3@pmmngr_all
	jmp	SHORT $LN5@pmmngr_all
$LN3@pmmngr_all:

; 157  : 		pmmngr_lock_page ((void*)(ram_bitmap_index * 4096));

	mov	rax, QWORD PTR ?ram_bitmap_index@@3_KA	; ram_bitmap_index
	imul	rax, 4096				; 00001000H
	mov	rcx, rax
	call	?pmmngr_lock_page@@YAXPEAX@Z		; pmmngr_lock_page

; 158  : 		return (void*)(ram_bitmap_index * 4096);

	mov	rax, QWORD PTR ?ram_bitmap_index@@3_KA	; ram_bitmap_index
	imul	rax, 4096				; 00001000H
	jmp	SHORT $LN7@pmmngr_all

; 159  : 	}

	jmp	SHORT $LN5@pmmngr_all
$LN4@pmmngr_all:

; 160  : 
; 161  : 
; 162  : 	printf ("Used RAM -> %d MB, Free RAM -> %d MB\n", used_memory /1024 / 1024, free_memory / 1024 / 1024);

	xor	edx, edx
	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	mov	ecx, 1024				; 00000400H
	div	rcx
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	rcx
	mov	QWORD PTR tv78[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR ?used_memory@@3_KA	; used_memory
	mov	ecx, 1024				; 00000400H
	div	rcx
	xor	edx, edx
	mov	ecx, 1024				; 00000400H
	div	rcx
	mov	rcx, QWORD PTR tv78[rsp]
	mov	r8, rcx
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG2801
	call	?printf@@YAXPEBDZZ			; printf

; 163  : 	printf ("No more available pages\n");

	lea	rcx, OFFSET FLAT:$SG2802
	call	?printf@@YAXPEBDZZ			; printf
$LN2@pmmngr_all:

; 164  : 	for(;;);

	jmp	SHORT $LN2@pmmngr_all

; 165  : 	return NULL; //here we need to swap page to file

	xor	eax, eax
$LN7@pmmngr_all:

; 166  : }

	add	rsp, 56					; 00000038H
	ret	0
?pmmngr_alloc@@YAPEAXXZ ENDP				; pmmngr_alloc
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\pmmngr.cpp
_TEXT	SEGMENT
i$1 = 32
efi_mem$2 = 40
memory_size$ = 48
bitmap_size$ = 56
memmap_entries$ = 64
unusable$ = 72
_info$ = 96
?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z PROC	; pmmngr_init

; 114  : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 115  : 	//! scan for memory above 1MB and set up the current pointer
; 116  : 
; 117  : 	uint64_t memory_size = _info->ram_size;

	mov	rax, QWORD PTR _info$[rsp]
	mov	rax, QWORD PTR [rax+20]
	mov	QWORD PTR memory_size$[rsp], rax

; 118  : 	free_memory = memory_size;

	mov	rax, QWORD PTR memory_size$[rsp]
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 119  : 	uint64_t bitmap_size = memory_size / 4096 / 8 + 1;

	xor	edx, edx
	mov	rax, QWORD PTR memory_size$[rsp]
	mov	ecx, 4096				; 00001000H
	div	rcx
	xor	edx, edx
	mov	ecx, 8
	div	rcx
	inc	rax
	mov	QWORD PTR bitmap_size$[rsp], rax

; 120  : 	ram_bitmap_index = 0;

	mov	QWORD PTR ?ram_bitmap_index@@3_KA, 0	; ram_bitmap_index

; 121  : 	total_ram = 0;

	mov	QWORD PTR ?total_ram@@3_KA, 0		; total_ram

; 122  : 
; 123  : 	pmmngr_init_bitmap (bitmap_size, (void*) _info->phys_start); 

	mov	rax, QWORD PTR _info$[rsp]
	mov	rdx, QWORD PTR [rax+4]
	mov	rcx, QWORD PTR bitmap_size$[rsp]
	call	?pmmngr_init_bitmap@@YAX_KPEAX@Z	; pmmngr_init_bitmap

; 124  : 
; 125  : 	pmmngr_lock_pages ((void*)_info->phys_start,bitmap_size);

	mov	rdx, QWORD PTR bitmap_size$[rsp]
	mov	rax, QWORD PTR _info$[rsp]
	mov	rcx, QWORD PTR [rax+4]
	call	?pmmngr_lock_pages@@YAXPEAX_K@Z		; pmmngr_lock_pages

; 126  : 
; 127  : 	//Lock every EFI-Reserved memories here
; 128  : 	uint64_t memmap_entries = _info->mem_map_size / _info->descriptor_size;

	xor	edx, edx
	mov	rax, QWORD PTR _info$[rsp]
	mov	rax, QWORD PTR [rax+44]
	mov	rcx, QWORD PTR _info$[rsp]
	div	QWORD PTR [rcx+36]
	mov	QWORD PTR memmap_entries$[rsp], rax

; 129  : 
; 130  : 	//! Currently uses EFI-Memory Maps to check reserved regions
; 131  : 	for (int i = 0; i < memmap_entries; i++) {

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@pmmngr_ini
$LN3@pmmngr_ini:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@pmmngr_ini:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR memmap_entries$[rsp]
	jae	SHORT $LN2@pmmngr_ini

; 132  : 		EFI_MEMORY_DESCRIPTOR *efi_mem = (EFI_MEMORY_DESCRIPTOR*)((uint64_t)_info->map + i * _info->descriptor_size);

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR _info$[rsp]
	imul	rax, QWORD PTR [rcx+36]
	mov	rcx, QWORD PTR _info$[rsp]
	add	rax, QWORD PTR [rcx+28]
	mov	QWORD PTR efi_mem$2[rsp], rax

; 133  : 		total_ram += efi_mem->num_pages * 4096;

	mov	rax, QWORD PTR efi_mem$2[rsp]
	mov	rax, QWORD PTR [rax+24]
	imul	rax, 4096				; 00001000H
	mov	rcx, QWORD PTR ?total_ram@@3_KA		; total_ram
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR ?total_ram@@3_KA, rax		; total_ram

; 134  : 		if (efi_mem->type != 7) {

	mov	rax, QWORD PTR efi_mem$2[rsp]
	cmp	DWORD PTR [rax], 7
	je	SHORT $LN1@pmmngr_ini

; 135  : 			//! lock every pages
; 136  : 			free_memory -= 4096;

	mov	rax, QWORD PTR ?free_memory@@3_KA	; free_memory
	sub	rax, 4096				; 00001000H
	mov	QWORD PTR ?free_memory@@3_KA, rax	; free_memory

; 137  : 			pmmngr_lock_pages ((void*)efi_mem->phys_start,efi_mem->num_pages);

	mov	rax, QWORD PTR efi_mem$2[rsp]
	mov	rdx, QWORD PTR [rax+24]
	mov	rax, QWORD PTR efi_mem$2[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	?pmmngr_lock_pages@@YAXPEAX_K@Z		; pmmngr_lock_pages
$LN1@pmmngr_ini:

; 138  : 		}
; 139  : 	}

	jmp	$LN3@pmmngr_ini
$LN2@pmmngr_ini:

; 140  : 
; 141  : 	void *unusable = pmmngr_alloc(); //0 is avoided

	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	QWORD PTR unusable$[rsp], rax

; 142  : }

	add	rsp, 88					; 00000058H
	ret	0
?pmmngr_init@@YAXPEAU_KERNEL_BOOT_INFO_@@@Z ENDP	; pmmngr_init
_TEXT	ENDS
END
