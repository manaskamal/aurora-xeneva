; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG6196	DB	'a:bs.jpg', 00H
	ORG $+7
$SG6209	DB	'JPEG:Decoder Error', 0aH, 00H
CONST	ENDS
PUBLIC	??0Decoder@Jpeg@@QEAA@PEBEIP6APEAXI@ZP6AXPEAX@Z@Z ; Jpeg::Decoder::Decoder
PUBLIC	?GetResult@Decoder@Jpeg@@QEBA?AW4DecodeResult@12@XZ ; Jpeg::Decoder::GetResult
PUBLIC	?_Clip@Decoder@Jpeg@@AEAAEH@Z			; Jpeg::Decoder::_Clip
PUBLIC	?_RowIDCT@Decoder@Jpeg@@AEAAXPEAH@Z		; Jpeg::Decoder::_RowIDCT
PUBLIC	?_ColIDCT@Decoder@Jpeg@@AEAAXPEBHPEAEH@Z	; Jpeg::Decoder::_ColIDCT
PUBLIC	?_ShowBits@Decoder@Jpeg@@AEAAHH@Z		; Jpeg::Decoder::_ShowBits
PUBLIC	?_SkipBits@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_SkipBits
PUBLIC	?_GetBits@Decoder@Jpeg@@AEAAHH@Z		; Jpeg::Decoder::_GetBits
PUBLIC	?_ByteAlign@Decoder@Jpeg@@AEAAXXZ		; Jpeg::Decoder::_ByteAlign
PUBLIC	?_Skip@Decoder@Jpeg@@AEAAXH@Z			; Jpeg::Decoder::_Skip
PUBLIC	?_Decode16@Decoder@Jpeg@@AEAAGPEBE@Z		; Jpeg::Decoder::_Decode16
PUBLIC	?_DecodeLength@Decoder@Jpeg@@AEAAXXZ		; Jpeg::Decoder::_DecodeLength
PUBLIC	?_SkipMarker@Decoder@Jpeg@@AEAAXXZ		; Jpeg::Decoder::_SkipMarker
PUBLIC	?_DecodeSOF@Decoder@Jpeg@@AEAAXXZ		; Jpeg::Decoder::_DecodeSOF
PUBLIC	?_DecodeDHT@Decoder@Jpeg@@AEAAXXZ		; Jpeg::Decoder::_DecodeDHT
PUBLIC	?_DecodeDQT@Decoder@Jpeg@@AEAAXXZ		; Jpeg::Decoder::_DecodeDQT
PUBLIC	?_DecodeDRI@Decoder@Jpeg@@AEAAXXZ		; Jpeg::Decoder::_DecodeDRI
PUBLIC	?_GetVLC@Decoder@Jpeg@@AEAAHPEAUVlcCode@12@PEAE@Z ; Jpeg::Decoder::_GetVLC
PUBLIC	?_DecodeBlock@Decoder@Jpeg@@AEAAXPEAUComponent@12@PEAE@Z ; Jpeg::Decoder::_DecodeBlock
PUBLIC	?_DecodeScan@Decoder@Jpeg@@AEAAXXZ		; Jpeg::Decoder::_DecodeScan
PUBLIC	?CF@Decoder@Jpeg@@AEAAEH@Z			; Jpeg::Decoder::CF
PUBLIC	?_UpsampleH@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z ; Jpeg::Decoder::_UpsampleH
PUBLIC	?_UpsampleV@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z ; Jpeg::Decoder::_UpsampleV
PUBLIC	?_Convert@Decoder@Jpeg@@AEAAXXZ			; Jpeg::Decoder::_Convert
PUBLIC	?_Decode@Decoder@Jpeg@@AEAA?AW4DecodeResult@12@PEBEH@Z ; Jpeg::Decoder::_Decode
PUBLIC	?start_boot_screen@@YAXXZ			; start_boot_screen
PUBLIC	?gui_draw_pixels@@YAXIII@Z			; gui_draw_pixels
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	?memset@@YAXPEAXEI@Z:PROC			; memset
EXTRN	memcpy:PROC
EXTRN	?printf@@YAXPEBDZZ:PROC				; printf
EXTRN	?get_screen_width@@YAIXZ:PROC			; get_screen_width
EXTRN	?get_framebuffer_addr@@YAPEAIXZ:PROC		; get_framebuffer_addr
EXTRN	?open@@YA?AU_file_@@PEBD@Z:PROC			; open
EXTRN	?read@@YAXPEAU_file_@@PEAEIH@Z:PROC		; read
EXTRN	?pmmngr_alloc@@YAPEAXXZ:PROC			; pmmngr_alloc
EXTRN	x64_cli:PROC
EXTRN	x64_sti:PROC
EXTRN	?map_page@@YA_N_K0@Z:PROC			; map_page
EXTRN	?malloc@@YAPEAXI@Z:PROC				; malloc
EXTRN	?mfree@@YAXPEAX@Z:PROC				; mfree
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Decoder@Jpeg@@QEAA@PEBEIP6APEAXI@ZP6AXPEAX@Z@Z DD imagerel $LN3
	DD	imagerel $LN3+468
	DD	imagerel $unwind$??0Decoder@Jpeg@@QEAA@PEBEIP6APEAXI@ZP6AXPEAX@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Clip@Decoder@Jpeg@@AEAAEH@Z DD imagerel $LN7
	DD	imagerel $LN7+74
	DD	imagerel $unwind$?_Clip@Decoder@Jpeg@@AEAAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_RowIDCT@Decoder@Jpeg@@AEAAXPEAH@Z DD imagerel $LN4
	DD	imagerel $LN4+1096
	DD	imagerel $unwind$?_RowIDCT@Decoder@Jpeg@@AEAAXPEAH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_ColIDCT@Decoder@Jpeg@@AEAAXPEBHPEAEH@Z DD imagerel $LN7
	DD	imagerel $LN7+1262
	DD	imagerel $unwind$?_ColIDCT@Decoder@Jpeg@@AEAAXPEBHPEAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_ShowBits@Decoder@Jpeg@@AEAAHH@Z DD imagerel $LN18
	DD	imagerel $LN18+521
	DD	imagerel $unwind$?_ShowBits@Decoder@Jpeg@@AEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_SkipBits@Decoder@Jpeg@@AEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$?_SkipBits@Decoder@Jpeg@@AEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_GetBits@Decoder@Jpeg@@AEAAHH@Z DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$?_GetBits@Decoder@Jpeg@@AEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_DecodeLength@Decoder@Jpeg@@AEAAXXZ DD imagerel $LN11
	DD	imagerel $LN11+126
	DD	imagerel $unwind$?_DecodeLength@Decoder@Jpeg@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_SkipMarker@Decoder@Jpeg@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?_SkipMarker@Decoder@Jpeg@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_DecodeSOF@Decoder@Jpeg@@AEAAXXZ DD imagerel $LN65
	DD	imagerel $LN65+1466
	DD	imagerel $unwind$?_DecodeSOF@Decoder@Jpeg@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_DecodeDHT@Decoder@Jpeg@@AEAAXXZ DD imagerel $LN40
	DD	imagerel $LN40+675
	DD	imagerel $unwind$?_DecodeDHT@Decoder@Jpeg@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_DecodeDQT@Decoder@Jpeg@@AEAAXXZ DD imagerel $LN16
	DD	imagerel $LN16+301
	DD	imagerel $unwind$?_DecodeDQT@Decoder@Jpeg@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_DecodeDRI@Decoder@Jpeg@@AEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+105
	DD	imagerel $unwind$?_DecodeDRI@Decoder@Jpeg@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_GetVLC@Decoder@Jpeg@@AEAAHPEAUVlcCode@12@PEAE@Z DD imagerel $LN7
	DD	imagerel $LN7+247
	DD	imagerel $unwind$?_GetVLC@Decoder@Jpeg@@AEAAHPEAUVlcCode@12@PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_DecodeBlock@Decoder@Jpeg@@AEAAXPEAUComponent@12@PEAE@Z DD imagerel $LN21
	DD	imagerel $LN21+612
	DD	imagerel $unwind$?_DecodeBlock@Decoder@Jpeg@@AEAAXPEAUComponent@12@PEAE@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_DecodeScan@Decoder@Jpeg@@AEAAXXZ DD imagerel $LN52
	DD	imagerel $LN52+1093
	DD	imagerel $unwind$?_DecodeScan@Decoder@Jpeg@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CF@Decoder@Jpeg@@AEAAEH@Z DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$?CF@Decoder@Jpeg@@AEAAEH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_UpsampleH@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z DD imagerel $LN13
	DD	imagerel $LN13+1099
	DD	imagerel $unwind$?_UpsampleH@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_UpsampleV@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z DD imagerel $LN13
	DD	imagerel $LN13+1188
	DD	imagerel $unwind$?_UpsampleV@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Convert@Decoder@Jpeg@@AEAAXXZ DD imagerel $LN30
	DD	imagerel $LN30+1267
	DD	imagerel $unwind$?_Convert@Decoder@Jpeg@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decode@Decoder@Jpeg@@AEAA?AW4DecodeResult@12@PEBEH@Z DD imagerel $LN23
	DD	imagerel $LN23+587
	DD	imagerel $unwind$?_Decode@Decoder@Jpeg@@AEAA?AW4DecodeResult@12@PEBEH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?start_boot_screen@@YAXXZ DD imagerel $LN9
	DD	imagerel $LN9+326
	DD	imagerel $unwind$?start_boot_screen@@YAXXZ
$pdata$?gui_draw_pixels@@YAXIII@Z DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$?gui_draw_pixels@@YAXIII@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?start_boot_screen@@YAXXZ DD 040a01H
	DD	025010aH
	DD	060027003H
$unwind$?gui_draw_pixels@@YAXIII@Z DD 011101H
	DD	06211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decode@Decoder@Jpeg@@AEAA?AW4DecodeResult@12@PEBEH@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Convert@Decoder@Jpeg@@AEAAXXZ DD 020c01H
	DD	011010cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_UpsampleV@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_UpsampleH@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CF@Decoder@Jpeg@@AEAAEH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_DecodeScan@Decoder@Jpeg@@AEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_DecodeBlock@Decoder@Jpeg@@AEAAXPEAUComponent@12@PEAE@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_GetVLC@Decoder@Jpeg@@AEAAHPEAUVlcCode@12@PEAE@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_DecodeDRI@Decoder@Jpeg@@AEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_DecodeDQT@Decoder@Jpeg@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_DecodeDHT@Decoder@Jpeg@@AEAAXXZ DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_DecodeSOF@Decoder@Jpeg@@AEAAXXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_SkipMarker@Decoder@Jpeg@@AEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_DecodeLength@Decoder@Jpeg@@AEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_GetBits@Decoder@Jpeg@@AEAAHH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_SkipBits@Decoder@Jpeg@@AEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_ShowBits@Decoder@Jpeg@@AEAAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_ColIDCT@Decoder@Jpeg@@AEAAXPEBHPEAEH@Z DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_RowIDCT@Decoder@Jpeg@@AEAAXPEAH@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Clip@Decoder@Jpeg@@AEAAEH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Decoder@Jpeg@@QEAA@PEBEIP6APEAXI@ZP6AXPEAX@Z@Z DD 011801H
	DD	0c218H
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\gui\splash.cpp
_TEXT	SEGMENT
lfb$ = 32
x$ = 64
y$ = 72
color$ = 80
?gui_draw_pixels@@YAXIII@Z PROC				; gui_draw_pixels

; 17   : void gui_draw_pixels (unsigned x, unsigned y, uint32_t color) {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 18   : 	uint32_t *lfb = get_framebuffer_addr();

	call	?get_framebuffer_addr@@YAPEAIXZ		; get_framebuffer_addr
	mov	QWORD PTR lfb$[rsp], rax

; 19   : 	lfb[x + y * get_screen_width()] = color;

	call	?get_screen_width@@YAIXZ		; get_screen_width
	mov	ecx, DWORD PTR y$[rsp]
	imul	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR x$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	eax, eax
	mov	rcx, QWORD PTR lfb$[rsp]
	mov	edx, DWORD PTR color$[rsp]
	mov	DWORD PTR [rcx+rax*4], edx

; 20   : }

	add	rsp, 56					; 00000038H
	ret	0
?gui_draw_pixels@@YAXIII@Z ENDP				; gui_draw_pixels
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\gui\splash.cpp
_TEXT	SEGMENT
i$1 = 48
buffer_i$ = 56
$T2 = 64
tv89 = 72
tv73 = 80
decoder$ = 88
f$ = 96
$T3 = 160
$T4 = 224
?start_boot_screen@@YAXXZ PROC				; start_boot_screen

; 22   : void start_boot_screen () {

$LN9:
	push	rsi
	push	rdi
	sub	rsp, 296				; 00000128H

; 23   : 	x64_cli();

	call	x64_cli

; 24   : 	FILE f = open("a:bs.jpg");

	lea	rdx, OFFSET FLAT:$SG6196
	lea	rcx, QWORD PTR $T4[rsp]
	call	?open@@YA?AU_file_@@PEBD@Z		; open
	lea	rcx, QWORD PTR $T3[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 60					; 0000003cH
	rep movsb
	lea	rax, QWORD PTR f$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 60					; 0000003cH
	rep movsb

; 25   : 	for (int i = 0; i < (48*1024)/4096; i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@start_boot
$LN3@start_boot:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@start_boot:
	cmp	DWORD PTR i$1[rsp], 12
	jge	SHORT $LN2@start_boot

; 26   : 		map_page((uint64_t)pmmngr_alloc(), 0x0000000060000000 + i * 4096);

	mov	eax, DWORD PTR i$1[rsp]
	imul	eax, 4096				; 00001000H
	add	eax, 1610612736				; 60000000H
	cdqe
	mov	QWORD PTR tv73[rsp], rax
	call	?pmmngr_alloc@@YAPEAXXZ			; pmmngr_alloc
	mov	rcx, QWORD PTR tv73[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	?map_page@@YA_N_K0@Z			; map_page
	jmp	SHORT $LN3@start_boot
$LN2@start_boot:

; 27   : 	unsigned char* buffer_i = (unsigned char*)0x0000000060000000;

	mov	QWORD PTR buffer_i$[rsp], 1610612736	; 60000000H

; 28   : 	read (&f,buffer_i,f.size, f.id);

	mov	r9d, DWORD PTR f$[rsp+32]
	mov	r8d, DWORD PTR f$[rsp+36]
	mov	rdx, QWORD PTR buffer_i$[rsp]
	lea	rcx, QWORD PTR f$[rsp]
	call	?read@@YAXPEAU_file_@@PEAEIH@Z		; read

; 29   : 
; 30   : 	Jpeg::Decoder *decoder = new Jpeg::Decoder(buffer_i, f.size, malloc, mfree);

	mov	ecx, 525112				; 00080338H
	call	??2@YAPEAX_K@Z				; operator new
	mov	QWORD PTR $T2[rsp], rax
	cmp	QWORD PTR $T2[rsp], 0
	je	SHORT $LN7@start_boot
	lea	rax, OFFSET FLAT:?mfree@@YAXPEAX@Z	; mfree
	mov	QWORD PTR [rsp+32], rax
	lea	r9, OFFSET FLAT:?malloc@@YAPEAXI@Z	; malloc
	mov	r8d, DWORD PTR f$[rsp+36]
	mov	rdx, QWORD PTR buffer_i$[rsp]
	mov	rcx, QWORD PTR $T2[rsp]
	call	??0Decoder@Jpeg@@QEAA@PEBEIP6APEAXI@ZP6AXPEAX@Z@Z ; Jpeg::Decoder::Decoder
	mov	QWORD PTR tv89[rsp], rax
	jmp	SHORT $LN8@start_boot
$LN7@start_boot:
	mov	QWORD PTR tv89[rsp], 0
$LN8@start_boot:
	mov	rax, QWORD PTR tv89[rsp]
	mov	QWORD PTR decoder$[rsp], rax

; 31   : 	if (decoder->GetResult() != Jpeg::Decoder::OK) {

	mov	rcx, QWORD PTR decoder$[rsp]
	call	?GetResult@Decoder@Jpeg@@QEBA?AW4DecodeResult@12@XZ ; Jpeg::Decoder::GetResult
	test	eax, eax
	je	SHORT $LN1@start_boot

; 32   : 		printf ("JPEG:Decoder Error\n");

	lea	rcx, OFFSET FLAT:$SG6209
	call	?printf@@YAXPEBDZZ			; printf
$LN1@start_boot:

; 33   : 	}
; 34   : 	//
; 35   : 	//uint8_t* data = decoder->GetImage();
; 36   : 	//for (int i = 0; i < decoder->GetHeight(); i++) {
; 37   : 	//	for (int k = 0; k < decoder->GetWidth(); k++) {
; 38   : 	//		int j = k + i * decoder->GetWidth();
; 39   : 	//		uint8_t r = data[j * 3];        //data[i * 3];
; 40   : 	//		uint8_t g = data[j * 3 + 1];        //data[i * 3 + 1];
; 41   : 	//		uint8_t b = data[j * 3 + 2];       //data[i * 3 + 2];
; 42   : 	//		uint32_t rgb =  ((r<<16) | (g<<8) | (b)) & 0x00ffffff;  //0xFF000000 | (r << 16) | (g << 8) | b;
; 43   : 	//		rgb = rgb | 0xff000000;
; 44   : 
; 45   : 	//		gui_draw_pixels(0 + k, 0 + i,rgb);
; 46   : 	//		j++;
; 47   : 	//	}
; 48   : 	//}
; 49   : 
; 50   : 	//svga_update(0,0,get_screen_width(), get_screen_height());
; 51   : 	x64_sti();

	call	x64_sti

; 52   : }

	add	rsp, 296				; 00000128H
	pop	rdi
	pop	rsi
	ret	0
?start_boot_screen@@YAXXZ ENDP				; start_boot_screen
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_Decode@Decoder@Jpeg@@AEAA?AW4DecodeResult@12@PEBEH@Z
_TEXT	SEGMENT
tv139 = 32
this$ = 64
jpeg$ = 72
size$ = 80
?_Decode@Decoder@Jpeg@@AEAA?AW4DecodeResult@12@PEBEH@Z PROC ; Jpeg::Decoder::_Decode, COMDAT

; 617  :         DecodeResult _Decode(const unsigned char* jpeg, const int size) {

$LN23:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 618  :             ctx.pos = (const unsigned char*) jpeg;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR jpeg$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 619  :             ctx.size = size & 0x7FFFFFFF;

	mov	eax, DWORD PTR size$[rsp]
	btr	eax, 31
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 620  :             if (ctx.size < 2) return NotAJpeg;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+16], 2
	jge	SHORT $LN18@Decode
	mov	eax, 1
	jmp	$LN19@Decode
$LN18@Decode:

; 621  :             if ((ctx.pos[0] ^ 0xFF) | (ctx.pos[1] ^ 0xD8)) return NotAJpeg;

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	xor	eax, 255				; 000000ffH
	mov	ecx, 1
	imul	rcx, 1
	mov	rdx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	movzx	ecx, BYTE PTR [rdx+rcx]
	xor	ecx, 216				; 000000d8H
	or	eax, ecx
	test	eax, eax
	je	SHORT $LN17@Decode
	mov	eax, 1
	jmp	$LN19@Decode
$LN17@Decode:

; 622  :             _Skip(2);

	mov	edx, 2
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip
$LN16@Decode:

; 623  :             while (!ctx.error) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	jne	$LN15@Decode

; 624  :                 if ((ctx.size < 2) || (ctx.pos[0] != 0xFF)) return SyntaxError;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+16], 2
	jl	SHORT $LN13@Decode
	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 255				; 000000ffH
	je	SHORT $LN14@Decode
$LN13@Decode:
	mov	eax, 5
	jmp	$LN19@Decode
$LN14@Decode:

; 625  :                 _Skip(2);

	mov	edx, 2
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip

; 626  :                 switch (ctx.pos[-1]) {

	mov	eax, 1
	imul	rax, -1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv139[rsp], eax
	mov	eax, DWORD PTR tv139[rsp]
	sub	eax, 192				; 000000c0H
	mov	DWORD PTR tv139[rsp], eax
	cmp	DWORD PTR tv139[rsp], 62		; 0000003eH
	ja	SHORT $LN4@Decode
	movsxd	rax, DWORD PTR tv139[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR $LN21@Decode[rcx+rax]
	mov	eax, DWORD PTR $LN22@Decode[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN10@Decode:

; 627  :                     case 0xC0: _DecodeSOF();  break;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_DecodeSOF@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_DecodeSOF
	jmp	SHORT $LN11@Decode
$LN9@Decode:

; 628  :                     case 0xC4: _DecodeDHT();  break;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_DecodeDHT@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_DecodeDHT
	jmp	SHORT $LN11@Decode
$LN8@Decode:

; 629  :                     case 0xDB: _DecodeDQT();  break;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_DecodeDQT@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_DecodeDQT
	jmp	SHORT $LN11@Decode
$LN7@Decode:

; 630  :                     case 0xDD: _DecodeDRI();  break;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_DecodeDRI@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_DecodeDRI
	jmp	SHORT $LN11@Decode
$LN6@Decode:

; 631  :                     case 0xDA: _DecodeScan(); break;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_DecodeScan@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_DecodeScan
	jmp	SHORT $LN11@Decode
$LN5@Decode:

; 632  :                     case 0xFE: _SkipMarker(); break;

	mov	rcx, QWORD PTR this$[rsp]
	call	?_SkipMarker@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_SkipMarker
	jmp	SHORT $LN11@Decode
$LN4@Decode:

; 633  :                     default:
; 634  :                         if ((ctx.pos[-1] & 0xF0) == 0xE0)

	mov	eax, 1
	imul	rax, -1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 240				; 000000f0H
	cmp	eax, 224				; 000000e0H
	jne	SHORT $LN3@Decode

; 635  :                             _SkipMarker();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_SkipMarker@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_SkipMarker

; 636  :                         else

	jmp	SHORT $LN2@Decode
$LN3@Decode:

; 637  :                             return Unsupported;

	mov	eax, 2
	jmp	SHORT $LN19@Decode
$LN2@Decode:
$LN11@Decode:

; 638  :                 }
; 639  :             }

	jmp	$LN16@Decode
$LN15@Decode:

; 640  :             if (ctx.error != Internal_Finished) return ctx.error;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 6
	je	SHORT $LN1@Decode
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	jmp	SHORT $LN19@Decode
$LN1@Decode:

; 641  :             ctx.error = OK;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 0

; 642  :             _Convert();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Convert@Decoder@Jpeg@@AEAAXXZ		; Jpeg::Decoder::_Convert

; 643  :             return ctx.error;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
$LN19@Decode:

; 644  :         }

	add	rsp, 56					; 00000038H
	ret	0
	npad	1
$LN22@Decode:
	DD	$LN10@Decode
	DD	$LN9@Decode
	DD	$LN6@Decode
	DD	$LN8@Decode
	DD	$LN7@Decode
	DD	$LN5@Decode
	DD	$LN4@Decode
$LN21@Decode:
	DB	0
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	3
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
?_Decode@Decoder@Jpeg@@AEAA?AW4DecodeResult@12@PEBEH@Z ENDP ; Jpeg::Decoder::_Decode
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_Convert@Decoder@Jpeg@@AEAAXXZ
_TEXT	SEGMENT
x$1 = 32
c$ = 40
prgb$2 = 48
y$3 = 56
yy$4 = 60
y$5 = 64
i$ = 68
cb$6 = 72
cr$7 = 76
pcb$8 = 80
pcr$9 = 88
pin$10 = 96
py$11 = 104
pout$12 = 112
this$ = 144
?_Convert@Decoder@Jpeg@@AEAAXXZ PROC			; Jpeg::Decoder::_Convert, COMDAT

; 571  :         inline void _Convert() {

$LN30:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 572  :             int i;
; 573  :             Component* c;
; 574  :             for (i = 0, c = ctx.comp;  i < ctx.ncomp;  ++i, ++c) {

	mov	DWORD PTR i$[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR c$[rsp], rax
	jmp	SHORT $LN27@Convert
$LN26@Convert:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR c$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR c$[rsp], rax
$LN27@Convert:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN25@Convert
$LN24@Convert:

; 575  :                 while ((c->width < ctx.width) || (c->height < ctx.height)) {

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	cmp	DWORD PTR [rax+12], ecx
	jl	SHORT $LN22@Convert
	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	cmp	DWORD PTR [rax+16], ecx
	jge	SHORT $LN23@Convert
$LN22@Convert:

; 576  :                     if (c->width < ctx.width) _UpsampleH(c);

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	cmp	DWORD PTR [rax+12], ecx
	jge	SHORT $LN21@Convert
	mov	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_UpsampleH@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z ; Jpeg::Decoder::_UpsampleH
$LN21@Convert:

; 577  :                     if (ctx.error) return;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN20@Convert
	jmp	$LN28@Convert
$LN20@Convert:

; 578  :                     if (c->height < ctx.height) _UpsampleV(c);

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	cmp	DWORD PTR [rax+16], ecx
	jge	SHORT $LN19@Convert
	mov	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_UpsampleV@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z ; Jpeg::Decoder::_UpsampleV
$LN19@Convert:

; 579  :                     if (ctx.error) return;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN18@Convert
	jmp	$LN28@Convert
$LN18@Convert:

; 580  :                 }

	jmp	$LN24@Convert
$LN23@Convert:

; 581  :                 if ((c->width < ctx.width) || (c->height < ctx.height)) JPEG_DECODER_THROW(InternalError);

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+24]
	cmp	DWORD PTR [rax+12], ecx
	jl	SHORT $LN16@Convert
	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+28]
	cmp	DWORD PTR [rax+16], ecx
	jge	SHORT $LN17@Convert
$LN16@Convert:
$LN15@Convert:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 4
	jmp	$LN28@Convert
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN15@Convert
$LN17@Convert:

; 582  :             }

	jmp	$LN26@Convert
$LN25@Convert:

; 583  :             if (ctx.ncomp == 3) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+48], 3
	jne	$LN12@Convert

; 584  :                 // convert to RGB
; 585  :                 int x, yy;
; 586  :                 unsigned char *prgb = ctx.rgb;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+525024]
	mov	QWORD PTR prgb$2[rsp], rax

; 587  :                 const unsigned char *py  = ctx.comp[0].pixels;

	mov	eax, 48					; 00000030H
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rcx+rax+96]
	mov	QWORD PTR py$11[rsp], rax

; 588  :                 const unsigned char *pcb = ctx.comp[1].pixels;

	mov	eax, 48					; 00000030H
	imul	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rcx+rax+96]
	mov	QWORD PTR pcb$8[rsp], rax

; 589  :                 const unsigned char *pcr = ctx.comp[2].pixels;

	mov	eax, 48					; 00000030H
	imul	rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rcx+rax+96]
	mov	QWORD PTR pcr$9[rsp], rax

; 590  :                 for (yy = ctx.height;  yy;  --yy) {

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	DWORD PTR yy$4[rsp], eax
	jmp	SHORT $LN11@Convert
$LN10@Convert:
	mov	eax, DWORD PTR yy$4[rsp]
	dec	eax
	mov	DWORD PTR yy$4[rsp], eax
$LN11@Convert:
	cmp	DWORD PTR yy$4[rsp], 0
	je	$LN9@Convert

; 591  :                     for (x = 0;  x < ctx.width;  ++x) {

	mov	DWORD PTR x$1[rsp], 0
	jmp	SHORT $LN8@Convert
$LN7@Convert:
	mov	eax, DWORD PTR x$1[rsp]
	inc	eax
	mov	DWORD PTR x$1[rsp], eax
$LN8@Convert:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	cmp	DWORD PTR x$1[rsp], eax
	jge	$LN6@Convert

; 592  :                         register int y = py[x] << 8;

	movsxd	rax, DWORD PTR x$1[rsp]
	mov	rcx, QWORD PTR py$11[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 8
	mov	DWORD PTR y$3[rsp], eax

; 593  :                         register int cb = pcb[x] - 128;

	movsxd	rax, DWORD PTR x$1[rsp]
	mov	rcx, QWORD PTR pcb$8[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	sub	eax, 128				; 00000080H
	mov	DWORD PTR cb$6[rsp], eax

; 594  :                         register int cr = pcr[x] - 128;

	movsxd	rax, DWORD PTR x$1[rsp]
	mov	rcx, QWORD PTR pcr$9[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	sub	eax, 128				; 00000080H
	mov	DWORD PTR cr$7[rsp], eax

; 595  :                         *prgb++ = _Clip((y            + 359 * cr + 128) >> 8);

	mov	eax, DWORD PTR cr$7[rsp]
	imul	eax, 359				; 00000167H
	mov	ecx, DWORD PTR y$3[rsp]
	lea	eax, DWORD PTR [rcx+rax+128]
	sar	eax, 8
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip
	mov	rcx, QWORD PTR prgb$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR prgb$2[rsp]
	inc	rax
	mov	QWORD PTR prgb$2[rsp], rax

; 596  :                         *prgb++ = _Clip((y -  88 * cb - 183 * cr + 128) >> 8);

	mov	eax, DWORD PTR cb$6[rsp]
	imul	eax, 88					; 00000058H
	mov	ecx, DWORD PTR y$3[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	ecx, DWORD PTR cr$7[rsp]
	imul	ecx, 183				; 000000b7H
	sub	eax, ecx
	add	eax, 128				; 00000080H
	sar	eax, 8
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip
	mov	rcx, QWORD PTR prgb$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR prgb$2[rsp]
	inc	rax
	mov	QWORD PTR prgb$2[rsp], rax

; 597  :                         *prgb++ = _Clip((y + 454 * cb            + 128) >> 8);

	mov	eax, DWORD PTR cb$6[rsp]
	imul	eax, 454				; 000001c6H
	mov	ecx, DWORD PTR y$3[rsp]
	lea	eax, DWORD PTR [rcx+rax+128]
	sar	eax, 8
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip
	mov	rcx, QWORD PTR prgb$2[rsp]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR prgb$2[rsp]
	inc	rax
	mov	QWORD PTR prgb$2[rsp], rax

; 598  :                     }

	jmp	$LN7@Convert
$LN6@Convert:

; 599  :                     py += ctx.comp[0].stride;

	mov	eax, 48					; 00000030H
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rcx+rax+76]
	mov	rcx, QWORD PTR py$11[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR py$11[rsp], rax

; 600  :                     pcb += ctx.comp[1].stride;

	mov	eax, 48					; 00000030H
	imul	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rcx+rax+76]
	mov	rcx, QWORD PTR pcb$8[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR pcb$8[rsp], rax

; 601  :                     pcr += ctx.comp[2].stride;

	mov	eax, 48					; 00000030H
	imul	rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rcx+rax+76]
	mov	rcx, QWORD PTR pcr$9[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR pcr$9[rsp], rax

; 602  :                 }

	jmp	$LN10@Convert
$LN9@Convert:

; 603  :             } else if (ctx.comp[0].width != ctx.comp[0].stride) {

	jmp	$LN5@Convert
$LN12@Convert:
	mov	eax, 48					; 00000030H
	imul	rax, 0
	mov	ecx, 48					; 00000030H
	imul	rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [r8+rcx+76]
	cmp	DWORD PTR [rdx+rax+68], ecx
	je	$LN4@Convert

; 604  :                 // grayscale -> only remove stride
; 605  :                 unsigned char *pin = &ctx.comp[0].pixels[ctx.comp[0].stride];

	mov	eax, 48					; 00000030H
	imul	rax, 0
	mov	ecx, 48					; 00000030H
	imul	rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	movsxd	rcx, DWORD PTR [rdx+rcx+76]
	mov	rdx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rdx+rax+96]
	add	rax, rcx
	mov	QWORD PTR pin$10[rsp], rax

; 606  :                 unsigned char *pout = &ctx.comp[0].pixels[ctx.comp[0].width];

	mov	eax, 48					; 00000030H
	imul	rax, 0
	mov	ecx, 48					; 00000030H
	imul	rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	movsxd	rcx, DWORD PTR [rdx+rcx+68]
	mov	rdx, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rdx+rax+96]
	add	rax, rcx
	mov	QWORD PTR pout$12[rsp], rax

; 607  :                 int y;
; 608  :                 for (y = ctx.comp[0].height - 1;  y;  --y) {

	mov	eax, 48					; 00000030H
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rcx+rax+72]
	dec	eax
	mov	DWORD PTR y$5[rsp], eax
	jmp	SHORT $LN3@Convert
$LN2@Convert:
	mov	eax, DWORD PTR y$5[rsp]
	dec	eax
	mov	DWORD PTR y$5[rsp], eax
$LN3@Convert:
	cmp	DWORD PTR y$5[rsp], 0
	je	SHORT $LN1@Convert

; 609  :                     memcpy(pout, pin, ctx.comp[0].width);

	mov	eax, 48					; 00000030H
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	r8d, DWORD PTR [rcx+rax+68]
	mov	rdx, QWORD PTR pin$10[rsp]
	mov	rcx, QWORD PTR pout$12[rsp]
	call	memcpy

; 610  :                     pin += ctx.comp[0].stride;

	mov	eax, 48					; 00000030H
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rcx+rax+76]
	mov	rcx, QWORD PTR pin$10[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR pin$10[rsp], rax

; 611  :                     pout += ctx.comp[0].width;

	mov	eax, 48					; 00000030H
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	movsxd	rax, DWORD PTR [rcx+rax+68]
	mov	rcx, QWORD PTR pout$12[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR pout$12[rsp], rax

; 612  :                 }

	jmp	$LN2@Convert
$LN1@Convert:

; 613  :                 ctx.comp[0].stride = ctx.comp[0].width;

	mov	eax, 48					; 00000030H
	imul	rax, 0
	mov	ecx, 48					; 00000030H
	imul	rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	r8, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [r8+rax+68]
	mov	DWORD PTR [rdx+rcx+76], eax
$LN4@Convert:
$LN5@Convert:
$LN28@Convert:

; 614  :             }
; 615  :         }

	add	rsp, 136				; 00000088H
	ret	0
?_Convert@Decoder@Jpeg@@AEAAXXZ ENDP			; Jpeg::Decoder::_Convert
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_UpsampleV@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z
_TEXT	SEGMENT
s1$ = 32
w$ = 36
s2$ = 40
x$ = 44
y$ = 48
cin$ = 56
cout$ = 64
out$ = 72
this$ = 96
c$ = 104
?_UpsampleV@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z PROC	; Jpeg::Decoder::_UpsampleV, COMDAT

; 542  :         inline void _UpsampleV(Component* c) {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 543  :             const int w = c->width, s1 = c->stride, s2 = s1 + s1;

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+12]
	mov	DWORD PTR w$[rsp], eax
	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+20]
	mov	DWORD PTR s1$[rsp], eax
	mov	eax, DWORD PTR s1$[rsp]
	mov	ecx, DWORD PTR s1$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR s2$[rsp], eax

; 544  :             unsigned char *out, *cin, *cout;
; 545  :             int x, y;
; 546  :             out = (unsigned char*)AllocMem((c->width * c->height) << 1);

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+12]
	imul	eax, DWORD PTR [rcx+16]
	shl	eax, 1
	mov	ecx, eax
	mov	rax, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+525096]
	mov	QWORD PTR out$[rsp], rax

; 547  :             if (!out) JPEG_DECODER_THROW(OutOfMemory);

	cmp	QWORD PTR out$[rsp], 0
	jne	SHORT $LN10@UpsampleV
$LN9@UpsampleV:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 3
	jmp	$LN11@UpsampleV
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN9@UpsampleV
$LN10@UpsampleV:

; 548  :             for (x = 0;  x < w;  ++x) {

	mov	DWORD PTR x$[rsp], 0
	jmp	SHORT $LN6@UpsampleV
$LN5@UpsampleV:
	mov	eax, DWORD PTR x$[rsp]
	inc	eax
	mov	DWORD PTR x$[rsp], eax
$LN6@UpsampleV:
	mov	eax, DWORD PTR w$[rsp]
	cmp	DWORD PTR x$[rsp], eax
	jge	$LN4@UpsampleV

; 549  :                 cin = &c->pixels[x];

	movsxd	rax, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cin$[rsp], rax

; 550  :                 cout = &out[x];

	movsxd	rax, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cout$[rsp], rax

; 551  :                 *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR cin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, 139				; 0000008bH
	movsxd	rcx, DWORD PTR s1$[rsp]
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -11
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	rcx, QWORD PTR cout$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR w$[rsp]
	mov	rcx, QWORD PTR cout$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cout$[rsp], rax

; 552  :                 *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR cin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, 104				; 00000068H
	movsxd	rcx, DWORD PTR s1$[rsp]
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 27
	add	eax, ecx
	movsxd	rcx, DWORD PTR s2$[rsp]
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -3
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	rcx, QWORD PTR cout$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR w$[rsp]
	mov	rcx, QWORD PTR cout$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cout$[rsp], rax

; 553  :                 *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR cin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, 28
	movsxd	rcx, DWORD PTR s1$[rsp]
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 109				; 0000006dH
	add	eax, ecx
	movsxd	rcx, DWORD PTR s2$[rsp]
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -9
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	rcx, QWORD PTR cout$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR w$[rsp]
	mov	rcx, QWORD PTR cout$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cout$[rsp], rax

; 554  :                 cin += s1;

	movsxd	rax, DWORD PTR s1$[rsp]
	mov	rcx, QWORD PTR cin$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cin$[rsp], rax

; 555  :                 for (y = c->height - 3;  y;  --y) {

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+16]
	sub	eax, 3
	mov	DWORD PTR y$[rsp], eax
	jmp	SHORT $LN3@UpsampleV
$LN2@UpsampleV:
	mov	eax, DWORD PTR y$[rsp]
	dec	eax
	mov	DWORD PTR y$[rsp], eax
$LN3@UpsampleV:
	cmp	DWORD PTR y$[rsp], 0
	je	$LN1@UpsampleV

; 556  :                     *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;

	mov	eax, DWORD PTR s1$[rsp]
	neg	eax
	cdqe
	mov	rcx, QWORD PTR cin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, -9
	mov	ecx, 1
	imul	rcx, 0
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 111				; 0000006fH
	add	eax, ecx
	movsxd	rcx, DWORD PTR s1$[rsp]
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 29
	add	eax, ecx
	movsxd	rcx, DWORD PTR s2$[rsp]
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -3
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	rcx, QWORD PTR cout$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR w$[rsp]
	mov	rcx, QWORD PTR cout$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cout$[rsp], rax

; 557  :                     *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;

	mov	eax, DWORD PTR s1$[rsp]
	neg	eax
	cdqe
	mov	rcx, QWORD PTR cin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, -3
	mov	ecx, 1
	imul	rcx, 0
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 29
	add	eax, ecx
	movsxd	rcx, DWORD PTR s1$[rsp]
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 111				; 0000006fH
	add	eax, ecx
	movsxd	rcx, DWORD PTR s2$[rsp]
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -9
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	rcx, QWORD PTR cout$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR w$[rsp]
	mov	rcx, QWORD PTR cout$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cout$[rsp], rax

; 558  :                     cin += s1;

	movsxd	rax, DWORD PTR s1$[rsp]
	mov	rcx, QWORD PTR cin$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cin$[rsp], rax

; 559  :                 }

	jmp	$LN2@UpsampleV
$LN1@UpsampleV:

; 560  :                 cin += s1;

	movsxd	rax, DWORD PTR s1$[rsp]
	mov	rcx, QWORD PTR cin$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cin$[rsp], rax

; 561  :                 *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR cin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, 28
	mov	ecx, DWORD PTR s1$[rsp]
	neg	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 109				; 0000006dH
	add	eax, ecx
	mov	ecx, DWORD PTR s2$[rsp]
	neg	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -9
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	rcx, QWORD PTR cout$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR w$[rsp]
	mov	rcx, QWORD PTR cout$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cout$[rsp], rax

; 562  :                 *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR cin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, 104				; 00000068H
	mov	ecx, DWORD PTR s1$[rsp]
	neg	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 27
	add	eax, ecx
	mov	ecx, DWORD PTR s2$[rsp]
	neg	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -3
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	rcx, QWORD PTR cout$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR w$[rsp]
	mov	rcx, QWORD PTR cout$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR cout$[rsp], rax

; 563  :                 *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR cin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, 139				; 0000008bH
	mov	ecx, DWORD PTR s1$[rsp]
	neg	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR cin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -11
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	rcx, QWORD PTR cout$[rsp]
	mov	BYTE PTR [rcx], al

; 564  :             }

	jmp	$LN5@UpsampleV
$LN4@UpsampleV:

; 565  :             c->height <<= 1;

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+16]
	shl	eax, 1
	mov	rcx, QWORD PTR c$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 566  :             c->stride = c->width;

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rax+20], ecx

; 567  :             FreeMem(c->pixels);

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR [rax+40]
	mov	rax, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+525104]

; 568  :             c->pixels = out;

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	mov	QWORD PTR [rax+40], rcx
$LN11@UpsampleV:

; 569  :         }

	add	rsp, 88					; 00000058H
	ret	0
?_UpsampleV@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z ENDP	; Jpeg::Decoder::_UpsampleV
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_UpsampleH@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z
_TEXT	SEGMENT
x$ = 32
y$ = 36
xmax$ = 40
lin$ = 48
lout$ = 56
out$ = 64
this$ = 96
c$ = 104
?_UpsampleH@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z PROC	; Jpeg::Decoder::_UpsampleH, COMDAT

; 514  :         inline void _UpsampleH(Component* c) {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 515  :             const int xmax = c->width - 3;

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+12]
	sub	eax, 3
	mov	DWORD PTR xmax$[rsp], eax

; 516  :             unsigned char *out, *lin, *lout;
; 517  :             int x, y;
; 518  :             out = (unsigned char*)AllocMem((c->width * c->height) << 1);

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+12]
	imul	eax, DWORD PTR [rcx+16]
	shl	eax, 1
	mov	ecx, eax
	mov	rax, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+525096]
	mov	QWORD PTR out$[rsp], rax

; 519  :             if (!out) JPEG_DECODER_THROW(OutOfMemory);

	cmp	QWORD PTR out$[rsp], 0
	jne	SHORT $LN10@UpsampleH
$LN9@UpsampleH:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 3
	jmp	$LN11@UpsampleH
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN9@UpsampleH
$LN10@UpsampleH:

; 520  :             lin = c->pixels;

	mov	rax, QWORD PTR c$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR lin$[rsp], rax

; 521  :             lout = out;

	mov	rax, QWORD PTR out$[rsp]
	mov	QWORD PTR lout$[rsp], rax

; 522  :             for (y = c->height;  y;  --y) {

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+16]
	mov	DWORD PTR y$[rsp], eax
	jmp	SHORT $LN6@UpsampleH
$LN5@UpsampleH:
	mov	eax, DWORD PTR y$[rsp]
	dec	eax
	mov	DWORD PTR y$[rsp], eax
$LN6@UpsampleH:
	cmp	DWORD PTR y$[rsp], 0
	je	$LN4@UpsampleH

; 523  :                 lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR lin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, 139				; 0000008bH
	mov	ecx, 1
	imul	rcx, 1
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -11
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	ecx, 1
	imul	rcx, 0
	mov	rdx, QWORD PTR lout$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 524  :                 lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR lin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, 104				; 00000068H
	mov	ecx, 1
	imul	rcx, 1
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 27
	add	eax, ecx
	mov	ecx, 1
	imul	rcx, 2
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -3
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	ecx, 1
	imul	rcx, 1
	mov	rdx, QWORD PTR lout$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 525  :                 lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR lin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, 28
	mov	ecx, 1
	imul	rcx, 1
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 109				; 0000006dH
	add	eax, ecx
	mov	ecx, 1
	imul	rcx, 2
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -9
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	ecx, 1
	imul	rcx, 2
	mov	rdx, QWORD PTR lout$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 526  :                 for (x = 0;  x < xmax;  ++x) {

	mov	DWORD PTR x$[rsp], 0
	jmp	SHORT $LN3@UpsampleH
$LN2@UpsampleH:
	mov	eax, DWORD PTR x$[rsp]
	inc	eax
	mov	DWORD PTR x$[rsp], eax
$LN3@UpsampleH:
	mov	eax, DWORD PTR xmax$[rsp]
	cmp	DWORD PTR x$[rsp], eax
	jge	$LN1@UpsampleH

; 527  :                     lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);

	movsxd	rax, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR lin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, -9
	mov	ecx, DWORD PTR x$[rsp]
	inc	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 111				; 0000006fH
	add	eax, ecx
	mov	ecx, DWORD PTR x$[rsp]
	add	ecx, 2
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 29
	add	eax, ecx
	mov	ecx, DWORD PTR x$[rsp]
	add	ecx, 3
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -3
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	ecx, DWORD PTR x$[rsp]
	lea	ecx, DWORD PTR [rcx+rcx+3]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR lout$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 528  :                     lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);

	movsxd	rax, DWORD PTR x$[rsp]
	mov	rcx, QWORD PTR lin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, -3
	mov	ecx, DWORD PTR x$[rsp]
	inc	ecx
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 29
	add	eax, ecx
	mov	ecx, DWORD PTR x$[rsp]
	add	ecx, 2
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 111				; 0000006fH
	add	eax, ecx
	mov	ecx, DWORD PTR x$[rsp]
	add	ecx, 3
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -9
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	ecx, DWORD PTR x$[rsp]
	lea	ecx, DWORD PTR [rcx+rcx+4]
	movsxd	rcx, ecx
	mov	rdx, QWORD PTR lout$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 529  :                 }

	jmp	$LN2@UpsampleH
$LN1@UpsampleH:

; 530  :                 lin += c->stride;

	mov	rax, QWORD PTR c$[rsp]
	movsxd	rax, DWORD PTR [rax+20]
	mov	rcx, QWORD PTR lin$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR lin$[rsp], rax

; 531  :                 lout += c->width << 1;

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+12]
	shl	eax, 1
	cdqe
	mov	rcx, QWORD PTR lout$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR lout$[rsp], rax

; 532  :                 lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);

	mov	eax, 1
	imul	rax, -1
	mov	rcx, QWORD PTR lin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, 28
	mov	ecx, 1
	imul	rcx, -2
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 109				; 0000006dH
	add	eax, ecx
	mov	ecx, 1
	imul	rcx, -3
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -9
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	ecx, 1
	imul	rcx, -3
	mov	rdx, QWORD PTR lout$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 533  :                 lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);

	mov	eax, 1
	imul	rax, -1
	mov	rcx, QWORD PTR lin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, 104				; 00000068H
	mov	ecx, 1
	imul	rcx, -2
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, 27
	add	eax, ecx
	mov	ecx, 1
	imul	rcx, -3
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -3
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	ecx, 1
	imul	rcx, -2
	mov	rdx, QWORD PTR lout$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 534  :                 lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);

	mov	eax, 1
	imul	rax, -1
	mov	rcx, QWORD PTR lin$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	imul	eax, 139				; 0000008bH
	mov	ecx, 1
	imul	rcx, -2
	mov	rdx, QWORD PTR lin$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	imul	ecx, -11
	add	eax, ecx
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?CF@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::CF
	mov	ecx, 1
	imul	rcx, -1
	mov	rdx, QWORD PTR lout$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 535  :             }

	jmp	$LN5@UpsampleH
$LN4@UpsampleH:

; 536  :             c->width <<= 1;

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+12]
	shl	eax, 1
	mov	rcx, QWORD PTR c$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 537  :             c->stride = c->width;

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR [rcx+12]
	mov	DWORD PTR [rax+20], ecx

; 538  :             FreeMem(c->pixels);

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR [rax+40]
	mov	rax, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+525104]

; 539  :             c->pixels = out;

	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	mov	QWORD PTR [rax+40], rcx
$LN11@UpsampleH:

; 540  :         }

	add	rsp, 88					; 00000058H
	ret	0
?_UpsampleH@Decoder@Jpeg@@AEAAXPEAUComponent@12@@Z ENDP	; Jpeg::Decoder::_UpsampleH
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?CF@Decoder@Jpeg@@AEAAEH@Z
_TEXT	SEGMENT
this$ = 48
x$ = 56
?CF@Decoder@Jpeg@@AEAAEH@Z PROC				; Jpeg::Decoder::CF, COMDAT

; 510  :         inline unsigned char CF(const int x) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 511  :             return _Clip((x + 64) >> 7);

	mov	eax, DWORD PTR x$[rsp]
	add	eax, 64					; 00000040H
	sar	eax, 7
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip

; 512  :         }

	add	rsp, 40					; 00000028H
	ret	0
?CF@Decoder@Jpeg@@AEAAEH@Z ENDP				; Jpeg::Decoder::CF
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_DecodeScan@Decoder@Jpeg@@AEAAXXZ
_TEXT	SEGMENT
i$ = 32
mby$ = 36
sby$ = 40
mbx$ = 44
sbx$ = 48
rstcount$ = 52
nextrst$ = 56
c$ = 64
this$ = 96
?_DecodeScan@Decoder@Jpeg@@AEAAXXZ PROC			; Jpeg::Decoder::_DecodeScan, COMDAT

; 456  :         inline void _DecodeScan(void) {

$LN52:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 457  :             int i, mbx, mby, sbx, sby;
; 458  :             int rstcount = ctx.rstinterval, nextrst = 0;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+525016]
	mov	DWORD PTR rstcount$[rsp], eax
	mov	DWORD PTR nextrst$[rsp], 0

; 459  :             Component* c;
; 460  :             _DecodeLength();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_DecodeLength@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_DecodeLength

; 461  :             if (ctx.length < (4 + 2 * ctx.ncomp)) JPEG_DECODER_THROW(SyntaxError);

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	lea	eax, DWORD PTR [rax+rax+4]
	mov	rcx, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rcx+20], eax
	jge	SHORT $LN49@DecodeScan
$LN48@DecodeScan:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN50@DecodeScan
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN48@DecodeScan
$LN49@DecodeScan:

; 462  :             if (ctx.pos[0] != ctx.ncomp) JPEG_DECODER_THROW(Unsupported);

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR this$[rsp]
	cmp	eax, DWORD PTR [rcx+48]
	je	SHORT $LN45@DecodeScan
$LN44@DecodeScan:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 2
	jmp	$LN50@DecodeScan
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN44@DecodeScan
$LN45@DecodeScan:

; 463  :             _Skip(1);

	mov	edx, 1
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip

; 464  :             for (i = 0, c = ctx.comp;  i < ctx.ncomp;  ++i, ++c) {

	mov	DWORD PTR i$[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR c$[rsp], rax
	jmp	SHORT $LN41@DecodeScan
$LN40@DecodeScan:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR c$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR c$[rsp], rax
$LN41@DecodeScan:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN39@DecodeScan

; 465  :                 if (ctx.pos[0] != c->cid) JPEG_DECODER_THROW(SyntaxError);

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR c$[rsp]
	cmp	eax, DWORD PTR [rcx]
	je	SHORT $LN38@DecodeScan
$LN37@DecodeScan:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN50@DecodeScan
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN37@DecodeScan
$LN38@DecodeScan:

; 466  :                 if (ctx.pos[1] & 0xEE) JPEG_DECODER_THROW(SyntaxError);

	mov	eax, 1
	imul	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 238				; 000000eeH
	test	eax, eax
	je	SHORT $LN34@DecodeScan
$LN33@DecodeScan:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN50@DecodeScan
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN33@DecodeScan
$LN34@DecodeScan:

; 467  :                 c->dctabsel = ctx.pos[1] >> 4;

	mov	eax, 1
	imul	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	sar	eax, 4
	mov	rcx, QWORD PTR c$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 468  :                 c->actabsel = (ctx.pos[1] & 1) | 2;

	mov	eax, 1
	imul	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 1
	or	eax, 2
	mov	rcx, QWORD PTR c$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 469  :                 _Skip(2);

	mov	edx, 2
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip

; 470  :             }

	jmp	$LN40@DecodeScan
$LN39@DecodeScan:

; 471  :             if (ctx.pos[0] || (ctx.pos[1] != 63) || ctx.pos[2]) JPEG_DECODER_THROW(Unsupported);

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	jne	SHORT $LN29@DecodeScan
	mov	eax, 1
	imul	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 63					; 0000003fH
	jne	SHORT $LN29@DecodeScan
	mov	eax, 1
	imul	rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	test	eax, eax
	je	SHORT $LN30@DecodeScan
$LN29@DecodeScan:
$LN28@DecodeScan:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 2
	jmp	$LN50@DecodeScan
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN28@DecodeScan
$LN30@DecodeScan:

; 472  :             _Skip(ctx.length);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR [rax+20]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip

; 473  :             for (mby = 0;  mby < ctx.mbheight;  ++mby)

	mov	DWORD PTR mby$[rsp], 0
	jmp	SHORT $LN25@DecodeScan
$LN24@DecodeScan:
	mov	eax, DWORD PTR mby$[rsp]
	inc	eax
	mov	DWORD PTR mby$[rsp], eax
$LN25@DecodeScan:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+36]
	cmp	DWORD PTR mby$[rsp], eax
	jge	$LN23@DecodeScan

; 474  :                 for (mbx = 0;  mbx < ctx.mbwidth;  ++mbx) {

	mov	DWORD PTR mbx$[rsp], 0
	jmp	SHORT $LN22@DecodeScan
$LN21@DecodeScan:
	mov	eax, DWORD PTR mbx$[rsp]
	inc	eax
	mov	DWORD PTR mbx$[rsp], eax
$LN22@DecodeScan:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+32]
	cmp	DWORD PTR mbx$[rsp], eax
	jge	$LN20@DecodeScan

; 475  :                     for (i = 0, c = ctx.comp;  i < ctx.ncomp;  ++i, ++c)

	mov	DWORD PTR i$[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR c$[rsp], rax
	jmp	SHORT $LN19@DecodeScan
$LN18@DecodeScan:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR c$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR c$[rsp], rax
$LN19@DecodeScan:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN17@DecodeScan

; 476  :                         for (sby = 0;  sby < c->ssy;  ++sby)

	mov	DWORD PTR sby$[rsp], 0
	jmp	SHORT $LN16@DecodeScan
$LN15@DecodeScan:
	mov	eax, DWORD PTR sby$[rsp]
	inc	eax
	mov	DWORD PTR sby$[rsp], eax
$LN16@DecodeScan:
	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR sby$[rsp], eax
	jge	$LN14@DecodeScan

; 477  :                             for (sbx = 0;  sbx < c->ssx;  ++sbx) {

	mov	DWORD PTR sbx$[rsp], 0
	jmp	SHORT $LN13@DecodeScan
$LN12@DecodeScan:
	mov	eax, DWORD PTR sbx$[rsp]
	inc	eax
	mov	DWORD PTR sbx$[rsp], eax
$LN13@DecodeScan:
	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR sbx$[rsp], eax
	jge	SHORT $LN11@DecodeScan

; 478  :                                 _DecodeBlock(c, &c->pixels[((mby * c->ssy + sby) * c->stride + mbx * c->ssx + sbx) << 3]);

	mov	rax, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR mby$[rsp]
	imul	ecx, DWORD PTR [rax+8]
	mov	eax, ecx
	add	eax, DWORD PTR sby$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	imul	eax, DWORD PTR [rcx+20]
	mov	rcx, QWORD PTR c$[rsp]
	mov	edx, DWORD PTR mbx$[rsp]
	imul	edx, DWORD PTR [rcx+4]
	mov	ecx, edx
	mov	edx, DWORD PTR sbx$[rsp]
	add	edx, eax
	mov	eax, edx
	add	ecx, eax
	mov	eax, ecx
	shl	eax, 3
	cdqe
	mov	rcx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	add	rcx, rax
	mov	rax, rcx
	mov	r8, rax
	mov	rdx, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_DecodeBlock@Decoder@Jpeg@@AEAAXPEAUComponent@12@PEAE@Z ; Jpeg::Decoder::_DecodeBlock

; 479  :                                 if (ctx.error)

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LN10@DecodeScan

; 480  :                                 return;

	jmp	$LN50@DecodeScan
$LN10@DecodeScan:

; 481  :                             }

	jmp	$LN12@DecodeScan
$LN11@DecodeScan:
	jmp	$LN15@DecodeScan
$LN14@DecodeScan:
	jmp	$LN18@DecodeScan
$LN17@DecodeScan:

; 482  :                     if (ctx.rstinterval && !(--rstcount)) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+525016], 0
	je	$LN9@DecodeScan
	mov	eax, DWORD PTR rstcount$[rsp]
	dec	eax
	mov	DWORD PTR rstcount$[rsp], eax
	cmp	DWORD PTR rstcount$[rsp], 0
	jne	$LN9@DecodeScan

; 483  :                         _ByteAlign();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_ByteAlign@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_ByteAlign

; 484  :                         i = _GetBits(16);

	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	?_GetBits@Decoder@Jpeg@@AEAAHH@Z	; Jpeg::Decoder::_GetBits
	mov	DWORD PTR i$[rsp], eax

; 485  :                         if (((i & 0xFFF8) != 0xFFD0) || ((i & 7) != nextrst)) JPEG_DECODER_THROW(SyntaxError);

	mov	eax, DWORD PTR i$[rsp]
	and	eax, 65528				; 0000fff8H
	cmp	eax, 65488				; 0000ffd0H
	jne	SHORT $LN7@DecodeScan
	mov	eax, DWORD PTR i$[rsp]
	and	eax, 7
	cmp	eax, DWORD PTR nextrst$[rsp]
	je	SHORT $LN8@DecodeScan
$LN7@DecodeScan:
$LN6@DecodeScan:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	SHORT $LN50@DecodeScan
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN6@DecodeScan
$LN8@DecodeScan:

; 486  :                         nextrst = (nextrst + 1) & 7;

	mov	eax, DWORD PTR nextrst$[rsp]
	inc	eax
	and	eax, 7
	mov	DWORD PTR nextrst$[rsp], eax

; 487  :                         rstcount = ctx.rstinterval;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+525016]
	mov	DWORD PTR rstcount$[rsp], eax

; 488  :                         for (i = 0;  i < 3;  ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN3@DecodeScan
$LN2@DecodeScan:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN3@DecodeScan:
	cmp	DWORD PTR i$[rsp], 3
	jge	SHORT $LN1@DecodeScan

; 489  :                             ctx.comp[i].dcpred = 0;

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 48					; 00000030H
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+rax+92], 0
	jmp	SHORT $LN2@DecodeScan
$LN1@DecodeScan:
$LN9@DecodeScan:

; 490  :                     }
; 491  :                 }

	jmp	$LN21@DecodeScan
$LN20@DecodeScan:
	jmp	$LN24@DecodeScan
$LN23@DecodeScan:

; 492  :             ctx.error = Internal_Finished;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 6
$LN50@DecodeScan:

; 493  :         }

	add	rsp, 88					; 00000058H
	ret	0
?_DecodeScan@Decoder@Jpeg@@AEAAXXZ ENDP			; Jpeg::Decoder::_DecodeScan
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_DecodeBlock@Decoder@Jpeg@@AEAAXPEAUComponent@12@PEAE@Z
_TEXT	SEGMENT
code$ = 32
coef$ = 36
value$ = 40
this$ = 64
c$ = 72
out$ = 80
?_DecodeBlock@Decoder@Jpeg@@AEAAXPEAUComponent@12@PEAE@Z PROC ; Jpeg::Decoder::_DecodeBlock, COMDAT

; 436  :         inline void _DecodeBlock(Component* c, unsigned char* out) {

$LN21:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 437  :             unsigned char code;
; 438  :             int value, coef = 0;

	mov	DWORD PTR coef$[rsp], 0

; 439  :             memset(ctx.block, 0, sizeof(ctx.block));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 524760				; 000801d8H
	mov	r8d, 256				; 00000100H
	xor	edx, edx
	mov	rcx, rax
	call	?memset@@YAXPEAXEI@Z			; memset

; 440  :             c->dcpred += _GetVLC(&ctx.vlctab[c->dctabsel][0], NULL);

	mov	rax, QWORD PTR c$[rsp]
	movsxd	rax, DWORD PTR [rax+32]
	imul	rax, 131072				; 00020000H
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+464]
	mov	ecx, 2
	imul	rcx, 0
	add	rax, rcx
	xor	r8d, r8d
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_GetVLC@Decoder@Jpeg@@AEAAHPEAUVlcCode@12@PEAE@Z ; Jpeg::Decoder::_GetVLC
	mov	rcx, QWORD PTR c$[rsp]
	add	eax, DWORD PTR [rcx+36]
	mov	rcx, QWORD PTR c$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 441  :             ctx.block[0] = (c->dcpred) * ctx.qtab[c->qtsel][0];

	mov	rax, QWORD PTR c$[rsp]
	movsxd	rax, DWORD PTR [rax+24]
	imul	rax, 64					; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+208]
	mov	ecx, 1
	imul	rcx, 0
	movzx	eax, BYTE PTR [rax+rcx]
	mov	rcx, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR [rcx+36]
	imul	ecx, eax
	mov	eax, ecx
	mov	ecx, 4
	imul	rcx, 0
	mov	rdx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rdx+rcx+524760], eax
$LN18@DecodeBloc:

; 442  :             do {
; 443  :                 value = _GetVLC(&ctx.vlctab[c->actabsel][0], &code);

	mov	rax, QWORD PTR c$[rsp]
	movsxd	rax, DWORD PTR [rax+28]
	imul	rax, 131072				; 00020000H
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+464]
	mov	ecx, 2
	imul	rcx, 0
	add	rax, rcx
	lea	r8, QWORD PTR code$[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_GetVLC@Decoder@Jpeg@@AEAAHPEAUVlcCode@12@PEAE@Z ; Jpeg::Decoder::_GetVLC
	mov	DWORD PTR value$[rsp], eax

; 444  :                 if (!code) break;  // EOB

	movzx	eax, BYTE PTR code$[rsp]
	test	eax, eax
	jne	SHORT $LN15@DecodeBloc
	jmp	$LN16@DecodeBloc
$LN15@DecodeBloc:

; 445  :                 if (!(code & 0x0F) && (code != 0xF0)) JPEG_DECODER_THROW(SyntaxError);

	movzx	eax, BYTE PTR code$[rsp]
	and	eax, 15
	test	eax, eax
	jne	SHORT $LN14@DecodeBloc
	movzx	eax, BYTE PTR code$[rsp]
	cmp	eax, 240				; 000000f0H
	je	SHORT $LN14@DecodeBloc
$LN13@DecodeBloc:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN19@DecodeBloc
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN13@DecodeBloc
$LN14@DecodeBloc:

; 446  :                 coef += (code >> 4) + 1;

	movzx	eax, BYTE PTR code$[rsp]
	sar	eax, 4
	mov	ecx, DWORD PTR coef$[rsp]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	DWORD PTR coef$[rsp], eax

; 447  :                 if (coef > 63) JPEG_DECODER_THROW(SyntaxError);

	cmp	DWORD PTR coef$[rsp], 63		; 0000003fH
	jle	SHORT $LN10@DecodeBloc
$LN9@DecodeBloc:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN19@DecodeBloc
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN9@DecodeBloc
$LN10@DecodeBloc:

; 448  :                 ctx.block[(int) ZZ[coef]] = value * ctx.qtab[c->qtsel][coef];

	mov	rax, QWORD PTR c$[rsp]
	movsxd	rax, DWORD PTR [rax+24]
	imul	rax, 64					; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+208]
	movsxd	rcx, DWORD PTR coef$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	ecx, DWORD PTR value$[rsp]
	imul	ecx, eax
	mov	eax, ecx
	movsxd	rcx, DWORD PTR coef$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	movsx	rcx, BYTE PTR [rdx+rcx+525032]
	mov	rdx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rdx+rcx*4+524760], eax

; 449  :             } while (coef < 63);

	cmp	DWORD PTR coef$[rsp], 63		; 0000003fH
	jl	$LN18@DecodeBloc
$LN16@DecodeBloc:

; 450  :             for (coef = 0;  coef < 64;  coef += 8)

	mov	DWORD PTR coef$[rsp], 0
	jmp	SHORT $LN6@DecodeBloc
$LN5@DecodeBloc:
	mov	eax, DWORD PTR coef$[rsp]
	add	eax, 8
	mov	DWORD PTR coef$[rsp], eax
$LN6@DecodeBloc:
	cmp	DWORD PTR coef$[rsp], 64		; 00000040H
	jge	SHORT $LN4@DecodeBloc

; 451  :                 _RowIDCT(&ctx.block[coef]);

	movsxd	rax, DWORD PTR coef$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax*4+524760]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_RowIDCT@Decoder@Jpeg@@AEAAXPEAH@Z	; Jpeg::Decoder::_RowIDCT
	jmp	SHORT $LN5@DecodeBloc
$LN4@DecodeBloc:

; 452  :             for (coef = 0;  coef < 8;  ++coef)

	mov	DWORD PTR coef$[rsp], 0
	jmp	SHORT $LN3@DecodeBloc
$LN2@DecodeBloc:
	mov	eax, DWORD PTR coef$[rsp]
	inc	eax
	mov	DWORD PTR coef$[rsp], eax
$LN3@DecodeBloc:
	cmp	DWORD PTR coef$[rsp], 8
	jge	SHORT $LN1@DecodeBloc

; 453  :                 _ColIDCT(&ctx.block[coef], &out[coef], c->stride);

	movsxd	rax, DWORD PTR coef$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movsxd	rcx, DWORD PTR coef$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR [rdx+rcx*4+524760]
	mov	rdx, QWORD PTR c$[rsp]
	mov	r9d, DWORD PTR [rdx+20]
	mov	r8, rax
	mov	rdx, rcx
	mov	rcx, QWORD PTR this$[rsp]
	call	?_ColIDCT@Decoder@Jpeg@@AEAAXPEBHPEAEH@Z ; Jpeg::Decoder::_ColIDCT
	jmp	SHORT $LN2@DecodeBloc
$LN1@DecodeBloc:
$LN19@DecodeBloc:

; 454  :         }

	add	rsp, 56					; 00000038H
	ret	0
?_DecodeBlock@Decoder@Jpeg@@AEAAXPEAUComponent@12@PEAE@Z ENDP ; Jpeg::Decoder::_DecodeBlock
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_GetVLC@Decoder@Jpeg@@AEAAHPEAUVlcCode@12@PEAE@Z
_TEXT	SEGMENT
value$ = 32
bits$ = 36
tv141 = 40
tv144 = 44
this$ = 64
vlc$ = 72
code$ = 80
?_GetVLC@Decoder@Jpeg@@AEAAHPEAUVlcCode@12@PEAE@Z PROC	; Jpeg::Decoder::_GetVLC, COMDAT

; 421  :         inline int _GetVLC(VlcCode* vlc, unsigned char* code) {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 422  :             int value = _ShowBits(16);

	mov	edx, 16
	mov	rcx, QWORD PTR this$[rsp]
	call	?_ShowBits@Decoder@Jpeg@@AEAAHH@Z	; Jpeg::Decoder::_ShowBits
	mov	DWORD PTR value$[rsp], eax

; 423  :             int bits = vlc[value].bits;

	movsxd	rax, DWORD PTR value$[rsp]
	mov	rcx, QWORD PTR vlc$[rsp]
	movzx	eax, BYTE PTR [rcx+rax*2]
	mov	DWORD PTR bits$[rsp], eax

; 424  :             if (!bits) { ctx.error = SyntaxError; return 0; }

	cmp	DWORD PTR bits$[rsp], 0
	jne	SHORT $LN4@GetVLC
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	xor	eax, eax
	jmp	$LN5@GetVLC
$LN4@GetVLC:

; 425  :             _SkipBits(bits);

	mov	edx, DWORD PTR bits$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_SkipBits@Decoder@Jpeg@@AEAAXH@Z	; Jpeg::Decoder::_SkipBits

; 426  :             value = vlc[value].code;

	movsxd	rax, DWORD PTR value$[rsp]
	mov	rcx, QWORD PTR vlc$[rsp]
	movzx	eax, BYTE PTR [rcx+rax*2+1]
	mov	DWORD PTR value$[rsp], eax

; 427  :             if (code) *code = (unsigned char) value;

	cmp	QWORD PTR code$[rsp], 0
	je	SHORT $LN3@GetVLC
	mov	rax, QWORD PTR code$[rsp]
	movzx	ecx, BYTE PTR value$[rsp]
	mov	BYTE PTR [rax], cl
$LN3@GetVLC:

; 428  :             bits = value & 15;

	mov	eax, DWORD PTR value$[rsp]
	and	eax, 15
	mov	DWORD PTR bits$[rsp], eax

; 429  :             if (!bits) return 0;

	cmp	DWORD PTR bits$[rsp], 0
	jne	SHORT $LN2@GetVLC
	xor	eax, eax
	jmp	SHORT $LN5@GetVLC
$LN2@GetVLC:

; 430  :             value = _GetBits(bits);

	mov	edx, DWORD PTR bits$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_GetBits@Decoder@Jpeg@@AEAAHH@Z	; Jpeg::Decoder::_GetBits
	mov	DWORD PTR value$[rsp], eax

; 431  :             if (value < (1 << (bits - 1)))

	mov	eax, DWORD PTR bits$[rsp]
	dec	eax
	mov	ecx, 1
	mov	DWORD PTR tv141[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv141[rsp]
	shl	eax, cl
	cmp	DWORD PTR value$[rsp], eax
	jge	SHORT $LN1@GetVLC

; 432  :                 value += ((-1) << bits) + 1;

	mov	eax, DWORD PTR bits$[rsp]
	mov	ecx, -1
	mov	DWORD PTR tv144[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv144[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR value$[rsp]
	lea	eax, DWORD PTR [rcx+rax+1]
	mov	DWORD PTR value$[rsp], eax
$LN1@GetVLC:

; 433  :             return value;

	mov	eax, DWORD PTR value$[rsp]
$LN5@GetVLC:

; 434  :         }

	add	rsp, 56					; 00000038H
	ret	0
?_GetVLC@Decoder@Jpeg@@AEAAHPEAUVlcCode@12@PEAE@Z ENDP	; Jpeg::Decoder::_GetVLC
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_DecodeDRI@Decoder@Jpeg@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_DecodeDRI@Decoder@Jpeg@@AEAAXXZ PROC			; Jpeg::Decoder::_DecodeDRI, COMDAT

; 414  :         inline void _DecodeDRI(void) {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 415  :             _DecodeLength();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_DecodeLength@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_DecodeLength

; 416  :             if (ctx.length < 2) JPEG_DECODER_THROW(SyntaxError);

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+20], 2
	jge	SHORT $LN4@DecodeDRI
$LN3@DecodeDRI:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	SHORT $LN5@DecodeDRI
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN3@DecodeDRI
$LN4@DecodeDRI:

; 417  :             ctx.rstinterval = _Decode16(ctx.pos);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Decode16@Decoder@Jpeg@@AEAAGPEBE@Z	; Jpeg::Decoder::_Decode16
	movzx	eax, ax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+525016], eax

; 418  :             _Skip(ctx.length);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR [rax+20]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip
$LN5@DecodeDRI:

; 419  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_DecodeDRI@Decoder@Jpeg@@AEAAXXZ ENDP			; Jpeg::Decoder::_DecodeDRI
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_DecodeDQT@Decoder@Jpeg@@AEAAXXZ
_TEXT	SEGMENT
i$ = 32
tv153 = 36
t$ = 40
this$ = 64
?_DecodeDQT@Decoder@Jpeg@@AEAAXXZ PROC			; Jpeg::Decoder::_DecodeDQT, COMDAT

; 398  :         inline void _DecodeDQT(void) {

$LN16:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 399  :             int i;
; 400  :             unsigned char *t;
; 401  :             _DecodeLength();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_DecodeLength@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_DecodeLength
$LN13@DecodeDQT:

; 402  :             while (ctx.length >= 65) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+20], 65			; 00000041H
	jl	$LN12@DecodeDQT

; 403  :                 i = ctx.pos[0];

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR i$[rsp], eax

; 404  :                 if (i & 0xFC) JPEG_DECODER_THROW(SyntaxError);

	mov	eax, DWORD PTR i$[rsp]
	and	eax, 252				; 000000fcH
	test	eax, eax
	je	SHORT $LN11@DecodeDQT
$LN10@DecodeDQT:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN14@DecodeDQT
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN10@DecodeDQT
$LN11@DecodeDQT:

; 405  :                 ctx.qtavail |= 1 << i;

	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, 1
	mov	DWORD PTR tv153[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv153[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+204]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+204], eax

; 406  :                 t = &ctx.qtab[i][0];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 64					; 00000040H
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+208]
	mov	ecx, 1
	imul	rcx, 0
	add	rax, rcx
	mov	QWORD PTR t$[rsp], rax

; 407  :                 for (i = 0;  i < 64;  ++i)

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN7@DecodeDQT
$LN6@DecodeDQT:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN7@DecodeDQT:
	cmp	DWORD PTR i$[rsp], 64			; 00000040H
	jge	SHORT $LN5@DecodeDQT

; 408  :                     t[i] = ctx.pos[i + 1];

	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	cdqe
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movsxd	rdx, DWORD PTR i$[rsp]
	mov	r8, QWORD PTR t$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al
	jmp	SHORT $LN6@DecodeDQT
$LN5@DecodeDQT:

; 409  :                 _Skip(65);

	mov	edx, 65					; 00000041H
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip

; 410  :             }

	jmp	$LN13@DecodeDQT
$LN12@DecodeDQT:

; 411  :             if (ctx.length) JPEG_DECODER_THROW(SyntaxError);

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+20], 0
	je	SHORT $LN4@DecodeDQT
$LN3@DecodeDQT:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	SHORT $LN14@DecodeDQT
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN3@DecodeDQT
$LN4@DecodeDQT:
$LN14@DecodeDQT:

; 412  :         }

	add	rsp, 56					; 00000038H
	ret	0
?_DecodeDQT@Decoder@Jpeg@@AEAAXXZ ENDP			; Jpeg::Decoder::_DecodeDQT
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_DecodeDHT@Decoder@Jpeg@@AEAAXXZ
_TEXT	SEGMENT
codelen$ = 32
i$ = 36
code$1 = 40
remain$ = 44
currcnt$ = 48
spread$ = 52
j$ = 56
vlc$ = 64
tv176 = 72
counts$ = 80
this$ = 112
?_DecodeDHT@Decoder@Jpeg@@AEAAXXZ PROC			; Jpeg::Decoder::_DecodeDHT, COMDAT

; 358  :         inline void _DecodeDHT(void) {

$LN40:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 359  :             int codelen, currcnt, remain, spread, i, j;
; 360  :             VlcCode *vlc;
; 361  :             unsigned char counts[16];
; 362  :             _DecodeLength();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_DecodeLength@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_DecodeLength
$LN37@DecodeDHT:

; 363  :             while (ctx.length >= 17) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+20], 17
	jl	$LN36@DecodeDHT

; 364  :                 i = ctx.pos[0];

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR i$[rsp], eax

; 365  :                 if (i & 0xEC) JPEG_DECODER_THROW(SyntaxError);

	mov	eax, DWORD PTR i$[rsp]
	and	eax, 236				; 000000ecH
	test	eax, eax
	je	SHORT $LN35@DecodeDHT
$LN34@DecodeDHT:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN38@DecodeDHT
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN34@DecodeDHT
$LN35@DecodeDHT:

; 366  :                 if (i & 0x02) JPEG_DECODER_THROW(Unsupported);

	mov	eax, DWORD PTR i$[rsp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN31@DecodeDHT
$LN30@DecodeDHT:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 2
	jmp	$LN38@DecodeDHT
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN30@DecodeDHT
$LN31@DecodeDHT:

; 367  :                 i = (i | (i >> 3)) & 3;  // combined DC/AC + tableid value

	mov	eax, DWORD PTR i$[rsp]
	sar	eax, 3
	mov	ecx, DWORD PTR i$[rsp]
	or	ecx, eax
	mov	eax, ecx
	and	eax, 3
	mov	DWORD PTR i$[rsp], eax

; 368  :                 for (codelen = 1;  codelen <= 16;  ++codelen)

	mov	DWORD PTR codelen$[rsp], 1
	jmp	SHORT $LN27@DecodeDHT
$LN26@DecodeDHT:
	mov	eax, DWORD PTR codelen$[rsp]
	inc	eax
	mov	DWORD PTR codelen$[rsp], eax
$LN27@DecodeDHT:
	cmp	DWORD PTR codelen$[rsp], 16
	jg	SHORT $LN25@DecodeDHT

; 369  :                     counts[codelen - 1] = ctx.pos[codelen];

	movsxd	rax, DWORD PTR codelen$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	edx, DWORD PTR codelen$[rsp]
	dec	edx
	movsxd	rdx, edx
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR counts$[rsp+rdx], al
	jmp	SHORT $LN26@DecodeDHT
$LN25@DecodeDHT:

; 370  :                 _Skip(17);

	mov	edx, 17
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip

; 371  :                 vlc = &ctx.vlctab[i][0];

	movsxd	rax, DWORD PTR i$[rsp]
	imul	rax, 131072				; 00020000H
	mov	rcx, QWORD PTR this$[rsp]
	lea	rax, QWORD PTR [rcx+rax+464]
	mov	ecx, 2
	imul	rcx, 0
	add	rax, rcx
	mov	QWORD PTR vlc$[rsp], rax

; 372  :                 remain = spread = 65536;

	mov	DWORD PTR spread$[rsp], 65536		; 00010000H
	mov	eax, DWORD PTR spread$[rsp]
	mov	DWORD PTR remain$[rsp], eax

; 373  :                 for (codelen = 1;  codelen <= 16;  ++codelen) {

	mov	DWORD PTR codelen$[rsp], 1
	jmp	SHORT $LN24@DecodeDHT
$LN23@DecodeDHT:
	mov	eax, DWORD PTR codelen$[rsp]
	inc	eax
	mov	DWORD PTR codelen$[rsp], eax
$LN24@DecodeDHT:
	cmp	DWORD PTR codelen$[rsp], 16
	jg	$LN22@DecodeDHT

; 374  :                     spread >>= 1;

	mov	eax, DWORD PTR spread$[rsp]
	sar	eax, 1
	mov	DWORD PTR spread$[rsp], eax

; 375  :                     currcnt = counts[codelen - 1];

	mov	eax, DWORD PTR codelen$[rsp]
	dec	eax
	cdqe
	movzx	eax, BYTE PTR counts$[rsp+rax]
	mov	DWORD PTR currcnt$[rsp], eax

; 376  :                     if (!currcnt) continue;

	cmp	DWORD PTR currcnt$[rsp], 0
	jne	SHORT $LN21@DecodeDHT
	jmp	SHORT $LN23@DecodeDHT
$LN21@DecodeDHT:

; 377  :                     if (ctx.length < currcnt) JPEG_DECODER_THROW(SyntaxError);

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR currcnt$[rsp]
	cmp	DWORD PTR [rax+20], ecx
	jge	SHORT $LN20@DecodeDHT
$LN19@DecodeDHT:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN38@DecodeDHT
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN19@DecodeDHT
$LN20@DecodeDHT:

; 378  :                     remain -= currcnt << (16 - codelen);

	mov	eax, 16
	sub	eax, DWORD PTR codelen$[rsp]
	movzx	ecx, al
	mov	eax, DWORD PTR currcnt$[rsp]
	shl	eax, cl
	mov	ecx, DWORD PTR remain$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR remain$[rsp], eax

; 379  :                     if (remain < 0) JPEG_DECODER_THROW(SyntaxError);

	cmp	DWORD PTR remain$[rsp], 0
	jge	SHORT $LN16@DecodeDHT
$LN15@DecodeDHT:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN38@DecodeDHT
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN15@DecodeDHT
$LN16@DecodeDHT:

; 380  :                     for (i = 0;  i < currcnt;  ++i) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN12@DecodeDHT
$LN11@DecodeDHT:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
$LN12@DecodeDHT:
	mov	eax, DWORD PTR currcnt$[rsp]
	cmp	DWORD PTR i$[rsp], eax
	jge	SHORT $LN10@DecodeDHT

; 381  :                         register unsigned char code = ctx.pos[i];

	movsxd	rax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR code$1[rsp], al

; 382  :                         for (j = spread;  j;  --j) {

	mov	eax, DWORD PTR spread$[rsp]
	mov	DWORD PTR j$[rsp], eax
	jmp	SHORT $LN9@DecodeDHT
$LN8@DecodeDHT:
	mov	eax, DWORD PTR j$[rsp]
	dec	eax
	mov	DWORD PTR j$[rsp], eax
$LN9@DecodeDHT:
	cmp	DWORD PTR j$[rsp], 0
	je	SHORT $LN7@DecodeDHT

; 383  :                             vlc->bits = (unsigned char) codelen;

	mov	rax, QWORD PTR vlc$[rsp]
	movzx	ecx, BYTE PTR codelen$[rsp]
	mov	BYTE PTR [rax], cl

; 384  :                             vlc->code = code;

	mov	rax, QWORD PTR vlc$[rsp]
	movzx	ecx, BYTE PTR code$1[rsp]
	mov	BYTE PTR [rax+1], cl

; 385  :                             ++vlc;

	mov	rax, QWORD PTR vlc$[rsp]
	add	rax, 2
	mov	QWORD PTR vlc$[rsp], rax

; 386  :                         }

	jmp	SHORT $LN8@DecodeDHT
$LN7@DecodeDHT:

; 387  :                     }

	jmp	SHORT $LN11@DecodeDHT
$LN10@DecodeDHT:

; 388  :                     _Skip(currcnt);

	mov	edx, DWORD PTR currcnt$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip

; 389  :                 }

	jmp	$LN23@DecodeDHT
$LN22@DecodeDHT:
$LN6@DecodeDHT:

; 390  :                 while (remain--) {

	mov	eax, DWORD PTR remain$[rsp]
	mov	DWORD PTR tv176[rsp], eax
	mov	eax, DWORD PTR remain$[rsp]
	dec	eax
	mov	DWORD PTR remain$[rsp], eax
	cmp	DWORD PTR tv176[rsp], 0
	je	SHORT $LN5@DecodeDHT

; 391  :                     vlc->bits = 0;

	mov	rax, QWORD PTR vlc$[rsp]
	mov	BYTE PTR [rax], 0

; 392  :                     ++vlc;

	mov	rax, QWORD PTR vlc$[rsp]
	add	rax, 2
	mov	QWORD PTR vlc$[rsp], rax

; 393  :                 }

	jmp	SHORT $LN6@DecodeDHT
$LN5@DecodeDHT:

; 394  :             }

	jmp	$LN37@DecodeDHT
$LN36@DecodeDHT:

; 395  :             if (ctx.length) JPEG_DECODER_THROW(SyntaxError);

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+20], 0
	je	SHORT $LN4@DecodeDHT
$LN3@DecodeDHT:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	SHORT $LN38@DecodeDHT
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN3@DecodeDHT
$LN4@DecodeDHT:
$LN38@DecodeDHT:

; 396  :         }

	add	rsp, 104				; 00000068H
	ret	0
?_DecodeDHT@Decoder@Jpeg@@AEAAXXZ ENDP			; Jpeg::Decoder::_DecodeDHT
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_DecodeSOF@Decoder@Jpeg@@AEAAXXZ
_TEXT	SEGMENT
c$ = 32
ssxmax$ = 40
ssymax$ = 44
i$ = 48
tv175 = 52
tv212 = 56
tv141 = 60
tv194 = 64
tv462 = 68
tv310 = 72
this$ = 96
?_DecodeSOF@Decoder@Jpeg@@AEAAXXZ PROC			; Jpeg::Decoder::_DecodeSOF, COMDAT

; 309  :         inline void _DecodeSOF(void) {

$LN65:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 310  :             int i, ssxmax = 0, ssymax = 0;

	mov	DWORD PTR ssxmax$[rsp], 0
	mov	DWORD PTR ssymax$[rsp], 0

; 311  :             Component* c;
; 312  :             _DecodeLength();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_DecodeLength@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_DecodeLength

; 313  :             if (ctx.length < 9) JPEG_DECODER_THROW(SyntaxError);

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+20], 9
	jge	SHORT $LN62@DecodeSOF
$LN61@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN63@DecodeSOF
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN61@DecodeSOF
$LN62@DecodeSOF:

; 314  :             if (ctx.pos[0] != 8) JPEG_DECODER_THROW(Unsupported);

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	cmp	eax, 8
	je	SHORT $LN58@DecodeSOF
$LN57@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 2
	jmp	$LN63@DecodeSOF
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN57@DecodeSOF
$LN58@DecodeSOF:

; 315  :             ctx.height = _Decode16(ctx.pos+1);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Decode16@Decoder@Jpeg@@AEAAGPEBE@Z	; Jpeg::Decoder::_Decode16
	movzx	eax, ax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+28], eax

; 316  :             ctx.width = _Decode16(ctx.pos+3);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 3
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Decode16@Decoder@Jpeg@@AEAAGPEBE@Z	; Jpeg::Decoder::_Decode16
	movzx	eax, ax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+24], eax

; 317  :             ctx.ncomp = ctx.pos[5];

	mov	eax, 1
	imul	rax, 5
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 318  :             _Skip(6);

	mov	edx, 6
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip

; 319  :             switch (ctx.ncomp) {

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	mov	DWORD PTR tv141[rsp], eax
	cmp	DWORD PTR tv141[rsp], 1
	je	SHORT $LN52@DecodeSOF
	cmp	DWORD PTR tv141[rsp], 3
	je	SHORT $LN52@DecodeSOF
	jmp	SHORT $LN51@DecodeSOF
$LN52@DecodeSOF:

; 320  :                 case 1:
; 321  :                 case 3:
; 322  :                     break;

	jmp	SHORT $LN53@DecodeSOF
$LN51@DecodeSOF:
$LN50@DecodeSOF:

; 323  :                 default:
; 324  :                     JPEG_DECODER_THROW(Unsupported);

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 2
	jmp	$LN63@DecodeSOF
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN50@DecodeSOF
$LN53@DecodeSOF:

; 325  :             }
; 326  :             if (ctx.length < (ctx.ncomp * 3)) JPEG_DECODER_THROW(SyntaxError);

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	imul	eax, 3
	mov	rcx, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rcx+20], eax
	jge	SHORT $LN47@DecodeSOF
$LN46@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN63@DecodeSOF
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN46@DecodeSOF
$LN47@DecodeSOF:

; 327  :             for (i = 0, c = ctx.comp;  i < ctx.ncomp;  ++i, ++c) {

	mov	DWORD PTR i$[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR c$[rsp], rax
	jmp	SHORT $LN43@DecodeSOF
$LN42@DecodeSOF:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR c$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR c$[rsp], rax
$LN43@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN41@DecodeSOF

; 328  :                 c->cid = ctx.pos[0];

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	rcx, QWORD PTR c$[rsp]
	mov	DWORD PTR [rcx], eax

; 329  :                 if (!(c->ssx = ctx.pos[1] >> 4)) JPEG_DECODER_THROW(SyntaxError);

	mov	eax, 1
	imul	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	sar	eax, 4
	mov	DWORD PTR tv175[rsp], eax
	mov	rax, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR tv175[rsp]
	mov	DWORD PTR [rax+4], ecx
	cmp	DWORD PTR tv175[rsp], 0
	jne	SHORT $LN40@DecodeSOF
$LN39@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN63@DecodeSOF
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN39@DecodeSOF
$LN40@DecodeSOF:

; 330  :                 if (c->ssx & (c->ssx - 1)) JPEG_DECODER_THROW(Unsupported);  // non-power of two

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+4]
	dec	eax
	mov	rcx, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR [rcx+4]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN36@DecodeSOF
$LN35@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 2
	jmp	$LN63@DecodeSOF
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN35@DecodeSOF
$LN36@DecodeSOF:

; 331  :                 if (!(c->ssy = ctx.pos[1] & 15)) JPEG_DECODER_THROW(SyntaxError);

	mov	eax, 1
	imul	rax, 1
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	and	eax, 15
	mov	DWORD PTR tv194[rsp], eax
	mov	rax, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR tv194[rsp]
	mov	DWORD PTR [rax+8], ecx
	cmp	DWORD PTR tv194[rsp], 0
	jne	SHORT $LN32@DecodeSOF
$LN31@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN63@DecodeSOF
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN31@DecodeSOF
$LN32@DecodeSOF:

; 332  :                 if (c->ssy & (c->ssy - 1)) JPEG_DECODER_THROW(Unsupported);  // non-power of two

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+8]
	dec	eax
	mov	rcx, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR [rcx+8]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN28@DecodeSOF
$LN27@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 2
	jmp	$LN63@DecodeSOF
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN27@DecodeSOF
$LN28@DecodeSOF:

; 333  :                 if ((c->qtsel = ctx.pos[2]) & 0xFC) JPEG_DECODER_THROW(SyntaxError);

	mov	eax, 1
	imul	rax, 2
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	DWORD PTR tv212[rsp], eax
	mov	rax, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR tv212[rsp]
	mov	DWORD PTR [rax+24], ecx
	mov	eax, DWORD PTR tv212[rsp]
	and	eax, 252				; 000000fcH
	test	eax, eax
	je	SHORT $LN24@DecodeSOF
$LN23@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	$LN63@DecodeSOF
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN23@DecodeSOF
$LN24@DecodeSOF:

; 334  :                 _Skip(3);

	mov	edx, 3
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip

; 335  :                 ctx.qtused |= 1 << c->qtsel;

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	ecx, 1
	mov	DWORD PTR tv462[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv462[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+200]
	or	ecx, eax
	mov	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+200], eax

; 336  :                 if (c->ssx > ssxmax) ssxmax = c->ssx;

	mov	rax, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR ssxmax$[rsp]
	cmp	DWORD PTR [rax+4], ecx
	jle	SHORT $LN20@DecodeSOF
	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR ssxmax$[rsp], eax
$LN20@DecodeSOF:

; 337  :                 if (c->ssy > ssymax) ssymax = c->ssy;

	mov	rax, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR ssymax$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jle	SHORT $LN19@DecodeSOF
	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR ssymax$[rsp], eax
$LN19@DecodeSOF:

; 338  :             }

	jmp	$LN42@DecodeSOF
$LN41@DecodeSOF:

; 339  :             ctx.mbsizex = ssxmax << 3;

	mov	eax, DWORD PTR ssxmax$[rsp]
	shl	eax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+40], eax

; 340  :             ctx.mbsizey = ssymax << 3;

	mov	eax, DWORD PTR ssymax$[rsp]
	shl	eax, 3
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+44], eax

; 341  :             ctx.mbwidth = (ctx.width + ctx.mbsizex - 1) / ctx.mbsizex;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+40]
	lea	eax, DWORD PTR [rax+rcx-1]
	cdq
	mov	rcx, QWORD PTR this$[rsp]
	idiv	DWORD PTR [rcx+40]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+32], eax

; 342  :             ctx.mbheight = (ctx.height + ctx.mbsizey - 1) / ctx.mbsizey;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+28]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+44]
	lea	eax, DWORD PTR [rax+rcx-1]
	cdq
	mov	rcx, QWORD PTR this$[rsp]
	idiv	DWORD PTR [rcx+44]
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+36], eax

; 343  :             for (i = 0, c = ctx.comp;  i < ctx.ncomp;  ++i, ++c) {

	mov	DWORD PTR i$[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 56					; 00000038H
	mov	QWORD PTR c$[rsp], rax
	jmp	SHORT $LN18@DecodeSOF
$LN17@DecodeSOF:
	mov	eax, DWORD PTR i$[rsp]
	inc	eax
	mov	DWORD PTR i$[rsp], eax
	mov	rax, QWORD PTR c$[rsp]
	add	rax, 48					; 00000030H
	mov	QWORD PTR c$[rsp], rax
$LN18@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+48]
	cmp	DWORD PTR i$[rsp], eax
	jge	$LN16@DecodeSOF

; 344  :                 c->width = (ctx.width * c->ssx + ssxmax - 1) / ssxmax;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+24]
	imul	eax, DWORD PTR [rcx+4]
	mov	ecx, DWORD PTR ssxmax$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	cdq
	idiv	DWORD PTR ssxmax$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	mov	DWORD PTR [rcx+12], eax

; 345  :                 c->stride = (c->width + 7) & 0x7FFFFFF8;

	mov	rax, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+12]
	add	eax, 7
	and	eax, 2147483640				; 7ffffff8H
	mov	rcx, QWORD PTR c$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 346  :                 c->height = (ctx.height * c->ssy + ssymax - 1) / ssymax;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	mov	eax, DWORD PTR [rax+28]
	imul	eax, DWORD PTR [rcx+8]
	mov	ecx, DWORD PTR ssymax$[rsp]
	lea	eax, DWORD PTR [rax+rcx-1]
	cdq
	idiv	DWORD PTR ssymax$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 347  :                 c->stride = ctx.mbwidth * ctx.mbsizex * c->ssx / ssxmax;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+32]
	imul	eax, DWORD PTR [rcx+40]
	mov	rcx, QWORD PTR c$[rsp]
	imul	eax, DWORD PTR [rcx+4]
	cdq
	idiv	DWORD PTR ssxmax$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 348  :                 if (((c->width < 3) && (c->ssx != ssxmax)) || ((c->height < 3) && (c->ssy != ssymax))) JPEG_DECODER_THROW(Unsupported);

	mov	rax, QWORD PTR c$[rsp]
	cmp	DWORD PTR [rax+12], 3
	jge	SHORT $LN13@DecodeSOF
	mov	rax, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR ssxmax$[rsp]
	cmp	DWORD PTR [rax+4], ecx
	jne	SHORT $LN14@DecodeSOF
$LN13@DecodeSOF:
	mov	rax, QWORD PTR c$[rsp]
	cmp	DWORD PTR [rax+16], 3
	jge	SHORT $LN15@DecodeSOF
	mov	rax, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR ssymax$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	je	SHORT $LN15@DecodeSOF
$LN14@DecodeSOF:
$LN12@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 2
	jmp	$LN63@DecodeSOF
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN12@DecodeSOF
$LN15@DecodeSOF:

; 349  :                 if (!(c->pixels = (unsigned char*)AllocMem(c->stride * (ctx.mbheight * ctx.mbsizey * c->ssy / ssymax)))) JPEG_DECODER_THROW(OutOfMemory);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+36]
	imul	eax, DWORD PTR [rcx+44]
	mov	rcx, QWORD PTR c$[rsp]
	imul	eax, DWORD PTR [rcx+8]
	cdq
	idiv	DWORD PTR ssymax$[rsp]
	mov	rcx, QWORD PTR c$[rsp]
	mov	ecx, DWORD PTR [rcx+20]
	imul	ecx, eax
	mov	eax, ecx
	mov	ecx, eax
	mov	rax, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+525096]
	mov	QWORD PTR tv310[rsp], rax
	mov	rax, QWORD PTR c$[rsp]
	mov	rcx, QWORD PTR tv310[rsp]
	mov	QWORD PTR [rax+40], rcx
	cmp	QWORD PTR tv310[rsp], 0
	jne	SHORT $LN9@DecodeSOF
$LN8@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 3
	jmp	SHORT $LN63@DecodeSOF
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN8@DecodeSOF
$LN9@DecodeSOF:

; 350  :             }

	jmp	$LN17@DecodeSOF
$LN16@DecodeSOF:

; 351  :             if (ctx.ncomp == 3) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+48], 3
	jne	SHORT $LN5@DecodeSOF

; 352  :                 ctx.rgb = (unsigned char*)AllocMem(ctx.width * ctx.height * ctx.ncomp);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	imul	eax, DWORD PTR [rcx+28]
	mov	rcx, QWORD PTR this$[rsp]
	imul	eax, DWORD PTR [rcx+48]
	mov	ecx, eax
	mov	rax, QWORD PTR this$[rsp]
	call	QWORD PTR [rax+525096]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+525024], rax

; 353  :                 if (!ctx.rgb) JPEG_DECODER_THROW(OutOfMemory);

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+525024], 0
	jne	SHORT $LN4@DecodeSOF
$LN3@DecodeSOF:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 3
	jmp	SHORT $LN63@DecodeSOF
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN3@DecodeSOF
$LN4@DecodeSOF:
$LN5@DecodeSOF:

; 354  :             }
; 355  :             _Skip(ctx.length);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR [rax+20]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip
$LN63@DecodeSOF:

; 356  :         }

	add	rsp, 88					; 00000058H
	ret	0
?_DecodeSOF@Decoder@Jpeg@@AEAAXXZ ENDP			; Jpeg::Decoder::_DecodeSOF
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_SkipMarker@Decoder@Jpeg@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_SkipMarker@Decoder@Jpeg@@AEAAXXZ PROC			; Jpeg::Decoder::_SkipMarker, COMDAT

; 304  :         inline void _SkipMarker(void) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 305  :             _DecodeLength();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_DecodeLength@Decoder@Jpeg@@AEAAXXZ	; Jpeg::Decoder::_DecodeLength

; 306  :             _Skip(ctx.length);

	mov	rax, QWORD PTR this$[rsp]
	mov	edx, DWORD PTR [rax+20]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip

; 307  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_SkipMarker@Decoder@Jpeg@@AEAAXXZ ENDP			; Jpeg::Decoder::_SkipMarker
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_DecodeLength@Decoder@Jpeg@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_DecodeLength@Decoder@Jpeg@@AEAAXXZ PROC		; Jpeg::Decoder::_DecodeLength, COMDAT

; 297  :         inline void _DecodeLength(void) {

$LN11:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 298  :             if (ctx.size < 2) JPEG_DECODER_THROW(SyntaxError);

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+16], 2
	jge	SHORT $LN8@DecodeLeng
$LN7@DecodeLeng:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	SHORT $LN9@DecodeLeng
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@DecodeLeng
$LN8@DecodeLeng:

; 299  :             ctx.length = _Decode16(ctx.pos);

	mov	rax, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Decode16@Decoder@Jpeg@@AEAAGPEBE@Z	; Jpeg::Decoder::_Decode16
	movzx	eax, ax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 300  :             if (ctx.length > ctx.size) JPEG_DECODER_THROW(SyntaxError);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR [rcx+16]
	cmp	DWORD PTR [rax+20], ecx
	jle	SHORT $LN4@DecodeLeng
$LN3@DecodeLeng:
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
	jmp	SHORT $LN9@DecodeLeng
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN3@DecodeLeng
$LN4@DecodeLeng:

; 301  :             _Skip(2);

	mov	edx, 2
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Skip@Decoder@Jpeg@@AEAAXH@Z		; Jpeg::Decoder::_Skip
$LN9@DecodeLeng:

; 302  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_DecodeLength@Decoder@Jpeg@@AEAAXXZ ENDP		; Jpeg::Decoder::_DecodeLength
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_Decode16@Decoder@Jpeg@@AEAAGPEBE@Z
_TEXT	SEGMENT
this$ = 8
pos$ = 16
?_Decode16@Decoder@Jpeg@@AEAAGPEBE@Z PROC		; Jpeg::Decoder::_Decode16, COMDAT

; 293  :         inline unsigned short _Decode16(const unsigned char *pos) {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 294  :             return (pos[0] << 8) | pos[1];

	mov	eax, 1
	imul	rax, 0
	mov	rcx, QWORD PTR pos$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	shl	eax, 8
	mov	ecx, 1
	imul	rcx, 1
	mov	rdx, QWORD PTR pos$[rsp]
	movzx	ecx, BYTE PTR [rdx+rcx]
	or	eax, ecx

; 295  :         }

	ret	0
?_Decode16@Decoder@Jpeg@@AEAAGPEBE@Z ENDP		; Jpeg::Decoder::_Decode16
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_Skip@Decoder@Jpeg@@AEAAXH@Z
_TEXT	SEGMENT
this$ = 8
count$ = 16
?_Skip@Decoder@Jpeg@@AEAAXH@Z PROC			; Jpeg::Decoder::_Skip, COMDAT

; 286  :         inline void _Skip(int count) {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx

; 287  :             ctx.pos += count;

	movsxd	rax, DWORD PTR count$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	add	rax, QWORD PTR [rcx+8]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 288  :             ctx.size -= count;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	mov	eax, DWORD PTR [rax+16]
	sub	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 289  :             ctx.length -= count;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR count$[rsp]
	mov	eax, DWORD PTR [rax+20]
	sub	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+20], eax

; 290  :             if (ctx.size < 0) ctx.error = SyntaxError;

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+16], 0
	jge	SHORT $LN1@Skip
	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
$LN1@Skip:

; 291  :         }

	fatret	0
?_Skip@Decoder@Jpeg@@AEAAXH@Z ENDP			; Jpeg::Decoder::_Skip
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_ByteAlign@Decoder@Jpeg@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_ByteAlign@Decoder@Jpeg@@AEAAXXZ PROC			; Jpeg::Decoder::_ByteAlign, COMDAT

; 282  :         inline void _ByteAlign(void) {

	mov	QWORD PTR [rsp+8], rcx

; 283  :             ctx.bufbits &= 0xF8;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+524756]
	and	eax, 248				; 000000f8H
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+524756], eax

; 284  :         }

	ret	0
?_ByteAlign@Decoder@Jpeg@@AEAAXXZ ENDP			; Jpeg::Decoder::_ByteAlign
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_GetBits@Decoder@Jpeg@@AEAAHH@Z
_TEXT	SEGMENT
res$ = 32
this$ = 64
bits$ = 72
?_GetBits@Decoder@Jpeg@@AEAAHH@Z PROC			; Jpeg::Decoder::_GetBits, COMDAT

; 276  :         inline int _GetBits(int bits) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 277  :             int res = _ShowBits(bits);

	mov	edx, DWORD PTR bits$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_ShowBits@Decoder@Jpeg@@AEAAHH@Z	; Jpeg::Decoder::_ShowBits
	mov	DWORD PTR res$[rsp], eax

; 278  :             _SkipBits(bits);

	mov	edx, DWORD PTR bits$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_SkipBits@Decoder@Jpeg@@AEAAXH@Z	; Jpeg::Decoder::_SkipBits

; 279  :             return res;

	mov	eax, DWORD PTR res$[rsp]

; 280  :         }

	add	rsp, 56					; 00000038H
	ret	0
?_GetBits@Decoder@Jpeg@@AEAAHH@Z ENDP			; Jpeg::Decoder::_GetBits
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_SkipBits@Decoder@Jpeg@@AEAAXH@Z
_TEXT	SEGMENT
this$ = 48
bits$ = 56
?_SkipBits@Decoder@Jpeg@@AEAAXH@Z PROC			; Jpeg::Decoder::_SkipBits, COMDAT

; 270  :         inline void _SkipBits(int bits) {

$LN4:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 271  :             if (ctx.bufbits < bits)

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR bits$[rsp]
	cmp	DWORD PTR [rax+524756], ecx
	jge	SHORT $LN1@SkipBits

; 272  :                 (void) _ShowBits(bits);

	mov	edx, DWORD PTR bits$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_ShowBits@Decoder@Jpeg@@AEAAHH@Z	; Jpeg::Decoder::_ShowBits
$LN1@SkipBits:

; 273  :             ctx.bufbits -= bits;

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR bits$[rsp]
	mov	eax, DWORD PTR [rax+524756]
	sub	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+524756], eax

; 274  :         }

	add	rsp, 40					; 00000028H
	ret	0
?_SkipBits@Decoder@Jpeg@@AEAAXH@Z ENDP			; Jpeg::Decoder::_SkipBits
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_ShowBits@Decoder@Jpeg@@AEAAHH@Z
_TEXT	SEGMENT
marker$1 = 0
newbyte$ = 1
tv162 = 4
tv256 = 8
this$ = 32
bits$ = 40
?_ShowBits@Decoder@Jpeg@@AEAAHH@Z PROC			; Jpeg::Decoder::_ShowBits, COMDAT

; 235  :         inline int _ShowBits(int bits) {

$LN18:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 236  :             unsigned char newbyte;
; 237  :             if (!bits) return 0;

	cmp	DWORD PTR bits$[rsp], 0
	jne	SHORT $LN14@ShowBits
	xor	eax, eax
	jmp	$LN15@ShowBits
$LN14@ShowBits:
$LN17@ShowBits:
$LN13@ShowBits:

; 238  :             while (ctx.bufbits < bits) {

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR bits$[rsp]
	cmp	DWORD PTR [rax+524756], ecx
	jge	$LN12@ShowBits

; 239  :                 if (ctx.size <= 0) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+16], 0
	jg	SHORT $LN11@ShowBits

; 240  :                     ctx.buf = (ctx.buf << 8) | 0xFF;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+524752]
	shl	eax, 8
	or	eax, 255				; 000000ffH
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+524752], eax

; 241  :                     ctx.bufbits += 8;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+524756]
	add	eax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+524756], eax

; 242  :                     continue;

	jmp	SHORT $LN13@ShowBits
$LN11@ShowBits:

; 243  :                 }
; 244  :                 newbyte = *ctx.pos++;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR newbyte$[rsp], al
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 245  :                 ctx.size--;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+16]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 246  :                 ctx.bufbits += 8;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+524756]
	add	eax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+524756], eax

; 247  :                 ctx.buf = (ctx.buf << 8) | newbyte;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+524752]
	shl	eax, 8
	movzx	ecx, BYTE PTR newbyte$[rsp]
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+524752], eax

; 248  :                 if (newbyte == 0xFF) {

	movzx	eax, BYTE PTR newbyte$[rsp]
	cmp	eax, 255				; 000000ffH
	jne	$LN10@ShowBits

; 249  :                     if (ctx.size) {

	mov	rax, QWORD PTR this$[rsp]
	cmp	DWORD PTR [rax+16], 0
	je	$LN9@ShowBits

; 250  :                         unsigned char marker = *ctx.pos++;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR marker$1[rsp], al
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	inc	rax
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 251  :                         ctx.size--;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+16]
	dec	eax
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+16], eax

; 252  :                         switch (marker) {

	movzx	eax, BYTE PTR marker$1[rsp]
	mov	BYTE PTR tv162[rsp], al
	cmp	BYTE PTR tv162[rsp], 0
	je	SHORT $LN6@ShowBits
	cmp	BYTE PTR tv162[rsp], 217		; 000000d9H
	je	SHORT $LN5@ShowBits
	jmp	SHORT $LN4@ShowBits
$LN6@ShowBits:

; 253  :                             case 0:    break;

	jmp	SHORT $LN7@ShowBits
$LN5@ShowBits:

; 254  :                             case 0xD9: ctx.size = 0; break;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax+16], 0
	jmp	SHORT $LN7@ShowBits
$LN4@ShowBits:

; 255  :                             default:
; 256  :                                 if ((marker & 0xF8) != 0xD0)

	movzx	eax, BYTE PTR marker$1[rsp]
	and	eax, 248				; 000000f8H
	cmp	eax, 208				; 000000d0H
	je	SHORT $LN3@ShowBits

; 257  :                                     ctx.error = SyntaxError;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5

; 258  :                                 else {

	jmp	SHORT $LN2@ShowBits
$LN3@ShowBits:

; 259  :                                     ctx.buf = (ctx.buf << 8) | marker;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+524752]
	shl	eax, 8
	movzx	ecx, BYTE PTR marker$1[rsp]
	or	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+524752], eax

; 260  :                                     ctx.bufbits += 8;

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+524756]
	add	eax, 8
	mov	rcx, QWORD PTR this$[rsp]
	mov	DWORD PTR [rcx+524756], eax
$LN2@ShowBits:
$LN7@ShowBits:

; 261  :                                 }
; 262  :                         }
; 263  :                     } else

	jmp	SHORT $LN1@ShowBits
$LN9@ShowBits:

; 264  :                         ctx.error = SyntaxError;

	mov	rax, QWORD PTR this$[rsp]
	mov	DWORD PTR [rax], 5
$LN1@ShowBits:
$LN10@ShowBits:

; 265  :                 }
; 266  :             }

	jmp	$LN17@ShowBits
$LN12@ShowBits:

; 267  :             return (ctx.buf >> (ctx.bufbits - bits)) & ((1 << bits) - 1);

	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR bits$[rsp]
	mov	eax, DWORD PTR [rax+524756]
	sub	eax, ecx
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR tv256[rsp], rcx
	movzx	ecx, al
	mov	rax, QWORD PTR tv256[rsp]
	mov	eax, DWORD PTR [rax+524752]
	sar	eax, cl
	mov	ecx, DWORD PTR bits$[rsp]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, edx
	dec	ecx
	and	eax, ecx
$LN15@ShowBits:

; 268  :         }

	add	rsp, 24
	ret	0
?_ShowBits@Decoder@Jpeg@@AEAAHH@Z ENDP			; Jpeg::Decoder::_ShowBits
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_ColIDCT@Decoder@Jpeg@@AEAAXPEBHPEAEH@Z
_TEXT	SEGMENT
x0$ = 32
x4$ = 36
x8$ = 40
x1$ = 44
x5$ = 48
x2$ = 52
x3$ = 56
x6$ = 60
x7$ = 64
this$ = 96
blk$ = 104
out$ = 112
stride$ = 120
?_ColIDCT@Decoder@Jpeg@@AEAAXPEBHPEAEH@Z PROC		; Jpeg::Decoder::_ColIDCT, COMDAT

; 184  :         inline void _ColIDCT(const int* blk, unsigned char *out, int stride) {

$LN7:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 185  :             int x0, x1, x2, x3, x4, x5, x6, x7, x8;
; 186  :             if (!((x1 = blk[8*4] << 8)
; 187  :                 | (x2 = blk[8*6])
; 188  :                 | (x3 = blk[8*2])
; 189  :                 | (x4 = blk[8*1])
; 190  :                 | (x5 = blk[8*7])
; 191  :                 | (x6 = blk[8*5])
; 192  :                 | (x7 = blk[8*3])))

	mov	eax, 4
	imul	rax, 32					; 00000020H
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	shl	eax, 8
	mov	DWORD PTR x1$[rsp], eax
	mov	eax, 4
	imul	rax, 48					; 00000030H
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR x2$[rsp], eax
	mov	eax, 4
	imul	rax, 16
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR x3$[rsp], eax
	mov	eax, 4
	imul	rax, 8
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR x4$[rsp], eax
	mov	eax, 4
	imul	rax, 56					; 00000038H
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR x5$[rsp], eax
	mov	eax, 4
	imul	rax, 40					; 00000028H
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR x6$[rsp], eax
	mov	eax, 4
	imul	rax, 24
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR x7$[rsp], eax
	mov	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x1$[rsp]
	or	ecx, eax
	mov	eax, ecx
	or	eax, DWORD PTR x3$[rsp]
	or	eax, DWORD PTR x4$[rsp]
	or	eax, DWORD PTR x5$[rsp]
	or	eax, DWORD PTR x6$[rsp]
	or	eax, DWORD PTR x7$[rsp]
	test	eax, eax
	jne	SHORT $LN4@ColIDCT

; 193  :             {
; 194  :                 x1 = _Clip(((blk[0] + 32) >> 6) + 128);

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	add	eax, 32					; 00000020H
	sar	eax, 6
	add	eax, 128				; 00000080H
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip
	movzx	eax, al
	mov	DWORD PTR x1$[rsp], eax

; 195  :                 for (x0 = 8;  x0;  --x0) {

	mov	DWORD PTR x0$[rsp], 8
	jmp	SHORT $LN3@ColIDCT
$LN2@ColIDCT:
	mov	eax, DWORD PTR x0$[rsp]
	dec	eax
	mov	DWORD PTR x0$[rsp], eax
$LN3@ColIDCT:
	cmp	DWORD PTR x0$[rsp], 0
	je	SHORT $LN1@ColIDCT

; 196  :                     *out = (unsigned char) x1;

	mov	rax, QWORD PTR out$[rsp]
	movzx	ecx, BYTE PTR x1$[rsp]
	mov	BYTE PTR [rax], cl

; 197  :                     out += stride;

	movsxd	rax, DWORD PTR stride$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR out$[rsp], rax

; 198  :                 }

	jmp	SHORT $LN2@ColIDCT
$LN1@ColIDCT:

; 199  :                 return;

	jmp	$LN5@ColIDCT
$LN4@ColIDCT:

; 200  :             }
; 201  :             x0 = (blk[0] << 8) + 8192;

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	shl	eax, 8
	add	eax, 8192				; 00002000H
	mov	DWORD PTR x0$[rsp], eax

; 202  :             x8 = W7 * (x4 + x5) + 4;

	mov	eax, DWORD PTR x5$[rsp]
	mov	ecx, DWORD PTR x4$[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, 565				; 00000235H
	add	eax, 4
	mov	DWORD PTR x8$[rsp], eax

; 203  :             x4 = (x8 + (W1 - W7) * x4) >> 3;

	mov	eax, DWORD PTR x4$[rsp]
	imul	eax, 2276				; 000008e4H
	mov	ecx, DWORD PTR x8$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 3
	mov	DWORD PTR x4$[rsp], eax

; 204  :             x5 = (x8 - (W1 + W7) * x5) >> 3;

	mov	eax, DWORD PTR x5$[rsp]
	imul	eax, 3406				; 00000d4eH
	mov	ecx, DWORD PTR x8$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 3
	mov	DWORD PTR x5$[rsp], eax

; 205  :             x8 = W3 * (x6 + x7) + 4;

	mov	eax, DWORD PTR x7$[rsp]
	mov	ecx, DWORD PTR x6$[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, 2408				; 00000968H
	add	eax, 4
	mov	DWORD PTR x8$[rsp], eax

; 206  :             x6 = (x8 - (W3 - W5) * x6) >> 3;

	mov	eax, DWORD PTR x6$[rsp]
	imul	eax, 799				; 0000031fH
	mov	ecx, DWORD PTR x8$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 3
	mov	DWORD PTR x6$[rsp], eax

; 207  :             x7 = (x8 - (W3 + W5) * x7) >> 3;

	mov	eax, DWORD PTR x7$[rsp]
	imul	eax, 4017				; 00000fb1H
	mov	ecx, DWORD PTR x8$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 3
	mov	DWORD PTR x7$[rsp], eax

; 208  :             x8 = x0 + x1;

	mov	eax, DWORD PTR x1$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x8$[rsp], eax

; 209  :             x0 -= x1;

	mov	eax, DWORD PTR x1$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x0$[rsp], eax

; 210  :             x1 = W6 * (x3 + x2) + 4;

	mov	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x3$[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, 1108				; 00000454H
	add	eax, 4
	mov	DWORD PTR x1$[rsp], eax

; 211  :             x2 = (x1 - (W2 + W6) * x2) >> 3;

	mov	eax, DWORD PTR x2$[rsp]
	imul	eax, 3784				; 00000ec8H
	mov	ecx, DWORD PTR x1$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 3
	mov	DWORD PTR x2$[rsp], eax

; 212  :             x3 = (x1 + (W2 - W6) * x3) >> 3;

	mov	eax, DWORD PTR x3$[rsp]
	imul	eax, 1568				; 00000620H
	mov	ecx, DWORD PTR x1$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 3
	mov	DWORD PTR x3$[rsp], eax

; 213  :             x1 = x4 + x6;

	mov	eax, DWORD PTR x6$[rsp]
	mov	ecx, DWORD PTR x4$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x1$[rsp], eax

; 214  :             x4 -= x6;

	mov	eax, DWORD PTR x6$[rsp]
	mov	ecx, DWORD PTR x4$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x4$[rsp], eax

; 215  :             x6 = x5 + x7;

	mov	eax, DWORD PTR x7$[rsp]
	mov	ecx, DWORD PTR x5$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x6$[rsp], eax

; 216  :             x5 -= x7;

	mov	eax, DWORD PTR x7$[rsp]
	mov	ecx, DWORD PTR x5$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x5$[rsp], eax

; 217  :             x7 = x8 + x3;

	mov	eax, DWORD PTR x3$[rsp]
	mov	ecx, DWORD PTR x8$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x7$[rsp], eax

; 218  :             x8 -= x3;

	mov	eax, DWORD PTR x3$[rsp]
	mov	ecx, DWORD PTR x8$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x8$[rsp], eax

; 219  :             x3 = x0 + x2;

	mov	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x3$[rsp], eax

; 220  :             x0 -= x2;

	mov	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x0$[rsp], eax

; 221  :             x2 = (181 * (x4 + x5) + 128) >> 8;

	mov	eax, DWORD PTR x5$[rsp]
	mov	ecx, DWORD PTR x4$[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, 181				; 000000b5H
	add	eax, 128				; 00000080H
	sar	eax, 8
	mov	DWORD PTR x2$[rsp], eax

; 222  :             x4 = (181 * (x4 - x5) + 128) >> 8;

	mov	eax, DWORD PTR x5$[rsp]
	mov	ecx, DWORD PTR x4$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	imul	eax, 181				; 000000b5H
	add	eax, 128				; 00000080H
	sar	eax, 8
	mov	DWORD PTR x4$[rsp], eax

; 223  :             *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;

	mov	eax, DWORD PTR x1$[rsp]
	mov	ecx, DWORD PTR x7$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 14
	add	eax, 128				; 00000080H
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip
	mov	rcx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR stride$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR out$[rsp], rax

; 224  :             *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;

	mov	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x3$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 14
	add	eax, 128				; 00000080H
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip
	mov	rcx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR stride$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR out$[rsp], rax

; 225  :             *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;

	mov	eax, DWORD PTR x4$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 14
	add	eax, 128				; 00000080H
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip
	mov	rcx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR stride$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR out$[rsp], rax

; 226  :             *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;

	mov	eax, DWORD PTR x6$[rsp]
	mov	ecx, DWORD PTR x8$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 14
	add	eax, 128				; 00000080H
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip
	mov	rcx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR stride$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR out$[rsp], rax

; 227  :             *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;

	mov	eax, DWORD PTR x6$[rsp]
	mov	ecx, DWORD PTR x8$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 14
	add	eax, 128				; 00000080H
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip
	mov	rcx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR stride$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR out$[rsp], rax

; 228  :             *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;

	mov	eax, DWORD PTR x4$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 14
	add	eax, 128				; 00000080H
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip
	mov	rcx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR stride$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR out$[rsp], rax

; 229  :             *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;

	mov	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x3$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 14
	add	eax, 128				; 00000080H
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip
	mov	rcx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rcx], al
	movsxd	rax, DWORD PTR stride$[rsp]
	mov	rcx, QWORD PTR out$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR out$[rsp], rax

; 230  :             *out = _Clip(((x7 - x1) >> 14) + 128);

	mov	eax, DWORD PTR x1$[rsp]
	mov	ecx, DWORD PTR x7$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 14
	add	eax, 128				; 00000080H
	mov	edx, eax
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Clip@Decoder@Jpeg@@AEAAEH@Z		; Jpeg::Decoder::_Clip
	mov	rcx, QWORD PTR out$[rsp]
	mov	BYTE PTR [rcx], al
$LN5@ColIDCT:

; 231  :         }

	add	rsp, 88					; 00000058H
	ret	0
?_ColIDCT@Decoder@Jpeg@@AEAAXPEBHPEAEH@Z ENDP		; Jpeg::Decoder::_ColIDCT
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_RowIDCT@Decoder@Jpeg@@AEAAXPEAH@Z
_TEXT	SEGMENT
x4$ = 0
x8$ = 4
x2$ = 8
x1$ = 12
x6$ = 16
x7$ = 20
x3$ = 24
x5$ = 28
tv136 = 32
x0$ = 36
this$ = 64
blk$ = 72
?_RowIDCT@Decoder@Jpeg@@AEAAXPEAH@Z PROC		; Jpeg::Decoder::_RowIDCT, COMDAT

; 139  :         inline void _RowIDCT(int* blk) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 140  :             int x0, x1, x2, x3, x4, x5, x6, x7, x8;
; 141  :             if (!((x1 = blk[4] << 11)
; 142  :                 | (x2 = blk[6])
; 143  :                 | (x3 = blk[2])
; 144  :                 | (x4 = blk[1])
; 145  :                 | (x5 = blk[7])
; 146  :                 | (x6 = blk[5])
; 147  :                 | (x7 = blk[3])))

	mov	eax, 4
	imul	rax, 4
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	shl	eax, 11
	mov	DWORD PTR x1$[rsp], eax
	mov	eax, 4
	imul	rax, 6
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR x2$[rsp], eax
	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR x3$[rsp], eax
	mov	eax, 4
	imul	rax, 1
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR x4$[rsp], eax
	mov	eax, 4
	imul	rax, 7
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR x5$[rsp], eax
	mov	eax, 4
	imul	rax, 5
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR x6$[rsp], eax
	mov	eax, 4
	imul	rax, 3
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	mov	DWORD PTR x7$[rsp], eax
	mov	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x1$[rsp]
	or	ecx, eax
	mov	eax, ecx
	or	eax, DWORD PTR x3$[rsp]
	or	eax, DWORD PTR x4$[rsp]
	or	eax, DWORD PTR x5$[rsp]
	or	eax, DWORD PTR x6$[rsp]
	or	eax, DWORD PTR x7$[rsp]
	test	eax, eax
	jne	$LN1@RowIDCT

; 148  :             {
; 149  :                 blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	shl	eax, 3
	mov	DWORD PTR tv136[rsp], eax
	mov	eax, 4
	imul	rax, 7
	mov	rcx, QWORD PTR blk$[rsp]
	mov	edx, DWORD PTR tv136[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, 6
	mov	rcx, QWORD PTR blk$[rsp]
	mov	edx, DWORD PTR tv136[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, 5
	mov	rcx, QWORD PTR blk$[rsp]
	mov	edx, DWORD PTR tv136[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, 4
	mov	rcx, QWORD PTR blk$[rsp]
	mov	edx, DWORD PTR tv136[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, 3
	mov	rcx, QWORD PTR blk$[rsp]
	mov	edx, DWORD PTR tv136[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, 2
	mov	rcx, QWORD PTR blk$[rsp]
	mov	edx, DWORD PTR tv136[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, 1
	mov	rcx, QWORD PTR blk$[rsp]
	mov	edx, DWORD PTR tv136[rsp]
	mov	DWORD PTR [rcx+rax], edx
	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR blk$[rsp]
	mov	edx, DWORD PTR tv136[rsp]
	mov	DWORD PTR [rcx+rax], edx

; 150  :                 return;

	jmp	$LN2@RowIDCT
$LN1@RowIDCT:

; 151  :             }
; 152  :             x0 = (blk[0] << 11) + 128;

	mov	eax, 4
	imul	rax, 0
	mov	rcx, QWORD PTR blk$[rsp]
	mov	eax, DWORD PTR [rcx+rax]
	shl	eax, 11
	add	eax, 128				; 00000080H
	mov	DWORD PTR x0$[rsp], eax

; 153  :             x8 = W7 * (x4 + x5);

	mov	eax, DWORD PTR x5$[rsp]
	mov	ecx, DWORD PTR x4$[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, 565				; 00000235H
	mov	DWORD PTR x8$[rsp], eax

; 154  :             x4 = x8 + (W1 - W7) * x4;

	mov	eax, DWORD PTR x4$[rsp]
	imul	eax, 2276				; 000008e4H
	mov	ecx, DWORD PTR x8$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x4$[rsp], eax

; 155  :             x5 = x8 - (W1 + W7) * x5;

	mov	eax, DWORD PTR x5$[rsp]
	imul	eax, 3406				; 00000d4eH
	mov	ecx, DWORD PTR x8$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x5$[rsp], eax

; 156  :             x8 = W3 * (x6 + x7);

	mov	eax, DWORD PTR x7$[rsp]
	mov	ecx, DWORD PTR x6$[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, 2408				; 00000968H
	mov	DWORD PTR x8$[rsp], eax

; 157  :             x6 = x8 - (W3 - W5) * x6;

	mov	eax, DWORD PTR x6$[rsp]
	imul	eax, 799				; 0000031fH
	mov	ecx, DWORD PTR x8$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x6$[rsp], eax

; 158  :             x7 = x8 - (W3 + W5) * x7;

	mov	eax, DWORD PTR x7$[rsp]
	imul	eax, 4017				; 00000fb1H
	mov	ecx, DWORD PTR x8$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x7$[rsp], eax

; 159  :             x8 = x0 + x1;

	mov	eax, DWORD PTR x1$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x8$[rsp], eax

; 160  :             x0 -= x1;

	mov	eax, DWORD PTR x1$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x0$[rsp], eax

; 161  :             x1 = W6 * (x3 + x2);

	mov	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x3$[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, 1108				; 00000454H
	mov	DWORD PTR x1$[rsp], eax

; 162  :             x2 = x1 - (W2 + W6) * x2;

	mov	eax, DWORD PTR x2$[rsp]
	imul	eax, 3784				; 00000ec8H
	mov	ecx, DWORD PTR x1$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x2$[rsp], eax

; 163  :             x3 = x1 + (W2 - W6) * x3;

	mov	eax, DWORD PTR x3$[rsp]
	imul	eax, 1568				; 00000620H
	mov	ecx, DWORD PTR x1$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x3$[rsp], eax

; 164  :             x1 = x4 + x6;

	mov	eax, DWORD PTR x6$[rsp]
	mov	ecx, DWORD PTR x4$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x1$[rsp], eax

; 165  :             x4 -= x6;

	mov	eax, DWORD PTR x6$[rsp]
	mov	ecx, DWORD PTR x4$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x4$[rsp], eax

; 166  :             x6 = x5 + x7;

	mov	eax, DWORD PTR x7$[rsp]
	mov	ecx, DWORD PTR x5$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x6$[rsp], eax

; 167  :             x5 -= x7;

	mov	eax, DWORD PTR x7$[rsp]
	mov	ecx, DWORD PTR x5$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x5$[rsp], eax

; 168  :             x7 = x8 + x3;

	mov	eax, DWORD PTR x3$[rsp]
	mov	ecx, DWORD PTR x8$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x7$[rsp], eax

; 169  :             x8 -= x3;

	mov	eax, DWORD PTR x3$[rsp]
	mov	ecx, DWORD PTR x8$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x8$[rsp], eax

; 170  :             x3 = x0 + x2;

	mov	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x3$[rsp], eax

; 171  :             x0 -= x2;

	mov	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR x0$[rsp], eax

; 172  :             x2 = (181 * (x4 + x5) + 128) >> 8;

	mov	eax, DWORD PTR x5$[rsp]
	mov	ecx, DWORD PTR x4$[rsp]
	add	ecx, eax
	mov	eax, ecx
	imul	eax, 181				; 000000b5H
	add	eax, 128				; 00000080H
	sar	eax, 8
	mov	DWORD PTR x2$[rsp], eax

; 173  :             x4 = (181 * (x4 - x5) + 128) >> 8;

	mov	eax, DWORD PTR x5$[rsp]
	mov	ecx, DWORD PTR x4$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	imul	eax, 181				; 000000b5H
	add	eax, 128				; 00000080H
	sar	eax, 8
	mov	DWORD PTR x4$[rsp], eax

; 174  :             blk[0] = (x7 + x1) >> 8;

	mov	eax, DWORD PTR x1$[rsp]
	mov	ecx, DWORD PTR x7$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 8
	mov	ecx, 4
	imul	rcx, 0
	mov	rdx, QWORD PTR blk$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 175  :             blk[1] = (x3 + x2) >> 8;

	mov	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x3$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 8
	mov	ecx, 4
	imul	rcx, 1
	mov	rdx, QWORD PTR blk$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 176  :             blk[2] = (x0 + x4) >> 8;

	mov	eax, DWORD PTR x4$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 8
	mov	ecx, 4
	imul	rcx, 2
	mov	rdx, QWORD PTR blk$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 177  :             blk[3] = (x8 + x6) >> 8;

	mov	eax, DWORD PTR x6$[rsp]
	mov	ecx, DWORD PTR x8$[rsp]
	add	ecx, eax
	mov	eax, ecx
	sar	eax, 8
	mov	ecx, 4
	imul	rcx, 3
	mov	rdx, QWORD PTR blk$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 178  :             blk[4] = (x8 - x6) >> 8;

	mov	eax, DWORD PTR x6$[rsp]
	mov	ecx, DWORD PTR x8$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 8
	mov	ecx, 4
	imul	rcx, 4
	mov	rdx, QWORD PTR blk$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 179  :             blk[5] = (x0 - x4) >> 8;

	mov	eax, DWORD PTR x4$[rsp]
	mov	ecx, DWORD PTR x0$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 8
	mov	ecx, 4
	imul	rcx, 5
	mov	rdx, QWORD PTR blk$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 180  :             blk[6] = (x3 - x2) >> 8;

	mov	eax, DWORD PTR x2$[rsp]
	mov	ecx, DWORD PTR x3$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 8
	mov	ecx, 4
	imul	rcx, 6
	mov	rdx, QWORD PTR blk$[rsp]
	mov	DWORD PTR [rdx+rcx], eax

; 181  :             blk[7] = (x7 - x1) >> 8;

	mov	eax, DWORD PTR x1$[rsp]
	mov	ecx, DWORD PTR x7$[rsp]
	sub	ecx, eax
	mov	eax, ecx
	sar	eax, 8
	mov	ecx, 4
	imul	rcx, 7
	mov	rdx, QWORD PTR blk$[rsp]
	mov	DWORD PTR [rdx+rcx], eax
$LN2@RowIDCT:

; 182  :         }

	add	rsp, 56					; 00000038H
	ret	0
?_RowIDCT@Decoder@Jpeg@@AEAAXPEAH@Z ENDP		; Jpeg::Decoder::_RowIDCT
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?_Clip@Decoder@Jpeg@@AEAAEH@Z
_TEXT	SEGMENT
tv67 = 0
tv68 = 4
this$ = 32
x$ = 40
?_Clip@Decoder@Jpeg@@AEAAEH@Z PROC			; Jpeg::Decoder::_Clip, COMDAT

; 126  :         inline unsigned char _Clip(const int x) {

$LN7:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 127  :             return (x < 0) ? 0 : ((x > 0xFF) ? 0xFF : (unsigned char) x);

	cmp	DWORD PTR x$[rsp], 0
	jge	SHORT $LN5@Clip
	mov	DWORD PTR tv68[rsp], 0
	jmp	SHORT $LN6@Clip
$LN5@Clip:
	cmp	DWORD PTR x$[rsp], 255			; 000000ffH
	jle	SHORT $LN3@Clip
	mov	DWORD PTR tv67[rsp], 255		; 000000ffH
	jmp	SHORT $LN4@Clip
$LN3@Clip:
	movzx	eax, BYTE PTR x$[rsp]
	mov	DWORD PTR tv67[rsp], eax
$LN4@Clip:
	mov	eax, DWORD PTR tv67[rsp]
	mov	DWORD PTR tv68[rsp], eax
$LN6@Clip:
	movzx	eax, BYTE PTR tv68[rsp]

; 128  :         }

	add	rsp, 24
	ret	0
?_Clip@Decoder@Jpeg@@AEAAEH@Z ENDP			; Jpeg::Decoder::_Clip
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ?GetResult@Decoder@Jpeg@@QEBA?AW4DecodeResult@12@XZ
_TEXT	SEGMENT
this$ = 8
?GetResult@Decoder@Jpeg@@QEBA?AW4DecodeResult@12@XZ PROC ; Jpeg::Decoder::GetResult, COMDAT

; 662  : inline Decoder::DecodeResult Decoder::GetResult() const { return ctx.error; }

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax]
	ret	0
?GetResult@Decoder@Jpeg@@QEBA?AW4DecodeResult@12@XZ ENDP ; Jpeg::Decoder::GetResult
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\include\gui\jpeg.h
;	COMDAT ??0Decoder@Jpeg@@QEAA@PEBEIP6APEAXI@ZP6AXPEAX@Z@Z
_TEXT	SEGMENT
temp$ = 32
this$ = 112
data$ = 120
size$ = 128
allocFunc$ = 136
freeFunc$ = 144
??0Decoder@Jpeg@@QEAA@PEBEIP6APEAXI@ZP6AXPEAX@Z@Z PROC	; Jpeg::Decoder::Decoder, COMDAT

; 651  : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR allocFunc$[rsp]
	mov	QWORD PTR [rax+525096], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR freeFunc$[rsp]
	mov	QWORD PTR [rax+525104], rcx

; 652  :     // should be static data, but this keeps us as a header
; 653  :     char temp[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,

	mov	BYTE PTR temp$[rsp], 0
	mov	BYTE PTR temp$[rsp+1], 1
	mov	BYTE PTR temp$[rsp+2], 8
	mov	BYTE PTR temp$[rsp+3], 16
	mov	BYTE PTR temp$[rsp+4], 9
	mov	BYTE PTR temp$[rsp+5], 2
	mov	BYTE PTR temp$[rsp+6], 3
	mov	BYTE PTR temp$[rsp+7], 10
	mov	BYTE PTR temp$[rsp+8], 17
	mov	BYTE PTR temp$[rsp+9], 24
	mov	BYTE PTR temp$[rsp+10], 32		; 00000020H
	mov	BYTE PTR temp$[rsp+11], 25
	mov	BYTE PTR temp$[rsp+12], 18

; 654  :         11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,

	mov	BYTE PTR temp$[rsp+13], 11
	mov	BYTE PTR temp$[rsp+14], 4
	mov	BYTE PTR temp$[rsp+15], 5
	mov	BYTE PTR temp$[rsp+16], 12
	mov	BYTE PTR temp$[rsp+17], 19
	mov	BYTE PTR temp$[rsp+18], 26
	mov	BYTE PTR temp$[rsp+19], 33		; 00000021H
	mov	BYTE PTR temp$[rsp+20], 40		; 00000028H
	mov	BYTE PTR temp$[rsp+21], 48		; 00000030H
	mov	BYTE PTR temp$[rsp+22], 41		; 00000029H
	mov	BYTE PTR temp$[rsp+23], 34		; 00000022H
	mov	BYTE PTR temp$[rsp+24], 27
	mov	BYTE PTR temp$[rsp+25], 20
	mov	BYTE PTR temp$[rsp+26], 13
	mov	BYTE PTR temp$[rsp+27], 6
	mov	BYTE PTR temp$[rsp+28], 7
	mov	BYTE PTR temp$[rsp+29], 14
	mov	BYTE PTR temp$[rsp+30], 21
	mov	BYTE PTR temp$[rsp+31], 28
	mov	BYTE PTR temp$[rsp+32], 35		; 00000023H

; 655  :         42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,

	mov	BYTE PTR temp$[rsp+33], 42		; 0000002aH
	mov	BYTE PTR temp$[rsp+34], 49		; 00000031H
	mov	BYTE PTR temp$[rsp+35], 56		; 00000038H
	mov	BYTE PTR temp$[rsp+36], 57		; 00000039H
	mov	BYTE PTR temp$[rsp+37], 50		; 00000032H
	mov	BYTE PTR temp$[rsp+38], 43		; 0000002bH
	mov	BYTE PTR temp$[rsp+39], 36		; 00000024H
	mov	BYTE PTR temp$[rsp+40], 29
	mov	BYTE PTR temp$[rsp+41], 22
	mov	BYTE PTR temp$[rsp+42], 15
	mov	BYTE PTR temp$[rsp+43], 23
	mov	BYTE PTR temp$[rsp+44], 30
	mov	BYTE PTR temp$[rsp+45], 37		; 00000025H
	mov	BYTE PTR temp$[rsp+46], 44		; 0000002cH
	mov	BYTE PTR temp$[rsp+47], 51		; 00000033H
	mov	BYTE PTR temp$[rsp+48], 58		; 0000003aH
	mov	BYTE PTR temp$[rsp+49], 59		; 0000003bH
	mov	BYTE PTR temp$[rsp+50], 52		; 00000034H
	mov	BYTE PTR temp$[rsp+51], 45		; 0000002dH

; 656  :         38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };

	mov	BYTE PTR temp$[rsp+52], 38		; 00000026H
	mov	BYTE PTR temp$[rsp+53], 31
	mov	BYTE PTR temp$[rsp+54], 39		; 00000027H
	mov	BYTE PTR temp$[rsp+55], 46		; 0000002eH
	mov	BYTE PTR temp$[rsp+56], 53		; 00000035H
	mov	BYTE PTR temp$[rsp+57], 60		; 0000003cH
	mov	BYTE PTR temp$[rsp+58], 61		; 0000003dH
	mov	BYTE PTR temp$[rsp+59], 54		; 00000036H
	mov	BYTE PTR temp$[rsp+60], 47		; 0000002fH
	mov	BYTE PTR temp$[rsp+61], 55		; 00000037H
	mov	BYTE PTR temp$[rsp+62], 62		; 0000003eH
	mov	BYTE PTR temp$[rsp+63], 63		; 0000003fH

; 657  :     memcpy(ZZ, temp, sizeof(ZZ));

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 525032				; 000802e8H
	mov	r8d, 64					; 00000040H
	lea	rdx, QWORD PTR temp$[rsp]
	mov	rcx, rax
	call	memcpy

; 658  :     memset(&ctx, 0, sizeof(Context));

	mov	rax, QWORD PTR this$[rsp]
	mov	r8d, 525032				; 000802e8H
	xor	edx, edx
	mov	rcx, rax
	call	?memset@@YAXPEAXEI@Z			; memset

; 659  :     _Decode(data, size);

	mov	r8d, DWORD PTR size$[rsp]
	mov	rdx, QWORD PTR data$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Decode@Decoder@Jpeg@@AEAA?AW4DecodeResult@12@PEBEH@Z ; Jpeg::Decoder::_Decode

; 660  : }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 104				; 00000068H
	ret	0
??0Decoder@Jpeg@@QEAA@PEBEIP6APEAXI@ZP6AXPEAX@Z@Z ENDP	; Jpeg::Decoder::Decoder
_TEXT	ENDS
END
