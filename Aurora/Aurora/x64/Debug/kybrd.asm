; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG3414	DB	'[Aurora]:Key Pressed', 0aH, 00H
CONST	ENDS
PUBLIC	?kybrd_init@@YAXXZ				; kybrd_init
PUBLIC	?kybrd_handler@@YAX_KPEAX@Z			; kybrd_handler
EXTRN	inportb:PROC
EXTRN	AuInterruptEnd:PROC
EXTRN	AuInterruptSet:PROC
EXTRN	printf:PROC
EXTRN	?AuPmmngrAlloc@@YAPEAXXZ:PROC			; AuPmmngrAlloc
EXTRN	?AuPmmngrFree@@YAXPEAX@Z:PROC			; AuPmmngrFree
EXTRN	?is_scheduler_initialized@@YA_NXZ:PROC		; is_scheduler_initialized
EXTRN	?message_send@@YAXGPEAU_message_@@@Z:PROC	; message_send
pdata	SEGMENT
$pdata$?kybrd_init@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?kybrd_init@@YAXXZ
$pdata$?kybrd_handler@@YAX_KPEAX@Z DD imagerel $LN6
	DD	imagerel $LN6+157
	DD	imagerel $unwind$?kybrd_handler@@YAX_KPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?kybrd_init@@YAXXZ DD 010401H
	DD	04204H
$unwind$?kybrd_handler@@YAX_KPEAX@Z DD 010e01H
	DD	0620eH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\kybrd.cpp
_TEXT	SEGMENT
code$1 = 32
code$ = 36
msg$2 = 40
v$ = 64
p$ = 72
?kybrd_handler@@YAX_KPEAX@Z PROC			; kybrd_handler

; 22   : {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 23   : 	static bool _extended = false;
; 24   : 	int code = 0;

	mov	DWORD PTR code$[rsp], 0

; 25   : 	//! read scan code only if the kybrd controller output buffer is full (scan mode is in it)
; 26   : 	if (inportb(0x64) & 1)

	mov	cx, 100					; 00000064H
	call	inportb
	movzx	eax, al
	and	eax, 1
	test	eax, eax
	je	SHORT $LN3@kybrd_hand

; 27   : 	{
; 28   : 		
; 29   : 		int code = inportb(0x60);

	mov	cx, 96					; 00000060H
	call	inportb
	movzx	eax, al
	mov	DWORD PTR code$1[rsp], eax

; 30   : 		if (is_scheduler_initialized()) {

	call	?is_scheduler_initialized@@YA_NXZ	; is_scheduler_initialized
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@kybrd_hand

; 31   : 			message_t *msg = (message_t*)AuPmmngrAlloc();

	call	?AuPmmngrAlloc@@YAPEAXXZ		; AuPmmngrAlloc
	mov	QWORD PTR msg$2[rsp], rax

; 32   : 			msg->type = 3;

	mov	eax, 3
	mov	rcx, QWORD PTR msg$2[rsp]
	mov	WORD PTR [rcx+56], ax

; 33   : 		    msg->dword = code;

	mov	rax, QWORD PTR msg$2[rsp]
	mov	ecx, DWORD PTR code$1[rsp]
	mov	DWORD PTR [rax], ecx

; 34   : 		    message_send (2,msg);

	mov	rdx, QWORD PTR msg$2[rsp]
	mov	cx, 2
	call	?message_send@@YAXGPEAU_message_@@@Z	; message_send

; 35   : 			AuPmmngrFree (msg);

	mov	rcx, QWORD PTR msg$2[rsp]
	call	?AuPmmngrFree@@YAXPEAX@Z		; AuPmmngrFree

; 36   : 		} else {

	jmp	SHORT $LN1@kybrd_hand
$LN2@kybrd_hand:

; 37   : 			printf ("[Aurora]:Key Pressed\n");

	lea	rcx, OFFSET FLAT:$SG3414
	call	printf
$LN1@kybrd_hand:
$LN3@kybrd_hand:
$end$7:

; 38   : 		}
; 39   : 
; 40   : 		/*thread_t* thr = (thread_t*)thread_iterate_ready_list (1);
; 41   : 	    if (thr != NULL){
; 42   : 			unblock_thread(thr);
; 43   : 		}*/
; 44   : 		//!Here we need to pass this code to window manager process {a.k.a DWM} or shell program
; 45   : 		//!shell will decode the scancode and will take action
; 46   : 	}
; 47   : 
; 48   :  end:
; 49   : 	//! tell apic we are done!!!
; 50   : 	AuInterruptEnd(1);

	mov	ecx, 1
	call	AuInterruptEnd

; 51   : 	return;
; 52   : }

	add	rsp, 56					; 00000038H
	ret	0
?kybrd_handler@@YAX_KPEAX@Z ENDP			; kybrd_handler
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\drivers\kybrd.cpp
_TEXT	SEGMENT
?kybrd_init@@YAXXZ PROC					; kybrd_init

; 60   : void kybrd_init () {

$LN3:
	sub	rsp, 40					; 00000028H

; 61   : 	AuInterruptSet (1,kybrd_handler,1);

	mov	r8b, 1
	lea	rdx, OFFSET FLAT:?kybrd_handler@@YAX_KPEAX@Z ; kybrd_handler
	mov	ecx, 1
	call	AuInterruptSet

; 62   : }

	add	rsp, 40					; 00000028H
	ret	0
?kybrd_init@@YAXXZ ENDP					; kybrd_init
_TEXT	ENDS
END
