; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?AuHalInitialize@@YAXXZ				; AuHalInitialize
PUBLIC	AuHalSetVect
PUBLIC	inportb
PUBLIC	inportw
PUBLIC	inportd
PUBLIC	outportb
PUBLIC	outportw
PUBLIC	outportd
PUBLIC	AuInterruptEnd
PUBLIC	AuInterruptSet
PUBLIC	?AuIrqMask@@YAXE_N@Z				; AuIrqMask
EXTRN	x64_inportb:PROC
EXTRN	x64_inportw:PROC
EXTRN	x64_inportd:PROC
EXTRN	x64_outportb:PROC
EXTRN	x64_outportw:PROC
EXTRN	x64_outportd:PROC
EXTRN	?x86_64_gdt_init@@YAXXZ:PROC			; x86_64_gdt_init
EXTRN	?setvect@@YAX_KP6AX0PEAX@Z@Z:PROC		; setvect
EXTRN	?x86_64_init_cpu@@YAXXZ:PROC			; x86_64_init_cpu
EXTRN	?apic_local_eoi@@YAXXZ:PROC			; apic_local_eoi
EXTRN	?ioapic_register_irq@@YAX_KP6AX0PEAX@ZE@Z:PROC	; ioapic_register_irq
EXTRN	?ioapic_mask_irq@@YAXE_N@Z:PROC			; ioapic_mask_irq
pdata	SEGMENT
$pdata$?AuHalInitialize@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+19
	DD	imagerel $unwind$?AuHalInitialize@@YAXXZ
$pdata$AuHalSetVect DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$AuHalSetVect
$pdata$inportb DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$inportb
$pdata$inportw DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$inportw
$pdata$inportd DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$inportd
$pdata$outportb DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$outportb
$pdata$outportw DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$outportw
$pdata$outportd DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$outportd
$pdata$AuInterruptEnd DD imagerel $LN3
	DD	imagerel $LN3+18
	DD	imagerel $unwind$AuInterruptEnd
$pdata$AuInterruptSet DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$AuInterruptSet
$pdata$?AuIrqMask@@YAXE_N@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$?AuIrqMask@@YAXE_N@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AuHalInitialize@@YAXXZ DD 010401H
	DD	04204H
$unwind$AuHalSetVect DD 010e01H
	DD	0420eH
$unwind$inportb DD 010901H
	DD	04209H
$unwind$inportw DD 010901H
	DD	04209H
$unwind$inportd DD 010901H
	DD	04209H
$unwind$outportb DD 010d01H
	DD	0420dH
$unwind$outportw DD 010e01H
	DD	0420eH
$unwind$outportd DD 010d01H
	DD	0420dH
$unwind$AuInterruptEnd DD 010801H
	DD	04208H
$unwind$AuInterruptSet DD 011301H
	DD	04213H
$unwind$?AuIrqMask@@YAXE_N@Z DD 010c01H
	DD	0420cH
xdata	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\hal.cpp
_TEXT	SEGMENT
irq$ = 48
value$ = 56
?AuIrqMask@@YAXE_N@Z PROC				; AuIrqMask

; 155  : void AuIrqMask (uint8_t irq, bool value) {

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 40					; 00000028H

; 156  : #ifdef USE_APIC
; 157  : 	ioapic_mask_irq(irq, value);

	movzx	edx, BYTE PTR value$[rsp]
	movzx	ecx, BYTE PTR irq$[rsp]
	call	?ioapic_mask_irq@@YAXE_N@Z		; ioapic_mask_irq

; 158  : #elif USE_PIC
; 159  : 	if(value)
; 160  : 		pic_set_mask(irq);
; 161  : 	else
; 162  : 		pic_clear_mask(irq);
; 163  : #endif
; 164  : }

	add	rsp, 40					; 00000028H
	ret	0
?AuIrqMask@@YAXE_N@Z ENDP				; AuIrqMask
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\hal.cpp
_TEXT	SEGMENT
vector$ = 48
fn$ = 56
irq$ = 64
AuInterruptSet PROC

; 138  : void AuInterruptSet (size_t vector, void (*fn)(size_t, void* p),uint8_t irq){

$LN3:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 139  : #ifdef ARCH_X64
; 140  : #ifdef USE_PIC
; 141  : 	setvect(32 + vector, fn);
; 142  : 	irq_mask(irq,false);
; 143  : #endif
; 144  : #ifdef USE_APIC
; 145  : 	ioapic_register_irq(vector,fn,irq);

	movzx	r8d, BYTE PTR irq$[rsp]
	mov	rdx, QWORD PTR fn$[rsp]
	mov	rcx, QWORD PTR vector$[rsp]
	call	?ioapic_register_irq@@YAX_KP6AX0PEAX@ZE@Z ; ioapic_register_irq

; 146  : #endif
; 147  : #elif  ARCH_ARM
; 148  : 	//! update comming soon..
; 149  : #elif ARCH_ARM64
; 150  : 	//! update comming soon...
; 151  : #endif
; 152  : }

	add	rsp, 40					; 00000028H
	ret	0
AuInterruptSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\hal.cpp
_TEXT	SEGMENT
irq$ = 48
AuInterruptEnd PROC

; 123  : void AuInterruptEnd (uint32_t irq) { 

$LN3:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 124  : #ifdef ARCH_X64
; 125  : #ifdef USE_PIC
; 126  : 	pic_interrupt_eoi(irq);
; 127  : #endif
; 128  : #ifdef USE_APIC
; 129  : 	apic_local_eoi ();

	call	?apic_local_eoi@@YAXXZ			; apic_local_eoi

; 130  : #endif
; 131  : #elif ARCH_ARM
; 132  : 	//! update comming soon..
; 133  : #elif ARCH_ARM64
; 134  : 	//! update comming soon..
; 135  : #endif
; 136  : }

	add	rsp, 40					; 00000028H
	ret	0
AuInterruptEnd ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\hal.cpp
_TEXT	SEGMENT
port$ = 48
data$ = 56
outportd PROC

; 112  : void  outportd (uint16_t port, uint32_t data) {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 40					; 00000028H

; 113  : #ifdef ARCH_X64
; 114  : 	x64_outportd (port, data);

	mov	edx, DWORD PTR data$[rsp]
	movzx	ecx, WORD PTR port$[rsp]
	call	x64_outportd

; 115  : #elif ARCH_ARM
; 116  : 	//! arm32_outportd (port, data);
; 117  : #elif ARCH_ARM64
; 118  : 	//! arm64_outportw (port, data);
; 119  : #endif
; 120  : }

	add	rsp, 40					; 00000028H
	ret	0
outportd ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\hal.cpp
_TEXT	SEGMENT
port$ = 48
data$ = 56
outportw PROC

; 100  : void outportw (uint16_t port, uint16_t data) {

$LN3:
	mov	WORD PTR [rsp+16], dx
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 40					; 00000028H

; 101  : #ifdef ARCH_X64
; 102  : 	x64_outportw (port, data);

	movzx	edx, WORD PTR data$[rsp]
	movzx	ecx, WORD PTR port$[rsp]
	call	x64_outportw

; 103  : #elif  ARCH_ARM
; 104  : 	//! arm32_outportw (port, data);
; 105  : #elif ARCH_ARM64
; 106  : 	//! arm64_outportw (port, data);
; 107  : #endif
; 108  : }

	add	rsp, 40					; 00000028H
	ret	0
outportw ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\hal.cpp
_TEXT	SEGMENT
port$ = 48
data$ = 56
outportb PROC

; 88   : void  outportb (uint16_t port, uint8_t data ) {

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 40					; 00000028H

; 89   : #ifdef ARCH_X64
; 90   : 	x64_outportb (port,data);

	movzx	edx, BYTE PTR data$[rsp]
	movzx	ecx, WORD PTR port$[rsp]
	call	x64_outportb

; 91   : #elif ARCH_ARM
; 92   : 	//!arm32_outportb (port, data);
; 93   : #elif ARCH_ARM64
; 94   : 	//!arm64_outportb (port, data);
; 95   : #endif
; 96   : }

	add	rsp, 40					; 00000028H
	ret	0
outportb ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\hal.cpp
_TEXT	SEGMENT
port$ = 48
inportd	PROC

; 75   : uint32_t  inportd (uint16_t port) {

$LN3:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 40					; 00000028H

; 76   : #ifdef ARCH_X64
; 77   : 	return x64_inportd (port);

	movzx	ecx, WORD PTR port$[rsp]
	call	x64_inportd

; 78   : #elif ARCH_ARM
; 79   : 	//! return arm32_inportd (port);
; 80   : #elif ARCH_ARM64
; 81   : 	//! return arm64_inportd (port);
; 82   : #endif
; 83   : 
; 84   : }

	add	rsp, 40					; 00000028H
	ret	0
inportd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\hal.cpp
_TEXT	SEGMENT
port$ = 48
inportw	PROC

; 63   : uint16_t inportw (uint16_t port) {

$LN3:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 40					; 00000028H

; 64   : #ifdef ARCH_X64
; 65   : 	return x64_inportw (port);

	movzx	ecx, WORD PTR port$[rsp]
	call	x64_inportw

; 66   : #elif ARCH_ARM
; 67   : 	//return arm32_inportw (port);
; 68   : #elif ARCH_ARM64
; 69   : 	//return arm64_inportw (port);
; 70   : #endif
; 71   : 
; 72   : }

	add	rsp, 40					; 00000028H
	ret	0
inportw	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\hal.cpp
_TEXT	SEGMENT
port$ = 48
inportb	PROC

; 52   : uint8_t inportb (uint16_t port) {

$LN3:
	mov	WORD PTR [rsp+8], cx
	sub	rsp, 40					; 00000028H

; 53   : #ifdef ARCH_X64
; 54   : 	return x64_inportb (port);

	movzx	ecx, WORD PTR port$[rsp]
	call	x64_inportb

; 55   : #elif ARCH_ARM
; 56   : 	//return arm32_inportb (port);
; 57   : #elif ARCH_ARM64
; 58   : 	//return arm64_inportb (port);
; 59   : #endif
; 60   : }

	add	rsp, 40					; 00000028H
	ret	0
inportb	ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\hal.cpp
_TEXT	SEGMENT
vector$ = 48
function$ = 56
AuHalSetVect PROC

; 17   : void AuHalSetVect (size_t vector, void (*function)(size_t vector, void* param)) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 18   : #ifdef ARCH_X64
; 19   : 	//! initialize x86_64 hal initializer
; 20   : 	setvect (vector,function);

	mov	rdx, QWORD PTR function$[rsp]
	mov	rcx, QWORD PTR vector$[rsp]
	call	?setvect@@YAX_KP6AX0PEAX@Z@Z		; setvect

; 21   : #elif  ARCH_ARM
; 22   : 	//! initialize arm32 hal initializer
; 23   : 	arm_set_vect(vector,function);
; 24   : #elif  ARCH_ARM64
; 25   : 	//! initialize arm64 hal initializer
; 26   : 	arm64_set_vect(vector,function);
; 27   : #endif
; 28   : }

	add	rsp, 40					; 00000028H
	ret	0
AuHalSetVect ENDP
_TEXT	ENDS
; Function compile flags: /Odtpy
; File e:\xeneva project\xeneva\aurora\aurora\hal.cpp
_TEXT	SEGMENT
?AuHalInitialize@@YAXXZ PROC				; AuHalInitialize

; 32   : void AuHalInitialize () {

$LN3:
	sub	rsp, 40					; 00000028H

; 33   : 
; 34   : 	//! Check processor type
; 35   : #ifdef ARCH_X64
; 36   : 	//! initialize x86_64 hal initializer
; 37   : 	x86_64_gdt_init ();

	call	?x86_64_gdt_init@@YAXXZ			; x86_64_gdt_init

; 38   : 	x86_64_init_cpu();

	call	?x86_64_init_cpu@@YAXXZ			; x86_64_init_cpu

; 39   : #elif  ARCH_ARM
; 40   : 	//! initialize arm32 hal initializer
; 41   : 	hal_arm_init ();
; 42   : #elif  ARCH_ARM64
; 43   : 	//! initialize arm64 hal initializer
; 44   : 	hal_arm64_init ();
; 45   : #endif
; 46   : 
; 47   : }

	add	rsp, 40					; 00000028H
	ret	0
?AuHalInitialize@@YAXXZ ENDP				; AuHalInitialize
_TEXT	ENDS
END
